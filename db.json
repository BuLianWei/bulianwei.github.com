{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/matery/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"source/notes/Git&GitHub.assets/QQ20200318-211942@2x.png","path":"notes/Git&GitHub.assets/QQ20200318-211942@2x.png","modified":0,"renderable":0},{"_id":"themes/matery/source/js/matery.js","path":"js/matery.js","modified":0,"renderable":1},{"_id":"themes/matery/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":0,"renderable":1},{"_id":"themes/matery/source/css/my.css","path":"css/my.css","modified":0,"renderable":1},{"_id":"themes/matery/source/css/matery.css","path":"css/matery.css","modified":0,"renderable":1},{"_id":"themes/matery/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatar.jpg","path":"medias/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/logo.png","path":"medias/logo.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/background/canvas-nest.js","path":"libs/background/canvas-nest.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/background/ribbon-dynamic.js","path":"libs/background/ribbon-dynamic.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/background/ribbon-refresh.min.js","path":"libs/background/ribbon-refresh.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/background/ribbon.min.js","path":"libs/background/ribbon.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/cover.jpg","path":"medias/cover.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","path":"libs/jquery/jquery-2.2.0.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":0,"renderable":1},{"_id":"source/notes/img/零拷贝.png","path":"notes/img/零拷贝.png","modified":0,"renderable":0},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":0,"renderable":1},{"_id":"source/notes/img/kafka架构.png","path":"notes/img/kafka架构.png","modified":0,"renderable":0},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","path":"libs/awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","path":"libs/awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","path":"libs/awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","path":"libs/awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"source/notes/img/普通拷贝.png","path":"notes/img/普通拷贝.png","modified":0,"renderable":0},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","path":"libs/awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","path":"libs/awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","path":"libs/awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/404.md","hash":"6e12eb0f1ff042b3de34c89bd87739dd0e521695","modified":1584532336000},{"_id":"source/.DS_Store","hash":"74fac78607cd2122a29a719e4e38dbfe98f89bdd","modified":1585735545000},{"_id":"themes/matery/.gitignore","hash":"eaa3d84cb77d92a21b111fd1e37f53edc1ff9de0","modified":1585745692000},{"_id":"themes/matery/.DS_Store","hash":"61d4653525ee800306d888d998f91174144e6d64","modified":1584602821000},{"_id":"themes/matery/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1585745692000},{"_id":"themes/matery/README.md","hash":"d07e122e05c7c78991132b1e6ad39638adf00749","modified":1585745692000},{"_id":"themes/matery/README_CN.md","hash":"74be780ca50b0e31abf95786cd54b57ff4679b82","modified":1585745692000},{"_id":"themes/matery/_config.yml","hash":"ea7b8c642fe3317424c2ae98a220ccf4f194855e","modified":1585745692000},{"_id":"source/_data/friends.json","hash":"2b4d18d300da957dd5750ac6567d86139ff8fae4","modified":1584593486000},{"_id":"source/_data/musics.json","hash":"46588a16b735cfb95b8083e39e2b9f6dec517dcb","modified":1584593486000},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1585729621000},{"_id":"source/about/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1585053071000},{"_id":"source/_posts/hello-world.md","hash":"63a86441b2092fb816b8cedd39516d50dcd03d6f","modified":1584593486000},{"_id":"source/_posts/大数据面试题.md","hash":"7a18bf89e075a192e7b8934133fc59c347b5c6c1","modified":1584532336000},{"_id":"source/_posts/手撕Spark之WordCount RDD执行流程.md","hash":"82b95d51e11911c056f77a9d4c42152f0b7f9cec","modified":1584532336000},{"_id":"source/about/index.md","hash":"640534d4352055bd689b2989518f5da44d0c050c","modified":1585745692000},{"_id":"source/categories/index.md","hash":"9758f1d8d7131ee10e4b1e3004ce298760c4be5c","modified":1584593486000},{"_id":"source/friends/index.md","hash":"f447cb37394634a9eb3fd0e57a81242c7b3529ff","modified":1584593486000},{"_id":"source/notes/Bigdata.md","hash":"a6948f99a0d9662366cf37e03eb35662decc9dc5","modified":1584611169000},{"_id":"source/notes/Docker.md","hash":"5b76d0cb91f5564b4b8db2405a47c39ab6544e5f","modified":1584532336000},{"_id":"source/notes/Git&Github.md","hash":"d3105de2e686454f649cf3e591ae5450a41ea9ec","modified":1585749133000},{"_id":"source/notes/.DS_Store","hash":"c7f5710ce1118402ba82dd059ee66e2d2eb33979","modified":1585749430000},{"_id":"source/notes/Hive.md","hash":"f138b5ced327157702a11685c49e896bc369a8a3","modified":1584532336000},{"_id":"source/notes/Flink-Trouble.md","hash":"f181c4efe5d722f88a7697fc5a0523da23b44d91","modified":1584532336000},{"_id":"source/notes/Flink.md","hash":"da1753acb3692cd69c06eb63aee20d1414463626","modified":1584532336000},{"_id":"source/notes/Golang.md","hash":"f97808118244bd1e1f4c689f716831e4492ac8b8","modified":1585749133000},{"_id":"source/notes/Kafka.md","hash":"edeb9a607de62b7659665945f9b5aa98852c7d65","modified":1584532336000},{"_id":"source/notes/Linux.md","hash":"28d3cda8809bcdf22e9cfd1991c1b898935c0d1e","modified":1584532336000},{"_id":"source/notes/index.md","hash":"82461aaa967d9f99463532dfe2cd25a186d6b247","modified":1585749133000},{"_id":"source/notes/Redis.md","hash":"61d1a50da3da768c488ee42e7383ef63906f4749","modified":1585730569000},{"_id":"source/notes/Spark.md","hash":"83c02049edad7c794fbb7d0ecb07dea360e1b76e","modified":1584532336000},{"_id":"source/notes/Scala.md","hash":"7846d29be76f40f7c820d5bb27c6722202db6f72","modified":1584532336000},{"_id":"source/tags/index.md","hash":"5a056cf0f7a89b20cfffae3546e9b80e89095056","modified":1584593486000},{"_id":"themes/matery/layout/.DS_Store","hash":"c65c9d1aa3e98324aaca09da74ae56a88212485c","modified":1584598009000},{"_id":"themes/matery/languages/default.yml","hash":"2c4d4e72f0fb3431260643dcb85af11655fabe13","modified":1585745692000},{"_id":"themes/matery/languages/zh-CN.yml","hash":"db4b71662d408255eebd633fa3ded8d039122df3","modified":1585745692000},{"_id":"themes/matery/layout/categories.ejs","hash":"8e54665cc25d7c333da7d9f312987190be6215da","modified":1585745692000},{"_id":"themes/matery/layout/about.ejs","hash":"e9c48455a86aa3faf37de8cc8b860d465c0de2dd","modified":1585745692000},{"_id":"themes/matery/layout/category.ejs","hash":"95176564ea32e65ddc9fdbe9074332239d6a1305","modified":1585745692000},{"_id":"themes/matery/layout/archive.ejs","hash":"c8459660e87a0a07a6e007a99a2303b142bb7744","modified":1585745692000},{"_id":"themes/matery/layout/index.ejs","hash":"489f2fe7e4171613504f58e7e0462d81d2f7f546","modified":1585745692000},{"_id":"themes/matery/layout/friends.ejs","hash":"89c47cf1eb2cf1feb8a8d06f4eb7c76b713f79c0","modified":1585745692000},{"_id":"themes/matery/layout/layout.ejs","hash":"94a6b3764faaf85ae0c71dc0fa9fdf80da26b3e5","modified":1585745692000},{"_id":"themes/matery/layout/tag.ejs","hash":"4305eeeb3434c24ba2493fa08d1f1bd9f2efa9aa","modified":1585745692000},{"_id":"themes/matery/layout/tags.ejs","hash":"cf9517aa6a0111355121f44615d6923e312283c7","modified":1585745692000},{"_id":"themes/matery/layout/post.ejs","hash":"f9662a96d0f497a3b2731472b8ad871c7cbdf13a","modified":1585745692000},{"_id":"themes/matery/source/.DS_Store","hash":"43907e13c4e0262600c2a3bf0ea779f5946943be","modified":1584612343000},{"_id":"themes/matery/source/favicon.png","hash":"fc9a1d2894e2a302646a177af15cf078a6da70b9","modified":1585745692000},{"_id":"source/notes/Git&GitHub.assets/QQ20200318-211942@2x.png","hash":"79e9dd32dc1662a34707fe8412e48da3b99db9a5","modified":1585749133000},{"_id":"themes/matery/layout/_partial/back-top.ejs","hash":"8c91d2088c9bb323246b054d4940bde6cead6828","modified":1585745692000},{"_id":"themes/matery/layout/_partial/bg-cover-content.ejs","hash":"2d9a44f6fbed4d117bbc403095d9a810cb05303c","modified":1585745692000},{"_id":"themes/matery/layout/_partial/disqus.ejs","hash":"a0f53d1a9b579d52e52ccad8c6e330bf3b89547e","modified":1585745692000},{"_id":"themes/matery/layout/_partial/bg-cover.ejs","hash":"02191109712f61c0e487b8f0b8466597181a9004","modified":1585745692000},{"_id":"themes/matery/layout/_partial/gitment.ejs","hash":"0abfb51dc80ad063fb2118bee28de6bb8d99ed4e","modified":1585745692000},{"_id":"themes/matery/layout/_partial/gitalk.ejs","hash":"e4c5bf28ddc29519eee8debe79cce45bf279adeb","modified":1585745692000},{"_id":"themes/matery/layout/_partial/footer.ejs","hash":"4cc761891333f5e8ac6b6bf48fc2e87c98d85e6f","modified":1585745692000},{"_id":"themes/matery/layout/_partial/head.ejs","hash":"1f337fe1343f87fc958eded799a9ac93fc194e87","modified":1585745692000},{"_id":"themes/matery/layout/_partial/google-analytics.ejs","hash":"5f4992205617da5f8cc5863c62b5ec46e414e2fb","modified":1585745692000},{"_id":"themes/matery/layout/_partial/github-link.ejs","hash":"3aeb581bd78ab8e15b858e4c44c03bcf92f20b9e","modified":1585745692000},{"_id":"themes/matery/layout/_partial/header.ejs","hash":"0f43d6593936fef1cc5703572dff6d0c41b60642","modified":1585745692000},{"_id":"themes/matery/layout/_partial/index-cover.ejs","hash":"6583c00323d891a03343b6a621a0484a68d74f8a","modified":1585745692000},{"_id":"themes/matery/layout/_partial/livere.ejs","hash":"9c3401b42ea7f26410a5593bae93ada7e57b43be","modified":1585745692000},{"_id":"themes/matery/layout/_partial/mobile-nav.ejs","hash":"b70a2d40677d64d6b56fc51ac1331ad3a50e777c","modified":1585745692000},{"_id":"themes/matery/layout/_partial/navigation.ejs","hash":"20216e7ad6b48d4a4f8d11d6881e667e5186820f","modified":1585745692000},{"_id":"themes/matery/layout/_partial/paging.ejs","hash":"68a24cad2b2049c4dc3a250aa30bf4256f9e50cb","modified":1585745692000},{"_id":"themes/matery/layout/_partial/post-cover.ejs","hash":"5b423384b9c0fe77acc4247a8a85304022e5bd2a","modified":1585745692000},{"_id":"themes/matery/layout/_partial/post-detail-toc.ejs","hash":"b7320ccb822f9969c58401a0bc946a8a7a1fea9c","modified":1585745692000},{"_id":"themes/matery/layout/_partial/post-detail.ejs","hash":"0fe9b13b06cb64123ddbf7ad48cf5bb3dab01ea4","modified":1585745692000},{"_id":"themes/matery/layout/_partial/post-statis.ejs","hash":"2b2fe8e8e94e65c52a4dbd454168e9b9df6baf10","modified":1585745692000},{"_id":"themes/matery/layout/_partial/reward.ejs","hash":"3dff4f6a73973b0b32f40604244255f3c2a5bb78","modified":1585745692000},{"_id":"themes/matery/layout/_partial/prev-next.ejs","hash":"3f73f077b05b6bf41150b00f43870a41d3fa390f","modified":1585745692000},{"_id":"themes/matery/layout/_partial/search.ejs","hash":"942609b9240d5c8c09b24562fc8fb31eabe1cae4","modified":1585745692000},{"_id":"themes/matery/layout/_partial/social-link.ejs","hash":"62e10bf4577946190e9c31dcdc2799a4ad1d00dd","modified":1585745692000},{"_id":"themes/matery/layout/_widget/category-cloud.ejs","hash":"a5a10d6fa66a389d0253d7a52e0a646af6e8e9be","modified":1585745692000},{"_id":"themes/matery/layout/_partial/share.ejs","hash":"34f8e4250bb66012026aa50686a7c89a0414ca1b","modified":1585745692000},{"_id":"themes/matery/layout/_partial/valine.ejs","hash":"90527186fc8ed906eb1f20b59bc7f86caab9087b","modified":1585745692000},{"_id":"themes/matery/layout/_widget/my-gallery.ejs","hash":"f81eb2891bea326908057029e2a063001371ba9b","modified":1585745692000},{"_id":"themes/matery/layout/_widget/dream.ejs","hash":"684450f0b42f89ab70370c5248b34e55b7adf6fc","modified":1585745692000},{"_id":"themes/matery/layout/_widget/category-radar.ejs","hash":"f5561dd7d53d68897a33090bf677719213459b19","modified":1585745692000},{"_id":"themes/matery/layout/_widget/music.ejs","hash":"8eafddbd73fed80e85c66d49837c1a241b087258","modified":1585745692000},{"_id":"themes/matery/layout/_widget/my-projects.ejs","hash":"b9bf70ec5d97b0e14bb1b4f60f92db7680be5949","modified":1585745692000},{"_id":"themes/matery/layout/_widget/my-skills.ejs","hash":"bd0edf8dad95b2255890d59fb6d6ed6f2eab9c2f","modified":1585745692000},{"_id":"themes/matery/layout/_widget/person-resume.ejs","hash":"812f39e5d2233d0d3c28b192f78478072c3e4f9c","modified":1585745692000},{"_id":"themes/matery/layout/_widget/post-calendar.ejs","hash":"0b0a3eb6af29bf0d55d535958c44b01c0f18d10d","modified":1585745692000},{"_id":"themes/matery/layout/_widget/post-charts.ejs","hash":"af0604623db37ef800bb7ad48028d18d99efbbc3","modified":1585745692000},{"_id":"themes/matery/layout/_widget/tag-cloud.ejs","hash":"a3725f0e3a405acb595b04630a27765b537fb580","modified":1585745692000},{"_id":"themes/matery/layout/_widget/recommend.ejs","hash":"babaa0cb32146870785449c70748721235e4eff0","modified":1585745692000},{"_id":"themes/matery/layout/_widget/tag-wordcloud.ejs","hash":"cb7a0151cd20e90351e151c22bca9d4c3112f234","modified":1585745692000},{"_id":"themes/matery/layout/_widget/video.ejs","hash":"bda810cc135b52f834f1c1ccf52defccacace714","modified":1585745692000},{"_id":"themes/matery/source/js/matery.js","hash":"92f07106944f5ef7cd72e84bb3534513d00eebe1","modified":1585745692000},{"_id":"themes/matery/source/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1585745692000},{"_id":"themes/matery/source/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1585745692000},{"_id":"themes/matery/source/css/my.css","hash":"3d3ce7c84fce447b3531432537b79117b08b8818","modified":1585745692000},{"_id":"themes/matery/source/css/matery.css","hash":"d136162e907de9ff3ba170dfbea220b1e688e593","modified":1585745692000},{"_id":"themes/matery/source/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1585745692000},{"_id":"themes/matery/source/libs/.DS_Store","hash":"3f3af900a25b1dffdbabc54702b837c114199ba4","modified":1584602933000},{"_id":"themes/matery/source/medias/.DS_Store","hash":"6e4c55ff5d134f6fae0c9199961e9409d02e9f12","modified":1584611927000},{"_id":"themes/matery/source/medias/avatar.jpg","hash":"b7f8ca0c682f95d93f002c845aafbcb508ec2b0f","modified":1585745692000},{"_id":"themes/matery/source/medias/logo.png","hash":"fc9a1d2894e2a302646a177af15cf078a6da70b9","modified":1585745692000},{"_id":"themes/matery/source/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1585745692000},{"_id":"themes/matery/source/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1585745692000},{"_id":"themes/matery/source/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1585745692000},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1585745692000},{"_id":"themes/matery/source/libs/awesome/.DS_Store","hash":"f373e7b9b6d3b211049d1fdca9ee91d900953168","modified":1584602900000},{"_id":"themes/matery/source/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1585745692000},{"_id":"themes/matery/source/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1585745692000},{"_id":"themes/matery/source/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1585745692000},{"_id":"themes/matery/source/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1585745692000},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1585745692000},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1585745692000},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","hash":"3aac1db83b0135c521187254ff302d125cc30706","modified":1585745692000},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1585745692000},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1585745692000},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/.DS_Store","hash":"8983992a301632f377142eb0de9b7125c7a7c97a","modified":1584602915000},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1585745692000},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1585745692000},{"_id":"themes/matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1585745692000},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1585745692000},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1585745692000},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/13.jpg","hash":"66706dfde7d910182c2f1dbadd0e9e917630b8dd","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/15.jpg","hash":"5cf9fc64d5d74ab6ba69bb8bff580fdc22ba32d0","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/16.jpg","hash":"9cac6b80b0cc8959fc8aabfbd1adcab79ebebfc9","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/2.jpg","hash":"16f1d89cdba4dce935ac0f12599e0fcfda543a93","modified":1585745692000},{"_id":"themes/matery/source/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/21.jpg","hash":"d70b088850c3565e5b5bb9eb8fe4abe688c964cf","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/22.jpg","hash":"bf5b59d193e5ca089a7fff034c222bfa2c4dc41f","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/23.jpg","hash":"ed5ac9f616d3b99af5188a10b1761884c37e93e5","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/5.jpg","hash":"c3c1f36a1b1886037db604f151f335cd4599e970","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/7.jpg","hash":"a0246a4a560438938489cdd154e35f172b3f31b0","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/8.jpg","hash":"5a46ca4ab4c4ab2101a2af77a31a8878bccc483c","modified":1585745692000},{"_id":"themes/matery/source/medias/reward/alipay.jpg","hash":"1abc719b95d1b26f1f898e6b0a9b7609146e332f","modified":1585745692000},{"_id":"themes/matery/source/medias/reward/wechat.png","hash":"fe93385aa92fe328e01c8221a80b039be9e4e140","modified":1585745692000},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1585745692000},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1585745692000},{"_id":"themes/matery/source/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1585745692000},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","hash":"5d7e5bbfa540f0e53bd599e4305e1a4e815b5dd1","modified":1585745692000},{"_id":"themes/matery/source/libs/valine/Valine.min.js","hash":"031c1a5640d64ab3b829395ad5a7596b9fb122e6","modified":1585745692000},{"_id":"themes/matery/source/medias/banner/0.jpg","hash":"1f2ec55fe7825475fde2601573bb622f0bf2acba","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/0.jpg","hash":"2066cdda98ad0035071cd4aa7bd696eb078c0b6d","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/1.jpg","hash":"d16e28bd23ea3a63643826dde5eea6b7a9bdda5d","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/10.jpg","hash":"838e704942de076c60894d14e5f280e2724b6f68","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/11.jpg","hash":"9ed45f95b83626e3d91d6c405eb8bfe6fcb9736a","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/12.jpg","hash":"047be4239dd7e0be83243ee6b49a392a61f16b9a","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/14.jpg","hash":"8aeb816faca2d5eaea4cce9e881d6ff87b8c7cf1","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/18.jpg","hash":"ae23fdfaa59bc57b7ed49e90c5d59e4b68e1eea5","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/17.jpg","hash":"f168ca5b046d10a878a7b0bcfab540e2c4428887","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/19.jpg","hash":"57bc7c804b78b5cceb4eb1f9e51b734b75151b71","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/20.jpg","hash":"8271c4a327632b566ea62f546c083d08a0528e72","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/3.jpg","hash":"5e879652e032f02961a331b598a50b60ebe80a39","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/4.jpg","hash":"4eea5bdb5724ef1ed65790e481eda0d2fb176bf0","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/6.jpg","hash":"c63ff64bdd5f6c82da8804c7248fc519d23eaf0b","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/9.jpg","hash":"815c84778b721e3606c2bd7c099c7de7c53251ba","modified":1585745692000},{"_id":"source/notes/img/零拷贝.png","hash":"b2e42de0f335105eb56aecc3fb6e653d71029ea6","modified":1584532336000},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","hash":"734f56442e62fe55f677e8ccae7f175445667767","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1585745692000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1585745692000},{"_id":"themes/matery/source/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1585745692000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1585745692000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","hash":"f0a1b849868a6bf351ff98dc3924a4e7254eb88b","modified":1585745692000},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1585745692000},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1585745692000},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1585745692000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1585745692000},{"_id":"themes/matery/source/libs/valine/av-min.js","hash":"2577e72b52b736d99649f9e95be8976d58563333","modified":1585745692000},{"_id":"themes/matery/source/medias/banner/1.jpg","hash":"c3d5ab183b39a7140941b8375e29498f9d24f343","modified":1585745692000},{"_id":"themes/matery/source/medias/banner/3.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1585745692000},{"_id":"themes/matery/source/medias/banner/2.jpg","hash":"8d3c8391ff161eec70f66d69e5545a9468cc52ef","modified":1585745692000},{"_id":"themes/matery/source/medias/banner/5.jpg","hash":"4a08deec1dd5b4f1490e8fc23adfb75a0f88b0c4","modified":1585745692000},{"_id":"themes/matery/source/medias/banner/6.jpg","hash":"62e9586a8cec91a160f147c424a3d1d1aea360f9","modified":1585745692000},{"_id":"source/notes/img/kafka架构.png","hash":"f0e0406e5310d389605609ce3c3225fa245280a1","modified":1584532336000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1585745692000},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","hash":"5063376f12a8f554d338b7f1eb69e63a0a6d42aa","modified":1585745692000},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1585745692000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1585745692000},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1585745692000},{"_id":"source/notes/img/普通拷贝.png","hash":"07b5d706b386ce490c66160d9cf9eb6d6d651b62","modified":1584532336000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1585745692000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1585745692000},{"_id":"themes/matery/source/medias/banner/4.jpg","hash":"56850c3139cbd72a0eff0c35d8fac32c9c66dd6a","modified":1585745692000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1585745692000},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1585745692000},{"_id":"source/notes/Git&GitHub.md","hash":"b948edcb09a8f5ffd65b12ab8d1b1e337e7708d8","modified":1585758243000}],"Category":[{"name":"前端","_id":"ck8hf2uv40004zhs6l0rreuuy"},{"name":"大数据面试题","_id":"ck8hf2uw0000nzhs69gboj7xu"},{"name":"Spark","_id":"ck8hf2uw2000rzhs6ewut5nrx"}],"Data":[{"_id":"friends","data":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]},{"_id":"musics","data":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}],"Page":[{"title":"404","date":"2020-03-19T05:09:33.000Z","type":"404","layout":"404","description":"Oops～，你来到了没有知识的荒原！ :(","_content":"\n","source":"404.md","raw":"---\ntitle: 404\ndate: \ntype: \"404\"\nlayout: \"404\"\ndescription: \"Oops～，你来到了没有知识的荒原！ :(\"\n---\n\n","updated":"2020-03-18T11:52:16.000Z","path":"404.html","comments":1,"_id":"ck8hf2uts0000zhs6gnda4sci","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":""},{"title":"个人简历","date":"2019-12-25T03:50:00.000Z","type":"about","layout":"post","password":"nihao","message":"请输入访问本文章的密码","_content":"\n<h1 align=\"center\">步连伟</h1>\n<div align=\"center\">18851659629 | bulianwei@gmail.com</div>\n<div align=\"center\">博客：https://blog.csdn.net/branwel | http://bulianwei.github.io </div>\n\n\n> ## 技能清单\n\n- 开发语言：Java（常用），Scala（常用），Shell，Python\n- 大数据框架及计算引擎：Hadoop，Hive，Hbase，Flink，Spark，Zookeeper，Kudu（了解）\n- 中间服务组件：Kafka，Redis，Flume\n- 大数据部署：Docker，CDH\n- 内存、性能分析：JProfile，MAT\n- 管理工具：Maven，Git，Confluence，GitLab，JIRA\n\n\n\n> ## 工作经历\n\n### 2017/12 ~ 2019/6\t\n\n#### 轻图信息技术(北京)有限公司\t\t\t数据治理\t\t\t大数据开发工程师 |项目技术负责人\t\n\n我们公司前身是某运营商大数据研发部门，由于其他原因独立出来。拥有大数据研发部门核心团队，主要负责该运营商的数据治理、大数据接口研发和数据销售。另外也在为另一家运营商提供数据治理解决方案。\n\n全国31个省每个省的数据通过Flume采集后，一份数据直接入Kafka进行其他计算需要，一份数据直接接入数仓底层HDFS（同时冷冻一份数据）。数仓使用MapReduce、Hive、Spark进行离线数据处理，准实时使用Spark、Flink计算，最后将指标数据放到HBase或者K-V集群，前台将数据转化为接口分配权限，对外销售和大屏展示。\n\n我属于数据治理组，负责对数仓内的数据进行建模、统计分析并将指标数据写到外部系统。主要负责位置业务的数据处理工作，需要将六种数据源的结构化数据进一步格式统一、单位统一、数据校验，然后将这些数据按用户、分钟级别粒度并按照优先级进行提取。将数据提取后进行去超速、去乒乓操作，过滤后的数据写入HDFS并创建Hive表进行数据映射供上层业务调用。同时针对项目进行优化和迭代，使业务代码可以尽量保证不增加资源的情况下以应对数据持续增长的需求。\n\n- 位置融合集市\n\n  设计分批两段式式及单Job全量与多Job分摊并行的方式对数据进行处理，分摊队列资源利用峰值，平滑队列资源利用率，使原来8:30之前完成的任务可以提前到5:30之前，提高数据处理效率30% ～ 40%。并且设计中间过程可配置的监控、报警机制，使数据处理过程实现阶段和完成度的透明显示。\n\n- 旅游集市\n\n  修改原基础架构替换计算引擎，将原来Spark+Redis的数据处理过程修改为使用Flink进行Stateful计算，对每个用户近2个小时内的状态数据进行保存更新，简化数据计算流程，使数据计算效率提高10% ～ 20%左右。\n\n- 商业地产集市\n\n  设计集市核心商圈人员归属算法，圈定固定范围商圈用户，用于指标统计运算。研发HQL脚本通用模版，固化通用性配置，使开发人员只注重业务逻辑开发，省去繁琐过程，使两人开发的工作量一个人就可以完成。研发脚本逻辑测试工具，三人一个项目减少为两人一个项目，提高测试效率。\n\n- 掌合天下数仓\n\n  负责订单、用户集市的设计和开发。Azkaban调度维护，并且与甲方进行数据核对，针对问题数据进行问题排查。\n\n### 2016/3 ~ 2017/10\n\n#### 北京中科弘睿科技有限公司\t\t\t大数据研发\t\t\t\t\t\t大数据开发工程师\n\n公司的数据主要是通过Web的日志数据，APP端的行为数据，埋点数据。使用Flume采集数据存储到HDFS，在数仓对数据进行清洗、脱敏和统计分析，最后将指标数据存入MySQL数据库，供前台展示。\n\n我是属于数据分析组，主要负责用Hive、Spark对数据进行清洗、脱敏和统计分析。清洗脱敏后的数据按照不同纬度进行数据建模，然后根据不同业务需求对数据进行多维指标统计。并将最后生成的指标数据放到MySQL供其他组同事进行展示使用。同时对一些临时项目需求进行报表统计。\n\n- 电子商城离线分析系统\n对数仓进行重新构造，按照业务进行集市划分，专人开发测试，针对大段HQL进行分拆，分表加分区。优化后提升代码效率10% ～ 20%，同时制定HQL开发标准，制作代码模版和数据测试流程。\n\n- 驾车习性系统\n设计路线契合度算法，使行车轨迹符合率达到85%以上。\n\n\n### 2015/3 ~ 2016/1\n\n#### 联想（北京）有限公司\t\tE&T\t\t移动互联产品开发助理\n\n- 移动互联网应用项目\n\n  开发比赛软件项目代码（Android），担任过两届全国8个省省赛的软件技术支持和评委，国赛的软件支持工作。撰写Android开发教材数据存储模块\n\n\n\n> ## 教育背景\n\n- 2012.9 ～ 2015.7\t\t山东劳动职业技术学院\t大专\t软件工程\t\n\n\n\n> ## 其他\n\n- 荣誉/奖项：移动互联网全国软件开发二等奖\n","source":"about/index.md","raw":"---\ntitle:  个人简历\ndate: 2019-12-25 11:50:00\ntype: about\nlayout: post\npassword: nihao\nmessage: 请输入访问本文章的密码\n---\n\n<h1 align=\"center\">步连伟</h1>\n<div align=\"center\">18851659629 | bulianwei@gmail.com</div>\n<div align=\"center\">博客：https://blog.csdn.net/branwel | http://bulianwei.github.io </div>\n\n\n> ## 技能清单\n\n- 开发语言：Java（常用），Scala（常用），Shell，Python\n- 大数据框架及计算引擎：Hadoop，Hive，Hbase，Flink，Spark，Zookeeper，Kudu（了解）\n- 中间服务组件：Kafka，Redis，Flume\n- 大数据部署：Docker，CDH\n- 内存、性能分析：JProfile，MAT\n- 管理工具：Maven，Git，Confluence，GitLab，JIRA\n\n\n\n> ## 工作经历\n\n### 2017/12 ~ 2019/6\t\n\n#### 轻图信息技术(北京)有限公司\t\t\t数据治理\t\t\t大数据开发工程师 |项目技术负责人\t\n\n我们公司前身是某运营商大数据研发部门，由于其他原因独立出来。拥有大数据研发部门核心团队，主要负责该运营商的数据治理、大数据接口研发和数据销售。另外也在为另一家运营商提供数据治理解决方案。\n\n全国31个省每个省的数据通过Flume采集后，一份数据直接入Kafka进行其他计算需要，一份数据直接接入数仓底层HDFS（同时冷冻一份数据）。数仓使用MapReduce、Hive、Spark进行离线数据处理，准实时使用Spark、Flink计算，最后将指标数据放到HBase或者K-V集群，前台将数据转化为接口分配权限，对外销售和大屏展示。\n\n我属于数据治理组，负责对数仓内的数据进行建模、统计分析并将指标数据写到外部系统。主要负责位置业务的数据处理工作，需要将六种数据源的结构化数据进一步格式统一、单位统一、数据校验，然后将这些数据按用户、分钟级别粒度并按照优先级进行提取。将数据提取后进行去超速、去乒乓操作，过滤后的数据写入HDFS并创建Hive表进行数据映射供上层业务调用。同时针对项目进行优化和迭代，使业务代码可以尽量保证不增加资源的情况下以应对数据持续增长的需求。\n\n- 位置融合集市\n\n  设计分批两段式式及单Job全量与多Job分摊并行的方式对数据进行处理，分摊队列资源利用峰值，平滑队列资源利用率，使原来8:30之前完成的任务可以提前到5:30之前，提高数据处理效率30% ～ 40%。并且设计中间过程可配置的监控、报警机制，使数据处理过程实现阶段和完成度的透明显示。\n\n- 旅游集市\n\n  修改原基础架构替换计算引擎，将原来Spark+Redis的数据处理过程修改为使用Flink进行Stateful计算，对每个用户近2个小时内的状态数据进行保存更新，简化数据计算流程，使数据计算效率提高10% ～ 20%左右。\n\n- 商业地产集市\n\n  设计集市核心商圈人员归属算法，圈定固定范围商圈用户，用于指标统计运算。研发HQL脚本通用模版，固化通用性配置，使开发人员只注重业务逻辑开发，省去繁琐过程，使两人开发的工作量一个人就可以完成。研发脚本逻辑测试工具，三人一个项目减少为两人一个项目，提高测试效率。\n\n- 掌合天下数仓\n\n  负责订单、用户集市的设计和开发。Azkaban调度维护，并且与甲方进行数据核对，针对问题数据进行问题排查。\n\n### 2016/3 ~ 2017/10\n\n#### 北京中科弘睿科技有限公司\t\t\t大数据研发\t\t\t\t\t\t大数据开发工程师\n\n公司的数据主要是通过Web的日志数据，APP端的行为数据，埋点数据。使用Flume采集数据存储到HDFS，在数仓对数据进行清洗、脱敏和统计分析，最后将指标数据存入MySQL数据库，供前台展示。\n\n我是属于数据分析组，主要负责用Hive、Spark对数据进行清洗、脱敏和统计分析。清洗脱敏后的数据按照不同纬度进行数据建模，然后根据不同业务需求对数据进行多维指标统计。并将最后生成的指标数据放到MySQL供其他组同事进行展示使用。同时对一些临时项目需求进行报表统计。\n\n- 电子商城离线分析系统\n对数仓进行重新构造，按照业务进行集市划分，专人开发测试，针对大段HQL进行分拆，分表加分区。优化后提升代码效率10% ～ 20%，同时制定HQL开发标准，制作代码模版和数据测试流程。\n\n- 驾车习性系统\n设计路线契合度算法，使行车轨迹符合率达到85%以上。\n\n\n### 2015/3 ~ 2016/1\n\n#### 联想（北京）有限公司\t\tE&T\t\t移动互联产品开发助理\n\n- 移动互联网应用项目\n\n  开发比赛软件项目代码（Android），担任过两届全国8个省省赛的软件技术支持和评委，国赛的软件支持工作。撰写Android开发教材数据存储模块\n\n\n\n> ## 教育背景\n\n- 2012.9 ～ 2015.7\t\t山东劳动职业技术学院\t大专\t软件工程\t\n\n\n\n> ## 其他\n\n- 荣誉/奖项：移动互联网全国软件开发二等奖\n","updated":"2020-04-01T12:54:52.000Z","path":"about/index.html","comments":1,"_id":"ck8hf2uv10002zhs6qjfena61","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">请输入访问本文章的密码</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"7384a2a9f09f6f6e726401025a0336e360edcd449d5127a1ebf7e8331733fab5\">589649e44508d99ffe98b80afd6055bbbf9ad90bac9e251074fab76c3d6d499f86d5f7c719ce32af3e5b1766c48304a01311a46bb08784f208807729e08eacf45d5c7d68f217cd7a54f1d7d0c6770c5c16a09b1f665a18a4151d59dbdf5dc99c89af4794bb10120ee74e774d00ab161d524be7fed0904823682d949145939ededa814b2d27959a64de9428261f53f666745e39da06f79b15a85a3da1de0d5ca69d95aae65cebb6194dfe07525cf24fc3d949d54134e9646df388c3821db0937ba63d9dd9139124e402853db876e88658aacd6821f54b3401a34e12eed32ef925ff041abd423f4ed3df6a8bdb7dc65bc204d0c7651f436d5dec68616f75c975a03351f1443dba25769a8e4c63c48360a2942846e6660034fbd94d7fa29121db3db2c29353863cb2b684578485abeaeefc7ab09a3b275d045e58aa124f127ff0c673d1e13950bfbfe87588611e45d9cc5d91e671d7234ae8c7fbb9628f282f7e944bd4c5dbe8c2aac74c7886f1b1876214efc302999774ad1a682a9b10b041117c7da7812cef723812281b5a6eb045423a63c80ae913ad795a77557799f69fb69af79730ebacb31e58a4bb9c86cef03949c0208ace1a5615706aca209ff987070d17a9a28cdba455c4de934147a2135387fe36e2593309b761be3e304d97c6d77e5e9f4e845d9e2aedd28d47e0de642355a67992774b6b80249c40bc02345826b2c336e7776bf392e911152e8a888e5a18cc12d42c6b6f905fe45e399b427cbcea3a2f76cb76433909d8c4bd2a58174856c5e5699a3805a8fc8bd1a94bc02dde93d18527440019b2f8ff3ebbb09617b3779bf9a62e390101b9e255ae283cf07bffc2f0db882f70e2c0c18743c18ecfc906f90414c9a244fd04944599adaaff30477c71c1ed5e4f3f5e9565c6e30c99ecec64e6e38a334038a78862a0c9d6f5b2725bbfaf6b5ce203292ad90a39799781501c7bbe5352c647c758cff09a4eb7475d8993e599414765992330f2b63c595f0024283dcc4421c010279432223486d8dc97e90190a6f1dec7d663f7dc503b8150eb4e05ffa0e310831e12f983623e04d95cbefe0291cdbc727b74fb81d73a5a4e88b6b41d7b0623dd0b309ba2fbb2b0a9eedfd096df2e02b15ce98b2e7f05c3e1319f072f57e85d0de9c3a9497cc4126c50aa8cf4082633fb6843d5a63c5274171e4e2cdcda62a50bf4cc51d1ba7fdccf01ac153ef95e31ab3b37bcdec0a82c1d81a8036c4ff7ae041a447fb99c94c171961833924d4714134d04014a337e5b3150dd487ce4a21c78530f05fc8f27c876ee9301d8478f52bc82d5da2ab2089f9706a009162279e04ab4fec87b5be2ce14f8b3134b3c51e122e85bb1e49447583c5f2a2f0ee6edb8e28c42ff718fbf92f095d3e24ee79700dc08cbf358efcb94afda5afd86ac50266f7e1b260c7db8bfa29a4da115f6f8ee4345c68e9bdfff704caee286ca8773db4c651e72440ce5bfcf2008c18882808c8f6cc51dbdb7027b5a55809088d12e6134a64fc81f5bf491a12b849b8c62100f1e5a832337407cc35b7f23071aecd49ddb460ca7d4b6faf8e6e7f82936bb16c9ae82ce5ff6e0dfac2bf142479608e930e6a2d9196805b5efe4244bd02a0c40c3c189d3c91e671caf970bd25e59a820b80daf3920ce9832a514c35fbb2c584e16fecf54a9cf28e59c17f57308a26ea86f5d711e0390281dda676b37b30971988088ebe6669c9a0219ce83af0a573bebc0e78049008151f239f5f8c21ed03c13e71731dce51e9ddad16db2b161ad479abf3b3e808b07e585786fabb8c1293b4471f00d130b1e85f9f9a15be8cc40333960cf9d7bd20c531ffa39d245adbd3eea26697ee02b2068b477e9b90b59b7372af770876918cc7f1ca4565b96439e8b6bad39f639097a6bade078477bde0e16cd80c7097a95ce2e2e1a0743a6453618fa365d6166d577bbdfa0e2c5dab81f5c7a5154c993482aa8d25dddb3dbb19248756f82fb93e822384e44ec0b21ba72e14e7ae82176485af7f2175a2b9c5deac3d4b54615bfa819a39edbc6961e2ede773c38f156d4bfef39cf02b30a5e2c3977162c2bf373b8a54fc0a98d53e37aea65ad80281e4178c9c4d8cafd5338b4e3d9a4236e9ef9753493ce2b9ada42b0d421086dd8d031e5ac599ab71bf7e371a70b065348dfe37a448780b33bd5fdec28f6c0eca98793880bddea9b089b5d11dcb5d6c0adbd71eae9b253ab40f60920a80053e81d5d6be7db76618d2b8fbfedb005131e0d8654a34138b3ff5f33ab02ec3937733bbf57bc5b2ecf8722343cd644726003a98d5f810c9ab7ef82aaafa868d38fa0890ff52bc79178b9b8fc2eb61e343d4a2b7e651e57bc942db51603702675781f8bb5ed9109c84ab9cd174406d63484c880ce0fdf89c6eec663dd39501970178d34fecbfe150afd9e2b50bc0769372836f1d5aefdabc02c61602d17cc6b1c75997f3277c09ab35320534ee91486b293c8872243e2546dbbe01b43d219f59f72396e3610b09dc9c345053bb8840efba105b836387c2b308b1eb3b9cf30bbf930889e06a9b8f929872fa4660edbfe22eabebe5ffafc6fa50a5b27cece66b2ba14c070ad942d46fd5bc690a195f2b6e6b3bb3f0f97e1e2e9a7deeb27b561d8a34e70a622ac22f14818faea1bf4d217baebd34ac5fcc54e74ca9d9310dbda6c114df0d1b97a8268b80d7f2f06f52f1fe7b18ea042a5af22cdb1e814cd9084c11ee59dff32d2b5cd5800073135084fd9e1a1e9541cf2c3b25afa73561cb024a879282740ea56220cde9fca7f491a61d123ec1d4fb7cdc3fbcac82ae307963e55b3ddcb0a8cc9680d59196c0b45f9972ca878fb09c50a7301b728e37ad14340aa6daa65ce13adddfbc27cc40f933fd789cf60bfcfc0ba10062d0571b4d7522421bfd69f7bdb9339d2c46bc80acd630a6b0311ce5bb3570c82a63852fedfe0cd424bb9266eccf0e6d2ae22f4697623c0d6a8ac9268352d0f2de2b5d221b9b3a009f70dc021accb364b24cfab5d8446ef128048abf2f7938206b82ae20aaeb714ef4780da5c0536331540433b607cc73bba8266d54aa3acf6b88002654df162f2bc84eaa99b0224c8ef9699c2ea940a1c5597c2df355770fbcb90b39194d7d798197f563d30c487dfbf599f2d916e96c450ab8668f6f54b77ac44574b3b307d52020149e9305301db520a4b93835a10a329e03729238a719089583a41d46b80ba645ec7b063f8c759f3699e8815b21dd57e0e9e2568afa558d6a43a3cc954fb71c6ff102252466df9ea55f77807364884f4c1b8ae336fe6574f8acfd8a87694e21f88771c24f72daba31502f5e53d800c1c0d4b411949162250130ac415b49f1830948320abdef1b35d466bf6b959fc8fe72128864c3f4d271515b34bc3926403bed6514135b33ef262c3d746d6e6dc3af601df6f072370add8d73e4e95717c4adf7f7eb6adb7590f1c47ddbb1ddea18ab86411d414481cedd923bc3c955d0a55372671c00f0af75112f85c61bbea070d8a4388c4834c42fbb8d51fbdb6d41d01ecc14d0aaae09302f1994f9a035690ad19d29d6d4d73de9c99132da6cab33729bb7c40f28bf4ffe2ce86517e728b5d8b010b7e61658a67e9acc1a3f9049fc887a8aeef241dd857a1840853ad0b274ce297118c56f5beba8217dcd7478a66991b7d3235ae5bb10c610645cdc076f2b8e7b495658875e3040e5a08f30b2690576ecd6b540ed938fc754d6622b634600b0b45c68b99178432a97516e063cdae83215d65b2bebee459b945d4a543f569f2455c2a7b759c17c20735854c20e475a78a1572513017f1860cdbba1914daf0208dc89f8a344195b1bc487f42df5096f642a4bccbf98810c1a405a810f7b98d6c9a6c03c5629b85a19e067680e0130c0b9bff835826f5dbe79b989e959dede00261265909afc198ec4acd33568c377ecad71ff71edaf6abffe895e73a9d82330ac7a9d8d6652247a0d2d67a06ee918ed30cb9d227504c017bb18eb9e6df3b98ca185de35891ca615117065cb49fef68c9327ce8a0cd0494848d84536d1deb25640172858fe1d453832db4d17907a08dffd304eb42fd7095565909c4c5186dcdbbba6ca01da5343edd433f39164fb9e5a4d50a13a1a9d302ac8dc7a934ba6b82cf280d40d0808fc8db5270016c5b5de632e80de08c52bd6e8e0226858b445b3acfa575de6a229388328d59abc060c7f0828af2c132584745d815aaafb62a6e1d39c053c7b177c67992e2a4b76547f87bc220949776af9c68722297731f0c1e3288b11c498e39feb184ec5017b46652adc743df98ce62817914232daf751ac2d50c4f818e2db589c817c600390f40628fabf8d47f75f0c730e12fdd1d7dc79aa58c5bc7abbe70986ebecacc1084e52a42c7e78500d182ffac036be2144d77b3ec36188795c6d14dec13f201829e9a4520b1e96e0f625637a83daeef87cc703aa4b181c0febebf9361719465f388853ed8f96f60b581f9016cfef0ed54aeb3a6f69e76e48ebdfbb333fbe4ed022371a041ec19875675856f34191aa4853213c81505572e4ba7f9a4cc75606728b0c9dae6dfcbaeb941e526868855eda51b1237064716bea63ede4c7e90e51784220bbe7771bfb7447c1935782a08395643c613e5172095824256d0d5fae7f419b5c3aa0f8acfc5ac1c84ce5a679fc225a76dedf9fd40e85a9e93c29272536df44097d51560677c1f3c9afa43ed662357b104f951e399d7faca2f58a6439d7be6cc578df5299d1b03af0c84bae96e8f265de9c4945f79e19c9e5baba50fe1b6ffefbb2d5ca292fec8f3dc4845b47138c9102a4950fdd882cdcccc9cc277de0d0bce752f969cf484e509b03a81ea5894580674f986eede8c884fd8bdce1c23425810fc3bb7f49c8365bab9a19d8a61fc715857df3b01c275f92e1ebcf7c304455cd3d58dafa104cc94f8d496a819b0e5436913ad19c322404e27ccf7850d079619d3b583052b5da94fce90c28423e5758dfedd5ea9e62a9da7bbe5e10424647bc19c2f5c88212cc16be0478379a9ac61524ee9f9985cf2dc011020f0daf56af8276ea0f6b17d2064ef8d52d9804cf9ba445947a2ea3b0074ce9a3787fd68054fca9a18704359133079bf839feb17dacb14bb99e1f5f004627b7224111ec1fef5c5b066ebdc8be741379ac8e0f980ccbdd5185b4b6d087b8504d63a2caf25c1ff67123935faa2df1a517e44b580268f2f3f357fe2202bd69bdde77bf7434a0bddeb99d321b1bf3cf8cc507d27510d8454603f0085a412d191b3d5be4f2928af1096d02e5cf6404242a6ea6c3938df794f5167c85b92a14f66ff33fb00e761cdd87583478d9b7d851bff69340d13a5d562294efdabfad421dbd01ba76f1ddc7f47a6ff61ae18911bf80e442d4acf4cbe3a830ec23ff321e76e6d24821c756dd6e284ca455f453034df01795e4e8fbd7f7574fc9fa80576dce38c0183da0bfb9758f7f729d7a9914a65f10811c7c2eb9f5349c1039142d863a96b7ab1e4c864b719a325662e51b3195fe61571a7766dde07e77ea4455c8cdd7a23e58375080616db57078d33ddcdb1ab54a8cf24610a0203a162132aa3c88c0ca06212f222f685a331375ffc37b0c81f1ede32cd149bfba3f6702f55d9a3c5075d3cc5b1e6cb96227b72cc32d6ac6f0d6a637bd9fa8d57a1ae6449ff8c1c0f983aba1b1dd8453847d7b5ab42c350f6f3197f0843c5d3f472405c171a30e6629d293a887f5b2774cc2e935ff1ab07920131e5ddbf78d44238dc6e982baaaadf3fa123c533a0461734bbdd98840e0a5914e881dd39c8e9fb976b0a003450b20e3253563d2a275f0bc86e34568fd879f2efcf51ff629f55cdf4415b1c86ec1b50bc6eb331d9f1c78a67f858c1f1e1f44a8b7c481a24da7a849fed787e82bb0903759897e0a18753b726aba5d4f72c9a979331d6899ce6fb18563d230461e4fb95500f0a7cf408bd86730fe9e5b7be3aade75fe9b3166b69629821f288be1bb6586baa5119e2b243d50aea3128c86b0977e7189a11cf1cfa79c58fd868d74f14cd052dddd0f8ff0715a1b0e633de4a0eb2d409a8c60a670f44345d5d4dccc4a4dff0ce53219c5c5c2aa9ef2c729f9767516a7c7e88d2c32c2fe0469c454497cc0124c577a14b4b20bccc0f7c1ba7c65d53ff870723b0cba9dd098332ace4562bc706af4622b34c2e04de78fc83a29fdabf5ad827a3b0caa8aa2a1d745b85931f008a4050ef049b329d4020c7b950cc5632ec1f1f973c85673ddf20fc34c7d0705d24ab59027cfdf5c0e26af52746a935ab379be10595842ba0801614beb6a936997a79758cb942c4329f48ead627425756710934097c39c2d517c75f7fc1f49d513e811858c2533a49b8254d785a46d3f5c162d6ab1390080e90dc952cb7473ddf58e021950ace1ae007d1d9f205da8ee778329718563586ba09f2a6dd7aeb531ca209bcb64cce9839d5213ea1c3a567926ad44f038227838ba45e456546d55d98785f5e38490827b0b0048ae662fe93c7312a692579ebb7de4d8b3067473d7ce842cf225b81b2686ddcfd99bc5053d892e7a8c9bb2498d4af75a17a3309dfbaac852115688f711025d3010a328041f2b1d3f1d357b703da95114164920b1f36fde48effdca9864430cd96504af8467ae952f39af6a81913bca54e004ddcec70699b92a9585828efa88591de0f6415e5122e6eb1afd11b6affad3691039cd588c12b5256b057de57cd75bd314f76cbe6e34e922a3f6384074ecb897c86b90d0790aa2672b99a1f50a610d6b908c84ff7416e0cd99db36a4bab08de793de63a9cea894a5151ebda7ad375035569d73984c6fcef56dbfe4a909216dcc20ba9721a5e313a1fa42dbac8fc4b0cb14be9873d3b9897aa1284da20ef75c780ece81c10cfd70c6763d25504ea3b892f231f0a5ef278097a95054b74fa1a7d3bf9a3a58fca1fb7cad82bc8053bfa7b8ff8d2d10e0408d8ffefa27867b18ec1f20e86ecd0a1afb50574a8d99a93ef9258969e7067a2145a5e696cf88bcb4448f58df1461f1a668af730a964d2cdea06a85b3d43a235813dd9dc8ff90dfdbfa028f071a5311bb30327f8ae96f3c79c78db178a29b0e8bdd866d1eb8c32e8042148c44b66e282da87bf13215e3579a1ad679d5edc77f34df6b5b857edd27d617e76deab115ae9a5d37455fe9be08fb3e0db1313dbde25599fb08b99d41739101e2df705c9e0e0b10464ea0da0967b00dc405af0fdf7e812ea57ce9d1959c38a4a0417f615dfb35f88d21cf9dae41a016aecbc08e178b94edd7d804610f1a2806b00e028862567ea8b2712d12a4268c5bef76bacc0f470e4d3361ebcd31a72eca397ac0cceac06e33c7c063959b58867659b9b012dfb10b49ebd955000e4950ae08dd163744c9c01f9107cbd5f9f4bb2048989ec8bb9bd0e7f40dcfdc46808ba6129b7d47a783d542aba08aa6204404b910570c8097cbf81a03d6c7bb34e363e9cf58443d32c996d58ef6f9ba511db9182382ccc41de36dc2e1ba38e7dff4fbec2b401e7101899a0138f0c9f40ff16a5a1f8db5501b778efb9142e14c993c9147ed3b47ca2bd6ade26591f23cb6a89094867e2889a43abf7c0c15eddd89979845252ace012cc791f9bd2523032053136498e0ac935ffc9c71a3e4e968f253f383175ad9e4c3457ff7e71ea7dbdaed90851d1f327efb057bd0dc4b5047c6a3d091891b107d4f49ca45257e689f5f74441b30a5c52472f4e2afbe44de1cd9ac344974f10228d802cd85b90b7f0f6764913511c927755bd476b215e3ea00cabb1617a94bd6d520a9d54e6e66fdb151dc6229c21de64b68de1150f2208cef7feabd7508fc81516a022f594cdb8e752ec6c3d2a47cf55fde5ef236b339f3131416e3f59e331e261294d87fb4163a1f4d56e00ba32259c188945a83c937d7941abbf29158c114ab9dcc570fbe5f5469ee8c26614d2758388d2726bfee0532b03a31b8c85aa620e0e07c1f0dbd7ff4c00400aef968317d419a4ed72f65a299573693a073d73b2f3e54df6c18f9a905a8512c0b2b49263aa4013c5ba438818e3d6780008f352e12f46a8a9cc0401b6dea5142b872199c1b995c58eb1e75d8353e072bd65c14d9a97ed7c040f2d260538c49350a4a5405063fa13a5e02df1330c5d36a246558704187baffc0c06e52a07bdd2d2a5efb37a1534f6d47cf4d9800027f265b6307c34c58a6eebf1ea740f4b4d57023406ad539517c961c9694747d54f5db2beee124fd09d4040bf4e0b087543f4ab87b56d863cf79f1a36b59de2dd0606951b0a4f2ee080f9fa4e49afe25a428cadebea777bb9d0f02544f9c77ca10b92744ae9f8c87dcd08fffcfc8f43bf07cac083148d23a0cecfdfa5b2e9075ca3b0df7a81c2c8f2753734495c0b153cf516e22888de583c43549c067d2778f396eecbea105c9c35bee0ec6a90c8845674ab0db1c422ee2bcae326c444587f4f88b7e39990c03c2e68cdee544ee0e2967d555c92d2be27ba6cce560863349145f24c244cb56b651996a0d0e1575c9d68a8d067aa552ac1f89772906ba20736d7934bff0b71fa5d01e98f15a3dc923d6f5082f3e338da73f5c5375574c0bd76e17ef828df150ebc9ce66fa2e794c62d326cc656f99b69de15bc1e6cef39a2b117a0f5b8a9ae170b6057d7429c74337e7b7ff57f0ef0d8a07f1b1430a741de160870ef888381b91d747ba5ca943153757b55da37b86aa8010133a843bdff3037de156fa332bd81178a77dc5aebf4f3413025aed7d0613d67bb7fa38ad9d7467fd1a636b3bf5f751c7366eaff1f78c5304ae1782d7784a151909af1ce6f9b1ec2fbd8ffe49c8c65137f4a0410680cf13505bef013035ee5e5c7bd535711e5de012cc8ee145a98ab1dc1733ddd329c8db563ea57d85a263bd5f314fbd3641811f0b6dcf3de1849866f39e9d213d14af6d68966b2319cdaeca09719c06267497bdded62a11ef3404ee7fbb4073f37f5c5823af7399f90b7e3f659d31ad388a0d47c3c739f64aa600eb6d60f48ea9f905ce6c0a09917b264fca6c6a9e67d38f47f95ec75e5dc1e7ed06a2aec4e3c4834eba5e991ef60b0feab83d2e7ce271bc4ffa66ef4e82c476713672f90397a0b5e402f586869aac93788fbcb493a9ac5dad08e376d82e8334048c1b334ca80daf36cf62d67b12fe81f859fcb2b6a86c23e31bedf14e5f5b6f511584fae45310194c1bf060c50e2b6d8ff3bf367f59989b376fdee4d02468336a7aae884983068a3020d4d3e359ac6e3234e6cdd1ac6407b5856c9519bb4a1e79a884ae6cbb1174ef2d6e451aa78aa227851a0921a6f7ddc74363f71f082297b12af3bc4f85aa4efa15df1b88a5520685496b6a5a327d96f6c7cff2a3a247175b93f8ade3978721999d449a03b6c505dac52a4e792e8d64c1bd341ceca98a23beecc7aeafd2f9db7fc529091bfbab194b8116d3e830b5a3a37389f088f21add9df3d081af366782b29e07f1c2bbfb176cc883c40f88d98a4d5aa4eb36c30ecf6307228e40cc13edb5c007e76d5d793d4eef2e57a8505dfdcc6a8f56995f60b47f1ff8e2d7c760b9caf050b6697129bdb6226bfc238156a6f01449674997aaa028406b44f8e797f5c371b5288d7d4ae8d0a330d268e25e52c560dc5a161eea514997051248607c5d219e832d1840a855033fb5d31df8aab69bfe237ca1958cf67e5d2febc7e8b2b9f31acd6f8ca0bf63e2f51a9750f19725780c24d7c8c802e013db23a242dce6267039531fd4acee8620cc8b842dea92c57c20a9f409621f1be5e4d0a</script>\n</div>\n<script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"Here's something encrypted, password is required to continue reading.","more":"Here's something encrypted, password is required to continue reading.","origin":"<h1 align=\"center\">步连伟</h1>\n<div align=\"center\">18851659629 | bulianwei@gmail.com</div>\n<div align=\"center\">博客：https://blog.csdn.net/branwel | http://bulianwei.github.io </div>\n\n\n<blockquote>\n<h2 id=\"技能清单\"><a href=\"#技能清单\" class=\"headerlink\" title=\"技能清单\"></a>技能清单</h2></blockquote>\n<ul>\n<li>开发语言：Java（常用），Scala（常用），Shell，Python</li>\n<li>大数据框架及计算引擎：Hadoop，Hive，Hbase，Flink，Spark，Zookeeper，Kudu（了解）</li>\n<li>中间服务组件：Kafka，Redis，Flume</li>\n<li>大数据部署：Docker，CDH</li>\n<li>内存、性能分析：JProfile，MAT</li>\n<li>管理工具：Maven，Git，Confluence，GitLab，JIRA</li>\n</ul>\n<blockquote>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2></blockquote>\n<h3 id=\"2017-12-2019-6\"><a href=\"#2017-12-2019-6\" class=\"headerlink\" title=\"2017/12 ~ 2019/6\"></a>2017/12 ~ 2019/6</h3><h4 id=\"轻图信息技术-北京-有限公司-数据治理-大数据开发工程师-项目技术负责人\"><a href=\"#轻图信息技术-北京-有限公司-数据治理-大数据开发工程师-项目技术负责人\" class=\"headerlink\" title=\"轻图信息技术(北京)有限公司            数据治理            大数据开发工程师 |项目技术负责人\"></a>轻图信息技术(北京)有限公司            数据治理            大数据开发工程师 |项目技术负责人</h4><p>我们公司前身是某运营商大数据研发部门，由于其他原因独立出来。拥有大数据研发部门核心团队，主要负责该运营商的数据治理、大数据接口研发和数据销售。另外也在为另一家运营商提供数据治理解决方案。</p>\n<p>全国31个省每个省的数据通过Flume采集后，一份数据直接入Kafka进行其他计算需要，一份数据直接接入数仓底层HDFS（同时冷冻一份数据）。数仓使用MapReduce、Hive、Spark进行离线数据处理，准实时使用Spark、Flink计算，最后将指标数据放到HBase或者K-V集群，前台将数据转化为接口分配权限，对外销售和大屏展示。</p>\n<p>我属于数据治理组，负责对数仓内的数据进行建模、统计分析并将指标数据写到外部系统。主要负责位置业务的数据处理工作，需要将六种数据源的结构化数据进一步格式统一、单位统一、数据校验，然后将这些数据按用户、分钟级别粒度并按照优先级进行提取。将数据提取后进行去超速、去乒乓操作，过滤后的数据写入HDFS并创建Hive表进行数据映射供上层业务调用。同时针对项目进行优化和迭代，使业务代码可以尽量保证不增加资源的情况下以应对数据持续增长的需求。</p>\n<ul>\n<li><p>位置融合集市</p>\n<p>设计分批两段式式及单Job全量与多Job分摊并行的方式对数据进行处理，分摊队列资源利用峰值，平滑队列资源利用率，使原来8:30之前完成的任务可以提前到5:30之前，提高数据处理效率30% ～ 40%。并且设计中间过程可配置的监控、报警机制，使数据处理过程实现阶段和完成度的透明显示。</p>\n</li>\n<li><p>旅游集市</p>\n<p>修改原基础架构替换计算引擎，将原来Spark+Redis的数据处理过程修改为使用Flink进行Stateful计算，对每个用户近2个小时内的状态数据进行保存更新，简化数据计算流程，使数据计算效率提高10% ～ 20%左右。</p>\n</li>\n<li><p>商业地产集市</p>\n<p>设计集市核心商圈人员归属算法，圈定固定范围商圈用户，用于指标统计运算。研发HQL脚本通用模版，固化通用性配置，使开发人员只注重业务逻辑开发，省去繁琐过程，使两人开发的工作量一个人就可以完成。研发脚本逻辑测试工具，三人一个项目减少为两人一个项目，提高测试效率。</p>\n</li>\n<li><p>掌合天下数仓</p>\n<p>负责订单、用户集市的设计和开发。Azkaban调度维护，并且与甲方进行数据核对，针对问题数据进行问题排查。</p>\n</li>\n</ul>\n<h3 id=\"2016-3-2017-10\"><a href=\"#2016-3-2017-10\" class=\"headerlink\" title=\"2016/3 ~ 2017/10\"></a>2016/3 ~ 2017/10</h3><h4 id=\"北京中科弘睿科技有限公司-大数据研发-大数据开发工程师\"><a href=\"#北京中科弘睿科技有限公司-大数据研发-大数据开发工程师\" class=\"headerlink\" title=\"北京中科弘睿科技有限公司            大数据研发                        大数据开发工程师\"></a>北京中科弘睿科技有限公司            大数据研发                        大数据开发工程师</h4><p>公司的数据主要是通过Web的日志数据，APP端的行为数据，埋点数据。使用Flume采集数据存储到HDFS，在数仓对数据进行清洗、脱敏和统计分析，最后将指标数据存入MySQL数据库，供前台展示。</p>\n<p>我是属于数据分析组，主要负责用Hive、Spark对数据进行清洗、脱敏和统计分析。清洗脱敏后的数据按照不同纬度进行数据建模，然后根据不同业务需求对数据进行多维指标统计。并将最后生成的指标数据放到MySQL供其他组同事进行展示使用。同时对一些临时项目需求进行报表统计。</p>\n<ul>\n<li><p>电子商城离线分析系统<br>对数仓进行重新构造，按照业务进行集市划分，专人开发测试，针对大段HQL进行分拆，分表加分区。优化后提升代码效率10% ～ 20%，同时制定HQL开发标准，制作代码模版和数据测试流程。</p>\n</li>\n<li><p>驾车习性系统<br>设计路线契合度算法，使行车轨迹符合率达到85%以上。</p>\n</li>\n</ul>\n<h3 id=\"2015-3-2016-1\"><a href=\"#2015-3-2016-1\" class=\"headerlink\" title=\"2015/3 ~ 2016/1\"></a>2015/3 ~ 2016/1</h3><h4 id=\"联想（北京）有限公司-E-amp-T-移动互联产品开发助理\"><a href=\"#联想（北京）有限公司-E-amp-T-移动互联产品开发助理\" class=\"headerlink\" title=\"联想（北京）有限公司        E&amp;T        移动互联产品开发助理\"></a>联想（北京）有限公司        E&amp;T        移动互联产品开发助理</h4><ul>\n<li><p>移动互联网应用项目</p>\n<p>开发比赛软件项目代码（Android），担任过两届全国8个省省赛的软件技术支持和评委，国赛的软件支持工作。撰写Android开发教材数据存储模块</p>\n</li>\n</ul>\n<blockquote>\n<h2 id=\"教育背景\"><a href=\"#教育背景\" class=\"headerlink\" title=\"教育背景\"></a>教育背景</h2></blockquote>\n<ul>\n<li>2012.9 ～ 2015.7        山东劳动职业技术学院    大专    软件工程    </li>\n</ul>\n<blockquote>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2></blockquote>\n<ul>\n<li>荣誉/奖项：移动互联网全国软件开发二等奖</li>\n</ul>\n","encrypt":true},{"title":"categories","date":"2018-10-01T16:47:23.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-10-02 00:47:23\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2020-03-19T04:51:26.000Z","path":"categories/index.html","comments":1,"_id":"ck8hf2uv30003zhs69d2m25me","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":""},{"title":"friends","date":"2018-12-13T15:43:47.000Z","type":"friends","layout":"friends","_content":"","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2018-12-13 23:43:47\ntype: \"friends\"\nlayout: \"friends\"\n---\n","updated":"2020-03-19T04:51:26.000Z","path":"friends/index.html","comments":1,"_id":"ck8hf2uv50006zhs6vjdu4cap","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":""},{"_content":"\n# Bigdata\n\n## 1. Hadoop\n~~~\n1.hdfs集群：负责文件读写\n2.yarn集群：负责为mapredece程序分配运算硬件资源\nHadoop配置：\n1.core-site.xml：fs.DefaultFS\thadoop.tmp.dir\n2.hadoop.env.sh:  JAVA_HOME\n3.mapred-site.xml:  mapreduce.framework.name\n4.hdfs-site.xml:  dfs.replication\n5.yarn-site.xml:   yarn.resourcemanager.hostname  yarn.nodemanager.aux-services    \nslaves：自动化脚本使用的配置文件\n修改Linux启动等待时间  vi /etc/fstab\nmkdir -p  /aa/bb/cc      可以直接建立aa下的bb下的cc  创建层级文件\n挂载光驱：mount -t iso9660 -o ro\t /dev/cdrom  /mnt/cdrom \n设置光驱开机挂载：vi /etc/fstab\t增加 /dev/cdrom\t/mnt/cdrom\tiso9660\tdefaults\t0 0\nrename\t文件重命名\t\n与mv的区别\nmv 支持单个文件重命名\nrename 支持多个文件重命名\ncp /aa/*  /bb\t复制aa下的所有文件到bb下面\nhadoop  fs -put  filename / \t\t上传文件\nhadoop  fs  -get   filename\t\t下载文件\nhadoop 副本数由客户端决定（conf.set 》自定义配置文件》jar包中的配置）\nnamenode和datanode两个的工作目录不能在同一个文件夹下，否则会启动不起来。\neclipse 本地运行代码时遇到调用远程路径权限不够时，在eclipse客户端运行配置时添加VM arguments参数使用hadoop用户运行，参数为“\t-DHADOOP_USER_NAME=hadoop\t”\nmr程序：\nconfiguration参数设置：\nconf.set（”mapreduce.framework.name\",\"local\"）#是否为本地运行模式，默认为local本地模式\nconf.set(\"fs.defaultFS\",\"file:///\")\t#输入输出数据的文件路径，默认为file\nconf.set(\"fs.defaultFS\",\"hdfs://hadoop01:9000/\") #输入输出文件路径\n本地运行模式文件可以用file也可以用hdfs\n设置在yarn上运行程序（要想设置在集群上运行程序 一下三个参数必须设置）\nconf.set（“mapreduce.framework.name”,\"yarn\"）#设置运行模式为在集群上运行\nconf.set(\"yarn.resourcename.hostname\",\"hadoop01\")\t#设置yarn的管理者resourcename在那一台机器上\nconf.set(\"fs.defaultFS\",\"hdfs://hadoop01:9000/\") #程序在设置在yarn上运行时必须设置文件存储为hdfs\n程序里面systemout的日子存在于hadoop里面的logs的userlogs里面对应job_id下的container里的syslog里面\nnamenode在刚启动时只包含block的数量和blockid不知道块所在datanode，要等待datanode向他汇报后才会在namenode元数据中补全文件块的位置信息，只有在namenode找到999.8%的块的位置信息才会退出安全模式正常对外提供服务。\n~~~\n","source":"notes/Bigdata.md","raw":"\n# Bigdata\n\n## 1. Hadoop\n~~~\n1.hdfs集群：负责文件读写\n2.yarn集群：负责为mapredece程序分配运算硬件资源\nHadoop配置：\n1.core-site.xml：fs.DefaultFS\thadoop.tmp.dir\n2.hadoop.env.sh:  JAVA_HOME\n3.mapred-site.xml:  mapreduce.framework.name\n4.hdfs-site.xml:  dfs.replication\n5.yarn-site.xml:   yarn.resourcemanager.hostname  yarn.nodemanager.aux-services    \nslaves：自动化脚本使用的配置文件\n修改Linux启动等待时间  vi /etc/fstab\nmkdir -p  /aa/bb/cc      可以直接建立aa下的bb下的cc  创建层级文件\n挂载光驱：mount -t iso9660 -o ro\t /dev/cdrom  /mnt/cdrom \n设置光驱开机挂载：vi /etc/fstab\t增加 /dev/cdrom\t/mnt/cdrom\tiso9660\tdefaults\t0 0\nrename\t文件重命名\t\n与mv的区别\nmv 支持单个文件重命名\nrename 支持多个文件重命名\ncp /aa/*  /bb\t复制aa下的所有文件到bb下面\nhadoop  fs -put  filename / \t\t上传文件\nhadoop  fs  -get   filename\t\t下载文件\nhadoop 副本数由客户端决定（conf.set 》自定义配置文件》jar包中的配置）\nnamenode和datanode两个的工作目录不能在同一个文件夹下，否则会启动不起来。\neclipse 本地运行代码时遇到调用远程路径权限不够时，在eclipse客户端运行配置时添加VM arguments参数使用hadoop用户运行，参数为“\t-DHADOOP_USER_NAME=hadoop\t”\nmr程序：\nconfiguration参数设置：\nconf.set（”mapreduce.framework.name\",\"local\"）#是否为本地运行模式，默认为local本地模式\nconf.set(\"fs.defaultFS\",\"file:///\")\t#输入输出数据的文件路径，默认为file\nconf.set(\"fs.defaultFS\",\"hdfs://hadoop01:9000/\") #输入输出文件路径\n本地运行模式文件可以用file也可以用hdfs\n设置在yarn上运行程序（要想设置在集群上运行程序 一下三个参数必须设置）\nconf.set（“mapreduce.framework.name”,\"yarn\"）#设置运行模式为在集群上运行\nconf.set(\"yarn.resourcename.hostname\",\"hadoop01\")\t#设置yarn的管理者resourcename在那一台机器上\nconf.set(\"fs.defaultFS\",\"hdfs://hadoop01:9000/\") #程序在设置在yarn上运行时必须设置文件存储为hdfs\n程序里面systemout的日子存在于hadoop里面的logs的userlogs里面对应job_id下的container里的syslog里面\nnamenode在刚启动时只包含block的数量和blockid不知道块所在datanode，要等待datanode向他汇报后才会在namenode元数据中补全文件块的位置信息，只有在namenode找到999.8%的块的位置信息才会退出安全模式正常对外提供服务。\n~~~\n","date":"2020-03-19T09:46:09.000Z","updated":"2020-03-19T09:46:09.000Z","path":"notes/Bigdata.html","title":"","comments":1,"layout":"page","_id":"ck8hf2uv60007zhs65iu2xf0e","content":"<h1 id=\"Bigdata\"><a href=\"#Bigdata\" class=\"headerlink\" title=\"Bigdata\"></a>Bigdata</h1><h2 id=\"1-Hadoop\"><a href=\"#1-Hadoop\" class=\"headerlink\" title=\"1. Hadoop\"></a>1. Hadoop</h2><pre><code>1.hdfs集群：负责文件读写\n2.yarn集群：负责为mapredece程序分配运算硬件资源\nHadoop配置：\n1.core-site.xml：fs.DefaultFS    hadoop.tmp.dir\n2.hadoop.env.sh:  JAVA_HOME\n3.mapred-site.xml:  mapreduce.framework.name\n4.hdfs-site.xml:  dfs.replication\n5.yarn-site.xml:   yarn.resourcemanager.hostname  yarn.nodemanager.aux-services    \nslaves：自动化脚本使用的配置文件\n修改Linux启动等待时间  vi /etc/fstab\nmkdir -p  /aa/bb/cc      可以直接建立aa下的bb下的cc  创建层级文件\n挂载光驱：mount -t iso9660 -o ro     /dev/cdrom  /mnt/cdrom \n设置光驱开机挂载：vi /etc/fstab    增加 /dev/cdrom    /mnt/cdrom    iso9660    defaults    0 0\nrename    文件重命名    \n与mv的区别\nmv 支持单个文件重命名\nrename 支持多个文件重命名\ncp /aa/*  /bb    复制aa下的所有文件到bb下面\nhadoop  fs -put  filename /         上传文件\nhadoop  fs  -get   filename        下载文件\nhadoop 副本数由客户端决定（conf.set 》自定义配置文件》jar包中的配置）\nnamenode和datanode两个的工作目录不能在同一个文件夹下，否则会启动不起来。\neclipse 本地运行代码时遇到调用远程路径权限不够时，在eclipse客户端运行配置时添加VM arguments参数使用hadoop用户运行，参数为“    -DHADOOP_USER_NAME=hadoop    ”\nmr程序：\nconfiguration参数设置：\nconf.set（”mapreduce.framework.name&quot;,&quot;local&quot;）#是否为本地运行模式，默认为local本地模式\nconf.set(&quot;fs.defaultFS&quot;,&quot;file:///&quot;)    #输入输出数据的文件路径，默认为file\nconf.set(&quot;fs.defaultFS&quot;,&quot;hdfs://hadoop01:9000/&quot;) #输入输出文件路径\n本地运行模式文件可以用file也可以用hdfs\n设置在yarn上运行程序（要想设置在集群上运行程序 一下三个参数必须设置）\nconf.set（“mapreduce.framework.name”,&quot;yarn&quot;）#设置运行模式为在集群上运行\nconf.set(&quot;yarn.resourcename.hostname&quot;,&quot;hadoop01&quot;)    #设置yarn的管理者resourcename在那一台机器上\nconf.set(&quot;fs.defaultFS&quot;,&quot;hdfs://hadoop01:9000/&quot;) #程序在设置在yarn上运行时必须设置文件存储为hdfs\n程序里面systemout的日子存在于hadoop里面的logs的userlogs里面对应job_id下的container里的syslog里面\nnamenode在刚启动时只包含block的数量和blockid不知道块所在datanode，要等待datanode向他汇报后才会在namenode元数据中补全文件块的位置信息，只有在namenode找到999.8%的块的位置信息才会退出安全模式正常对外提供服务。</code></pre>","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":"<h1 id=\"Bigdata\"><a href=\"#Bigdata\" class=\"headerlink\" title=\"Bigdata\"></a>Bigdata</h1><h2 id=\"1-Hadoop\"><a href=\"#1-Hadoop\" class=\"headerlink\" title=\"1. Hadoop\"></a>1. Hadoop</h2><pre><code>1.hdfs集群：负责文件读写\n2.yarn集群：负责为mapredece程序分配运算硬件资源\nHadoop配置：\n1.core-site.xml：fs.DefaultFS    hadoop.tmp.dir\n2.hadoop.env.sh:  JAVA_HOME\n3.mapred-site.xml:  mapreduce.framework.name\n4.hdfs-site.xml:  dfs.replication\n5.yarn-site.xml:   yarn.resourcemanager.hostname  yarn.nodemanager.aux-services    \nslaves：自动化脚本使用的配置文件\n修改Linux启动等待时间  vi /etc/fstab\nmkdir -p  /aa/bb/cc      可以直接建立aa下的bb下的cc  创建层级文件\n挂载光驱：mount -t iso9660 -o ro     /dev/cdrom  /mnt/cdrom \n设置光驱开机挂载：vi /etc/fstab    增加 /dev/cdrom    /mnt/cdrom    iso9660    defaults    0 0\nrename    文件重命名    \n与mv的区别\nmv 支持单个文件重命名\nrename 支持多个文件重命名\ncp /aa/*  /bb    复制aa下的所有文件到bb下面\nhadoop  fs -put  filename /         上传文件\nhadoop  fs  -get   filename        下载文件\nhadoop 副本数由客户端决定（conf.set 》自定义配置文件》jar包中的配置）\nnamenode和datanode两个的工作目录不能在同一个文件夹下，否则会启动不起来。\neclipse 本地运行代码时遇到调用远程路径权限不够时，在eclipse客户端运行配置时添加VM arguments参数使用hadoop用户运行，参数为“    -DHADOOP_USER_NAME=hadoop    ”\nmr程序：\nconfiguration参数设置：\nconf.set（”mapreduce.framework.name&quot;,&quot;local&quot;）#是否为本地运行模式，默认为local本地模式\nconf.set(&quot;fs.defaultFS&quot;,&quot;file:///&quot;)    #输入输出数据的文件路径，默认为file\nconf.set(&quot;fs.defaultFS&quot;,&quot;hdfs://hadoop01:9000/&quot;) #输入输出文件路径\n本地运行模式文件可以用file也可以用hdfs\n设置在yarn上运行程序（要想设置在集群上运行程序 一下三个参数必须设置）\nconf.set（“mapreduce.framework.name”,&quot;yarn&quot;）#设置运行模式为在集群上运行\nconf.set(&quot;yarn.resourcename.hostname&quot;,&quot;hadoop01&quot;)    #设置yarn的管理者resourcename在那一台机器上\nconf.set(&quot;fs.defaultFS&quot;,&quot;hdfs://hadoop01:9000/&quot;) #程序在设置在yarn上运行时必须设置文件存储为hdfs\n程序里面systemout的日子存在于hadoop里面的logs的userlogs里面对应job_id下的container里的syslog里面\nnamenode在刚启动时只包含block的数量和blockid不知道块所在datanode，要等待datanode向他汇报后才会在namenode元数据中补全文件块的位置信息，只有在namenode找到999.8%的块的位置信息才会退出安全模式正常对外提供服务。</code></pre>"},{"_content":"# Docker\n\n## 命令\n\n### 镜像\n+ docker images\t//列出本地镜像\n  + -a\t//列出本地所有镜像\n  + -q\t//只显示镜像ID\n  + --digests\t//显示镜像的摘要信息\n  + --no-trunc\t//显示完整的镜像信息\n\n+ docker search\t//查找镜像\n\t+ --no-trunc\t//显示完整的镜像描述\n\t+ -s\t//列出收藏数不小于制定值的镜像\n\t+ --automated\t//只列出automated build 类型的镜像\n\n+ docker pull\t//下载镜像\n\n+ docker rmi\t//删除镜像\n\t+ -f\t//强制删除\n\n+ docker commit\t//提交容器副本使之成为一个新镜像\n\t+ -m\t//提交信息\n\t+ -a\t//作者\n\n### 容器\n+ docker run //使用镜像创建并启动容器\n\t+ -i\t//以交互模式运行容器\n\t+ -t\t//为容器重新分配一个熟人终端，通常与-i同用\n\t+ -d\t//后台运行容器\n\t+ --name\t//为容器指定名字\n\t+ -p\t//指定端口映射\n\t+ -P（大写）\t//随机端口映射\n\t+ -v\t//添加数据卷  ／宿主机绝对路径:/容器内目录\n+ docker ps\t//列出现在正在运行的容器\n\t+ -a\t//列出所有的容器\n\t+ -l\t//显示最近创建的容器\n\t+ -n\t//显示最近n个创建的容器\n\t+ -q\t//只显示容器编号\n\t+ --no-trunc\t//不截断输出\n+ docker exec\t//在运行的容器中执行命令\n+ docker attach\t//进入运行着的容器\n+ docker start\t//启动容器\n+ docker stop\t//关闭容器\n+ docker restart\t//重启容器\n+ docker top\t//查看容器内运行的进程\n+ docker inspect\t//查看容器内部细节\n+ docker cp\t//从容器内拷贝内容到主机上\n+ docker kill\t//杀掉容器\n+ docker rm\t//删除容器\n+ docker logs\t//查看日志\n\t+ -t\t//加入时间戳\n\t+ -f\t//跟进最新日志打印\n\t+ --tail\t//显示最新多少条\n\n\n## 容器数据卷\n容器的持久化，容器间继承+数据共享\n### 数据卷\ndocker run -v /宿主机绝对路径:/容器内目录 镜像名\n### 数据卷容器\ndocker run --volumes-from 父容器\n\n## DockerFile\n是一个由一系列命令和参数组成的构建Docker镜像的文件\n### 关键字\n+ FROM\t//父镜像，依赖镜像\n+ MAINTAINER\t//镜像维护姓名和邮箱\n+ RUN\t//容器构建时需要执行的命令\n+ EXPOSE\t//当前容器对外暴露出的端口\n+ WORKDIR\t//指定容器创建后，登陆进来的工作目录\n+ ENV\t//用来在构建镜像过程中设置的环境变量\n+ ADD\t//将宿主目录下的文件加载进容器里（自动处理url和解压）\n+ COPY\t//将宿主目录下的文件复制到容器相关目录\n+ VOLUME\t//容器数据卷，用于数据共享和持久化\n+ CMD\t//指定容器启动时要运行的命令（多个命令时只有最后一个生效，运行时指定的命令耶会覆盖cmd 命令）\n+ ENTRYPOINT\t//指定容器启动时要运行的命令，运行时指定的命令会被追加）\n+ ONBUILD\t//当构建一个被继承的DockerFile时的运行命令，父镜像的onbuild 在子镜像被build时触发\n\n\n\n\n\n\n\n\n\n\n","source":"notes/Docker.md","raw":"# Docker\n\n## 命令\n\n### 镜像\n+ docker images\t//列出本地镜像\n  + -a\t//列出本地所有镜像\n  + -q\t//只显示镜像ID\n  + --digests\t//显示镜像的摘要信息\n  + --no-trunc\t//显示完整的镜像信息\n\n+ docker search\t//查找镜像\n\t+ --no-trunc\t//显示完整的镜像描述\n\t+ -s\t//列出收藏数不小于制定值的镜像\n\t+ --automated\t//只列出automated build 类型的镜像\n\n+ docker pull\t//下载镜像\n\n+ docker rmi\t//删除镜像\n\t+ -f\t//强制删除\n\n+ docker commit\t//提交容器副本使之成为一个新镜像\n\t+ -m\t//提交信息\n\t+ -a\t//作者\n\n### 容器\n+ docker run //使用镜像创建并启动容器\n\t+ -i\t//以交互模式运行容器\n\t+ -t\t//为容器重新分配一个熟人终端，通常与-i同用\n\t+ -d\t//后台运行容器\n\t+ --name\t//为容器指定名字\n\t+ -p\t//指定端口映射\n\t+ -P（大写）\t//随机端口映射\n\t+ -v\t//添加数据卷  ／宿主机绝对路径:/容器内目录\n+ docker ps\t//列出现在正在运行的容器\n\t+ -a\t//列出所有的容器\n\t+ -l\t//显示最近创建的容器\n\t+ -n\t//显示最近n个创建的容器\n\t+ -q\t//只显示容器编号\n\t+ --no-trunc\t//不截断输出\n+ docker exec\t//在运行的容器中执行命令\n+ docker attach\t//进入运行着的容器\n+ docker start\t//启动容器\n+ docker stop\t//关闭容器\n+ docker restart\t//重启容器\n+ docker top\t//查看容器内运行的进程\n+ docker inspect\t//查看容器内部细节\n+ docker cp\t//从容器内拷贝内容到主机上\n+ docker kill\t//杀掉容器\n+ docker rm\t//删除容器\n+ docker logs\t//查看日志\n\t+ -t\t//加入时间戳\n\t+ -f\t//跟进最新日志打印\n\t+ --tail\t//显示最新多少条\n\n\n## 容器数据卷\n容器的持久化，容器间继承+数据共享\n### 数据卷\ndocker run -v /宿主机绝对路径:/容器内目录 镜像名\n### 数据卷容器\ndocker run --volumes-from 父容器\n\n## DockerFile\n是一个由一系列命令和参数组成的构建Docker镜像的文件\n### 关键字\n+ FROM\t//父镜像，依赖镜像\n+ MAINTAINER\t//镜像维护姓名和邮箱\n+ RUN\t//容器构建时需要执行的命令\n+ EXPOSE\t//当前容器对外暴露出的端口\n+ WORKDIR\t//指定容器创建后，登陆进来的工作目录\n+ ENV\t//用来在构建镜像过程中设置的环境变量\n+ ADD\t//将宿主目录下的文件加载进容器里（自动处理url和解压）\n+ COPY\t//将宿主目录下的文件复制到容器相关目录\n+ VOLUME\t//容器数据卷，用于数据共享和持久化\n+ CMD\t//指定容器启动时要运行的命令（多个命令时只有最后一个生效，运行时指定的命令耶会覆盖cmd 命令）\n+ ENTRYPOINT\t//指定容器启动时要运行的命令，运行时指定的命令会被追加）\n+ ONBUILD\t//当构建一个被继承的DockerFile时的运行命令，父镜像的onbuild 在子镜像被build时触发\n\n\n\n\n\n\n\n\n\n\n","date":"2020-03-19T05:09:33.000Z","updated":"2020-03-18T11:52:16.000Z","path":"notes/Docker.html","title":"","comments":1,"layout":"page","_id":"ck8hf2uv70008zhs6j685kcim","content":"<h1 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h1><h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><h3 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h3><ul>\n<li><p>docker images    //列出本地镜像</p>\n<ul>\n<li>-a    //列出本地所有镜像</li>\n<li>-q    //只显示镜像ID</li>\n<li>–digests    //显示镜像的摘要信息</li>\n<li>–no-trunc    //显示完整的镜像信息</li>\n</ul>\n</li>\n<li><p>docker search    //查找镜像</p>\n<ul>\n<li>–no-trunc    //显示完整的镜像描述</li>\n<li>-s    //列出收藏数不小于制定值的镜像</li>\n<li>–automated    //只列出automated build 类型的镜像</li>\n</ul>\n</li>\n<li><p>docker pull    //下载镜像</p>\n</li>\n<li><p>docker rmi    //删除镜像</p>\n<ul>\n<li>-f    //强制删除</li>\n</ul>\n</li>\n<li><p>docker commit    //提交容器副本使之成为一个新镜像</p>\n<ul>\n<li>-m    //提交信息</li>\n<li>-a    //作者</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><ul>\n<li>docker run //使用镜像创建并启动容器<ul>\n<li>-i    //以交互模式运行容器</li>\n<li>-t    //为容器重新分配一个熟人终端，通常与-i同用</li>\n<li>-d    //后台运行容器</li>\n<li>–name    //为容器指定名字</li>\n<li>-p    //指定端口映射</li>\n<li>-P（大写）    //随机端口映射</li>\n<li>-v    //添加数据卷  ／宿主机绝对路径:/容器内目录</li>\n</ul>\n</li>\n<li>docker ps    //列出现在正在运行的容器<ul>\n<li>-a    //列出所有的容器</li>\n<li>-l    //显示最近创建的容器</li>\n<li>-n    //显示最近n个创建的容器</li>\n<li>-q    //只显示容器编号</li>\n<li>–no-trunc    //不截断输出</li>\n</ul>\n</li>\n<li>docker exec    //在运行的容器中执行命令</li>\n<li>docker attach    //进入运行着的容器</li>\n<li>docker start    //启动容器</li>\n<li>docker stop    //关闭容器</li>\n<li>docker restart    //重启容器</li>\n<li>docker top    //查看容器内运行的进程</li>\n<li>docker inspect    //查看容器内部细节</li>\n<li>docker cp    //从容器内拷贝内容到主机上</li>\n<li>docker kill    //杀掉容器</li>\n<li>docker rm    //删除容器</li>\n<li>docker logs    //查看日志<ul>\n<li>-t    //加入时间戳</li>\n<li>-f    //跟进最新日志打印</li>\n<li>–tail    //显示最新多少条</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"容器数据卷\"><a href=\"#容器数据卷\" class=\"headerlink\" title=\"容器数据卷\"></a>容器数据卷</h2><p>容器的持久化，容器间继承+数据共享</p>\n<h3 id=\"数据卷\"><a href=\"#数据卷\" class=\"headerlink\" title=\"数据卷\"></a>数据卷</h3><p>docker run -v /宿主机绝对路径:/容器内目录 镜像名</p>\n<h3 id=\"数据卷容器\"><a href=\"#数据卷容器\" class=\"headerlink\" title=\"数据卷容器\"></a>数据卷容器</h3><p>docker run –volumes-from 父容器</p>\n<h2 id=\"DockerFile\"><a href=\"#DockerFile\" class=\"headerlink\" title=\"DockerFile\"></a>DockerFile</h2><p>是一个由一系列命令和参数组成的构建Docker镜像的文件</p>\n<h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><ul>\n<li>FROM    //父镜像，依赖镜像</li>\n<li>MAINTAINER    //镜像维护姓名和邮箱</li>\n<li>RUN    //容器构建时需要执行的命令</li>\n<li>EXPOSE    //当前容器对外暴露出的端口</li>\n<li>WORKDIR    //指定容器创建后，登陆进来的工作目录</li>\n<li>ENV    //用来在构建镜像过程中设置的环境变量</li>\n<li>ADD    //将宿主目录下的文件加载进容器里（自动处理url和解压）</li>\n<li>COPY    //将宿主目录下的文件复制到容器相关目录</li>\n<li>VOLUME    //容器数据卷，用于数据共享和持久化</li>\n<li>CMD    //指定容器启动时要运行的命令（多个命令时只有最后一个生效，运行时指定的命令耶会覆盖cmd 命令）</li>\n<li>ENTRYPOINT    //指定容器启动时要运行的命令，运行时指定的命令会被追加）</li>\n<li>ONBUILD    //当构建一个被继承的DockerFile时的运行命令，父镜像的onbuild 在子镜像被build时触发</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":"<h1 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h1><h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><h3 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h3><ul>\n<li><p>docker images    //列出本地镜像</p>\n<ul>\n<li>-a    //列出本地所有镜像</li>\n<li>-q    //只显示镜像ID</li>\n<li>–digests    //显示镜像的摘要信息</li>\n<li>–no-trunc    //显示完整的镜像信息</li>\n</ul>\n</li>\n<li><p>docker search    //查找镜像</p>\n<ul>\n<li>–no-trunc    //显示完整的镜像描述</li>\n<li>-s    //列出收藏数不小于制定值的镜像</li>\n<li>–automated    //只列出automated build 类型的镜像</li>\n</ul>\n</li>\n<li><p>docker pull    //下载镜像</p>\n</li>\n<li><p>docker rmi    //删除镜像</p>\n<ul>\n<li>-f    //强制删除</li>\n</ul>\n</li>\n<li><p>docker commit    //提交容器副本使之成为一个新镜像</p>\n<ul>\n<li>-m    //提交信息</li>\n<li>-a    //作者</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><ul>\n<li>docker run //使用镜像创建并启动容器<ul>\n<li>-i    //以交互模式运行容器</li>\n<li>-t    //为容器重新分配一个熟人终端，通常与-i同用</li>\n<li>-d    //后台运行容器</li>\n<li>–name    //为容器指定名字</li>\n<li>-p    //指定端口映射</li>\n<li>-P（大写）    //随机端口映射</li>\n<li>-v    //添加数据卷  ／宿主机绝对路径:/容器内目录</li>\n</ul>\n</li>\n<li>docker ps    //列出现在正在运行的容器<ul>\n<li>-a    //列出所有的容器</li>\n<li>-l    //显示最近创建的容器</li>\n<li>-n    //显示最近n个创建的容器</li>\n<li>-q    //只显示容器编号</li>\n<li>–no-trunc    //不截断输出</li>\n</ul>\n</li>\n<li>docker exec    //在运行的容器中执行命令</li>\n<li>docker attach    //进入运行着的容器</li>\n<li>docker start    //启动容器</li>\n<li>docker stop    //关闭容器</li>\n<li>docker restart    //重启容器</li>\n<li>docker top    //查看容器内运行的进程</li>\n<li>docker inspect    //查看容器内部细节</li>\n<li>docker cp    //从容器内拷贝内容到主机上</li>\n<li>docker kill    //杀掉容器</li>\n<li>docker rm    //删除容器</li>\n<li>docker logs    //查看日志<ul>\n<li>-t    //加入时间戳</li>\n<li>-f    //跟进最新日志打印</li>\n<li>–tail    //显示最新多少条</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"容器数据卷\"><a href=\"#容器数据卷\" class=\"headerlink\" title=\"容器数据卷\"></a>容器数据卷</h2><p>容器的持久化，容器间继承+数据共享</p>\n<h3 id=\"数据卷\"><a href=\"#数据卷\" class=\"headerlink\" title=\"数据卷\"></a>数据卷</h3><p>docker run -v /宿主机绝对路径:/容器内目录 镜像名</p>\n<h3 id=\"数据卷容器\"><a href=\"#数据卷容器\" class=\"headerlink\" title=\"数据卷容器\"></a>数据卷容器</h3><p>docker run –volumes-from 父容器</p>\n<h2 id=\"DockerFile\"><a href=\"#DockerFile\" class=\"headerlink\" title=\"DockerFile\"></a>DockerFile</h2><p>是一个由一系列命令和参数组成的构建Docker镜像的文件</p>\n<h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><ul>\n<li>FROM    //父镜像，依赖镜像</li>\n<li>MAINTAINER    //镜像维护姓名和邮箱</li>\n<li>RUN    //容器构建时需要执行的命令</li>\n<li>EXPOSE    //当前容器对外暴露出的端口</li>\n<li>WORKDIR    //指定容器创建后，登陆进来的工作目录</li>\n<li>ENV    //用来在构建镜像过程中设置的环境变量</li>\n<li>ADD    //将宿主目录下的文件加载进容器里（自动处理url和解压）</li>\n<li>COPY    //将宿主目录下的文件复制到容器相关目录</li>\n<li>VOLUME    //容器数据卷，用于数据共享和持久化</li>\n<li>CMD    //指定容器启动时要运行的命令（多个命令时只有最后一个生效，运行时指定的命令耶会覆盖cmd 命令）</li>\n<li>ENTRYPOINT    //指定容器启动时要运行的命令，运行时指定的命令会被追加）</li>\n<li>ONBUILD    //当构建一个被继承的DockerFile时的运行命令，父镜像的onbuild 在子镜像被build时触发</li>\n</ul>\n"},{"_content":"1. 表的数据加载\n\n   1. insert\n   2. load\n\n2. 创建分区表（外表）\n\n3. 数据导出\n\n   1. hdfs dfs -get filename\n\n   2. hdfs dfs -text filename    //查看\n\n      1. insert overwrite 【local】 directory 'filename'\n\n         【row format delimited fields terminated by '\\t'】\n\n         select col， col1 from tablename\n\n         //local 与 row。。 只能在导出到本地时使用\n\n   3. Shell 命令加管道：hive -f/e | sed/awk/gred >filename\n\n   4. sqoop\n\n   5. 动态分区\n\n      1. 设置 set hive.exec.dynamic.partition=true //设置使用动态分区\n      2. 设置 set hive.exec.dynamic.partition.mode=nonstrict //使用无限制模式\n      3. insert into table tablename partition(dt) select col,col1 as dt from tablename  //一个分区 动态设置\n      4. Insert into table tablename partition(dt='2017',value) select col,col1 as value from tablename //两个分区 ，静态分区必须在设置的动态分区前面\n\n   6. 修改表\n\n      1. 重命名表 alter table tablename rename to newtablename;\n\n      2. 修改列名 alter table tablename change column c1 c2 int comment 'xxx';\n\n      3. 移动列的位置 alter table  tablename change column c1 c2 after c3;\n\n      4. 增加列 alter table tablename add columns(c1 string comment 'xxx',c2 int);\n\n      5. 删除列 alter table tablename replace columns(col string,col1 int) \n\n         //col col1 都是保留下来的列\n\n      6. 修改分割符 alter table tablename【partition(dt='xxxx')】 set serdeproperties('field.delim'='\\t')\n\n      7. 修改location;\n\n          alter table tablename 【partition()】set location 'path'\n\n      8. 内部表改外部表 \n\n         alter table tablename set tblproperties('EXTERNAL'='TRUE')  \n\n         //外部表改内部表 EXTERNAL=FALSE；\n\n   7. group by：\n\n      select col1,col2 from tablename group by col1,col2\n\n      //查询的列 col1，col2 必须出现在group by后面；\n\n   8. sum(col)  //col可为int，double 等数字类型也可以为string类型\n\n   9. 在hive中使用python脚本\n\n      add file filenamepath //先将脚本缓存到hive集群上\n\n      select * from ( select transform (col,col1) using 'filename' 【as coll ,coll2】from tablename  ) tablename\n\n   10. 【inner】join，left 【outer】 join，right 【outer】 join, full 【outer】 join，\n\n     /* +mapjoin(tablename) */,left semi join 相当于in \n\n   11. 函数\n\n       1. nvl(col,0) //如果col非空则显示col否则显示0\n       2. 【nvl2(col1,col2,col3) //如果col1为空则显示col2否则显示col3】\n       3. 【nullif(col1,col2) //如果col1与col2相等则返回null否则返回col1】\n       4. coalesce(col1,col2,col3….) //返回第一个非空（null）值，如果都为空则返回null\n       5. concat(col1,col2….) //字符串拼接，如果col1或col2中有一个为null则返回null\n       6. concat_ws(',',col1,col2…..) //带有分隔符的字符串拼接，如果有col2为null则不会拼接，拼接的内容可以为array\n       7. cast(1 as bigint) //转化1为bigint\n       8. round(0.0089,4) //保留4位小数\n       9. if (condition,a,b) //若condition为真则返回a，否则返回b；\n       10. explode(array(or map)) //将输入的一行数组或map转换成列输出\n       11. split(str,',') //第一个参数是要分隔的字符串，第二个参数是分隔符，分隔后的数据可看成数组\n\n   12. distribute by 打散数据 长和sort by（使每一个reduce里面的数据都有序）连用。distribute by 与group by 都是安key对数据进行划分，都使用reduce操作，但是distribute by只是将数据分散，而group by 是把相同的key聚集到一起然后进行聚合操作。sort by与order by，order by 是全局排序，只会有一个reduce ，sort by是确保每一个reduce 上的数据都是有序的，如果只有一个reduce时，sort by 和order by作用是一样的。\n\n   13. cluster by\n\n   14. unoin all\n\n   15. 自定义UDF：\n\n       重写evaluate函数\n\n   16. 优化：\n\n       1. join优化\n\n          hive.optimize.skewjoin=true\n\n          hive.skewjoin.key=n //当key的数量到达n时会主动进行优化\n\n       2. mapjoin\n\n          hive.atuo.conwert.join=true\n\n          hive.mapjoin.smalltable.filesize=n\n\n          select /*+mapjoin(a) */,col1,col2 form a join b\n\n          注：a表要非常小，mapjoin因为是在map端操作可以进行不等值操作\n\n       3. group by \n\n          hive.groupby.skewindata=true\n\n          Hive.groupby.mapaggr.checkinterval=n\n\n       4. job\n\n          hive.exec.parallel=true. //设置job的并行化\n\n          hive.exec.parallel.thread.numbe=n //设置最大线程数\n\n          hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat //合并文件，文件受mapred.max.split.size大小的限制\n\n          Hive.merge.smallfiles.avgsize=n  //设置输出文件平均大小小于改值，启动job合并文件\n\n          Hive.merge.size.per.task=n //合并之后文件的大小\n\n       5. \n\n       6. \n\n          \n\n   17. yarn queue -status mt1\n\n   18. mapred【hadoop】 queue -list\n\n   19. \n\n   20. \n\n       \n\n   21. 命令：\n\n       1. mapred[hadoop] job -list | grep o2o4 //查job\n       2. ps -ef| grep xxxx.sh | grep -v grep // 查进程\n       3. mapred[hadoop] queue -list // 查队列（所有）\n       4. yarn queue -status o2o4  //查队列（单个）\n       5. du -h //查文件大小\n       6. sed -n 's/old/new/gp' filename //-n  代表行   g 全局 p 打印  \n       7. 使用”;”时，不管command1是否执行成功都会执行command2； 使用”&&”时，只有command1执行成功后，command2才会执行，否则command2不执行；使用”||”时，command1执行成功后command2 不执行，否则去执行command2，总之command1和command2总有一条命令会执行。\n       8. \n\n\n* hive 分区下有数据但是查询表没有数据\n\n  可以是表的读入设置了压缩等其他格式，单纯txt的文件，表无法读取\n\n  STORED AS INPUTFORMAT \n    'com.hadoop.mapred.DeprecatedLzoTextInputFormat'   //设置压缩为lzo 所以只能读取lzo数据\n\n* Hive count(distinct ) 优化\n\n  可以先进行group by  然后再进行count\n\n  ```sql\n  select count(*),count(distinct col) from tablename where day_id=20180708\n  ```\n\n\n  select max(cnt), max(mdn_cnt), max(day_id) from (select null  as cnt , count(*) as mdn_cnt , day_id  as day_id from (select mdn, day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by mdn,day_id )a group by  day_id union all select count(*) as cnt, null  as mdn_cnt , day_id as day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by day_id )b;//union all\n\n\n  select b.cnt,a.mdn_cnt ,a.day_id from (\n  select count(*) as mdn_cnt ,day_id from (select mdn,day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by mdn,day_id)a1 group by day_id)a\n  left join \n  (select count(*) as cnt, day_id from dwi_m.dwi_res_regn_mergelocation_msk_d  b where day_id=20180708 group by day_id)b\n  on a.day_id=b.day_id;//join\n\n\n  join 和 union all 用的时间差不多  但相对 直接count distinct 要 少很多","source":"notes/Hive.md","raw":"1. 表的数据加载\n\n   1. insert\n   2. load\n\n2. 创建分区表（外表）\n\n3. 数据导出\n\n   1. hdfs dfs -get filename\n\n   2. hdfs dfs -text filename    //查看\n\n      1. insert overwrite 【local】 directory 'filename'\n\n         【row format delimited fields terminated by '\\t'】\n\n         select col， col1 from tablename\n\n         //local 与 row。。 只能在导出到本地时使用\n\n   3. Shell 命令加管道：hive -f/e | sed/awk/gred >filename\n\n   4. sqoop\n\n   5. 动态分区\n\n      1. 设置 set hive.exec.dynamic.partition=true //设置使用动态分区\n      2. 设置 set hive.exec.dynamic.partition.mode=nonstrict //使用无限制模式\n      3. insert into table tablename partition(dt) select col,col1 as dt from tablename  //一个分区 动态设置\n      4. Insert into table tablename partition(dt='2017',value) select col,col1 as value from tablename //两个分区 ，静态分区必须在设置的动态分区前面\n\n   6. 修改表\n\n      1. 重命名表 alter table tablename rename to newtablename;\n\n      2. 修改列名 alter table tablename change column c1 c2 int comment 'xxx';\n\n      3. 移动列的位置 alter table  tablename change column c1 c2 after c3;\n\n      4. 增加列 alter table tablename add columns(c1 string comment 'xxx',c2 int);\n\n      5. 删除列 alter table tablename replace columns(col string,col1 int) \n\n         //col col1 都是保留下来的列\n\n      6. 修改分割符 alter table tablename【partition(dt='xxxx')】 set serdeproperties('field.delim'='\\t')\n\n      7. 修改location;\n\n          alter table tablename 【partition()】set location 'path'\n\n      8. 内部表改外部表 \n\n         alter table tablename set tblproperties('EXTERNAL'='TRUE')  \n\n         //外部表改内部表 EXTERNAL=FALSE；\n\n   7. group by：\n\n      select col1,col2 from tablename group by col1,col2\n\n      //查询的列 col1，col2 必须出现在group by后面；\n\n   8. sum(col)  //col可为int，double 等数字类型也可以为string类型\n\n   9. 在hive中使用python脚本\n\n      add file filenamepath //先将脚本缓存到hive集群上\n\n      select * from ( select transform (col,col1) using 'filename' 【as coll ,coll2】from tablename  ) tablename\n\n   10. 【inner】join，left 【outer】 join，right 【outer】 join, full 【outer】 join，\n\n     /* +mapjoin(tablename) */,left semi join 相当于in \n\n   11. 函数\n\n       1. nvl(col,0) //如果col非空则显示col否则显示0\n       2. 【nvl2(col1,col2,col3) //如果col1为空则显示col2否则显示col3】\n       3. 【nullif(col1,col2) //如果col1与col2相等则返回null否则返回col1】\n       4. coalesce(col1,col2,col3….) //返回第一个非空（null）值，如果都为空则返回null\n       5. concat(col1,col2….) //字符串拼接，如果col1或col2中有一个为null则返回null\n       6. concat_ws(',',col1,col2…..) //带有分隔符的字符串拼接，如果有col2为null则不会拼接，拼接的内容可以为array\n       7. cast(1 as bigint) //转化1为bigint\n       8. round(0.0089,4) //保留4位小数\n       9. if (condition,a,b) //若condition为真则返回a，否则返回b；\n       10. explode(array(or map)) //将输入的一行数组或map转换成列输出\n       11. split(str,',') //第一个参数是要分隔的字符串，第二个参数是分隔符，分隔后的数据可看成数组\n\n   12. distribute by 打散数据 长和sort by（使每一个reduce里面的数据都有序）连用。distribute by 与group by 都是安key对数据进行划分，都使用reduce操作，但是distribute by只是将数据分散，而group by 是把相同的key聚集到一起然后进行聚合操作。sort by与order by，order by 是全局排序，只会有一个reduce ，sort by是确保每一个reduce 上的数据都是有序的，如果只有一个reduce时，sort by 和order by作用是一样的。\n\n   13. cluster by\n\n   14. unoin all\n\n   15. 自定义UDF：\n\n       重写evaluate函数\n\n   16. 优化：\n\n       1. join优化\n\n          hive.optimize.skewjoin=true\n\n          hive.skewjoin.key=n //当key的数量到达n时会主动进行优化\n\n       2. mapjoin\n\n          hive.atuo.conwert.join=true\n\n          hive.mapjoin.smalltable.filesize=n\n\n          select /*+mapjoin(a) */,col1,col2 form a join b\n\n          注：a表要非常小，mapjoin因为是在map端操作可以进行不等值操作\n\n       3. group by \n\n          hive.groupby.skewindata=true\n\n          Hive.groupby.mapaggr.checkinterval=n\n\n       4. job\n\n          hive.exec.parallel=true. //设置job的并行化\n\n          hive.exec.parallel.thread.numbe=n //设置最大线程数\n\n          hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat //合并文件，文件受mapred.max.split.size大小的限制\n\n          Hive.merge.smallfiles.avgsize=n  //设置输出文件平均大小小于改值，启动job合并文件\n\n          Hive.merge.size.per.task=n //合并之后文件的大小\n\n       5. \n\n       6. \n\n          \n\n   17. yarn queue -status mt1\n\n   18. mapred【hadoop】 queue -list\n\n   19. \n\n   20. \n\n       \n\n   21. 命令：\n\n       1. mapred[hadoop] job -list | grep o2o4 //查job\n       2. ps -ef| grep xxxx.sh | grep -v grep // 查进程\n       3. mapred[hadoop] queue -list // 查队列（所有）\n       4. yarn queue -status o2o4  //查队列（单个）\n       5. du -h //查文件大小\n       6. sed -n 's/old/new/gp' filename //-n  代表行   g 全局 p 打印  \n       7. 使用”;”时，不管command1是否执行成功都会执行command2； 使用”&&”时，只有command1执行成功后，command2才会执行，否则command2不执行；使用”||”时，command1执行成功后command2 不执行，否则去执行command2，总之command1和command2总有一条命令会执行。\n       8. \n\n\n* hive 分区下有数据但是查询表没有数据\n\n  可以是表的读入设置了压缩等其他格式，单纯txt的文件，表无法读取\n\n  STORED AS INPUTFORMAT \n    'com.hadoop.mapred.DeprecatedLzoTextInputFormat'   //设置压缩为lzo 所以只能读取lzo数据\n\n* Hive count(distinct ) 优化\n\n  可以先进行group by  然后再进行count\n\n  ```sql\n  select count(*),count(distinct col) from tablename where day_id=20180708\n  ```\n\n\n  select max(cnt), max(mdn_cnt), max(day_id) from (select null  as cnt , count(*) as mdn_cnt , day_id  as day_id from (select mdn, day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by mdn,day_id )a group by  day_id union all select count(*) as cnt, null  as mdn_cnt , day_id as day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by day_id )b;//union all\n\n\n  select b.cnt,a.mdn_cnt ,a.day_id from (\n  select count(*) as mdn_cnt ,day_id from (select mdn,day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by mdn,day_id)a1 group by day_id)a\n  left join \n  (select count(*) as cnt, day_id from dwi_m.dwi_res_regn_mergelocation_msk_d  b where day_id=20180708 group by day_id)b\n  on a.day_id=b.day_id;//join\n\n\n  join 和 union all 用的时间差不多  但相对 直接count distinct 要 少很多","date":"2020-03-19T05:09:33.000Z","updated":"2020-03-18T11:52:16.000Z","path":"notes/Hive.html","title":"","comments":1,"layout":"page","_id":"ck8hf2uv9000czhs6qrx4mqlc","content":"<ol>\n<li><p>表的数据加载</p>\n<ol>\n<li>insert</li>\n<li>load</li>\n</ol>\n</li>\n<li><p>创建分区表（外表）</p>\n</li>\n<li><p>数据导出</p>\n<ol>\n<li><p>hdfs dfs -get filename</p>\n</li>\n<li><p>hdfs dfs -text filename    //查看</p>\n<ol>\n<li><p>insert overwrite 【local】 directory ‘filename’</p>\n<p>【row format delimited fields terminated by ‘\\t’】</p>\n<p>select col， col1 from tablename</p>\n<p>//local 与 row。。 只能在导出到本地时使用</p>\n</li>\n</ol>\n</li>\n<li><p>Shell 命令加管道：hive -f/e | sed/awk/gred &gt;filename</p>\n</li>\n<li><p>sqoop</p>\n</li>\n<li><p>动态分区</p>\n<ol>\n<li>设置 set hive.exec.dynamic.partition=true //设置使用动态分区</li>\n<li>设置 set hive.exec.dynamic.partition.mode=nonstrict //使用无限制模式</li>\n<li>insert into table tablename partition(dt) select col,col1 as dt from tablename  //一个分区 动态设置</li>\n<li>Insert into table tablename partition(dt=’2017’,value) select col,col1 as value from tablename //两个分区 ，静态分区必须在设置的动态分区前面</li>\n</ol>\n</li>\n<li><p>修改表</p>\n<ol>\n<li><p>重命名表 alter table tablename rename to newtablename;</p>\n</li>\n<li><p>修改列名 alter table tablename change column c1 c2 int comment ‘xxx’;</p>\n</li>\n<li><p>移动列的位置 alter table  tablename change column c1 c2 after c3;</p>\n</li>\n<li><p>增加列 alter table tablename add columns(c1 string comment ‘xxx’,c2 int);</p>\n</li>\n<li><p>删除列 alter table tablename replace columns(col string,col1 int) </p>\n<p>//col col1 都是保留下来的列</p>\n</li>\n<li><p>修改分割符 alter table tablename【partition(dt=’xxxx’)】 set serdeproperties(‘field.delim’=’\\t’)</p>\n</li>\n<li><p>修改location;</p>\n<p> alter table tablename 【partition()】set location ‘path’</p>\n</li>\n<li><p>内部表改外部表 </p>\n<p>alter table tablename set tblproperties(‘EXTERNAL’=’TRUE’)  </p>\n<p>//外部表改内部表 EXTERNAL=FALSE；</p>\n</li>\n</ol>\n</li>\n<li><p>group by：</p>\n<p>select col1,col2 from tablename group by col1,col2</p>\n<p>//查询的列 col1，col2 必须出现在group by后面；</p>\n</li>\n<li><p>sum(col)  //col可为int，double 等数字类型也可以为string类型</p>\n</li>\n<li><p>在hive中使用python脚本</p>\n<p>add file filenamepath //先将脚本缓存到hive集群上</p>\n<p>select * from ( select transform (col,col1) using ‘filename’ 【as coll ,coll2】from tablename  ) tablename</p>\n</li>\n<li><p>【inner】join，left 【outer】 join，right 【outer】 join, full 【outer】 join，</p>\n<p>/* +mapjoin(tablename) */,left semi join 相当于in </p>\n</li>\n<li><p>函数</p>\n<ol>\n<li>nvl(col,0) //如果col非空则显示col否则显示0</li>\n<li>【nvl2(col1,col2,col3) //如果col1为空则显示col2否则显示col3】</li>\n<li>【nullif(col1,col2) //如果col1与col2相等则返回null否则返回col1】</li>\n<li>coalesce(col1,col2,col3….) //返回第一个非空（null）值，如果都为空则返回null</li>\n<li>concat(col1,col2….) //字符串拼接，如果col1或col2中有一个为null则返回null</li>\n<li>concat_ws(‘,’,col1,col2…..) //带有分隔符的字符串拼接，如果有col2为null则不会拼接，拼接的内容可以为array</li>\n<li>cast(1 as bigint) //转化1为bigint</li>\n<li>round(0.0089,4) //保留4位小数</li>\n<li>if (condition,a,b) //若condition为真则返回a，否则返回b；</li>\n<li>explode(array(or map)) //将输入的一行数组或map转换成列输出</li>\n<li>split(str,’,’) //第一个参数是要分隔的字符串，第二个参数是分隔符，分隔后的数据可看成数组</li>\n</ol>\n</li>\n<li><p>distribute by 打散数据 长和sort by（使每一个reduce里面的数据都有序）连用。distribute by 与group by 都是安key对数据进行划分，都使用reduce操作，但是distribute by只是将数据分散，而group by 是把相同的key聚集到一起然后进行聚合操作。sort by与order by，order by 是全局排序，只会有一个reduce ，sort by是确保每一个reduce 上的数据都是有序的，如果只有一个reduce时，sort by 和order by作用是一样的。</p>\n</li>\n<li><p>cluster by</p>\n</li>\n<li><p>unoin all</p>\n</li>\n<li><p>自定义UDF：</p>\n<p>重写evaluate函数</p>\n</li>\n<li><p>优化：</p>\n<ol>\n<li><p>join优化</p>\n<p>hive.optimize.skewjoin=true</p>\n<p>hive.skewjoin.key=n //当key的数量到达n时会主动进行优化</p>\n</li>\n<li><p>mapjoin</p>\n<p>hive.atuo.conwert.join=true</p>\n<p>hive.mapjoin.smalltable.filesize=n</p>\n<p>select /*+mapjoin(a) */,col1,col2 form a join b</p>\n<p>注：a表要非常小，mapjoin因为是在map端操作可以进行不等值操作</p>\n</li>\n<li><p>group by </p>\n<p>hive.groupby.skewindata=true</p>\n<p>Hive.groupby.mapaggr.checkinterval=n</p>\n</li>\n<li><p>job</p>\n<p>hive.exec.parallel=true. //设置job的并行化</p>\n<p>hive.exec.parallel.thread.numbe=n //设置最大线程数</p>\n<p>hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat //合并文件，文件受mapred.max.split.size大小的限制</p>\n<p>Hive.merge.smallfiles.avgsize=n  //设置输出文件平均大小小于改值，启动job合并文件</p>\n<p>Hive.merge.size.per.task=n //合并之后文件的大小</p>\n</li>\n<li></li>\n<li></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<ol start=\"17\">\n<li><p>yarn queue -status mt1</p>\n</li>\n<li><p>mapred【hadoop】 queue -list</p>\n</li>\n<li></li>\n<li></li>\n</ol>\n<ol start=\"21\">\n<li><p>命令：</p>\n<ol>\n<li>mapred[hadoop] job -list | grep o2o4 //查job</li>\n<li>ps -ef| grep xxxx.sh | grep -v grep // 查进程</li>\n<li>mapred[hadoop] queue -list // 查队列（所有）</li>\n<li>yarn queue -status o2o4  //查队列（单个）</li>\n<li>du -h //查文件大小</li>\n<li>sed -n ‘s/old/new/gp’ filename //-n  代表行   g 全局 p 打印  </li>\n<li>使用”;”时，不管command1是否执行成功都会执行command2； 使用”&amp;&amp;”时，只有command1执行成功后，command2才会执行，否则command2不执行；使用”||”时，command1执行成功后command2 不执行，否则去执行command2，总之command1和command2总有一条命令会执行。</li>\n<li></li>\n</ol>\n</li>\n</ol>\n<ul>\n<li><p>hive 分区下有数据但是查询表没有数据</p>\n<p>可以是表的读入设置了压缩等其他格式，单纯txt的文件，表无法读取</p>\n<p>STORED AS INPUTFORMAT<br>  ‘com.hadoop.mapred.DeprecatedLzoTextInputFormat’   //设置压缩为lzo 所以只能读取lzo数据</p>\n</li>\n<li><p>Hive count(distinct ) 优化</p>\n<p>可以先进行group by  然后再进行count</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">distinct</span> col<span class=\"token punctuation\">)</span> <span class=\"token keyword\">from</span> tablename <span class=\"token keyword\">where</span> day_id<span class=\"token operator\">=</span><span class=\"token number\">20180708</span></code></pre>\n</li>\n</ul>\n<p>  select max(cnt), max(mdn_cnt), max(day_id) from (select null  as cnt , count(<em>) as mdn_cnt , day_id  as day_id from (select mdn, day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by mdn,day_id )a group by  day_id union all select count(</em>) as cnt, null  as mdn_cnt , day_id as day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by day_id )b;//union all</p>\n<p>  select b.cnt,a.mdn_cnt ,a.day_id from (<br>  select count(<em>) as mdn_cnt ,day_id from (select mdn,day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by mdn,day_id)a1 group by day_id)a<br>  left join<br>  (select count(</em>) as cnt, day_id from dwi_m.dwi_res_regn_mergelocation_msk_d  b where day_id=20180708 group by day_id)b<br>  on a.day_id=b.day_id;//join</p>\n<p>  join 和 union all 用的时间差不多  但相对 直接count distinct 要 少很多</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":"<ol>\n<li><p>表的数据加载</p>\n<ol>\n<li>insert</li>\n<li>load</li>\n</ol>\n</li>\n<li><p>创建分区表（外表）</p>\n</li>\n<li><p>数据导出</p>\n<ol>\n<li><p>hdfs dfs -get filename</p>\n</li>\n<li><p>hdfs dfs -text filename    //查看</p>\n<ol>\n<li><p>insert overwrite 【local】 directory ‘filename’</p>\n<p>【row format delimited fields terminated by ‘\\t’】</p>\n<p>select col， col1 from tablename</p>\n<p>//local 与 row。。 只能在导出到本地时使用</p>\n</li>\n</ol>\n</li>\n<li><p>Shell 命令加管道：hive -f/e | sed/awk/gred &gt;filename</p>\n</li>\n<li><p>sqoop</p>\n</li>\n<li><p>动态分区</p>\n<ol>\n<li>设置 set hive.exec.dynamic.partition=true //设置使用动态分区</li>\n<li>设置 set hive.exec.dynamic.partition.mode=nonstrict //使用无限制模式</li>\n<li>insert into table tablename partition(dt) select col,col1 as dt from tablename  //一个分区 动态设置</li>\n<li>Insert into table tablename partition(dt=’2017’,value) select col,col1 as value from tablename //两个分区 ，静态分区必须在设置的动态分区前面</li>\n</ol>\n</li>\n<li><p>修改表</p>\n<ol>\n<li><p>重命名表 alter table tablename rename to newtablename;</p>\n</li>\n<li><p>修改列名 alter table tablename change column c1 c2 int comment ‘xxx’;</p>\n</li>\n<li><p>移动列的位置 alter table  tablename change column c1 c2 after c3;</p>\n</li>\n<li><p>增加列 alter table tablename add columns(c1 string comment ‘xxx’,c2 int);</p>\n</li>\n<li><p>删除列 alter table tablename replace columns(col string,col1 int) </p>\n<p>//col col1 都是保留下来的列</p>\n</li>\n<li><p>修改分割符 alter table tablename【partition(dt=’xxxx’)】 set serdeproperties(‘field.delim’=’\\t’)</p>\n</li>\n<li><p>修改location;</p>\n<p> alter table tablename 【partition()】set location ‘path’</p>\n</li>\n<li><p>内部表改外部表 </p>\n<p>alter table tablename set tblproperties(‘EXTERNAL’=’TRUE’)  </p>\n<p>//外部表改内部表 EXTERNAL=FALSE；</p>\n</li>\n</ol>\n</li>\n<li><p>group by：</p>\n<p>select col1,col2 from tablename group by col1,col2</p>\n<p>//查询的列 col1，col2 必须出现在group by后面；</p>\n</li>\n<li><p>sum(col)  //col可为int，double 等数字类型也可以为string类型</p>\n</li>\n<li><p>在hive中使用python脚本</p>\n<p>add file filenamepath //先将脚本缓存到hive集群上</p>\n<p>select * from ( select transform (col,col1) using ‘filename’ 【as coll ,coll2】from tablename  ) tablename</p>\n</li>\n<li><p>【inner】join，left 【outer】 join，right 【outer】 join, full 【outer】 join，</p>\n<p>/* +mapjoin(tablename) */,left semi join 相当于in </p>\n</li>\n<li><p>函数</p>\n<ol>\n<li>nvl(col,0) //如果col非空则显示col否则显示0</li>\n<li>【nvl2(col1,col2,col3) //如果col1为空则显示col2否则显示col3】</li>\n<li>【nullif(col1,col2) //如果col1与col2相等则返回null否则返回col1】</li>\n<li>coalesce(col1,col2,col3….) //返回第一个非空（null）值，如果都为空则返回null</li>\n<li>concat(col1,col2….) //字符串拼接，如果col1或col2中有一个为null则返回null</li>\n<li>concat_ws(‘,’,col1,col2…..) //带有分隔符的字符串拼接，如果有col2为null则不会拼接，拼接的内容可以为array</li>\n<li>cast(1 as bigint) //转化1为bigint</li>\n<li>round(0.0089,4) //保留4位小数</li>\n<li>if (condition,a,b) //若condition为真则返回a，否则返回b；</li>\n<li>explode(array(or map)) //将输入的一行数组或map转换成列输出</li>\n<li>split(str,’,’) //第一个参数是要分隔的字符串，第二个参数是分隔符，分隔后的数据可看成数组</li>\n</ol>\n</li>\n<li><p>distribute by 打散数据 长和sort by（使每一个reduce里面的数据都有序）连用。distribute by 与group by 都是安key对数据进行划分，都使用reduce操作，但是distribute by只是将数据分散，而group by 是把相同的key聚集到一起然后进行聚合操作。sort by与order by，order by 是全局排序，只会有一个reduce ，sort by是确保每一个reduce 上的数据都是有序的，如果只有一个reduce时，sort by 和order by作用是一样的。</p>\n</li>\n<li><p>cluster by</p>\n</li>\n<li><p>unoin all</p>\n</li>\n<li><p>自定义UDF：</p>\n<p>重写evaluate函数</p>\n</li>\n<li><p>优化：</p>\n<ol>\n<li><p>join优化</p>\n<p>hive.optimize.skewjoin=true</p>\n<p>hive.skewjoin.key=n //当key的数量到达n时会主动进行优化</p>\n</li>\n<li><p>mapjoin</p>\n<p>hive.atuo.conwert.join=true</p>\n<p>hive.mapjoin.smalltable.filesize=n</p>\n<p>select /*+mapjoin(a) */,col1,col2 form a join b</p>\n<p>注：a表要非常小，mapjoin因为是在map端操作可以进行不等值操作</p>\n</li>\n<li><p>group by </p>\n<p>hive.groupby.skewindata=true</p>\n<p>Hive.groupby.mapaggr.checkinterval=n</p>\n</li>\n<li><p>job</p>\n<p>hive.exec.parallel=true. //设置job的并行化</p>\n<p>hive.exec.parallel.thread.numbe=n //设置最大线程数</p>\n<p>hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat //合并文件，文件受mapred.max.split.size大小的限制</p>\n<p>Hive.merge.smallfiles.avgsize=n  //设置输出文件平均大小小于改值，启动job合并文件</p>\n<p>Hive.merge.size.per.task=n //合并之后文件的大小</p>\n</li>\n<li></li>\n<li></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<ol start=\"17\">\n<li><p>yarn queue -status mt1</p>\n</li>\n<li><p>mapred【hadoop】 queue -list</p>\n</li>\n<li></li>\n<li></li>\n</ol>\n<ol start=\"21\">\n<li><p>命令：</p>\n<ol>\n<li>mapred[hadoop] job -list | grep o2o4 //查job</li>\n<li>ps -ef| grep xxxx.sh | grep -v grep // 查进程</li>\n<li>mapred[hadoop] queue -list // 查队列（所有）</li>\n<li>yarn queue -status o2o4  //查队列（单个）</li>\n<li>du -h //查文件大小</li>\n<li>sed -n ‘s/old/new/gp’ filename //-n  代表行   g 全局 p 打印  </li>\n<li>使用”;”时，不管command1是否执行成功都会执行command2； 使用”&amp;&amp;”时，只有command1执行成功后，command2才会执行，否则command2不执行；使用”||”时，command1执行成功后command2 不执行，否则去执行command2，总之command1和command2总有一条命令会执行。</li>\n<li></li>\n</ol>\n</li>\n</ol>\n<ul>\n<li><p>hive 分区下有数据但是查询表没有数据</p>\n<p>可以是表的读入设置了压缩等其他格式，单纯txt的文件，表无法读取</p>\n<p>STORED AS INPUTFORMAT<br>  ‘com.hadoop.mapred.DeprecatedLzoTextInputFormat’   //设置压缩为lzo 所以只能读取lzo数据</p>\n</li>\n<li><p>Hive count(distinct ) 优化</p>\n<p>可以先进行group by  然后再进行count</p>\n<pre><code class=\"sql\">select count(*),count(distinct col) from tablename where day_id=20180708</code></pre>\n</li>\n</ul>\n<p>  select max(cnt), max(mdn_cnt), max(day_id) from (select null  as cnt , count(<em>) as mdn_cnt , day_id  as day_id from (select mdn, day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by mdn,day_id )a group by  day_id union all select count(</em>) as cnt, null  as mdn_cnt , day_id as day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by day_id )b;//union all</p>\n<p>  select b.cnt,a.mdn_cnt ,a.day_id from (<br>  select count(<em>) as mdn_cnt ,day_id from (select mdn,day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by mdn,day_id)a1 group by day_id)a<br>  left join<br>  (select count(</em>) as cnt, day_id from dwi_m.dwi_res_regn_mergelocation_msk_d  b where day_id=20180708 group by day_id)b<br>  on a.day_id=b.day_id;//join</p>\n<p>  join 和 union all 用的时间差不多  但相对 直接count distinct 要 少很多</p>\n"},{"_content":"# Flink-Trouble\n\n## 1. 处理时间窗口数据时未添加窗口或者设置处理的时间类型\n### 错误现象\n```\nCaused by: java.lang.RuntimeException: Record has Long.MIN_VALUE timestamp (= no timestamp marker). Is the time characteristic set to 'ProcessingTime', or did you forget to call 'DataStream.assignTimestampsAndWatermarks(...)'?\n```\n### 解决方案\n+ assignTimestampsAndWatermarks\n+ env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\n## 2. 程序重写(删除算子)导致使用savepoint数据快照无法恢复启动\n### 错误现象\n```\nFailed to rollback to checkpoint/savepoint file:/Users/bulianwei/workspace/project/idea/flink_demo/data/test/savepoint-18c72f-803ce50127dc. Cannot map checkpoint/savepoint state for operator c27dcf7b54ef6bfd6cff02ca8870b681 to the new program, because the operator is not available in the new program. If you want to allow to skip this, you can set the --allowNonRestoredState option on the CLI.\n```\n### 解决方案\n启动时使用 --allowNonRestoredState 或者 -n 跳过删除算子恢复\nflink run -s savepointdir -n -c mainclasspath jarpath\n\n## 3. 使用flink stop 停止job时出现无法停止现象\n### 错误现象\n```\n[org.apache.flink.runtime.rest.handler.RestHandlerException: Config key [state.savepoints.dir] is not set. Property [targetDirectory] must be provided.\n```\n### 解决方案\n使用flink stop jobid停止job时会保存数据快照，如果未设置savepointpath会导致无法保存快照，会导致无法停止job\nflink stop jobid -p savepointpath\n\n## 4.\n### 错误现象\n```\n\n```\n### 解决方案","source":"notes/Flink-Trouble.md","raw":"# Flink-Trouble\n\n## 1. 处理时间窗口数据时未添加窗口或者设置处理的时间类型\n### 错误现象\n```\nCaused by: java.lang.RuntimeException: Record has Long.MIN_VALUE timestamp (= no timestamp marker). Is the time characteristic set to 'ProcessingTime', or did you forget to call 'DataStream.assignTimestampsAndWatermarks(...)'?\n```\n### 解决方案\n+ assignTimestampsAndWatermarks\n+ env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\n## 2. 程序重写(删除算子)导致使用savepoint数据快照无法恢复启动\n### 错误现象\n```\nFailed to rollback to checkpoint/savepoint file:/Users/bulianwei/workspace/project/idea/flink_demo/data/test/savepoint-18c72f-803ce50127dc. Cannot map checkpoint/savepoint state for operator c27dcf7b54ef6bfd6cff02ca8870b681 to the new program, because the operator is not available in the new program. If you want to allow to skip this, you can set the --allowNonRestoredState option on the CLI.\n```\n### 解决方案\n启动时使用 --allowNonRestoredState 或者 -n 跳过删除算子恢复\nflink run -s savepointdir -n -c mainclasspath jarpath\n\n## 3. 使用flink stop 停止job时出现无法停止现象\n### 错误现象\n```\n[org.apache.flink.runtime.rest.handler.RestHandlerException: Config key [state.savepoints.dir] is not set. Property [targetDirectory] must be provided.\n```\n### 解决方案\n使用flink stop jobid停止job时会保存数据快照，如果未设置savepointpath会导致无法保存快照，会导致无法停止job\nflink stop jobid -p savepointpath\n\n## 4.\n### 错误现象\n```\n\n```\n### 解决方案","date":"2020-03-19T05:09:33.000Z","updated":"2020-03-18T11:52:16.000Z","path":"notes/Flink-Trouble.html","title":"","comments":1,"layout":"page","_id":"ck8hf2uv9000dzhs61zzzfsrz","content":"<h1 id=\"Flink-Trouble\"><a href=\"#Flink-Trouble\" class=\"headerlink\" title=\"Flink-Trouble\"></a>Flink-Trouble</h1><h2 id=\"1-处理时间窗口数据时未添加窗口或者设置处理的时间类型\"><a href=\"#1-处理时间窗口数据时未添加窗口或者设置处理的时间类型\" class=\"headerlink\" title=\"1. 处理时间窗口数据时未添加窗口或者设置处理的时间类型\"></a>1. 处理时间窗口数据时未添加窗口或者设置处理的时间类型</h2><h3 id=\"错误现象\"><a href=\"#错误现象\" class=\"headerlink\" title=\"错误现象\"></a>错误现象</h3><pre><code>Caused by: java.lang.RuntimeException: Record has Long.MIN_VALUE timestamp (= no timestamp marker). Is the time characteristic set to &#39;ProcessingTime&#39;, or did you forget to call &#39;DataStream.assignTimestampsAndWatermarks(...)&#39;?</code></pre><h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><ul>\n<li>assignTimestampsAndWatermarks</li>\n<li>env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</li>\n</ul>\n<h2 id=\"2-程序重写-删除算子-导致使用savepoint数据快照无法恢复启动\"><a href=\"#2-程序重写-删除算子-导致使用savepoint数据快照无法恢复启动\" class=\"headerlink\" title=\"2. 程序重写(删除算子)导致使用savepoint数据快照无法恢复启动\"></a>2. 程序重写(删除算子)导致使用savepoint数据快照无法恢复启动</h2><h3 id=\"错误现象-1\"><a href=\"#错误现象-1\" class=\"headerlink\" title=\"错误现象\"></a>错误现象</h3><pre><code>Failed to rollback to checkpoint/savepoint file:/Users/bulianwei/workspace/project/idea/flink_demo/data/test/savepoint-18c72f-803ce50127dc. Cannot map checkpoint/savepoint state for operator c27dcf7b54ef6bfd6cff02ca8870b681 to the new program, because the operator is not available in the new program. If you want to allow to skip this, you can set the --allowNonRestoredState option on the CLI.</code></pre><h3 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>启动时使用 –allowNonRestoredState 或者 -n 跳过删除算子恢复<br>flink run -s savepointdir -n -c mainclasspath jarpath</p>\n<h2 id=\"3-使用flink-stop-停止job时出现无法停止现象\"><a href=\"#3-使用flink-stop-停止job时出现无法停止现象\" class=\"headerlink\" title=\"3. 使用flink stop 停止job时出现无法停止现象\"></a>3. 使用flink stop 停止job时出现无法停止现象</h2><h3 id=\"错误现象-2\"><a href=\"#错误现象-2\" class=\"headerlink\" title=\"错误现象\"></a>错误现象</h3><pre><code>[org.apache.flink.runtime.rest.handler.RestHandlerException: Config key [state.savepoints.dir] is not set. Property [targetDirectory] must be provided.</code></pre><h3 id=\"解决方案-2\"><a href=\"#解决方案-2\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>使用flink stop jobid停止job时会保存数据快照，如果未设置savepointpath会导致无法保存快照，会导致无法停止job<br>flink stop jobid -p savepointpath</p>\n<h2 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4.\"></a>4.</h2><h3 id=\"错误现象-3\"><a href=\"#错误现象-3\" class=\"headerlink\" title=\"错误现象\"></a>错误现象</h3><pre><code></code></pre><h3 id=\"解决方案-3\"><a href=\"#解决方案-3\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3>","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":"<h1 id=\"Flink-Trouble\"><a href=\"#Flink-Trouble\" class=\"headerlink\" title=\"Flink-Trouble\"></a>Flink-Trouble</h1><h2 id=\"1-处理时间窗口数据时未添加窗口或者设置处理的时间类型\"><a href=\"#1-处理时间窗口数据时未添加窗口或者设置处理的时间类型\" class=\"headerlink\" title=\"1. 处理时间窗口数据时未添加窗口或者设置处理的时间类型\"></a>1. 处理时间窗口数据时未添加窗口或者设置处理的时间类型</h2><h3 id=\"错误现象\"><a href=\"#错误现象\" class=\"headerlink\" title=\"错误现象\"></a>错误现象</h3><pre><code>Caused by: java.lang.RuntimeException: Record has Long.MIN_VALUE timestamp (= no timestamp marker). Is the time characteristic set to &#39;ProcessingTime&#39;, or did you forget to call &#39;DataStream.assignTimestampsAndWatermarks(...)&#39;?</code></pre><h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><ul>\n<li>assignTimestampsAndWatermarks</li>\n<li>env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</li>\n</ul>\n<h2 id=\"2-程序重写-删除算子-导致使用savepoint数据快照无法恢复启动\"><a href=\"#2-程序重写-删除算子-导致使用savepoint数据快照无法恢复启动\" class=\"headerlink\" title=\"2. 程序重写(删除算子)导致使用savepoint数据快照无法恢复启动\"></a>2. 程序重写(删除算子)导致使用savepoint数据快照无法恢复启动</h2><h3 id=\"错误现象-1\"><a href=\"#错误现象-1\" class=\"headerlink\" title=\"错误现象\"></a>错误现象</h3><pre><code>Failed to rollback to checkpoint/savepoint file:/Users/bulianwei/workspace/project/idea/flink_demo/data/test/savepoint-18c72f-803ce50127dc. Cannot map checkpoint/savepoint state for operator c27dcf7b54ef6bfd6cff02ca8870b681 to the new program, because the operator is not available in the new program. If you want to allow to skip this, you can set the --allowNonRestoredState option on the CLI.</code></pre><h3 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>启动时使用 –allowNonRestoredState 或者 -n 跳过删除算子恢复<br>flink run -s savepointdir -n -c mainclasspath jarpath</p>\n<h2 id=\"3-使用flink-stop-停止job时出现无法停止现象\"><a href=\"#3-使用flink-stop-停止job时出现无法停止现象\" class=\"headerlink\" title=\"3. 使用flink stop 停止job时出现无法停止现象\"></a>3. 使用flink stop 停止job时出现无法停止现象</h2><h3 id=\"错误现象-2\"><a href=\"#错误现象-2\" class=\"headerlink\" title=\"错误现象\"></a>错误现象</h3><pre><code>[org.apache.flink.runtime.rest.handler.RestHandlerException: Config key [state.savepoints.dir] is not set. Property [targetDirectory] must be provided.</code></pre><h3 id=\"解决方案-2\"><a href=\"#解决方案-2\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>使用flink stop jobid停止job时会保存数据快照，如果未设置savepointpath会导致无法保存快照，会导致无法停止job<br>flink stop jobid -p savepointpath</p>\n<h2 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4.\"></a>4.</h2><h3 id=\"错误现象-3\"><a href=\"#错误现象-3\" class=\"headerlink\" title=\"错误现象\"></a>错误现象</h3><pre><code></code></pre><h3 id=\"解决方案-3\"><a href=\"#解决方案-3\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3>"},{"title":"Kafka","date":"2020-01-13T07:22:21.000Z","_content":"# Kafka\n\n一个分区内的数据才能保证幂等性和有序性\n\n##  架构\n\n![架构图](img/kafka架构.png \"dd\")\n\n## 名次解释\n+ Broker：Kafka服务器\n+ Producer：生产者，生产消息\n+ Consumer：消费者，消费数据\n+ Consumer Group：消费者组，某一个分区只能被同一个消费者组内的一个消费者消费\n+ Topic：消息主题。逻辑概念\n+ Partition：消息分区。消息物理存储上概念\n+ Offset：偏移量\n+ Replia：副本，同一个分区（Partition）内的副本分Leader和Follower\n+ Leader：主副本。对外提供服务\n+ Follower：从副本。做数据同步工作\n+ acks：acknowledgments，消息接收后的确认值\n+ AR（Assigned Replicas）：分区中所有副本\n+ ISR（In-Sync Replicas）：所有与Leader 部分保持一定程度的副本（包含Leader副本在内）组成ISR\n+ OSR（Out-Sync Replicas）：与Leader副本同步滞后过多的副本\n+ HW（High Watermark）：指消费者能够见到的最大Offset，ISR队列中最小的LEO。高水位，标志一个特定的Offset，消费者只能拉取到这个Offset之前的消息，Consumer可见数据的最大偏移量。保证副本数据一致性\n+ LEO（Log End Offset）：每个副本最后一个Offset。即日志末端位移，记录了该副本底层日志中下一条消息的位移值。注意是下一条消息，也就是说如果LEO=10，那么表示该副本保存了10条消息，位移值范围是[0,9]。\n>1 Topic = n Partition\n>1 Partition = n Replica\n\n## Producer（生产者）\n\n拦截器->序列化器->分区器\n\n### 命令\n\n#### 使用脚本\nkafka-console-producer.sh\n\n#### 常用参数\n+ --broker-list\t//kafka集群地址\n+ --topic\t//生产主题\n\n\n#### 举例\nkafka-console-producer.sh\t--broker-list\tlocalhost:9092\t--topic\ttest\n\n### 分区策略\n1. 指定分区（Partition）：直接按照分区号\n2. 没有分区（Partition）但是有Key：（默认）根据Key的Hash值获取分区号\n3. 即没有分区（Partition）也没有Key：第一次险随机获取一个分区号，然后在这个分区号的基础上轮训所有分区号。\n\t\n\t>如果有3个分区，0、1、2当随机获取的分区号为1时，然后1、2、0、1、2、0、1 ... 这样轮询下去\n\n### 发送返回值\nACKS值：\n+ 0：Producer不等待Leader所在的Broker的acks，这一操作保证了最低延迟，Leader所在的Broker一接到消息不等消息保存就会先将ack的值返回给Producer。此值下当Leader所在的Broker宕机时会造成数据丢失\n+ 1：Producer等待Leader所在的Broker的acks，当Leader所在Broker接收到消息保存完消息后才会将ack值返回给Producer。在Leader的消息落盘后还没等Follower同步数据其所在Broker宕机后，就会导致数据丢失。（默认）\n+ -1（all）：Producer等待Leader所在的Broker的acks，当Leader和ISR中的Follower全部将消息落盘之后所在的Broker才会将ack的值返回给Producer。但是如果Follower将消息同步完以后，Leader所在的Broker还没将ack的值返回给Producer之前，Leader所在的Broker发生故障，会造成数据重复\n\n### 幂等性\n设置：enable.idempotence=true\n解决单次会话单个分区数据重复问题\n开启幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带SequenceNumber，而Broker会对<PID，Partition，SequenceNumber>做缓存，当具有相同主键的消息提及时，Broker只会持久化一条。\n\n## Consumer（消费者）\n\n当前消费者需要提交的消费位移是offset+1\n\n### 命令\n\n#### 使用脚本\nkafka-console-consumer.sh\t\n\n#### 常用参数\n+ --bootstrap-server\t//目标服务器地址\n+ --topic\t//消费主题\n\n\n#### 举例\nkafka-console-consumer.sh\t--bootstrap-server\tlocalhost:9092\t--topic\ttest\n\n### 分配策略\n+ RoundRobin\t将订阅的所有主题看作一个整体。（按组分配）\n+ Range\t将订阅的单个主题看作整体。（按主题分配）\n\n## Topic（主题）\n\n###\t命令\n\n#### 使用脚本\nkafka-configs.sh\t//0.9中已经废弃kafka-topics.sh脚本，改用kafka-configs.sh来配置主题\n\n#### 常用参数\n+ --zookeeper\t//zookeeper地址，多个用逗号链接\n+ --create\t//创建命令\n+ --list\t//列出所有主题\n+ --alter\t//修改主题\n+ --delete\t//删除主题\n+ --topic\t//主题\n+ --partitions\t//主题分区数，分区数要小于等于broker数\n+ --replication-fator\t//主题副本数\n\n\n#### 举例\n+ 创建主题：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--create\t--topic\ttest\t--partition\t2\t--replication-fator\t3\n+ 列出所有主题：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--list\n+ 列出主题详情：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--describe\t--topic test\n+ 修改主题：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--alter\t--topic test\n+ 删除主题：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--delete\t--topic test\n\n## Kafka高读写\n\n+ 顺序读写\n+ 零复制\n\t![普通拷贝](./img/普通拷贝.png) \n\t![零拷贝 ](./img/零拷贝.png)\n\t\n\t","source":"notes/Kafka.md","raw":"---\ntitle: Kafka\ndate: 2020-01-13 15:22:21\n---\n# Kafka\n\n一个分区内的数据才能保证幂等性和有序性\n\n##  架构\n\n![架构图](img/kafka架构.png \"dd\")\n\n## 名次解释\n+ Broker：Kafka服务器\n+ Producer：生产者，生产消息\n+ Consumer：消费者，消费数据\n+ Consumer Group：消费者组，某一个分区只能被同一个消费者组内的一个消费者消费\n+ Topic：消息主题。逻辑概念\n+ Partition：消息分区。消息物理存储上概念\n+ Offset：偏移量\n+ Replia：副本，同一个分区（Partition）内的副本分Leader和Follower\n+ Leader：主副本。对外提供服务\n+ Follower：从副本。做数据同步工作\n+ acks：acknowledgments，消息接收后的确认值\n+ AR（Assigned Replicas）：分区中所有副本\n+ ISR（In-Sync Replicas）：所有与Leader 部分保持一定程度的副本（包含Leader副本在内）组成ISR\n+ OSR（Out-Sync Replicas）：与Leader副本同步滞后过多的副本\n+ HW（High Watermark）：指消费者能够见到的最大Offset，ISR队列中最小的LEO。高水位，标志一个特定的Offset，消费者只能拉取到这个Offset之前的消息，Consumer可见数据的最大偏移量。保证副本数据一致性\n+ LEO（Log End Offset）：每个副本最后一个Offset。即日志末端位移，记录了该副本底层日志中下一条消息的位移值。注意是下一条消息，也就是说如果LEO=10，那么表示该副本保存了10条消息，位移值范围是[0,9]。\n>1 Topic = n Partition\n>1 Partition = n Replica\n\n## Producer（生产者）\n\n拦截器->序列化器->分区器\n\n### 命令\n\n#### 使用脚本\nkafka-console-producer.sh\n\n#### 常用参数\n+ --broker-list\t//kafka集群地址\n+ --topic\t//生产主题\n\n\n#### 举例\nkafka-console-producer.sh\t--broker-list\tlocalhost:9092\t--topic\ttest\n\n### 分区策略\n1. 指定分区（Partition）：直接按照分区号\n2. 没有分区（Partition）但是有Key：（默认）根据Key的Hash值获取分区号\n3. 即没有分区（Partition）也没有Key：第一次险随机获取一个分区号，然后在这个分区号的基础上轮训所有分区号。\n\t\n\t>如果有3个分区，0、1、2当随机获取的分区号为1时，然后1、2、0、1、2、0、1 ... 这样轮询下去\n\n### 发送返回值\nACKS值：\n+ 0：Producer不等待Leader所在的Broker的acks，这一操作保证了最低延迟，Leader所在的Broker一接到消息不等消息保存就会先将ack的值返回给Producer。此值下当Leader所在的Broker宕机时会造成数据丢失\n+ 1：Producer等待Leader所在的Broker的acks，当Leader所在Broker接收到消息保存完消息后才会将ack值返回给Producer。在Leader的消息落盘后还没等Follower同步数据其所在Broker宕机后，就会导致数据丢失。（默认）\n+ -1（all）：Producer等待Leader所在的Broker的acks，当Leader和ISR中的Follower全部将消息落盘之后所在的Broker才会将ack的值返回给Producer。但是如果Follower将消息同步完以后，Leader所在的Broker还没将ack的值返回给Producer之前，Leader所在的Broker发生故障，会造成数据重复\n\n### 幂等性\n设置：enable.idempotence=true\n解决单次会话单个分区数据重复问题\n开启幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带SequenceNumber，而Broker会对<PID，Partition，SequenceNumber>做缓存，当具有相同主键的消息提及时，Broker只会持久化一条。\n\n## Consumer（消费者）\n\n当前消费者需要提交的消费位移是offset+1\n\n### 命令\n\n#### 使用脚本\nkafka-console-consumer.sh\t\n\n#### 常用参数\n+ --bootstrap-server\t//目标服务器地址\n+ --topic\t//消费主题\n\n\n#### 举例\nkafka-console-consumer.sh\t--bootstrap-server\tlocalhost:9092\t--topic\ttest\n\n### 分配策略\n+ RoundRobin\t将订阅的所有主题看作一个整体。（按组分配）\n+ Range\t将订阅的单个主题看作整体。（按主题分配）\n\n## Topic（主题）\n\n###\t命令\n\n#### 使用脚本\nkafka-configs.sh\t//0.9中已经废弃kafka-topics.sh脚本，改用kafka-configs.sh来配置主题\n\n#### 常用参数\n+ --zookeeper\t//zookeeper地址，多个用逗号链接\n+ --create\t//创建命令\n+ --list\t//列出所有主题\n+ --alter\t//修改主题\n+ --delete\t//删除主题\n+ --topic\t//主题\n+ --partitions\t//主题分区数，分区数要小于等于broker数\n+ --replication-fator\t//主题副本数\n\n\n#### 举例\n+ 创建主题：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--create\t--topic\ttest\t--partition\t2\t--replication-fator\t3\n+ 列出所有主题：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--list\n+ 列出主题详情：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--describe\t--topic test\n+ 修改主题：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--alter\t--topic test\n+ 删除主题：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--delete\t--topic test\n\n## Kafka高读写\n\n+ 顺序读写\n+ 零复制\n\t![普通拷贝](./img/普通拷贝.png) \n\t![零拷贝 ](./img/零拷贝.png)\n\t\n\t","updated":"2020-03-18T11:52:16.000Z","path":"notes/Kafka.html","comments":1,"layout":"page","_id":"ck8hf2uvb000ezhs69tegc1v3","content":"<h1 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h1><p>一个分区内的数据才能保证幂等性和有序性</p>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><p><img src=\"img/kafka%E6%9E%B6%E6%9E%84.png\" alt=\"架构图\" title=\"dd\"></p>\n<h2 id=\"名次解释\"><a href=\"#名次解释\" class=\"headerlink\" title=\"名次解释\"></a>名次解释</h2><ul>\n<li>Broker：Kafka服务器</li>\n<li>Producer：生产者，生产消息</li>\n<li>Consumer：消费者，消费数据</li>\n<li>Consumer Group：消费者组，某一个分区只能被同一个消费者组内的一个消费者消费</li>\n<li>Topic：消息主题。逻辑概念</li>\n<li>Partition：消息分区。消息物理存储上概念</li>\n<li>Offset：偏移量</li>\n<li>Replia：副本，同一个分区（Partition）内的副本分Leader和Follower</li>\n<li>Leader：主副本。对外提供服务</li>\n<li>Follower：从副本。做数据同步工作</li>\n<li>acks：acknowledgments，消息接收后的确认值</li>\n<li>AR（Assigned Replicas）：分区中所有副本</li>\n<li>ISR（In-Sync Replicas）：所有与Leader 部分保持一定程度的副本（包含Leader副本在内）组成ISR</li>\n<li>OSR（Out-Sync Replicas）：与Leader副本同步滞后过多的副本</li>\n<li>HW（High Watermark）：指消费者能够见到的最大Offset，ISR队列中最小的LEO。高水位，标志一个特定的Offset，消费者只能拉取到这个Offset之前的消息，Consumer可见数据的最大偏移量。保证副本数据一致性</li>\n<li>LEO（Log End Offset）：每个副本最后一个Offset。即日志末端位移，记录了该副本底层日志中下一条消息的位移值。注意是下一条消息，也就是说如果LEO=10，那么表示该副本保存了10条消息，位移值范围是[0,9]。<blockquote>\n<p>1 Topic = n Partition<br>1 Partition = n Replica</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"Producer（生产者）\"><a href=\"#Producer（生产者）\" class=\"headerlink\" title=\"Producer（生产者）\"></a>Producer（生产者）</h2><p>拦截器-&gt;序列化器-&gt;分区器</p>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><h4 id=\"使用脚本\"><a href=\"#使用脚本\" class=\"headerlink\" title=\"使用脚本\"></a>使用脚本</h4><p>kafka-console-producer.sh</p>\n<h4 id=\"常用参数\"><a href=\"#常用参数\" class=\"headerlink\" title=\"常用参数\"></a>常用参数</h4><ul>\n<li>–broker-list    //kafka集群地址</li>\n<li>–topic    //生产主题</li>\n</ul>\n<h4 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h4><p>kafka-console-producer.sh    –broker-list    localhost:9092    –topic    test</p>\n<h3 id=\"分区策略\"><a href=\"#分区策略\" class=\"headerlink\" title=\"分区策略\"></a>分区策略</h3><ol>\n<li><p>指定分区（Partition）：直接按照分区号</p>\n</li>\n<li><p>没有分区（Partition）但是有Key：（默认）根据Key的Hash值获取分区号</p>\n</li>\n<li><p>即没有分区（Partition）也没有Key：第一次险随机获取一个分区号，然后在这个分区号的基础上轮训所有分区号。</p>\n<blockquote>\n<p>如果有3个分区，0、1、2当随机获取的分区号为1时，然后1、2、0、1、2、0、1 … 这样轮询下去</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"发送返回值\"><a href=\"#发送返回值\" class=\"headerlink\" title=\"发送返回值\"></a>发送返回值</h3><p>ACKS值：</p>\n<ul>\n<li>0：Producer不等待Leader所在的Broker的acks，这一操作保证了最低延迟，Leader所在的Broker一接到消息不等消息保存就会先将ack的值返回给Producer。此值下当Leader所在的Broker宕机时会造成数据丢失</li>\n<li>1：Producer等待Leader所在的Broker的acks，当Leader所在Broker接收到消息保存完消息后才会将ack值返回给Producer。在Leader的消息落盘后还没等Follower同步数据其所在Broker宕机后，就会导致数据丢失。（默认）</li>\n<li>-1（all）：Producer等待Leader所在的Broker的acks，当Leader和ISR中的Follower全部将消息落盘之后所在的Broker才会将ack的值返回给Producer。但是如果Follower将消息同步完以后，Leader所在的Broker还没将ack的值返回给Producer之前，Leader所在的Broker发生故障，会造成数据重复</li>\n</ul>\n<h3 id=\"幂等性\"><a href=\"#幂等性\" class=\"headerlink\" title=\"幂等性\"></a>幂等性</h3><p>设置：enable.idempotence=true<br>解决单次会话单个分区数据重复问题<br>开启幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带SequenceNumber，而Broker会对&lt;PID，Partition，SequenceNumber&gt;做缓存，当具有相同主键的消息提及时，Broker只会持久化一条。</p>\n<h2 id=\"Consumer（消费者）\"><a href=\"#Consumer（消费者）\" class=\"headerlink\" title=\"Consumer（消费者）\"></a>Consumer（消费者）</h2><p>当前消费者需要提交的消费位移是offset+1</p>\n<h3 id=\"命令-1\"><a href=\"#命令-1\" class=\"headerlink\" title=\"命令\"></a>命令</h3><h4 id=\"使用脚本-1\"><a href=\"#使用脚本-1\" class=\"headerlink\" title=\"使用脚本\"></a>使用脚本</h4><p>kafka-console-consumer.sh    </p>\n<h4 id=\"常用参数-1\"><a href=\"#常用参数-1\" class=\"headerlink\" title=\"常用参数\"></a>常用参数</h4><ul>\n<li>–bootstrap-server    //目标服务器地址</li>\n<li>–topic    //消费主题</li>\n</ul>\n<h4 id=\"举例-1\"><a href=\"#举例-1\" class=\"headerlink\" title=\"举例\"></a>举例</h4><p>kafka-console-consumer.sh    –bootstrap-server    localhost:9092    –topic    test</p>\n<h3 id=\"分配策略\"><a href=\"#分配策略\" class=\"headerlink\" title=\"分配策略\"></a>分配策略</h3><ul>\n<li>RoundRobin    将订阅的所有主题看作一个整体。（按组分配）</li>\n<li>Range    将订阅的单个主题看作整体。（按主题分配）</li>\n</ul>\n<h2 id=\"Topic（主题）\"><a href=\"#Topic（主题）\" class=\"headerlink\" title=\"Topic（主题）\"></a>Topic（主题）</h2><h3 id=\"命令-2\"><a href=\"#命令-2\" class=\"headerlink\" title=\"命令\"></a>命令</h3><h4 id=\"使用脚本-2\"><a href=\"#使用脚本-2\" class=\"headerlink\" title=\"使用脚本\"></a>使用脚本</h4><p>kafka-configs.sh    //0.9中已经废弃kafka-topics.sh脚本，改用kafka-configs.sh来配置主题</p>\n<h4 id=\"常用参数-2\"><a href=\"#常用参数-2\" class=\"headerlink\" title=\"常用参数\"></a>常用参数</h4><ul>\n<li>–zookeeper    //zookeeper地址，多个用逗号链接</li>\n<li>–create    //创建命令</li>\n<li>–list    //列出所有主题</li>\n<li>–alter    //修改主题</li>\n<li>–delete    //删除主题</li>\n<li>–topic    //主题</li>\n<li>–partitions    //主题分区数，分区数要小于等于broker数</li>\n<li>–replication-fator    //主题副本数</li>\n</ul>\n<h4 id=\"举例-2\"><a href=\"#举例-2\" class=\"headerlink\" title=\"举例\"></a>举例</h4><ul>\n<li>创建主题：kafka-configs.sh    –zookeeper    localhost:9092    –create    –topic    test    –partition    2    –replication-fator    3</li>\n<li>列出所有主题：kafka-configs.sh    –zookeeper    localhost:9092    –list</li>\n<li>列出主题详情：kafka-configs.sh    –zookeeper    localhost:9092    –describe    –topic test</li>\n<li>修改主题：kafka-configs.sh    –zookeeper    localhost:9092    –alter    –topic test</li>\n<li>删除主题：kafka-configs.sh    –zookeeper    localhost:9092    –delete    –topic test</li>\n</ul>\n<h2 id=\"Kafka高读写\"><a href=\"#Kafka高读写\" class=\"headerlink\" title=\"Kafka高读写\"></a>Kafka高读写</h2><ul>\n<li>顺序读写</li>\n<li>零复制<br>  <img src=\"./img/%E6%99%AE%E9%80%9A%E6%8B%B7%E8%B4%9D.png\" alt=\"普通拷贝\"><br>  <img src=\"./img/%E9%9B%B6%E6%8B%B7%E8%B4%9D.png\" alt=\"零拷贝 \"></li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":"<h1 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h1><p>一个分区内的数据才能保证幂等性和有序性</p>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><p><img src=\"img/kafka%E6%9E%B6%E6%9E%84.png\" alt=\"架构图\" title=\"dd\"></p>\n<h2 id=\"名次解释\"><a href=\"#名次解释\" class=\"headerlink\" title=\"名次解释\"></a>名次解释</h2><ul>\n<li>Broker：Kafka服务器</li>\n<li>Producer：生产者，生产消息</li>\n<li>Consumer：消费者，消费数据</li>\n<li>Consumer Group：消费者组，某一个分区只能被同一个消费者组内的一个消费者消费</li>\n<li>Topic：消息主题。逻辑概念</li>\n<li>Partition：消息分区。消息物理存储上概念</li>\n<li>Offset：偏移量</li>\n<li>Replia：副本，同一个分区（Partition）内的副本分Leader和Follower</li>\n<li>Leader：主副本。对外提供服务</li>\n<li>Follower：从副本。做数据同步工作</li>\n<li>acks：acknowledgments，消息接收后的确认值</li>\n<li>AR（Assigned Replicas）：分区中所有副本</li>\n<li>ISR（In-Sync Replicas）：所有与Leader 部分保持一定程度的副本（包含Leader副本在内）组成ISR</li>\n<li>OSR（Out-Sync Replicas）：与Leader副本同步滞后过多的副本</li>\n<li>HW（High Watermark）：指消费者能够见到的最大Offset，ISR队列中最小的LEO。高水位，标志一个特定的Offset，消费者只能拉取到这个Offset之前的消息，Consumer可见数据的最大偏移量。保证副本数据一致性</li>\n<li>LEO（Log End Offset）：每个副本最后一个Offset。即日志末端位移，记录了该副本底层日志中下一条消息的位移值。注意是下一条消息，也就是说如果LEO=10，那么表示该副本保存了10条消息，位移值范围是[0,9]。<blockquote>\n<p>1 Topic = n Partition<br>1 Partition = n Replica</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"Producer（生产者）\"><a href=\"#Producer（生产者）\" class=\"headerlink\" title=\"Producer（生产者）\"></a>Producer（生产者）</h2><p>拦截器-&gt;序列化器-&gt;分区器</p>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><h4 id=\"使用脚本\"><a href=\"#使用脚本\" class=\"headerlink\" title=\"使用脚本\"></a>使用脚本</h4><p>kafka-console-producer.sh</p>\n<h4 id=\"常用参数\"><a href=\"#常用参数\" class=\"headerlink\" title=\"常用参数\"></a>常用参数</h4><ul>\n<li>–broker-list    //kafka集群地址</li>\n<li>–topic    //生产主题</li>\n</ul>\n<h4 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h4><p>kafka-console-producer.sh    –broker-list    localhost:9092    –topic    test</p>\n<h3 id=\"分区策略\"><a href=\"#分区策略\" class=\"headerlink\" title=\"分区策略\"></a>分区策略</h3><ol>\n<li><p>指定分区（Partition）：直接按照分区号</p>\n</li>\n<li><p>没有分区（Partition）但是有Key：（默认）根据Key的Hash值获取分区号</p>\n</li>\n<li><p>即没有分区（Partition）也没有Key：第一次险随机获取一个分区号，然后在这个分区号的基础上轮训所有分区号。</p>\n<blockquote>\n<p>如果有3个分区，0、1、2当随机获取的分区号为1时，然后1、2、0、1、2、0、1 … 这样轮询下去</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"发送返回值\"><a href=\"#发送返回值\" class=\"headerlink\" title=\"发送返回值\"></a>发送返回值</h3><p>ACKS值：</p>\n<ul>\n<li>0：Producer不等待Leader所在的Broker的acks，这一操作保证了最低延迟，Leader所在的Broker一接到消息不等消息保存就会先将ack的值返回给Producer。此值下当Leader所在的Broker宕机时会造成数据丢失</li>\n<li>1：Producer等待Leader所在的Broker的acks，当Leader所在Broker接收到消息保存完消息后才会将ack值返回给Producer。在Leader的消息落盘后还没等Follower同步数据其所在Broker宕机后，就会导致数据丢失。（默认）</li>\n<li>-1（all）：Producer等待Leader所在的Broker的acks，当Leader和ISR中的Follower全部将消息落盘之后所在的Broker才会将ack的值返回给Producer。但是如果Follower将消息同步完以后，Leader所在的Broker还没将ack的值返回给Producer之前，Leader所在的Broker发生故障，会造成数据重复</li>\n</ul>\n<h3 id=\"幂等性\"><a href=\"#幂等性\" class=\"headerlink\" title=\"幂等性\"></a>幂等性</h3><p>设置：enable.idempotence=true<br>解决单次会话单个分区数据重复问题<br>开启幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带SequenceNumber，而Broker会对&lt;PID，Partition，SequenceNumber&gt;做缓存，当具有相同主键的消息提及时，Broker只会持久化一条。</p>\n<h2 id=\"Consumer（消费者）\"><a href=\"#Consumer（消费者）\" class=\"headerlink\" title=\"Consumer（消费者）\"></a>Consumer（消费者）</h2><p>当前消费者需要提交的消费位移是offset+1</p>\n<h3 id=\"命令-1\"><a href=\"#命令-1\" class=\"headerlink\" title=\"命令\"></a>命令</h3><h4 id=\"使用脚本-1\"><a href=\"#使用脚本-1\" class=\"headerlink\" title=\"使用脚本\"></a>使用脚本</h4><p>kafka-console-consumer.sh    </p>\n<h4 id=\"常用参数-1\"><a href=\"#常用参数-1\" class=\"headerlink\" title=\"常用参数\"></a>常用参数</h4><ul>\n<li>–bootstrap-server    //目标服务器地址</li>\n<li>–topic    //消费主题</li>\n</ul>\n<h4 id=\"举例-1\"><a href=\"#举例-1\" class=\"headerlink\" title=\"举例\"></a>举例</h4><p>kafka-console-consumer.sh    –bootstrap-server    localhost:9092    –topic    test</p>\n<h3 id=\"分配策略\"><a href=\"#分配策略\" class=\"headerlink\" title=\"分配策略\"></a>分配策略</h3><ul>\n<li>RoundRobin    将订阅的所有主题看作一个整体。（按组分配）</li>\n<li>Range    将订阅的单个主题看作整体。（按主题分配）</li>\n</ul>\n<h2 id=\"Topic（主题）\"><a href=\"#Topic（主题）\" class=\"headerlink\" title=\"Topic（主题）\"></a>Topic（主题）</h2><h3 id=\"命令-2\"><a href=\"#命令-2\" class=\"headerlink\" title=\"命令\"></a>命令</h3><h4 id=\"使用脚本-2\"><a href=\"#使用脚本-2\" class=\"headerlink\" title=\"使用脚本\"></a>使用脚本</h4><p>kafka-configs.sh    //0.9中已经废弃kafka-topics.sh脚本，改用kafka-configs.sh来配置主题</p>\n<h4 id=\"常用参数-2\"><a href=\"#常用参数-2\" class=\"headerlink\" title=\"常用参数\"></a>常用参数</h4><ul>\n<li>–zookeeper    //zookeeper地址，多个用逗号链接</li>\n<li>–create    //创建命令</li>\n<li>–list    //列出所有主题</li>\n<li>–alter    //修改主题</li>\n<li>–delete    //删除主题</li>\n<li>–topic    //主题</li>\n<li>–partitions    //主题分区数，分区数要小于等于broker数</li>\n<li>–replication-fator    //主题副本数</li>\n</ul>\n<h4 id=\"举例-2\"><a href=\"#举例-2\" class=\"headerlink\" title=\"举例\"></a>举例</h4><ul>\n<li>创建主题：kafka-configs.sh    –zookeeper    localhost:9092    –create    –topic    test    –partition    2    –replication-fator    3</li>\n<li>列出所有主题：kafka-configs.sh    –zookeeper    localhost:9092    –list</li>\n<li>列出主题详情：kafka-configs.sh    –zookeeper    localhost:9092    –describe    –topic test</li>\n<li>修改主题：kafka-configs.sh    –zookeeper    localhost:9092    –alter    –topic test</li>\n<li>删除主题：kafka-configs.sh    –zookeeper    localhost:9092    –delete    –topic test</li>\n</ul>\n<h2 id=\"Kafka高读写\"><a href=\"#Kafka高读写\" class=\"headerlink\" title=\"Kafka高读写\"></a>Kafka高读写</h2><ul>\n<li>顺序读写</li>\n<li>零复制<br>  <img src=\"./img/%E6%99%AE%E9%80%9A%E6%8B%B7%E8%B4%9D.png\" alt=\"普通拷贝\"><br>  <img src=\"./img/%E9%9B%B6%E6%8B%B7%E8%B4%9D.png\" alt=\"零拷贝 \"></li>\n</ul>\n"},{"_content":"\n\n#Linux\n\n### 1. 挂载\n\n~~~\nmount -t iso9660 -o ro /dev/cdrom /mnt/cdrom  //将文件类型为iso9660的文件 以只读（ro）方式从 /dev/cdrom 挂载到/mnt/cdrom\n~~~\n\n### 2. 设置开机自动挂载\n~~~\nvi /etc/fstab\n/dev/cdrom\t/mnt/cdrom\tiso9660\tdefaults\t0\t0\n~~~\n\n### 3. 关闭防火墙\n~~~\nchkconfig iptables --list\nchkconfig iptables  off   //重启时也自动关闭\n~~~\n### 4. 设置yum本地源\n~~~\ncd /etc/yum.repos.d/\n修改baseurl=file:///或http://\n~~~\n\n### 5. 将自己的包配置成yum库\n~~~\n进入到repo目录\n执行命令：createrepo  .  \n~~~\n\n### 6. rename 批量重命名\n~~~\nrename .a .b *.a   //将所有.a结尾的文件重命名成.b结尾的文件\n~~~\n\n### 7. 服务\n~~~\nservice httpd status  //查看服务状态\nservice httpd start   //开启服务\nservice httpd restart //重启服务\nservice httpd stop  //关闭服务\n~~~\n\n### 8. 关闭SELinux\n~~~\nvi /etc/selinux/config\n修改SE Linux=disabled\n~~~\n\n\n### 9. 添加字符串到文件\n~~~\n“>” 将一条命令重定向到一个文件，会覆盖原文件；\n“>>” 将一条命令追加到一个文件，不会覆盖，在文件末尾添加；\n~~~\n\n### 10. vi快捷键\n\n#### 一般模式下：\n~~~\ny\t复制，3yy 复制三行；\nd\t删除， 5dd 删除附近五行；\n~~~\n#### 命令行模式：\n~~~\n%s／abc／efg\t字符串替换。将所有的abc替换成efg\n／abc\t查找字符串abc ，按n查找下一个，N查找上一个；\n~~~\n### 11. 修改文件权限\n~~~\nchmod\tu+／-r\t文件\t\t给文件拥有者添加／减少 可读权限（u为拥有者，g为用户组，o其他用户）\nchmod\t777\t\t文件\t\t修改文件为所有人可读可写可执行（r：4，w：2，x：1）\nchmod\t-r\t把文件夹及其下子文件修改为一致；\nchown 用户 目录或文件名\t修改文件所属用户\n~~~\n### 12. 用户管理\n\n#### 添加用户：\n~~~\nuseradd\t用户名\t添加用户\npasswd\t用户名\t修改用户密码\n~~~\n### 13. 查看大小\n\n#### 查看文件夹：\n~~~\ndu\t-sh\t文件夹\n~~~\n#### 查看分区：\n~~~\ndf\t-h\n~~~\n\n### 14. 跟踪日志文件\n~~~\ntail -10\t文件\t\t跟踪显示后10行\ntail\t-f\t文件\t\t实时跟踪显示文件（只跟踪文件indo号）\ntail\t-F\t文件\t\t实时跟踪显示文件 （跟踪文件的名称）\n~~~\n### 15. cut\n~~~\ncut\t-d\t‘ ：’\t-f\t1\t截取以 ：分割的第一个\n~~~\n### 16. sort\n~~~\nsort\t-t\t' : '\t-k  2nr\t  将用  ：分割的字符串以第二列数字倒序排列\n~~~\n### 17. sed\n~~~\nsed\t‘2d’\tfilename\t删除filename第二行\t不会改变源文件里面的数据加sed -i 会改变源文件里面的数据\nsed\t‘/test/’d \tfilename\t删除匹配test的行\nsed\t‘2，$d’\tfilename\t删除filename2到结束\nsed\t‘s/aa/bb/g’\tfilename\t全局将带有aa的行替换成bb\n~~~\n### 18. awk\n~~~\nawk\t-F\t‘ ：’  ‘ { print $1 \",\" $7 }   将以 ：分割的字符串打印第1和第7列中间用 ，分割\n~~~\n### 19. expor\n~~~\nexport 定义的变量只对本会话和子会话生效（bash），要想使在子对话定义的变量在父会话中生效，要使用source  /etc/profile**1.添加字符串到文件**\n“>” 将一条命令重定向到一个文件，会覆盖原文件；\n“>>” 将一条命令追加到一个文件，不会覆盖，在文件末尾添加；\n~~~\n\n### 20. 安装centos mini版本后应该处理的问题\n\n#### 1. ifconfig后没有eth0 网卡\n~~~\nvi /etc/sysconfig/network-scripts/ifcfg-eth0 \nONBOOT=no 改为 yes\n~~~\n\n#### 2. 安装ssh\n~~~\nyum install openssh-server  安装ssh服务\nyum install opens-clients    安装ssh客户端\n查看ssh是否启动\nnetstat -antp | grep ssh    可以看到22号端口是否启动\n~~~\n\n#### 3. 永久关闭防火墙\n~~~\nchkconfig  iptables off\nservice iptables stop （重启以后不会再生效，不能永久关闭）\n~~~\n\n#### 4. 修改主机名\n~~~\nvi  /etc/sysconfig/network\nhostname=xxxx     xxx改为需要的名称\n~~~\n#### 5. 增加用户并为用户添加密码\n~~~\nadduser   xxx    xxx为用户\npasswd    xxx    xxx为用户\n~~~\n#### 6. 为用户添加权限\n~~~\nvi /etc/sudoers\n找到root all=（all） all\n添加xxx  all=（all） all\n~~~\n#### 7. 当复制一个虚拟机时网卡eth0启动不了\n~~~\nvi /etc/udev/rules.d/70-persistent-net.rules\n将eth0的删除，将eth1的改成eth0\n或者查看eth1的序列号将网卡ifcfg-eth0的序列号改成eth1的\n~~~\n#### 8. 添加几台虚拟机的网址主机名映射\n~~~\nvi /etc/hosts\n添加如192.168.1.101  hadoop01\n~~~\n#### 9. 为几台虚拟机设置免密登录\n\n### 21. Linux下轻量级的集群管理利器ClusterShell","source":"notes/Linux.md","raw":"\n\n#Linux\n\n### 1. 挂载\n\n~~~\nmount -t iso9660 -o ro /dev/cdrom /mnt/cdrom  //将文件类型为iso9660的文件 以只读（ro）方式从 /dev/cdrom 挂载到/mnt/cdrom\n~~~\n\n### 2. 设置开机自动挂载\n~~~\nvi /etc/fstab\n/dev/cdrom\t/mnt/cdrom\tiso9660\tdefaults\t0\t0\n~~~\n\n### 3. 关闭防火墙\n~~~\nchkconfig iptables --list\nchkconfig iptables  off   //重启时也自动关闭\n~~~\n### 4. 设置yum本地源\n~~~\ncd /etc/yum.repos.d/\n修改baseurl=file:///或http://\n~~~\n\n### 5. 将自己的包配置成yum库\n~~~\n进入到repo目录\n执行命令：createrepo  .  \n~~~\n\n### 6. rename 批量重命名\n~~~\nrename .a .b *.a   //将所有.a结尾的文件重命名成.b结尾的文件\n~~~\n\n### 7. 服务\n~~~\nservice httpd status  //查看服务状态\nservice httpd start   //开启服务\nservice httpd restart //重启服务\nservice httpd stop  //关闭服务\n~~~\n\n### 8. 关闭SELinux\n~~~\nvi /etc/selinux/config\n修改SE Linux=disabled\n~~~\n\n\n### 9. 添加字符串到文件\n~~~\n“>” 将一条命令重定向到一个文件，会覆盖原文件；\n“>>” 将一条命令追加到一个文件，不会覆盖，在文件末尾添加；\n~~~\n\n### 10. vi快捷键\n\n#### 一般模式下：\n~~~\ny\t复制，3yy 复制三行；\nd\t删除， 5dd 删除附近五行；\n~~~\n#### 命令行模式：\n~~~\n%s／abc／efg\t字符串替换。将所有的abc替换成efg\n／abc\t查找字符串abc ，按n查找下一个，N查找上一个；\n~~~\n### 11. 修改文件权限\n~~~\nchmod\tu+／-r\t文件\t\t给文件拥有者添加／减少 可读权限（u为拥有者，g为用户组，o其他用户）\nchmod\t777\t\t文件\t\t修改文件为所有人可读可写可执行（r：4，w：2，x：1）\nchmod\t-r\t把文件夹及其下子文件修改为一致；\nchown 用户 目录或文件名\t修改文件所属用户\n~~~\n### 12. 用户管理\n\n#### 添加用户：\n~~~\nuseradd\t用户名\t添加用户\npasswd\t用户名\t修改用户密码\n~~~\n### 13. 查看大小\n\n#### 查看文件夹：\n~~~\ndu\t-sh\t文件夹\n~~~\n#### 查看分区：\n~~~\ndf\t-h\n~~~\n\n### 14. 跟踪日志文件\n~~~\ntail -10\t文件\t\t跟踪显示后10行\ntail\t-f\t文件\t\t实时跟踪显示文件（只跟踪文件indo号）\ntail\t-F\t文件\t\t实时跟踪显示文件 （跟踪文件的名称）\n~~~\n### 15. cut\n~~~\ncut\t-d\t‘ ：’\t-f\t1\t截取以 ：分割的第一个\n~~~\n### 16. sort\n~~~\nsort\t-t\t' : '\t-k  2nr\t  将用  ：分割的字符串以第二列数字倒序排列\n~~~\n### 17. sed\n~~~\nsed\t‘2d’\tfilename\t删除filename第二行\t不会改变源文件里面的数据加sed -i 会改变源文件里面的数据\nsed\t‘/test/’d \tfilename\t删除匹配test的行\nsed\t‘2，$d’\tfilename\t删除filename2到结束\nsed\t‘s/aa/bb/g’\tfilename\t全局将带有aa的行替换成bb\n~~~\n### 18. awk\n~~~\nawk\t-F\t‘ ：’  ‘ { print $1 \",\" $7 }   将以 ：分割的字符串打印第1和第7列中间用 ，分割\n~~~\n### 19. expor\n~~~\nexport 定义的变量只对本会话和子会话生效（bash），要想使在子对话定义的变量在父会话中生效，要使用source  /etc/profile**1.添加字符串到文件**\n“>” 将一条命令重定向到一个文件，会覆盖原文件；\n“>>” 将一条命令追加到一个文件，不会覆盖，在文件末尾添加；\n~~~\n\n### 20. 安装centos mini版本后应该处理的问题\n\n#### 1. ifconfig后没有eth0 网卡\n~~~\nvi /etc/sysconfig/network-scripts/ifcfg-eth0 \nONBOOT=no 改为 yes\n~~~\n\n#### 2. 安装ssh\n~~~\nyum install openssh-server  安装ssh服务\nyum install opens-clients    安装ssh客户端\n查看ssh是否启动\nnetstat -antp | grep ssh    可以看到22号端口是否启动\n~~~\n\n#### 3. 永久关闭防火墙\n~~~\nchkconfig  iptables off\nservice iptables stop （重启以后不会再生效，不能永久关闭）\n~~~\n\n#### 4. 修改主机名\n~~~\nvi  /etc/sysconfig/network\nhostname=xxxx     xxx改为需要的名称\n~~~\n#### 5. 增加用户并为用户添加密码\n~~~\nadduser   xxx    xxx为用户\npasswd    xxx    xxx为用户\n~~~\n#### 6. 为用户添加权限\n~~~\nvi /etc/sudoers\n找到root all=（all） all\n添加xxx  all=（all） all\n~~~\n#### 7. 当复制一个虚拟机时网卡eth0启动不了\n~~~\nvi /etc/udev/rules.d/70-persistent-net.rules\n将eth0的删除，将eth1的改成eth0\n或者查看eth1的序列号将网卡ifcfg-eth0的序列号改成eth1的\n~~~\n#### 8. 添加几台虚拟机的网址主机名映射\n~~~\nvi /etc/hosts\n添加如192.168.1.101  hadoop01\n~~~\n#### 9. 为几台虚拟机设置免密登录\n\n### 21. Linux下轻量级的集群管理利器ClusterShell","date":"2020-03-19T05:09:33.000Z","updated":"2020-03-18T11:52:16.000Z","path":"notes/Linux.html","title":"","comments":1,"layout":"page","_id":"ck8hf2uvc000fzhs6wiijj8y5","content":"<p>#Linux</p>\n<h3 id=\"1-挂载\"><a href=\"#1-挂载\" class=\"headerlink\" title=\"1. 挂载\"></a>1. 挂载</h3><pre><code>mount -t iso9660 -o ro /dev/cdrom /mnt/cdrom  //将文件类型为iso9660的文件 以只读（ro）方式从 /dev/cdrom 挂载到/mnt/cdrom</code></pre><h3 id=\"2-设置开机自动挂载\"><a href=\"#2-设置开机自动挂载\" class=\"headerlink\" title=\"2. 设置开机自动挂载\"></a>2. 设置开机自动挂载</h3><pre><code>vi /etc/fstab\n/dev/cdrom    /mnt/cdrom    iso9660    defaults    0    0</code></pre><h3 id=\"3-关闭防火墙\"><a href=\"#3-关闭防火墙\" class=\"headerlink\" title=\"3. 关闭防火墙\"></a>3. 关闭防火墙</h3><pre><code>chkconfig iptables --list\nchkconfig iptables  off   //重启时也自动关闭</code></pre><h3 id=\"4-设置yum本地源\"><a href=\"#4-设置yum本地源\" class=\"headerlink\" title=\"4. 设置yum本地源\"></a>4. 设置yum本地源</h3><pre><code>cd /etc/yum.repos.d/\n修改baseurl=file:///或http://</code></pre><h3 id=\"5-将自己的包配置成yum库\"><a href=\"#5-将自己的包配置成yum库\" class=\"headerlink\" title=\"5. 将自己的包配置成yum库\"></a>5. 将自己的包配置成yum库</h3><pre><code>进入到repo目录\n执行命令：createrepo  .  </code></pre><h3 id=\"6-rename-批量重命名\"><a href=\"#6-rename-批量重命名\" class=\"headerlink\" title=\"6. rename 批量重命名\"></a>6. rename 批量重命名</h3><pre><code>rename .a .b *.a   //将所有.a结尾的文件重命名成.b结尾的文件</code></pre><h3 id=\"7-服务\"><a href=\"#7-服务\" class=\"headerlink\" title=\"7. 服务\"></a>7. 服务</h3><pre><code>service httpd status  //查看服务状态\nservice httpd start   //开启服务\nservice httpd restart //重启服务\nservice httpd stop  //关闭服务</code></pre><h3 id=\"8-关闭SELinux\"><a href=\"#8-关闭SELinux\" class=\"headerlink\" title=\"8. 关闭SELinux\"></a>8. 关闭SELinux</h3><pre><code>vi /etc/selinux/config\n修改SE Linux=disabled</code></pre><h3 id=\"9-添加字符串到文件\"><a href=\"#9-添加字符串到文件\" class=\"headerlink\" title=\"9. 添加字符串到文件\"></a>9. 添加字符串到文件</h3><pre><code>“&gt;” 将一条命令重定向到一个文件，会覆盖原文件；\n“&gt;&gt;” 将一条命令追加到一个文件，不会覆盖，在文件末尾添加；</code></pre><h3 id=\"10-vi快捷键\"><a href=\"#10-vi快捷键\" class=\"headerlink\" title=\"10. vi快捷键\"></a>10. vi快捷键</h3><h4 id=\"一般模式下：\"><a href=\"#一般模式下：\" class=\"headerlink\" title=\"一般模式下：\"></a>一般模式下：</h4><pre><code>y    复制，3yy 复制三行；\nd    删除， 5dd 删除附近五行；</code></pre><h4 id=\"命令行模式：\"><a href=\"#命令行模式：\" class=\"headerlink\" title=\"命令行模式：\"></a>命令行模式：</h4><pre><code>%s／abc／efg    字符串替换。将所有的abc替换成efg\n／abc    查找字符串abc ，按n查找下一个，N查找上一个；</code></pre><h3 id=\"11-修改文件权限\"><a href=\"#11-修改文件权限\" class=\"headerlink\" title=\"11. 修改文件权限\"></a>11. 修改文件权限</h3><pre><code>chmod    u+／-r    文件        给文件拥有者添加／减少 可读权限（u为拥有者，g为用户组，o其他用户）\nchmod    777        文件        修改文件为所有人可读可写可执行（r：4，w：2，x：1）\nchmod    -r    把文件夹及其下子文件修改为一致；\nchown 用户 目录或文件名    修改文件所属用户</code></pre><h3 id=\"12-用户管理\"><a href=\"#12-用户管理\" class=\"headerlink\" title=\"12. 用户管理\"></a>12. 用户管理</h3><h4 id=\"添加用户：\"><a href=\"#添加用户：\" class=\"headerlink\" title=\"添加用户：\"></a>添加用户：</h4><pre><code>useradd    用户名    添加用户\npasswd    用户名    修改用户密码</code></pre><h3 id=\"13-查看大小\"><a href=\"#13-查看大小\" class=\"headerlink\" title=\"13. 查看大小\"></a>13. 查看大小</h3><h4 id=\"查看文件夹：\"><a href=\"#查看文件夹：\" class=\"headerlink\" title=\"查看文件夹：\"></a>查看文件夹：</h4><pre><code>du    -sh    文件夹</code></pre><h4 id=\"查看分区：\"><a href=\"#查看分区：\" class=\"headerlink\" title=\"查看分区：\"></a>查看分区：</h4><pre><code>df    -h</code></pre><h3 id=\"14-跟踪日志文件\"><a href=\"#14-跟踪日志文件\" class=\"headerlink\" title=\"14. 跟踪日志文件\"></a>14. 跟踪日志文件</h3><pre><code>tail -10    文件        跟踪显示后10行\ntail    -f    文件        实时跟踪显示文件（只跟踪文件indo号）\ntail    -F    文件        实时跟踪显示文件 （跟踪文件的名称）</code></pre><h3 id=\"15-cut\"><a href=\"#15-cut\" class=\"headerlink\" title=\"15. cut\"></a>15. cut</h3><pre><code>cut    -d    ‘ ：’    -f    1    截取以 ：分割的第一个</code></pre><h3 id=\"16-sort\"><a href=\"#16-sort\" class=\"headerlink\" title=\"16. sort\"></a>16. sort</h3><pre><code>sort    -t    &#39; : &#39;    -k  2nr      将用  ：分割的字符串以第二列数字倒序排列</code></pre><h3 id=\"17-sed\"><a href=\"#17-sed\" class=\"headerlink\" title=\"17. sed\"></a>17. sed</h3><pre><code>sed    ‘2d’    filename    删除filename第二行    不会改变源文件里面的数据加sed -i 会改变源文件里面的数据\nsed    ‘/test/’d     filename    删除匹配test的行\nsed    ‘2，$d’    filename    删除filename2到结束\nsed    ‘s/aa/bb/g’    filename    全局将带有aa的行替换成bb</code></pre><h3 id=\"18-awk\"><a href=\"#18-awk\" class=\"headerlink\" title=\"18. awk\"></a>18. awk</h3><pre><code>awk    -F    ‘ ：’  ‘ { print $1 &quot;,&quot; $7 }   将以 ：分割的字符串打印第1和第7列中间用 ，分割</code></pre><h3 id=\"19-expor\"><a href=\"#19-expor\" class=\"headerlink\" title=\"19. expor\"></a>19. expor</h3><pre><code>export 定义的变量只对本会话和子会话生效（bash），要想使在子对话定义的变量在父会话中生效，要使用source  /etc/profile**1.添加字符串到文件**\n“&gt;” 将一条命令重定向到一个文件，会覆盖原文件；\n“&gt;&gt;” 将一条命令追加到一个文件，不会覆盖，在文件末尾添加；</code></pre><h3 id=\"20-安装centos-mini版本后应该处理的问题\"><a href=\"#20-安装centos-mini版本后应该处理的问题\" class=\"headerlink\" title=\"20. 安装centos mini版本后应该处理的问题\"></a>20. 安装centos mini版本后应该处理的问题</h3><h4 id=\"1-ifconfig后没有eth0-网卡\"><a href=\"#1-ifconfig后没有eth0-网卡\" class=\"headerlink\" title=\"1. ifconfig后没有eth0 网卡\"></a>1. ifconfig后没有eth0 网卡</h4><pre><code>vi /etc/sysconfig/network-scripts/ifcfg-eth0 \nONBOOT=no 改为 yes</code></pre><h4 id=\"2-安装ssh\"><a href=\"#2-安装ssh\" class=\"headerlink\" title=\"2. 安装ssh\"></a>2. 安装ssh</h4><pre><code>yum install openssh-server  安装ssh服务\nyum install opens-clients    安装ssh客户端\n查看ssh是否启动\nnetstat -antp | grep ssh    可以看到22号端口是否启动</code></pre><h4 id=\"3-永久关闭防火墙\"><a href=\"#3-永久关闭防火墙\" class=\"headerlink\" title=\"3. 永久关闭防火墙\"></a>3. 永久关闭防火墙</h4><pre><code>chkconfig  iptables off\nservice iptables stop （重启以后不会再生效，不能永久关闭）</code></pre><h4 id=\"4-修改主机名\"><a href=\"#4-修改主机名\" class=\"headerlink\" title=\"4. 修改主机名\"></a>4. 修改主机名</h4><pre><code>vi  /etc/sysconfig/network\nhostname=xxxx     xxx改为需要的名称</code></pre><h4 id=\"5-增加用户并为用户添加密码\"><a href=\"#5-增加用户并为用户添加密码\" class=\"headerlink\" title=\"5. 增加用户并为用户添加密码\"></a>5. 增加用户并为用户添加密码</h4><pre><code>adduser   xxx    xxx为用户\npasswd    xxx    xxx为用户</code></pre><h4 id=\"6-为用户添加权限\"><a href=\"#6-为用户添加权限\" class=\"headerlink\" title=\"6. 为用户添加权限\"></a>6. 为用户添加权限</h4><pre><code>vi /etc/sudoers\n找到root all=（all） all\n添加xxx  all=（all） all</code></pre><h4 id=\"7-当复制一个虚拟机时网卡eth0启动不了\"><a href=\"#7-当复制一个虚拟机时网卡eth0启动不了\" class=\"headerlink\" title=\"7. 当复制一个虚拟机时网卡eth0启动不了\"></a>7. 当复制一个虚拟机时网卡eth0启动不了</h4><pre><code>vi /etc/udev/rules.d/70-persistent-net.rules\n将eth0的删除，将eth1的改成eth0\n或者查看eth1的序列号将网卡ifcfg-eth0的序列号改成eth1的</code></pre><h4 id=\"8-添加几台虚拟机的网址主机名映射\"><a href=\"#8-添加几台虚拟机的网址主机名映射\" class=\"headerlink\" title=\"8. 添加几台虚拟机的网址主机名映射\"></a>8. 添加几台虚拟机的网址主机名映射</h4><pre><code>vi /etc/hosts\n添加如192.168.1.101  hadoop01</code></pre><h4 id=\"9-为几台虚拟机设置免密登录\"><a href=\"#9-为几台虚拟机设置免密登录\" class=\"headerlink\" title=\"9. 为几台虚拟机设置免密登录\"></a>9. 为几台虚拟机设置免密登录</h4><h3 id=\"21-Linux下轻量级的集群管理利器ClusterShell\"><a href=\"#21-Linux下轻量级的集群管理利器ClusterShell\" class=\"headerlink\" title=\"21. Linux下轻量级的集群管理利器ClusterShell\"></a>21. Linux下轻量级的集群管理利器ClusterShell</h3>","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":"<p>#Linux</p>\n<h3 id=\"1-挂载\"><a href=\"#1-挂载\" class=\"headerlink\" title=\"1. 挂载\"></a>1. 挂载</h3><pre><code>mount -t iso9660 -o ro /dev/cdrom /mnt/cdrom  //将文件类型为iso9660的文件 以只读（ro）方式从 /dev/cdrom 挂载到/mnt/cdrom</code></pre><h3 id=\"2-设置开机自动挂载\"><a href=\"#2-设置开机自动挂载\" class=\"headerlink\" title=\"2. 设置开机自动挂载\"></a>2. 设置开机自动挂载</h3><pre><code>vi /etc/fstab\n/dev/cdrom    /mnt/cdrom    iso9660    defaults    0    0</code></pre><h3 id=\"3-关闭防火墙\"><a href=\"#3-关闭防火墙\" class=\"headerlink\" title=\"3. 关闭防火墙\"></a>3. 关闭防火墙</h3><pre><code>chkconfig iptables --list\nchkconfig iptables  off   //重启时也自动关闭</code></pre><h3 id=\"4-设置yum本地源\"><a href=\"#4-设置yum本地源\" class=\"headerlink\" title=\"4. 设置yum本地源\"></a>4. 设置yum本地源</h3><pre><code>cd /etc/yum.repos.d/\n修改baseurl=file:///或http://</code></pre><h3 id=\"5-将自己的包配置成yum库\"><a href=\"#5-将自己的包配置成yum库\" class=\"headerlink\" title=\"5. 将自己的包配置成yum库\"></a>5. 将自己的包配置成yum库</h3><pre><code>进入到repo目录\n执行命令：createrepo  .  </code></pre><h3 id=\"6-rename-批量重命名\"><a href=\"#6-rename-批量重命名\" class=\"headerlink\" title=\"6. rename 批量重命名\"></a>6. rename 批量重命名</h3><pre><code>rename .a .b *.a   //将所有.a结尾的文件重命名成.b结尾的文件</code></pre><h3 id=\"7-服务\"><a href=\"#7-服务\" class=\"headerlink\" title=\"7. 服务\"></a>7. 服务</h3><pre><code>service httpd status  //查看服务状态\nservice httpd start   //开启服务\nservice httpd restart //重启服务\nservice httpd stop  //关闭服务</code></pre><h3 id=\"8-关闭SELinux\"><a href=\"#8-关闭SELinux\" class=\"headerlink\" title=\"8. 关闭SELinux\"></a>8. 关闭SELinux</h3><pre><code>vi /etc/selinux/config\n修改SE Linux=disabled</code></pre><h3 id=\"9-添加字符串到文件\"><a href=\"#9-添加字符串到文件\" class=\"headerlink\" title=\"9. 添加字符串到文件\"></a>9. 添加字符串到文件</h3><pre><code>“&gt;” 将一条命令重定向到一个文件，会覆盖原文件；\n“&gt;&gt;” 将一条命令追加到一个文件，不会覆盖，在文件末尾添加；</code></pre><h3 id=\"10-vi快捷键\"><a href=\"#10-vi快捷键\" class=\"headerlink\" title=\"10. vi快捷键\"></a>10. vi快捷键</h3><h4 id=\"一般模式下：\"><a href=\"#一般模式下：\" class=\"headerlink\" title=\"一般模式下：\"></a>一般模式下：</h4><pre><code>y    复制，3yy 复制三行；\nd    删除， 5dd 删除附近五行；</code></pre><h4 id=\"命令行模式：\"><a href=\"#命令行模式：\" class=\"headerlink\" title=\"命令行模式：\"></a>命令行模式：</h4><pre><code>%s／abc／efg    字符串替换。将所有的abc替换成efg\n／abc    查找字符串abc ，按n查找下一个，N查找上一个；</code></pre><h3 id=\"11-修改文件权限\"><a href=\"#11-修改文件权限\" class=\"headerlink\" title=\"11. 修改文件权限\"></a>11. 修改文件权限</h3><pre><code>chmod    u+／-r    文件        给文件拥有者添加／减少 可读权限（u为拥有者，g为用户组，o其他用户）\nchmod    777        文件        修改文件为所有人可读可写可执行（r：4，w：2，x：1）\nchmod    -r    把文件夹及其下子文件修改为一致；\nchown 用户 目录或文件名    修改文件所属用户</code></pre><h3 id=\"12-用户管理\"><a href=\"#12-用户管理\" class=\"headerlink\" title=\"12. 用户管理\"></a>12. 用户管理</h3><h4 id=\"添加用户：\"><a href=\"#添加用户：\" class=\"headerlink\" title=\"添加用户：\"></a>添加用户：</h4><pre><code>useradd    用户名    添加用户\npasswd    用户名    修改用户密码</code></pre><h3 id=\"13-查看大小\"><a href=\"#13-查看大小\" class=\"headerlink\" title=\"13. 查看大小\"></a>13. 查看大小</h3><h4 id=\"查看文件夹：\"><a href=\"#查看文件夹：\" class=\"headerlink\" title=\"查看文件夹：\"></a>查看文件夹：</h4><pre><code>du    -sh    文件夹</code></pre><h4 id=\"查看分区：\"><a href=\"#查看分区：\" class=\"headerlink\" title=\"查看分区：\"></a>查看分区：</h4><pre><code>df    -h</code></pre><h3 id=\"14-跟踪日志文件\"><a href=\"#14-跟踪日志文件\" class=\"headerlink\" title=\"14. 跟踪日志文件\"></a>14. 跟踪日志文件</h3><pre><code>tail -10    文件        跟踪显示后10行\ntail    -f    文件        实时跟踪显示文件（只跟踪文件indo号）\ntail    -F    文件        实时跟踪显示文件 （跟踪文件的名称）</code></pre><h3 id=\"15-cut\"><a href=\"#15-cut\" class=\"headerlink\" title=\"15. cut\"></a>15. cut</h3><pre><code>cut    -d    ‘ ：’    -f    1    截取以 ：分割的第一个</code></pre><h3 id=\"16-sort\"><a href=\"#16-sort\" class=\"headerlink\" title=\"16. sort\"></a>16. sort</h3><pre><code>sort    -t    &#39; : &#39;    -k  2nr      将用  ：分割的字符串以第二列数字倒序排列</code></pre><h3 id=\"17-sed\"><a href=\"#17-sed\" class=\"headerlink\" title=\"17. sed\"></a>17. sed</h3><pre><code>sed    ‘2d’    filename    删除filename第二行    不会改变源文件里面的数据加sed -i 会改变源文件里面的数据\nsed    ‘/test/’d     filename    删除匹配test的行\nsed    ‘2，$d’    filename    删除filename2到结束\nsed    ‘s/aa/bb/g’    filename    全局将带有aa的行替换成bb</code></pre><h3 id=\"18-awk\"><a href=\"#18-awk\" class=\"headerlink\" title=\"18. awk\"></a>18. awk</h3><pre><code>awk    -F    ‘ ：’  ‘ { print $1 &quot;,&quot; $7 }   将以 ：分割的字符串打印第1和第7列中间用 ，分割</code></pre><h3 id=\"19-expor\"><a href=\"#19-expor\" class=\"headerlink\" title=\"19. expor\"></a>19. expor</h3><pre><code>export 定义的变量只对本会话和子会话生效（bash），要想使在子对话定义的变量在父会话中生效，要使用source  /etc/profile**1.添加字符串到文件**\n“&gt;” 将一条命令重定向到一个文件，会覆盖原文件；\n“&gt;&gt;” 将一条命令追加到一个文件，不会覆盖，在文件末尾添加；</code></pre><h3 id=\"20-安装centos-mini版本后应该处理的问题\"><a href=\"#20-安装centos-mini版本后应该处理的问题\" class=\"headerlink\" title=\"20. 安装centos mini版本后应该处理的问题\"></a>20. 安装centos mini版本后应该处理的问题</h3><h4 id=\"1-ifconfig后没有eth0-网卡\"><a href=\"#1-ifconfig后没有eth0-网卡\" class=\"headerlink\" title=\"1. ifconfig后没有eth0 网卡\"></a>1. ifconfig后没有eth0 网卡</h4><pre><code>vi /etc/sysconfig/network-scripts/ifcfg-eth0 \nONBOOT=no 改为 yes</code></pre><h4 id=\"2-安装ssh\"><a href=\"#2-安装ssh\" class=\"headerlink\" title=\"2. 安装ssh\"></a>2. 安装ssh</h4><pre><code>yum install openssh-server  安装ssh服务\nyum install opens-clients    安装ssh客户端\n查看ssh是否启动\nnetstat -antp | grep ssh    可以看到22号端口是否启动</code></pre><h4 id=\"3-永久关闭防火墙\"><a href=\"#3-永久关闭防火墙\" class=\"headerlink\" title=\"3. 永久关闭防火墙\"></a>3. 永久关闭防火墙</h4><pre><code>chkconfig  iptables off\nservice iptables stop （重启以后不会再生效，不能永久关闭）</code></pre><h4 id=\"4-修改主机名\"><a href=\"#4-修改主机名\" class=\"headerlink\" title=\"4. 修改主机名\"></a>4. 修改主机名</h4><pre><code>vi  /etc/sysconfig/network\nhostname=xxxx     xxx改为需要的名称</code></pre><h4 id=\"5-增加用户并为用户添加密码\"><a href=\"#5-增加用户并为用户添加密码\" class=\"headerlink\" title=\"5. 增加用户并为用户添加密码\"></a>5. 增加用户并为用户添加密码</h4><pre><code>adduser   xxx    xxx为用户\npasswd    xxx    xxx为用户</code></pre><h4 id=\"6-为用户添加权限\"><a href=\"#6-为用户添加权限\" class=\"headerlink\" title=\"6. 为用户添加权限\"></a>6. 为用户添加权限</h4><pre><code>vi /etc/sudoers\n找到root all=（all） all\n添加xxx  all=（all） all</code></pre><h4 id=\"7-当复制一个虚拟机时网卡eth0启动不了\"><a href=\"#7-当复制一个虚拟机时网卡eth0启动不了\" class=\"headerlink\" title=\"7. 当复制一个虚拟机时网卡eth0启动不了\"></a>7. 当复制一个虚拟机时网卡eth0启动不了</h4><pre><code>vi /etc/udev/rules.d/70-persistent-net.rules\n将eth0的删除，将eth1的改成eth0\n或者查看eth1的序列号将网卡ifcfg-eth0的序列号改成eth1的</code></pre><h4 id=\"8-添加几台虚拟机的网址主机名映射\"><a href=\"#8-添加几台虚拟机的网址主机名映射\" class=\"headerlink\" title=\"8. 添加几台虚拟机的网址主机名映射\"></a>8. 添加几台虚拟机的网址主机名映射</h4><pre><code>vi /etc/hosts\n添加如192.168.1.101  hadoop01</code></pre><h4 id=\"9-为几台虚拟机设置免密登录\"><a href=\"#9-为几台虚拟机设置免密登录\" class=\"headerlink\" title=\"9. 为几台虚拟机设置免密登录\"></a>9. 为几台虚拟机设置免密登录</h4><h3 id=\"21-Linux下轻量级的集群管理利器ClusterShell\"><a href=\"#21-Linux下轻量级的集群管理利器ClusterShell\" class=\"headerlink\" title=\"21. Linux下轻量级的集群管理利器ClusterShell\"></a>21. Linux下轻量级的集群管理利器ClusterShell</h3>"},{"title":"笔记","date":"2019-12-26T15:50:21.000Z","_content":"\n[Bigdata](./Bigdata.html)\n\n[Hive](./Hive.html)\n\n[Redis](./Redis.html)\n\n[Kafka](./Kafka.html)\n\n[Linux](./Linux.html)\n\n[Docker](./Docker.html)\n\n[Git&GitHub](./Git&GitHub.html)\n\n[Golang](./Golang.html)\n\n","source":"notes/index.md","raw":"---\ntitle: 笔记\ndate: 2019-12-26 23:50:21\n---\n\n[Bigdata](./Bigdata.html)\n\n[Hive](./Hive.html)\n\n[Redis](./Redis.html)\n\n[Kafka](./Kafka.html)\n\n[Linux](./Linux.html)\n\n[Docker](./Docker.html)\n\n[Git&GitHub](./Git&GitHub.html)\n\n[Golang](./Golang.html)\n\n","updated":"2020-04-01T13:52:13.000Z","path":"notes/index.html","comments":1,"layout":"page","_id":"ck8hf2uvd000gzhs667hs60ay","content":"<p><a href=\"./Bigdata.html\">Bigdata</a></p>\n<p><a href=\"./Hive.html\">Hive</a></p>\n<p><a href=\"./Redis.html\">Redis</a></p>\n<p><a href=\"./Kafka.html\">Kafka</a></p>\n<p><a href=\"./Linux.html\">Linux</a></p>\n<p><a href=\"./Docker.html\">Docker</a></p>\n<p><a href=\"./Git&GitHub.html\">Git&amp;GitHub</a></p>\n<p><a href=\"./Golang.html\">Golang</a></p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":"<p><a href=\"./Bigdata.html\">Bigdata</a></p>\n<p><a href=\"./Hive.html\">Hive</a></p>\n<p><a href=\"./Redis.html\">Redis</a></p>\n<p><a href=\"./Kafka.html\">Kafka</a></p>\n<p><a href=\"./Linux.html\">Linux</a></p>\n<p><a href=\"./Docker.html\">Docker</a></p>\n<p><a href=\"./Git&GitHub.html\">Git&amp;GitHub</a></p>\n<p><a href=\"./Golang.html\">Golang</a></p>\n"},{"_content":"# Spark 编码\n\n## 1. map 和 mapPartitions\n\n~~~\nmap是对rdd中的每一个元素进行操作；\nmapPartitions则是对rdd中的每个分区的迭代器进行操作\nMapPartitions的优点：\n如果是普通的map，比如一个partition中有1万条数据。ok，那么你的function要执行和计算1万次。\n使用MapPartitions操作之后，一个task仅仅会执行一次function，function一次接收所有\n的partition数据。只要执行一次就可以了，性能比较高。如果在map过程中需要频繁创建额外的对象(例如将rdd中的数据通过jdbc写入数据库,map需要为每个元素创建一个链接而mapPartition为每个partition创建一个链接),则mapPartitions效率比map高的多。\nSparkSql或DataFrame默认会对程序进行mapPartition的优化。\nMapPartitions的缺点：\n如果是普通的map操作，一次function的执行就处理一条数据；那么如果内存不够用的情况下， 比如处理了1千条数据了，那么这个时候内存不够了，那么就可以将已经处理完的1千条数据从内存里面垃圾回收掉，或者用其他方法，腾出空间来吧。\n所以说普通的map操作通常不会导致内存的OOM异常。 \n\n但是MapPartitions操作，对于大量数据来说，比如甚至一个partition，100万数据，\n一次传入一个function以后，那么可能一下子内存不够，但是又没有办法去腾出内存空间来，可能就OOM，内存溢出。\n\n~~~\n\n## 2. Drive 和 Executo\n\n~~~\n所有RDD算子的计算功能都是由Excutor执行\n~~~\n\n## 3. Shuffle\n\n~~~\n将RDD中一个分区的数据打乱重组到其他不同分区的操作\n~~~\n\n## 4. Task 和 Partition\n\n~~~\n一个分区划分一个任务，一个任务会被分配到一个excutor\n~~~\n\n## 5. reduceByKey 和groupByKey\n\n~~~\nreduceByKey 在shuffle之前有combine(预聚合)操作，性能相对groupByKey要好\n~~~\n\n## 6. stage 划分\n\n~~~\nstage划分根据宽依赖，stage个数=1+shuffle个数\n~~~\n\n## 7. 更新map\n\n```scala\n/**\n *简化if else 结构\n **/\nif(map.contains(v))\n\tmap+=(v->0)\nmap.update(v,map(v)+1) //if外边\n```\n\n## 8. 数组切片\n\n```scala\nval l=List(1,2,3,4,5,6,7)\nval sl=l.slice(0,l.size-1) //[1,2,3,4,5,6]\nval zl=sl.zip(sl.tail) //[(1,2),(2,3),...]\nval zl.map((x,y)=>x+\"_\"+y) //[1_2,2_3,...]\n```\n\n","source":"notes/Spark.md","raw":"# Spark 编码\n\n## 1. map 和 mapPartitions\n\n~~~\nmap是对rdd中的每一个元素进行操作；\nmapPartitions则是对rdd中的每个分区的迭代器进行操作\nMapPartitions的优点：\n如果是普通的map，比如一个partition中有1万条数据。ok，那么你的function要执行和计算1万次。\n使用MapPartitions操作之后，一个task仅仅会执行一次function，function一次接收所有\n的partition数据。只要执行一次就可以了，性能比较高。如果在map过程中需要频繁创建额外的对象(例如将rdd中的数据通过jdbc写入数据库,map需要为每个元素创建一个链接而mapPartition为每个partition创建一个链接),则mapPartitions效率比map高的多。\nSparkSql或DataFrame默认会对程序进行mapPartition的优化。\nMapPartitions的缺点：\n如果是普通的map操作，一次function的执行就处理一条数据；那么如果内存不够用的情况下， 比如处理了1千条数据了，那么这个时候内存不够了，那么就可以将已经处理完的1千条数据从内存里面垃圾回收掉，或者用其他方法，腾出空间来吧。\n所以说普通的map操作通常不会导致内存的OOM异常。 \n\n但是MapPartitions操作，对于大量数据来说，比如甚至一个partition，100万数据，\n一次传入一个function以后，那么可能一下子内存不够，但是又没有办法去腾出内存空间来，可能就OOM，内存溢出。\n\n~~~\n\n## 2. Drive 和 Executo\n\n~~~\n所有RDD算子的计算功能都是由Excutor执行\n~~~\n\n## 3. Shuffle\n\n~~~\n将RDD中一个分区的数据打乱重组到其他不同分区的操作\n~~~\n\n## 4. Task 和 Partition\n\n~~~\n一个分区划分一个任务，一个任务会被分配到一个excutor\n~~~\n\n## 5. reduceByKey 和groupByKey\n\n~~~\nreduceByKey 在shuffle之前有combine(预聚合)操作，性能相对groupByKey要好\n~~~\n\n## 6. stage 划分\n\n~~~\nstage划分根据宽依赖，stage个数=1+shuffle个数\n~~~\n\n## 7. 更新map\n\n```scala\n/**\n *简化if else 结构\n **/\nif(map.contains(v))\n\tmap+=(v->0)\nmap.update(v,map(v)+1) //if外边\n```\n\n## 8. 数组切片\n\n```scala\nval l=List(1,2,3,4,5,6,7)\nval sl=l.slice(0,l.size-1) //[1,2,3,4,5,6]\nval zl=sl.zip(sl.tail) //[(1,2),(2,3),...]\nval zl.map((x,y)=>x+\"_\"+y) //[1_2,2_3,...]\n```\n\n","date":"2020-03-19T05:09:33.000Z","updated":"2020-03-18T11:52:16.000Z","path":"notes/Spark.html","title":"","comments":1,"layout":"page","_id":"ck8hf2uve000hzhs6if4ua97c","content":"<h1 id=\"Spark-编码\"><a href=\"#Spark-编码\" class=\"headerlink\" title=\"Spark 编码\"></a>Spark 编码</h1><h2 id=\"1-map-和-mapPartitions\"><a href=\"#1-map-和-mapPartitions\" class=\"headerlink\" title=\"1. map 和 mapPartitions\"></a>1. map 和 mapPartitions</h2><pre><code>map是对rdd中的每一个元素进行操作；\nmapPartitions则是对rdd中的每个分区的迭代器进行操作\nMapPartitions的优点：\n如果是普通的map，比如一个partition中有1万条数据。ok，那么你的function要执行和计算1万次。\n使用MapPartitions操作之后，一个task仅仅会执行一次function，function一次接收所有\n的partition数据。只要执行一次就可以了，性能比较高。如果在map过程中需要频繁创建额外的对象(例如将rdd中的数据通过jdbc写入数据库,map需要为每个元素创建一个链接而mapPartition为每个partition创建一个链接),则mapPartitions效率比map高的多。\nSparkSql或DataFrame默认会对程序进行mapPartition的优化。\nMapPartitions的缺点：\n如果是普通的map操作，一次function的执行就处理一条数据；那么如果内存不够用的情况下， 比如处理了1千条数据了，那么这个时候内存不够了，那么就可以将已经处理完的1千条数据从内存里面垃圾回收掉，或者用其他方法，腾出空间来吧。\n所以说普通的map操作通常不会导致内存的OOM异常。 \n\n但是MapPartitions操作，对于大量数据来说，比如甚至一个partition，100万数据，\n一次传入一个function以后，那么可能一下子内存不够，但是又没有办法去腾出内存空间来，可能就OOM，内存溢出。\n</code></pre><h2 id=\"2-Drive-和-Executo\"><a href=\"#2-Drive-和-Executo\" class=\"headerlink\" title=\"2. Drive 和 Executo\"></a>2. Drive 和 Executo</h2><pre><code>所有RDD算子的计算功能都是由Excutor执行</code></pre><h2 id=\"3-Shuffle\"><a href=\"#3-Shuffle\" class=\"headerlink\" title=\"3. Shuffle\"></a>3. Shuffle</h2><pre><code>将RDD中一个分区的数据打乱重组到其他不同分区的操作</code></pre><h2 id=\"4-Task-和-Partition\"><a href=\"#4-Task-和-Partition\" class=\"headerlink\" title=\"4. Task 和 Partition\"></a>4. Task 和 Partition</h2><pre><code>一个分区划分一个任务，一个任务会被分配到一个excutor</code></pre><h2 id=\"5-reduceByKey-和groupByKey\"><a href=\"#5-reduceByKey-和groupByKey\" class=\"headerlink\" title=\"5. reduceByKey 和groupByKey\"></a>5. reduceByKey 和groupByKey</h2><pre><code>reduceByKey 在shuffle之前有combine(预聚合)操作，性能相对groupByKey要好</code></pre><h2 id=\"6-stage-划分\"><a href=\"#6-stage-划分\" class=\"headerlink\" title=\"6. stage 划分\"></a>6. stage 划分</h2><pre><code>stage划分根据宽依赖，stage个数=1+shuffle个数</code></pre><h2 id=\"7-更新map\"><a href=\"#7-更新map\" class=\"headerlink\" title=\"7. 更新map\"></a>7. 更新map</h2><pre class=\" language-scala\"><code class=\"language-scala\"><span class=\"token comment\" spellcheck=\"true\">/**\n *简化if else 结构\n **/</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span>contains<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    map<span class=\"token operator\">+=</span><span class=\"token punctuation\">(</span>v<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\nmap<span class=\"token punctuation\">.</span>update<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span>map<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//if外边</span></code></pre>\n<h2 id=\"8-数组切片\"><a href=\"#8-数组切片\" class=\"headerlink\" title=\"8. 数组切片\"></a>8. 数组切片</h2><pre class=\" language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> l<span class=\"token operator\">=</span>List<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> sl<span class=\"token operator\">=</span>l<span class=\"token punctuation\">.</span>slice<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>l<span class=\"token punctuation\">.</span>size<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//[1,2,3,4,5,6]</span>\n<span class=\"token keyword\">val</span> zl<span class=\"token operator\">=</span>sl<span class=\"token punctuation\">.</span>zip<span class=\"token punctuation\">(</span>sl<span class=\"token punctuation\">.</span>tail<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//[(1,2),(2,3),...]</span>\n<span class=\"token keyword\">val</span> zl<span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span>y<span class=\"token punctuation\">)</span><span class=\"token keyword\">=></span>x<span class=\"token operator\">+</span><span class=\"token string\">\"_\"</span><span class=\"token operator\">+</span>y<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//[1_2,2_3,...]</span></code></pre>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":"<h1 id=\"Spark-编码\"><a href=\"#Spark-编码\" class=\"headerlink\" title=\"Spark 编码\"></a>Spark 编码</h1><h2 id=\"1-map-和-mapPartitions\"><a href=\"#1-map-和-mapPartitions\" class=\"headerlink\" title=\"1. map 和 mapPartitions\"></a>1. map 和 mapPartitions</h2><pre><code>map是对rdd中的每一个元素进行操作；\nmapPartitions则是对rdd中的每个分区的迭代器进行操作\nMapPartitions的优点：\n如果是普通的map，比如一个partition中有1万条数据。ok，那么你的function要执行和计算1万次。\n使用MapPartitions操作之后，一个task仅仅会执行一次function，function一次接收所有\n的partition数据。只要执行一次就可以了，性能比较高。如果在map过程中需要频繁创建额外的对象(例如将rdd中的数据通过jdbc写入数据库,map需要为每个元素创建一个链接而mapPartition为每个partition创建一个链接),则mapPartitions效率比map高的多。\nSparkSql或DataFrame默认会对程序进行mapPartition的优化。\nMapPartitions的缺点：\n如果是普通的map操作，一次function的执行就处理一条数据；那么如果内存不够用的情况下， 比如处理了1千条数据了，那么这个时候内存不够了，那么就可以将已经处理完的1千条数据从内存里面垃圾回收掉，或者用其他方法，腾出空间来吧。\n所以说普通的map操作通常不会导致内存的OOM异常。 \n\n但是MapPartitions操作，对于大量数据来说，比如甚至一个partition，100万数据，\n一次传入一个function以后，那么可能一下子内存不够，但是又没有办法去腾出内存空间来，可能就OOM，内存溢出。\n</code></pre><h2 id=\"2-Drive-和-Executo\"><a href=\"#2-Drive-和-Executo\" class=\"headerlink\" title=\"2. Drive 和 Executo\"></a>2. Drive 和 Executo</h2><pre><code>所有RDD算子的计算功能都是由Excutor执行</code></pre><h2 id=\"3-Shuffle\"><a href=\"#3-Shuffle\" class=\"headerlink\" title=\"3. Shuffle\"></a>3. Shuffle</h2><pre><code>将RDD中一个分区的数据打乱重组到其他不同分区的操作</code></pre><h2 id=\"4-Task-和-Partition\"><a href=\"#4-Task-和-Partition\" class=\"headerlink\" title=\"4. Task 和 Partition\"></a>4. Task 和 Partition</h2><pre><code>一个分区划分一个任务，一个任务会被分配到一个excutor</code></pre><h2 id=\"5-reduceByKey-和groupByKey\"><a href=\"#5-reduceByKey-和groupByKey\" class=\"headerlink\" title=\"5. reduceByKey 和groupByKey\"></a>5. reduceByKey 和groupByKey</h2><pre><code>reduceByKey 在shuffle之前有combine(预聚合)操作，性能相对groupByKey要好</code></pre><h2 id=\"6-stage-划分\"><a href=\"#6-stage-划分\" class=\"headerlink\" title=\"6. stage 划分\"></a>6. stage 划分</h2><pre><code>stage划分根据宽依赖，stage个数=1+shuffle个数</code></pre><h2 id=\"7-更新map\"><a href=\"#7-更新map\" class=\"headerlink\" title=\"7. 更新map\"></a>7. 更新map</h2><pre><code class=\"scala\">/**\n *简化if else 结构\n **/\nif(map.contains(v))\n    map+=(v-&gt;0)\nmap.update(v,map(v)+1) //if外边</code></pre>\n<h2 id=\"8-数组切片\"><a href=\"#8-数组切片\" class=\"headerlink\" title=\"8. 数组切片\"></a>8. 数组切片</h2><pre><code class=\"scala\">val l=List(1,2,3,4,5,6,7)\nval sl=l.slice(0,l.size-1) //[1,2,3,4,5,6]\nval zl=sl.zip(sl.tail) //[(1,2),(2,3),...]\nval zl.map((x,y)=&gt;x+&quot;_&quot;+y) //[1_2,2_3,...]</code></pre>\n"},{"_content":"# Scala\n\n## 1. 半生类和半生对象\n\n```scala\n//半生类\nclass A{\ndef apply()={\n\n}\n\n}\n\n//半生对象\nobject A{\n\ndef apply()={\n\n}\n\n}\n\n\nval a=A()   //调用的是object.apply\nval a1=new A()\nal()       //调用的是class.apply\n\n\n//类名()    object.apply\n//对象名()  class.apply\n\n\n最佳实践是在object的apply里面 new Class\n```\n\n\n\n## 2. 尾递归求和\n\n```scala\ndef sum(nums:Int*)={\n\tif(nums==0){\n\t\t0\n\t}else{\n\t\tnums.head+sum(nums.tail:_*)\n\t}\n\n}\n```\n\n\n\n## 3. Range\n\nto // 闭区间\n\nuntil //左闭右开\n\nRange //左闭右开\n\n```\n1 to 4 \t\t\t => [1,4]  =>  1,2,3,4\n1 until 4 \t => [1,4)  =>  1,2,3\nRange(1,4)   => [1,4)  =>  1,2,3\n```\n\n\n\n","source":"notes/Scala.md","raw":"# Scala\n\n## 1. 半生类和半生对象\n\n```scala\n//半生类\nclass A{\ndef apply()={\n\n}\n\n}\n\n//半生对象\nobject A{\n\ndef apply()={\n\n}\n\n}\n\n\nval a=A()   //调用的是object.apply\nval a1=new A()\nal()       //调用的是class.apply\n\n\n//类名()    object.apply\n//对象名()  class.apply\n\n\n最佳实践是在object的apply里面 new Class\n```\n\n\n\n## 2. 尾递归求和\n\n```scala\ndef sum(nums:Int*)={\n\tif(nums==0){\n\t\t0\n\t}else{\n\t\tnums.head+sum(nums.tail:_*)\n\t}\n\n}\n```\n\n\n\n## 3. Range\n\nto // 闭区间\n\nuntil //左闭右开\n\nRange //左闭右开\n\n```\n1 to 4 \t\t\t => [1,4]  =>  1,2,3,4\n1 until 4 \t => [1,4)  =>  1,2,3\nRange(1,4)   => [1,4)  =>  1,2,3\n```\n\n\n\n","date":"2020-03-19T05:09:33.000Z","updated":"2020-03-18T11:52:16.000Z","path":"notes/Scala.html","title":"","comments":1,"layout":"page","_id":"ck8hf2uve000izhs6d6zi367s","content":"<h1 id=\"Scala\"><a href=\"#Scala\" class=\"headerlink\" title=\"Scala\"></a>Scala</h1><h2 id=\"1-半生类和半生对象\"><a href=\"#1-半生类和半生对象\" class=\"headerlink\" title=\"1. 半生类和半生对象\"></a>1. 半生类和半生对象</h2><pre class=\" language-scala\"><code class=\"language-scala\"><span class=\"token comment\" spellcheck=\"true\">//半生类</span>\n<span class=\"token keyword\">class</span> A<span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">def</span> apply<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//半生对象</span>\n<span class=\"token keyword\">object</span> A<span class=\"token punctuation\">{</span>\n\n<span class=\"token keyword\">def</span> apply<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">val</span> a<span class=\"token operator\">=</span>A<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\" spellcheck=\"true\">//调用的是object.apply</span>\n<span class=\"token keyword\">val</span> a1<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> A<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nal<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>       <span class=\"token comment\" spellcheck=\"true\">//调用的是class.apply</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\">//类名()    object.apply</span>\n<span class=\"token comment\" spellcheck=\"true\">//对象名()  class.apply</span>\n\n\n最佳实践是在<span class=\"token keyword\">object</span>的apply里面 <span class=\"token keyword\">new</span> Class</code></pre>\n<h2 id=\"2-尾递归求和\"><a href=\"#2-尾递归求和\" class=\"headerlink\" title=\"2. 尾递归求和\"></a>2. 尾递归求和</h2><pre class=\" language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> sum<span class=\"token punctuation\">(</span>nums<span class=\"token operator\">:</span><span class=\"token builtin\">Int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token number\">0</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n        nums<span class=\"token punctuation\">.</span>head<span class=\"token operator\">+</span>sum<span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">.</span>tail<span class=\"token operator\">:</span>_<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"3-Range\"><a href=\"#3-Range\" class=\"headerlink\" title=\"3. Range\"></a>3. Range</h2><p>to // 闭区间</p>\n<p>until //左闭右开</p>\n<p>Range //左闭右开</p>\n<pre><code>1 to 4              =&gt; [1,4]  =&gt;  1,2,3,4\n1 until 4      =&gt; [1,4)  =&gt;  1,2,3\nRange(1,4)   =&gt; [1,4)  =&gt;  1,2,3</code></pre>","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":"<h1 id=\"Scala\"><a href=\"#Scala\" class=\"headerlink\" title=\"Scala\"></a>Scala</h1><h2 id=\"1-半生类和半生对象\"><a href=\"#1-半生类和半生对象\" class=\"headerlink\" title=\"1. 半生类和半生对象\"></a>1. 半生类和半生对象</h2><pre><code class=\"scala\">//半生类\nclass A{\ndef apply()={\n\n}\n\n}\n\n//半生对象\nobject A{\n\ndef apply()={\n\n}\n\n}\n\n\nval a=A()   //调用的是object.apply\nval a1=new A()\nal()       //调用的是class.apply\n\n\n//类名()    object.apply\n//对象名()  class.apply\n\n\n最佳实践是在object的apply里面 new Class</code></pre>\n<h2 id=\"2-尾递归求和\"><a href=\"#2-尾递归求和\" class=\"headerlink\" title=\"2. 尾递归求和\"></a>2. 尾递归求和</h2><pre><code class=\"scala\">def sum(nums:Int*)={\n    if(nums==0){\n        0\n    }else{\n        nums.head+sum(nums.tail:_*)\n    }\n\n}</code></pre>\n<h2 id=\"3-Range\"><a href=\"#3-Range\" class=\"headerlink\" title=\"3. Range\"></a>3. Range</h2><p>to // 闭区间</p>\n<p>until //左闭右开</p>\n<p>Range //左闭右开</p>\n<pre><code>1 to 4              =&gt; [1,4]  =&gt;  1,2,3,4\n1 until 4      =&gt; [1,4)  =&gt;  1,2,3\nRange(1,4)   =&gt; [1,4)  =&gt;  1,2,3</code></pre>"},{"_content":"# Flink\n\n## Application\n+ 启动：flink run -c mainclasspath jarpath\n+ 取消：flink cancel jobid\n+ 停止：flink stop jobid\n### Job\n## Task\njob中的一个阶段就是一个task，一个task包括链条连接的多个subtask，一个task运行在一个线程里面，task平分slot里面的内存资源共享slot里面的cpu资源\n## SubTask\nflink job中最小执行单元\n## 算子\n\n### Source\n\n使用EventTime，划分滚动窗口，如果使用的是并行的Source，例如KafkaSource，创建Kafka的Topic时有多个分区，每个Source的分区都要满足触发的条件，整个窗口才会被触发\n\n### Transformation\n+ map\t//DataStream - > DataStream\n+\tflatMap\t//DataStream -> DataStream\n+\tfilter\t//DataStream -> DataStream\n+\tkeyBy\t//DataStream -> KeyStream\n### Sink\n\nwriteAsCsv必须是元组才能正常写入\n\n## WaterMark\n决定一个窗口什么时候激活（触发），这时的窗口的最大长度为\n\nmaterMark>=上一个窗口的结束边界就会触发窗口执行\n\nwatermark是flink中窗口延迟触发的机制\n\n在每个算子内部都自己有一个事件时间时钟，事件时间时钟是根据watermark来更新的，。流入算子的数据可能是单分区也可能是多分区的，每个流入算子的分区端都会有一个自己的partition watermark标记，当该分区内进入新的高于之前watermark的watermark数据时，partition watermark标记才会被更新，task内部也维护一个task的watermark数据。如果某个分区的partition watermark < task watermark，那么task watermark会更新为该partition watermark数据，然后把task 把当前更新的task watermark数据发向下游task。\n\n### AssignerWithPeriodicWatermarks\nwindowmax=watermark+windowsize\nwaterMark=数据携带的时间（窗口中最大的时间）-延迟执行的时间\n\n周期性的生成watermark，定期向分区数据流中插入时间水印。默认周期时间为200毫秒，可以使用setAutoWatermakrIntaval（）来设置\nBoundedOutOfOrdernessTimestampExtractor继承自AssignerWithPeriodicWatermarks 属于周期性watermark\n\n>周期性数据水印在特定条件下可能会造成数据错误\n>例如：env.fromCollection(List((1, \"a1\", 158324361000l), (1, \"a2\", 158324369000l), (1, \"a3\", 158324364000l), (1, \"a4\", 158324361000l), (1, \"a5\",158324365000l), (1, \"a6\", 158324362000l), (1, \"a7\",158324367000l))) \n>.assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor[(Int, String, Long)](Time.milliseconds(0)) {\n>override def extractTimestamp(element: (Int, String, Long)): Long = {\n> element._3\n> }\n> })\n> .keyBy(0)\n> .window(TumblingEventTimeWindows.of(Time.seconds(4)))\n> .sum(2)\n> .print()\n> 当使用周期性水印AssignerWithPeriodicWatermarks时就会造成数据的错误计算\n> 是因为周期性水印是定期产生的（默认200毫秒）但是在这个周期里可能会出现有多个数据已经过去，这多个数据用于一个水印从而造成数据计算错误\n\n### AssignerWithPunctuatedWatermarks\n根据事件生成watermark。可以用于根据具体数据来生成watermark，\n## Window\n\n### Keyed Window\n使用keyby后流的窗口\n#### GlobalWindow\n#### CountWindow\n#### TimeWindow\n+ Tumbling\n+ Sliding\n+ Session\n\n### Non-Keyed Windows\n未使用keyby后流的窗口\n#### windowAll\n\n## Window 之后的算子\n### Trigger\nwindow 数据触发器，keyed or non-keyed window 都可以使用\n+ EventTimeTrigger：事件时间触发器\n+ ProcessingTimeTrigger：程序时间触发器\n+ CountTrigger：数量出发器。只发送窗口触发信号\n+ PurgingTrigger：代理模式触发器，发送窗口触发和数据清理信号\n### Evictor\nwindow 数据剔除器，可以在window执行前或者执行后剔除window内的元素\n+ CountEvictor：数量剔除器。在Window中保留指定数量的元素，并从窗口头部开始丢弃其余元素。\n+ DeltaEvictor： 阈值剔除器。计算Window中最后一个元素与其余每个元素之间的增量，丢弃增量大于或等于阈值的元素。\n+ TimeEvictor：时间剔除器。保留Window中最近一段时间内的元素，并丢弃其余元素。\n### AllowedLateness\n\n决定一个窗口什么时候销毁，window 延迟数据是否保留计算，可能会造成窗口的二次触发，会导致结果数据的更新，造成数据不一致。这时窗口的最大长度为windowmax=waterma+windowsize+allowedleteness\n\n## State\n### Managed State\n#### Operator State\noperator state 绑定到每个算子的实例上，各个实例拥有自己的state，一个实例无法获取同并行的其他实例的state数据\n\noperator state ：记录的是每一个分区的偏移量\n\n#### Keyed State\n\nkeyedstate：在一个subtask中可能有多个state，一个组对应一个key的状态\n\n\n\n### Raw State\n## CheckPoint\n全自动程序管理，轻量快捷算子级数据快照\n\n开启flink checkpoint 后设置精准一次消费，kafka的offset会保存在savepoint设置的路径里面，还会降offset保存在kafka 特殊topic里面，如果程序重启时没有指定savepiont保存数据的地址会默认根据kafka 特殊topic保存的偏移量消费数据，可以设置不降offset保存在kafka 特殊topic里面使用，setCommitOffsetOnCheckpoints(false)\n\n开启检查点机制\n\n```\n// start a checkpoint every 1000 ms\nenv.enableCheckpointing(1000);\n\n// advanced options:\n\n// set mode to exactly-once (this is the default)\nenv.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);\n\n// make sure 500 ms of progress happen between checkpoints\nenv.getCheckpointConfig().setMinPauseBetweenCheckpoints(500);\n\n// checkpoints have to complete within one minute, or are discarded\nenv.getCheckpointConfig().setCheckpointTimeout(60000);\n\n// allow only one checkpoint to be in progress at the same time\nenv.getCheckpointConfig().setMaxConcurrentCheckpoints(1);\n\n// enable externalized checkpoints which are retained after job cancellation\nenv.getCheckpointConfig().enableExternalizedCheckpoints(ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);\n\n// allow job recovery fallback to checkpoint when there is a more recent savepoint\nenv.getCheckpointConfig().setPreferCheckpointForRecovery(true);\n```\n### Barrier\n算子checkpoint的依据，是exactly-once 和at-least-once语义的根据\n## SavePoint\n\n人工参与管理的application级别的数据快照\n\n### 手动保存数据快照\n+ flink stop jobid\n  停止job并保存快照，如果在flink-conf.yaml上配置了state.savepoints.dir，停止任务后会自动将快照保存。\n  \n+ flink stop jobid -p dirpath\n  停止job并将快照保存在dirpath\n  \n+ flink savepoint jobid [dirpath] \n  在不结束job的情况下保存快照。如果带有dirpath则会将快照保存在此目录否则会保存在默认配置的保存目录\n### 从数据快照恢复程序\n+ 直接从savepoint目录恢复\n  flink run -s dirpath\n  从dirpath目录恢复程序\n  \n+ 跳过无法恢复的算子恢复\n  flink run -s dirpath -n\n  \n### 手动清除数据快照\n+ flink savepoint -d itemdirpath\n  手动将数据某个具体快照删除（itemdirpath 快照具体根目录）\n  \n  \n  \n## CEP（Complex Event Processing）\n\nNFA（Nondeterministic Finite Automaton）\n\n## 反压\nflink 三层buff缓存（resultsubpartition，nettybuff，netty中通过高水位来控制buff是否还可以接收数据，socketbuff）\n\n1.5 之前是基于tcp 窗口的反压机制，发送端根据接收端返回的ack和windox size 来发送数据，当window size 为0时，发送端则不会再附上数据，而是发送一个zerowindow 的探测性数据来确定是否可以再次发送数据，当接收端继续可以接收数据时，发送端才会继续发送数据\n\n基于tcp窗口的反压机制缺点\n1.单个task造成的反压，会阻断整个TM-TM的socket，连chekcpoint barrier 也无法发送\n2.反压路径较长，导致生效延迟较大\n\n\n1.5 引入credit 机制实现反压，credit 反压机制是类似于tcp 窗口反压实现的另一种反压机制，resultsubpartition在发送数据时会带有resultbuff里面还存有的数据大小 backlog size，inputchanel在接收到时会计算自己当前还能接收到的数据大小，当inputchanel无法再接收数据时会将credit置为0，告诉result不能再接收消息。result每次发送消息时会检测当前自己的credit数据，当credit为0时 则不会再向netty发送数据从而实现反压机制\n\n\n\n## 其他\n\n两个流join 必须有等值字段必须都在同一个窗口里面\n\nduplicate key update  mysql数据库的更新插入 合为一条sql\n\n并行度： **算子级别** > **env级别** > **Client级别** > **系统默认级别**\n\n在所有Task共享资源槽点名字相同，默认情况下 （pipline）\n同一个job的同一个Task中的多个subTask不能在同一个slot槽中\n\n>具有并行度的subtask 不能在一个slot槽中\n对于同一个job，不同Task【阶段】的subTask可以在同一个资源槽中\n\n\n","source":"notes/Flink.md","raw":"# Flink\n\n## Application\n+ 启动：flink run -c mainclasspath jarpath\n+ 取消：flink cancel jobid\n+ 停止：flink stop jobid\n### Job\n## Task\njob中的一个阶段就是一个task，一个task包括链条连接的多个subtask，一个task运行在一个线程里面，task平分slot里面的内存资源共享slot里面的cpu资源\n## SubTask\nflink job中最小执行单元\n## 算子\n\n### Source\n\n使用EventTime，划分滚动窗口，如果使用的是并行的Source，例如KafkaSource，创建Kafka的Topic时有多个分区，每个Source的分区都要满足触发的条件，整个窗口才会被触发\n\n### Transformation\n+ map\t//DataStream - > DataStream\n+\tflatMap\t//DataStream -> DataStream\n+\tfilter\t//DataStream -> DataStream\n+\tkeyBy\t//DataStream -> KeyStream\n### Sink\n\nwriteAsCsv必须是元组才能正常写入\n\n## WaterMark\n决定一个窗口什么时候激活（触发），这时的窗口的最大长度为\n\nmaterMark>=上一个窗口的结束边界就会触发窗口执行\n\nwatermark是flink中窗口延迟触发的机制\n\n在每个算子内部都自己有一个事件时间时钟，事件时间时钟是根据watermark来更新的，。流入算子的数据可能是单分区也可能是多分区的，每个流入算子的分区端都会有一个自己的partition watermark标记，当该分区内进入新的高于之前watermark的watermark数据时，partition watermark标记才会被更新，task内部也维护一个task的watermark数据。如果某个分区的partition watermark < task watermark，那么task watermark会更新为该partition watermark数据，然后把task 把当前更新的task watermark数据发向下游task。\n\n### AssignerWithPeriodicWatermarks\nwindowmax=watermark+windowsize\nwaterMark=数据携带的时间（窗口中最大的时间）-延迟执行的时间\n\n周期性的生成watermark，定期向分区数据流中插入时间水印。默认周期时间为200毫秒，可以使用setAutoWatermakrIntaval（）来设置\nBoundedOutOfOrdernessTimestampExtractor继承自AssignerWithPeriodicWatermarks 属于周期性watermark\n\n>周期性数据水印在特定条件下可能会造成数据错误\n>例如：env.fromCollection(List((1, \"a1\", 158324361000l), (1, \"a2\", 158324369000l), (1, \"a3\", 158324364000l), (1, \"a4\", 158324361000l), (1, \"a5\",158324365000l), (1, \"a6\", 158324362000l), (1, \"a7\",158324367000l))) \n>.assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor[(Int, String, Long)](Time.milliseconds(0)) {\n>override def extractTimestamp(element: (Int, String, Long)): Long = {\n> element._3\n> }\n> })\n> .keyBy(0)\n> .window(TumblingEventTimeWindows.of(Time.seconds(4)))\n> .sum(2)\n> .print()\n> 当使用周期性水印AssignerWithPeriodicWatermarks时就会造成数据的错误计算\n> 是因为周期性水印是定期产生的（默认200毫秒）但是在这个周期里可能会出现有多个数据已经过去，这多个数据用于一个水印从而造成数据计算错误\n\n### AssignerWithPunctuatedWatermarks\n根据事件生成watermark。可以用于根据具体数据来生成watermark，\n## Window\n\n### Keyed Window\n使用keyby后流的窗口\n#### GlobalWindow\n#### CountWindow\n#### TimeWindow\n+ Tumbling\n+ Sliding\n+ Session\n\n### Non-Keyed Windows\n未使用keyby后流的窗口\n#### windowAll\n\n## Window 之后的算子\n### Trigger\nwindow 数据触发器，keyed or non-keyed window 都可以使用\n+ EventTimeTrigger：事件时间触发器\n+ ProcessingTimeTrigger：程序时间触发器\n+ CountTrigger：数量出发器。只发送窗口触发信号\n+ PurgingTrigger：代理模式触发器，发送窗口触发和数据清理信号\n### Evictor\nwindow 数据剔除器，可以在window执行前或者执行后剔除window内的元素\n+ CountEvictor：数量剔除器。在Window中保留指定数量的元素，并从窗口头部开始丢弃其余元素。\n+ DeltaEvictor： 阈值剔除器。计算Window中最后一个元素与其余每个元素之间的增量，丢弃增量大于或等于阈值的元素。\n+ TimeEvictor：时间剔除器。保留Window中最近一段时间内的元素，并丢弃其余元素。\n### AllowedLateness\n\n决定一个窗口什么时候销毁，window 延迟数据是否保留计算，可能会造成窗口的二次触发，会导致结果数据的更新，造成数据不一致。这时窗口的最大长度为windowmax=waterma+windowsize+allowedleteness\n\n## State\n### Managed State\n#### Operator State\noperator state 绑定到每个算子的实例上，各个实例拥有自己的state，一个实例无法获取同并行的其他实例的state数据\n\noperator state ：记录的是每一个分区的偏移量\n\n#### Keyed State\n\nkeyedstate：在一个subtask中可能有多个state，一个组对应一个key的状态\n\n\n\n### Raw State\n## CheckPoint\n全自动程序管理，轻量快捷算子级数据快照\n\n开启flink checkpoint 后设置精准一次消费，kafka的offset会保存在savepoint设置的路径里面，还会降offset保存在kafka 特殊topic里面，如果程序重启时没有指定savepiont保存数据的地址会默认根据kafka 特殊topic保存的偏移量消费数据，可以设置不降offset保存在kafka 特殊topic里面使用，setCommitOffsetOnCheckpoints(false)\n\n开启检查点机制\n\n```\n// start a checkpoint every 1000 ms\nenv.enableCheckpointing(1000);\n\n// advanced options:\n\n// set mode to exactly-once (this is the default)\nenv.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);\n\n// make sure 500 ms of progress happen between checkpoints\nenv.getCheckpointConfig().setMinPauseBetweenCheckpoints(500);\n\n// checkpoints have to complete within one minute, or are discarded\nenv.getCheckpointConfig().setCheckpointTimeout(60000);\n\n// allow only one checkpoint to be in progress at the same time\nenv.getCheckpointConfig().setMaxConcurrentCheckpoints(1);\n\n// enable externalized checkpoints which are retained after job cancellation\nenv.getCheckpointConfig().enableExternalizedCheckpoints(ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);\n\n// allow job recovery fallback to checkpoint when there is a more recent savepoint\nenv.getCheckpointConfig().setPreferCheckpointForRecovery(true);\n```\n### Barrier\n算子checkpoint的依据，是exactly-once 和at-least-once语义的根据\n## SavePoint\n\n人工参与管理的application级别的数据快照\n\n### 手动保存数据快照\n+ flink stop jobid\n  停止job并保存快照，如果在flink-conf.yaml上配置了state.savepoints.dir，停止任务后会自动将快照保存。\n  \n+ flink stop jobid -p dirpath\n  停止job并将快照保存在dirpath\n  \n+ flink savepoint jobid [dirpath] \n  在不结束job的情况下保存快照。如果带有dirpath则会将快照保存在此目录否则会保存在默认配置的保存目录\n### 从数据快照恢复程序\n+ 直接从savepoint目录恢复\n  flink run -s dirpath\n  从dirpath目录恢复程序\n  \n+ 跳过无法恢复的算子恢复\n  flink run -s dirpath -n\n  \n### 手动清除数据快照\n+ flink savepoint -d itemdirpath\n  手动将数据某个具体快照删除（itemdirpath 快照具体根目录）\n  \n  \n  \n## CEP（Complex Event Processing）\n\nNFA（Nondeterministic Finite Automaton）\n\n## 反压\nflink 三层buff缓存（resultsubpartition，nettybuff，netty中通过高水位来控制buff是否还可以接收数据，socketbuff）\n\n1.5 之前是基于tcp 窗口的反压机制，发送端根据接收端返回的ack和windox size 来发送数据，当window size 为0时，发送端则不会再附上数据，而是发送一个zerowindow 的探测性数据来确定是否可以再次发送数据，当接收端继续可以接收数据时，发送端才会继续发送数据\n\n基于tcp窗口的反压机制缺点\n1.单个task造成的反压，会阻断整个TM-TM的socket，连chekcpoint barrier 也无法发送\n2.反压路径较长，导致生效延迟较大\n\n\n1.5 引入credit 机制实现反压，credit 反压机制是类似于tcp 窗口反压实现的另一种反压机制，resultsubpartition在发送数据时会带有resultbuff里面还存有的数据大小 backlog size，inputchanel在接收到时会计算自己当前还能接收到的数据大小，当inputchanel无法再接收数据时会将credit置为0，告诉result不能再接收消息。result每次发送消息时会检测当前自己的credit数据，当credit为0时 则不会再向netty发送数据从而实现反压机制\n\n\n\n## 其他\n\n两个流join 必须有等值字段必须都在同一个窗口里面\n\nduplicate key update  mysql数据库的更新插入 合为一条sql\n\n并行度： **算子级别** > **env级别** > **Client级别** > **系统默认级别**\n\n在所有Task共享资源槽点名字相同，默认情况下 （pipline）\n同一个job的同一个Task中的多个subTask不能在同一个slot槽中\n\n>具有并行度的subtask 不能在一个slot槽中\n对于同一个job，不同Task【阶段】的subTask可以在同一个资源槽中\n\n\n","date":"2020-03-19T05:09:33.000Z","updated":"2020-03-18T11:52:16.000Z","path":"notes/Flink.html","title":"","comments":1,"layout":"page","_id":"ck8hf2uvy000kzhs6biamqaod","content":"<h1 id=\"Flink\"><a href=\"#Flink\" class=\"headerlink\" title=\"Flink\"></a>Flink</h1><h2 id=\"Application\"><a href=\"#Application\" class=\"headerlink\" title=\"Application\"></a>Application</h2><ul>\n<li>启动：flink run -c mainclasspath jarpath</li>\n<li>取消：flink cancel jobid</li>\n<li>停止：flink stop jobid<h3 id=\"Job\"><a href=\"#Job\" class=\"headerlink\" title=\"Job\"></a>Job</h3><h2 id=\"Task\"><a href=\"#Task\" class=\"headerlink\" title=\"Task\"></a>Task</h2>job中的一个阶段就是一个task，一个task包括链条连接的多个subtask，一个task运行在一个线程里面，task平分slot里面的内存资源共享slot里面的cpu资源<h2 id=\"SubTask\"><a href=\"#SubTask\" class=\"headerlink\" title=\"SubTask\"></a>SubTask</h2>flink job中最小执行单元<h2 id=\"算子\"><a href=\"#算子\" class=\"headerlink\" title=\"算子\"></a>算子</h2></li>\n</ul>\n<h3 id=\"Source\"><a href=\"#Source\" class=\"headerlink\" title=\"Source\"></a>Source</h3><p>使用EventTime，划分滚动窗口，如果使用的是并行的Source，例如KafkaSource，创建Kafka的Topic时有多个分区，每个Source的分区都要满足触发的条件，整个窗口才会被触发</p>\n<h3 id=\"Transformation\"><a href=\"#Transformation\" class=\"headerlink\" title=\"Transformation\"></a>Transformation</h3><ul>\n<li>map    //DataStream - &gt; DataStream</li>\n<li>flatMap    //DataStream -&gt; DataStream</li>\n<li>filter    //DataStream -&gt; DataStream</li>\n<li>keyBy    //DataStream -&gt; KeyStream<h3 id=\"Sink\"><a href=\"#Sink\" class=\"headerlink\" title=\"Sink\"></a>Sink</h3></li>\n</ul>\n<p>writeAsCsv必须是元组才能正常写入</p>\n<h2 id=\"WaterMark\"><a href=\"#WaterMark\" class=\"headerlink\" title=\"WaterMark\"></a>WaterMark</h2><p>决定一个窗口什么时候激活（触发），这时的窗口的最大长度为</p>\n<p>materMark&gt;=上一个窗口的结束边界就会触发窗口执行</p>\n<p>watermark是flink中窗口延迟触发的机制</p>\n<p>在每个算子内部都自己有一个事件时间时钟，事件时间时钟是根据watermark来更新的，。流入算子的数据可能是单分区也可能是多分区的，每个流入算子的分区端都会有一个自己的partition watermark标记，当该分区内进入新的高于之前watermark的watermark数据时，partition watermark标记才会被更新，task内部也维护一个task的watermark数据。如果某个分区的partition watermark &lt; task watermark，那么task watermark会更新为该partition watermark数据，然后把task 把当前更新的task watermark数据发向下游task。</p>\n<h3 id=\"AssignerWithPeriodicWatermarks\"><a href=\"#AssignerWithPeriodicWatermarks\" class=\"headerlink\" title=\"AssignerWithPeriodicWatermarks\"></a>AssignerWithPeriodicWatermarks</h3><p>windowmax=watermark+windowsize<br>waterMark=数据携带的时间（窗口中最大的时间）-延迟执行的时间</p>\n<p>周期性的生成watermark，定期向分区数据流中插入时间水印。默认周期时间为200毫秒，可以使用setAutoWatermakrIntaval（）来设置<br>BoundedOutOfOrdernessTimestampExtractor继承自AssignerWithPeriodicWatermarks 属于周期性watermark</p>\n<blockquote>\n<p>周期性数据水印在特定条件下可能会造成数据错误<br>例如：env.fromCollection(List((1, “a1”, 158324361000l), (1, “a2”, 158324369000l), (1, “a3”, 158324364000l), (1, “a4”, 158324361000l), (1, “a5”,158324365000l), (1, “a6”, 158324362000l), (1, “a7”,158324367000l)))<br>.assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor<a href=\"Time.milliseconds(0)\">(Int, String, Long)</a> {<br>override def extractTimestamp(element: (Int, String, Long)): Long = {<br>element._3<br>}<br>})<br>.keyBy(0)<br>.window(TumblingEventTimeWindows.of(Time.seconds(4)))<br>.sum(2)<br>.print()<br>当使用周期性水印AssignerWithPeriodicWatermarks时就会造成数据的错误计算<br>是因为周期性水印是定期产生的（默认200毫秒）但是在这个周期里可能会出现有多个数据已经过去，这多个数据用于一个水印从而造成数据计算错误</p>\n</blockquote>\n<h3 id=\"AssignerWithPunctuatedWatermarks\"><a href=\"#AssignerWithPunctuatedWatermarks\" class=\"headerlink\" title=\"AssignerWithPunctuatedWatermarks\"></a>AssignerWithPunctuatedWatermarks</h3><p>根据事件生成watermark。可以用于根据具体数据来生成watermark，</p>\n<h2 id=\"Window\"><a href=\"#Window\" class=\"headerlink\" title=\"Window\"></a>Window</h2><h3 id=\"Keyed-Window\"><a href=\"#Keyed-Window\" class=\"headerlink\" title=\"Keyed Window\"></a>Keyed Window</h3><p>使用keyby后流的窗口</p>\n<h4 id=\"GlobalWindow\"><a href=\"#GlobalWindow\" class=\"headerlink\" title=\"GlobalWindow\"></a>GlobalWindow</h4><h4 id=\"CountWindow\"><a href=\"#CountWindow\" class=\"headerlink\" title=\"CountWindow\"></a>CountWindow</h4><h4 id=\"TimeWindow\"><a href=\"#TimeWindow\" class=\"headerlink\" title=\"TimeWindow\"></a>TimeWindow</h4><ul>\n<li>Tumbling</li>\n<li>Sliding</li>\n<li>Session</li>\n</ul>\n<h3 id=\"Non-Keyed-Windows\"><a href=\"#Non-Keyed-Windows\" class=\"headerlink\" title=\"Non-Keyed Windows\"></a>Non-Keyed Windows</h3><p>未使用keyby后流的窗口</p>\n<h4 id=\"windowAll\"><a href=\"#windowAll\" class=\"headerlink\" title=\"windowAll\"></a>windowAll</h4><h2 id=\"Window-之后的算子\"><a href=\"#Window-之后的算子\" class=\"headerlink\" title=\"Window 之后的算子\"></a>Window 之后的算子</h2><h3 id=\"Trigger\"><a href=\"#Trigger\" class=\"headerlink\" title=\"Trigger\"></a>Trigger</h3><p>window 数据触发器，keyed or non-keyed window 都可以使用</p>\n<ul>\n<li>EventTimeTrigger：事件时间触发器</li>\n<li>ProcessingTimeTrigger：程序时间触发器</li>\n<li>CountTrigger：数量出发器。只发送窗口触发信号</li>\n<li>PurgingTrigger：代理模式触发器，发送窗口触发和数据清理信号<h3 id=\"Evictor\"><a href=\"#Evictor\" class=\"headerlink\" title=\"Evictor\"></a>Evictor</h3>window 数据剔除器，可以在window执行前或者执行后剔除window内的元素</li>\n<li>CountEvictor：数量剔除器。在Window中保留指定数量的元素，并从窗口头部开始丢弃其余元素。</li>\n<li>DeltaEvictor： 阈值剔除器。计算Window中最后一个元素与其余每个元素之间的增量，丢弃增量大于或等于阈值的元素。</li>\n<li>TimeEvictor：时间剔除器。保留Window中最近一段时间内的元素，并丢弃其余元素。<h3 id=\"AllowedLateness\"><a href=\"#AllowedLateness\" class=\"headerlink\" title=\"AllowedLateness\"></a>AllowedLateness</h3></li>\n</ul>\n<p>决定一个窗口什么时候销毁，window 延迟数据是否保留计算，可能会造成窗口的二次触发，会导致结果数据的更新，造成数据不一致。这时窗口的最大长度为windowmax=waterma+windowsize+allowedleteness</p>\n<h2 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h2><h3 id=\"Managed-State\"><a href=\"#Managed-State\" class=\"headerlink\" title=\"Managed State\"></a>Managed State</h3><h4 id=\"Operator-State\"><a href=\"#Operator-State\" class=\"headerlink\" title=\"Operator State\"></a>Operator State</h4><p>operator state 绑定到每个算子的实例上，各个实例拥有自己的state，一个实例无法获取同并行的其他实例的state数据</p>\n<p>operator state ：记录的是每一个分区的偏移量</p>\n<h4 id=\"Keyed-State\"><a href=\"#Keyed-State\" class=\"headerlink\" title=\"Keyed State\"></a>Keyed State</h4><p>keyedstate：在一个subtask中可能有多个state，一个组对应一个key的状态</p>\n<h3 id=\"Raw-State\"><a href=\"#Raw-State\" class=\"headerlink\" title=\"Raw State\"></a>Raw State</h3><h2 id=\"CheckPoint\"><a href=\"#CheckPoint\" class=\"headerlink\" title=\"CheckPoint\"></a>CheckPoint</h2><p>全自动程序管理，轻量快捷算子级数据快照</p>\n<p>开启flink checkpoint 后设置精准一次消费，kafka的offset会保存在savepoint设置的路径里面，还会降offset保存在kafka 特殊topic里面，如果程序重启时没有指定savepiont保存数据的地址会默认根据kafka 特殊topic保存的偏移量消费数据，可以设置不降offset保存在kafka 特殊topic里面使用，setCommitOffsetOnCheckpoints(false)</p>\n<p>开启检查点机制</p>\n<pre><code>// start a checkpoint every 1000 ms\nenv.enableCheckpointing(1000);\n\n// advanced options:\n\n// set mode to exactly-once (this is the default)\nenv.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);\n\n// make sure 500 ms of progress happen between checkpoints\nenv.getCheckpointConfig().setMinPauseBetweenCheckpoints(500);\n\n// checkpoints have to complete within one minute, or are discarded\nenv.getCheckpointConfig().setCheckpointTimeout(60000);\n\n// allow only one checkpoint to be in progress at the same time\nenv.getCheckpointConfig().setMaxConcurrentCheckpoints(1);\n\n// enable externalized checkpoints which are retained after job cancellation\nenv.getCheckpointConfig().enableExternalizedCheckpoints(ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);\n\n// allow job recovery fallback to checkpoint when there is a more recent savepoint\nenv.getCheckpointConfig().setPreferCheckpointForRecovery(true);</code></pre><h3 id=\"Barrier\"><a href=\"#Barrier\" class=\"headerlink\" title=\"Barrier\"></a>Barrier</h3><p>算子checkpoint的依据，是exactly-once 和at-least-once语义的根据</p>\n<h2 id=\"SavePoint\"><a href=\"#SavePoint\" class=\"headerlink\" title=\"SavePoint\"></a>SavePoint</h2><p>人工参与管理的application级别的数据快照</p>\n<h3 id=\"手动保存数据快照\"><a href=\"#手动保存数据快照\" class=\"headerlink\" title=\"手动保存数据快照\"></a>手动保存数据快照</h3><ul>\n<li><p>flink stop jobid<br>停止job并保存快照，如果在flink-conf.yaml上配置了state.savepoints.dir，停止任务后会自动将快照保存。</p>\n</li>\n<li><p>flink stop jobid -p dirpath<br>停止job并将快照保存在dirpath</p>\n</li>\n<li><p>flink savepoint jobid [dirpath]<br>在不结束job的情况下保存快照。如果带有dirpath则会将快照保存在此目录否则会保存在默认配置的保存目录</p>\n<h3 id=\"从数据快照恢复程序\"><a href=\"#从数据快照恢复程序\" class=\"headerlink\" title=\"从数据快照恢复程序\"></a>从数据快照恢复程序</h3></li>\n<li><p>直接从savepoint目录恢复<br>flink run -s dirpath<br>从dirpath目录恢复程序</p>\n</li>\n<li><p>跳过无法恢复的算子恢复<br>flink run -s dirpath -n</p>\n</li>\n</ul>\n<h3 id=\"手动清除数据快照\"><a href=\"#手动清除数据快照\" class=\"headerlink\" title=\"手动清除数据快照\"></a>手动清除数据快照</h3><ul>\n<li>flink savepoint -d itemdirpath<br>手动将数据某个具体快照删除（itemdirpath 快照具体根目录）</li>\n</ul>\n<h2 id=\"CEP（Complex-Event-Processing）\"><a href=\"#CEP（Complex-Event-Processing）\" class=\"headerlink\" title=\"CEP（Complex Event Processing）\"></a>CEP（Complex Event Processing）</h2><p>NFA（Nondeterministic Finite Automaton）</p>\n<h2 id=\"反压\"><a href=\"#反压\" class=\"headerlink\" title=\"反压\"></a>反压</h2><p>flink 三层buff缓存（resultsubpartition，nettybuff，netty中通过高水位来控制buff是否还可以接收数据，socketbuff）</p>\n<p>1.5 之前是基于tcp 窗口的反压机制，发送端根据接收端返回的ack和windox size 来发送数据，当window size 为0时，发送端则不会再附上数据，而是发送一个zerowindow 的探测性数据来确定是否可以再次发送数据，当接收端继续可以接收数据时，发送端才会继续发送数据</p>\n<p>基于tcp窗口的反压机制缺点<br>1.单个task造成的反压，会阻断整个TM-TM的socket，连chekcpoint barrier 也无法发送<br>2.反压路径较长，导致生效延迟较大</p>\n<p>1.5 引入credit 机制实现反压，credit 反压机制是类似于tcp 窗口反压实现的另一种反压机制，resultsubpartition在发送数据时会带有resultbuff里面还存有的数据大小 backlog size，inputchanel在接收到时会计算自己当前还能接收到的数据大小，当inputchanel无法再接收数据时会将credit置为0，告诉result不能再接收消息。result每次发送消息时会检测当前自己的credit数据，当credit为0时 则不会再向netty发送数据从而实现反压机制</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>两个流join 必须有等值字段必须都在同一个窗口里面</p>\n<p>duplicate key update  mysql数据库的更新插入 合为一条sql</p>\n<p>并行度： <strong>算子级别</strong> &gt; <strong>env级别</strong> &gt; <strong>Client级别</strong> &gt; <strong>系统默认级别</strong></p>\n<p>在所有Task共享资源槽点名字相同，默认情况下 （pipline）<br>同一个job的同一个Task中的多个subTask不能在同一个slot槽中</p>\n<blockquote>\n<p>具有并行度的subtask 不能在一个slot槽中<br>对于同一个job，不同Task【阶段】的subTask可以在同一个资源槽中</p>\n</blockquote>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":"<h1 id=\"Flink\"><a href=\"#Flink\" class=\"headerlink\" title=\"Flink\"></a>Flink</h1><h2 id=\"Application\"><a href=\"#Application\" class=\"headerlink\" title=\"Application\"></a>Application</h2><ul>\n<li>启动：flink run -c mainclasspath jarpath</li>\n<li>取消：flink cancel jobid</li>\n<li>停止：flink stop jobid<h3 id=\"Job\"><a href=\"#Job\" class=\"headerlink\" title=\"Job\"></a>Job</h3><h2 id=\"Task\"><a href=\"#Task\" class=\"headerlink\" title=\"Task\"></a>Task</h2>job中的一个阶段就是一个task，一个task包括链条连接的多个subtask，一个task运行在一个线程里面，task平分slot里面的内存资源共享slot里面的cpu资源<h2 id=\"SubTask\"><a href=\"#SubTask\" class=\"headerlink\" title=\"SubTask\"></a>SubTask</h2>flink job中最小执行单元<h2 id=\"算子\"><a href=\"#算子\" class=\"headerlink\" title=\"算子\"></a>算子</h2></li>\n</ul>\n<h3 id=\"Source\"><a href=\"#Source\" class=\"headerlink\" title=\"Source\"></a>Source</h3><p>使用EventTime，划分滚动窗口，如果使用的是并行的Source，例如KafkaSource，创建Kafka的Topic时有多个分区，每个Source的分区都要满足触发的条件，整个窗口才会被触发</p>\n<h3 id=\"Transformation\"><a href=\"#Transformation\" class=\"headerlink\" title=\"Transformation\"></a>Transformation</h3><ul>\n<li>map    //DataStream - &gt; DataStream</li>\n<li>flatMap    //DataStream -&gt; DataStream</li>\n<li>filter    //DataStream -&gt; DataStream</li>\n<li>keyBy    //DataStream -&gt; KeyStream<h3 id=\"Sink\"><a href=\"#Sink\" class=\"headerlink\" title=\"Sink\"></a>Sink</h3></li>\n</ul>\n<p>writeAsCsv必须是元组才能正常写入</p>\n<h2 id=\"WaterMark\"><a href=\"#WaterMark\" class=\"headerlink\" title=\"WaterMark\"></a>WaterMark</h2><p>决定一个窗口什么时候激活（触发），这时的窗口的最大长度为</p>\n<p>materMark&gt;=上一个窗口的结束边界就会触发窗口执行</p>\n<p>watermark是flink中窗口延迟触发的机制</p>\n<p>在每个算子内部都自己有一个事件时间时钟，事件时间时钟是根据watermark来更新的，。流入算子的数据可能是单分区也可能是多分区的，每个流入算子的分区端都会有一个自己的partition watermark标记，当该分区内进入新的高于之前watermark的watermark数据时，partition watermark标记才会被更新，task内部也维护一个task的watermark数据。如果某个分区的partition watermark &lt; task watermark，那么task watermark会更新为该partition watermark数据，然后把task 把当前更新的task watermark数据发向下游task。</p>\n<h3 id=\"AssignerWithPeriodicWatermarks\"><a href=\"#AssignerWithPeriodicWatermarks\" class=\"headerlink\" title=\"AssignerWithPeriodicWatermarks\"></a>AssignerWithPeriodicWatermarks</h3><p>windowmax=watermark+windowsize<br>waterMark=数据携带的时间（窗口中最大的时间）-延迟执行的时间</p>\n<p>周期性的生成watermark，定期向分区数据流中插入时间水印。默认周期时间为200毫秒，可以使用setAutoWatermakrIntaval（）来设置<br>BoundedOutOfOrdernessTimestampExtractor继承自AssignerWithPeriodicWatermarks 属于周期性watermark</p>\n<blockquote>\n<p>周期性数据水印在特定条件下可能会造成数据错误<br>例如：env.fromCollection(List((1, “a1”, 158324361000l), (1, “a2”, 158324369000l), (1, “a3”, 158324364000l), (1, “a4”, 158324361000l), (1, “a5”,158324365000l), (1, “a6”, 158324362000l), (1, “a7”,158324367000l)))<br>.assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor<a href=\"Time.milliseconds(0)\">(Int, String, Long)</a> {<br>override def extractTimestamp(element: (Int, String, Long)): Long = {<br>element._3<br>}<br>})<br>.keyBy(0)<br>.window(TumblingEventTimeWindows.of(Time.seconds(4)))<br>.sum(2)<br>.print()<br>当使用周期性水印AssignerWithPeriodicWatermarks时就会造成数据的错误计算<br>是因为周期性水印是定期产生的（默认200毫秒）但是在这个周期里可能会出现有多个数据已经过去，这多个数据用于一个水印从而造成数据计算错误</p>\n</blockquote>\n<h3 id=\"AssignerWithPunctuatedWatermarks\"><a href=\"#AssignerWithPunctuatedWatermarks\" class=\"headerlink\" title=\"AssignerWithPunctuatedWatermarks\"></a>AssignerWithPunctuatedWatermarks</h3><p>根据事件生成watermark。可以用于根据具体数据来生成watermark，</p>\n<h2 id=\"Window\"><a href=\"#Window\" class=\"headerlink\" title=\"Window\"></a>Window</h2><h3 id=\"Keyed-Window\"><a href=\"#Keyed-Window\" class=\"headerlink\" title=\"Keyed Window\"></a>Keyed Window</h3><p>使用keyby后流的窗口</p>\n<h4 id=\"GlobalWindow\"><a href=\"#GlobalWindow\" class=\"headerlink\" title=\"GlobalWindow\"></a>GlobalWindow</h4><h4 id=\"CountWindow\"><a href=\"#CountWindow\" class=\"headerlink\" title=\"CountWindow\"></a>CountWindow</h4><h4 id=\"TimeWindow\"><a href=\"#TimeWindow\" class=\"headerlink\" title=\"TimeWindow\"></a>TimeWindow</h4><ul>\n<li>Tumbling</li>\n<li>Sliding</li>\n<li>Session</li>\n</ul>\n<h3 id=\"Non-Keyed-Windows\"><a href=\"#Non-Keyed-Windows\" class=\"headerlink\" title=\"Non-Keyed Windows\"></a>Non-Keyed Windows</h3><p>未使用keyby后流的窗口</p>\n<h4 id=\"windowAll\"><a href=\"#windowAll\" class=\"headerlink\" title=\"windowAll\"></a>windowAll</h4><h2 id=\"Window-之后的算子\"><a href=\"#Window-之后的算子\" class=\"headerlink\" title=\"Window 之后的算子\"></a>Window 之后的算子</h2><h3 id=\"Trigger\"><a href=\"#Trigger\" class=\"headerlink\" title=\"Trigger\"></a>Trigger</h3><p>window 数据触发器，keyed or non-keyed window 都可以使用</p>\n<ul>\n<li>EventTimeTrigger：事件时间触发器</li>\n<li>ProcessingTimeTrigger：程序时间触发器</li>\n<li>CountTrigger：数量出发器。只发送窗口触发信号</li>\n<li>PurgingTrigger：代理模式触发器，发送窗口触发和数据清理信号<h3 id=\"Evictor\"><a href=\"#Evictor\" class=\"headerlink\" title=\"Evictor\"></a>Evictor</h3>window 数据剔除器，可以在window执行前或者执行后剔除window内的元素</li>\n<li>CountEvictor：数量剔除器。在Window中保留指定数量的元素，并从窗口头部开始丢弃其余元素。</li>\n<li>DeltaEvictor： 阈值剔除器。计算Window中最后一个元素与其余每个元素之间的增量，丢弃增量大于或等于阈值的元素。</li>\n<li>TimeEvictor：时间剔除器。保留Window中最近一段时间内的元素，并丢弃其余元素。<h3 id=\"AllowedLateness\"><a href=\"#AllowedLateness\" class=\"headerlink\" title=\"AllowedLateness\"></a>AllowedLateness</h3></li>\n</ul>\n<p>决定一个窗口什么时候销毁，window 延迟数据是否保留计算，可能会造成窗口的二次触发，会导致结果数据的更新，造成数据不一致。这时窗口的最大长度为windowmax=waterma+windowsize+allowedleteness</p>\n<h2 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h2><h3 id=\"Managed-State\"><a href=\"#Managed-State\" class=\"headerlink\" title=\"Managed State\"></a>Managed State</h3><h4 id=\"Operator-State\"><a href=\"#Operator-State\" class=\"headerlink\" title=\"Operator State\"></a>Operator State</h4><p>operator state 绑定到每个算子的实例上，各个实例拥有自己的state，一个实例无法获取同并行的其他实例的state数据</p>\n<p>operator state ：记录的是每一个分区的偏移量</p>\n<h4 id=\"Keyed-State\"><a href=\"#Keyed-State\" class=\"headerlink\" title=\"Keyed State\"></a>Keyed State</h4><p>keyedstate：在一个subtask中可能有多个state，一个组对应一个key的状态</p>\n<h3 id=\"Raw-State\"><a href=\"#Raw-State\" class=\"headerlink\" title=\"Raw State\"></a>Raw State</h3><h2 id=\"CheckPoint\"><a href=\"#CheckPoint\" class=\"headerlink\" title=\"CheckPoint\"></a>CheckPoint</h2><p>全自动程序管理，轻量快捷算子级数据快照</p>\n<p>开启flink checkpoint 后设置精准一次消费，kafka的offset会保存在savepoint设置的路径里面，还会降offset保存在kafka 特殊topic里面，如果程序重启时没有指定savepiont保存数据的地址会默认根据kafka 特殊topic保存的偏移量消费数据，可以设置不降offset保存在kafka 特殊topic里面使用，setCommitOffsetOnCheckpoints(false)</p>\n<p>开启检查点机制</p>\n<pre><code>// start a checkpoint every 1000 ms\nenv.enableCheckpointing(1000);\n\n// advanced options:\n\n// set mode to exactly-once (this is the default)\nenv.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);\n\n// make sure 500 ms of progress happen between checkpoints\nenv.getCheckpointConfig().setMinPauseBetweenCheckpoints(500);\n\n// checkpoints have to complete within one minute, or are discarded\nenv.getCheckpointConfig().setCheckpointTimeout(60000);\n\n// allow only one checkpoint to be in progress at the same time\nenv.getCheckpointConfig().setMaxConcurrentCheckpoints(1);\n\n// enable externalized checkpoints which are retained after job cancellation\nenv.getCheckpointConfig().enableExternalizedCheckpoints(ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);\n\n// allow job recovery fallback to checkpoint when there is a more recent savepoint\nenv.getCheckpointConfig().setPreferCheckpointForRecovery(true);</code></pre><h3 id=\"Barrier\"><a href=\"#Barrier\" class=\"headerlink\" title=\"Barrier\"></a>Barrier</h3><p>算子checkpoint的依据，是exactly-once 和at-least-once语义的根据</p>\n<h2 id=\"SavePoint\"><a href=\"#SavePoint\" class=\"headerlink\" title=\"SavePoint\"></a>SavePoint</h2><p>人工参与管理的application级别的数据快照</p>\n<h3 id=\"手动保存数据快照\"><a href=\"#手动保存数据快照\" class=\"headerlink\" title=\"手动保存数据快照\"></a>手动保存数据快照</h3><ul>\n<li><p>flink stop jobid<br>停止job并保存快照，如果在flink-conf.yaml上配置了state.savepoints.dir，停止任务后会自动将快照保存。</p>\n</li>\n<li><p>flink stop jobid -p dirpath<br>停止job并将快照保存在dirpath</p>\n</li>\n<li><p>flink savepoint jobid [dirpath]<br>在不结束job的情况下保存快照。如果带有dirpath则会将快照保存在此目录否则会保存在默认配置的保存目录</p>\n<h3 id=\"从数据快照恢复程序\"><a href=\"#从数据快照恢复程序\" class=\"headerlink\" title=\"从数据快照恢复程序\"></a>从数据快照恢复程序</h3></li>\n<li><p>直接从savepoint目录恢复<br>flink run -s dirpath<br>从dirpath目录恢复程序</p>\n</li>\n<li><p>跳过无法恢复的算子恢复<br>flink run -s dirpath -n</p>\n</li>\n</ul>\n<h3 id=\"手动清除数据快照\"><a href=\"#手动清除数据快照\" class=\"headerlink\" title=\"手动清除数据快照\"></a>手动清除数据快照</h3><ul>\n<li>flink savepoint -d itemdirpath<br>手动将数据某个具体快照删除（itemdirpath 快照具体根目录）</li>\n</ul>\n<h2 id=\"CEP（Complex-Event-Processing）\"><a href=\"#CEP（Complex-Event-Processing）\" class=\"headerlink\" title=\"CEP（Complex Event Processing）\"></a>CEP（Complex Event Processing）</h2><p>NFA（Nondeterministic Finite Automaton）</p>\n<h2 id=\"反压\"><a href=\"#反压\" class=\"headerlink\" title=\"反压\"></a>反压</h2><p>flink 三层buff缓存（resultsubpartition，nettybuff，netty中通过高水位来控制buff是否还可以接收数据，socketbuff）</p>\n<p>1.5 之前是基于tcp 窗口的反压机制，发送端根据接收端返回的ack和windox size 来发送数据，当window size 为0时，发送端则不会再附上数据，而是发送一个zerowindow 的探测性数据来确定是否可以再次发送数据，当接收端继续可以接收数据时，发送端才会继续发送数据</p>\n<p>基于tcp窗口的反压机制缺点<br>1.单个task造成的反压，会阻断整个TM-TM的socket，连chekcpoint barrier 也无法发送<br>2.反压路径较长，导致生效延迟较大</p>\n<p>1.5 引入credit 机制实现反压，credit 反压机制是类似于tcp 窗口反压实现的另一种反压机制，resultsubpartition在发送数据时会带有resultbuff里面还存有的数据大小 backlog size，inputchanel在接收到时会计算自己当前还能接收到的数据大小，当inputchanel无法再接收数据时会将credit置为0，告诉result不能再接收消息。result每次发送消息时会检测当前自己的credit数据，当credit为0时 则不会再向netty发送数据从而实现反压机制</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>两个流join 必须有等值字段必须都在同一个窗口里面</p>\n<p>duplicate key update  mysql数据库的更新插入 合为一条sql</p>\n<p>并行度： <strong>算子级别</strong> &gt; <strong>env级别</strong> &gt; <strong>Client级别</strong> &gt; <strong>系统默认级别</strong></p>\n<p>在所有Task共享资源槽点名字相同，默认情况下 （pipline）<br>同一个job的同一个Task中的多个subTask不能在同一个slot槽中</p>\n<blockquote>\n<p>具有并行度的subtask 不能在一个slot槽中<br>对于同一个job，不同Task【阶段】的subTask可以在同一个资源槽中</p>\n</blockquote>\n"},{"_content":"# Golang\n\n## 数据类型\n\n### 数值类型\n\n#### bool\n\n#### byte\nbyte = uint8\n\n#### int\n有符号类型：int8，int16，int32，int64\n无符号类型：uint8，uint16，uint32，uint64\nrune = int32\n\n#### float\nfloat16，float32\n\n#### string\n\n#### 数组\n\n### 引用类型\n\n#### slice\n\n#### map\n\n\n\n## 变量\ngo语言的变量声明了就必须使用，不用就别声明，否则编译不通过\n\n### 函数变量声明\n\n#### 单一变量声明\n关键字\t变量名称\t变量类型\n~~~go\nvar a\tint\t\n~~~\n声明的同时可以赋值变量，同时赋值可以省略变量类型\n~~~go\nvar a\t= 0\t\n~~~\n#### 多变量同时声明1\n关键字\t变量名称，变量名称\t变量类型\n多变量同时声明时，必须为多个类型一样的变量\n~~~go\nvar a,b,c int\n~~~\n声明的同时可以赋值变量，同时赋值时可以省略变量类型\n~~~go\nvar a,b,c = 0,0,0\n~~~\n#### 多变量同时声明2\n关键字\t（\n变量名称\t变量类型\t\n变量名称\t变量类型\n）\n带有括号的多变量赋值时，变量类型可以不同\n~~~go\nvar (\n  a int\n  b string\n)\n~~~\n其中并且可以进行赋值操作，变量类型可以直接省略\n~~~go\nvar (\n  a = 0\n  b = \"bb\"\n)\n~~~\n\n#### 简短声明赋值\n变量名称  :=  变量值\n~~~go\na := 0\n~~~\n\n### 全局变量声明\n\n全局变量声明，包含以上**单一变量声明**，**多变量同时声明1**，**多变量同时声明2**，声明方式，但是只有**多变量同时声明2**声明方式可以同时进行赋值操作，其他方式不支持赋值操作\n\n### 指针\n\n&：取地址\n\n\\*：取值\n\n#### 指针数组\n\\*[4]Type\n首先是一个指针，存储的是数组地址\n\n\n\nvar arr [3]int{1,2,3}\n\nvar p1 *[3]int\n\np1=&arr\n\n(*p1)[2]=100 简写成：p1[2]=100。p1操作的是arr数组\n\n#### 数组指针\n首先是一个数组，存储的是指针\n\n[4]\\*Type\n\n\n\n>注意：\n>\t\\*[4]int\t//指针，4个长度的int类型数组的指针\n>\t[4]\\*int\t//数组，4个长度的int指针地址的数组\n>\t\\*[4]\\*int\t//指针，4个长度int指针地址数组的指针\n>\t\\*\\*[4]\\*int\t//指针，4个长度int指针地址数组的指针的指针\n\n\n\n\n## 条件语句\n\n### if\n- 简单形式\n  ~~~go\n  if 1==2 {\n  \n  }\n  ~~~\n\n- 复合形式\n  - 1\n    ~~~go\n    if a := 0; a ==0 {\n    \n    }\n    ~~~\n  - 2\n    ~~~go\n    if  {\n    \n    }\n    ~~~\n    当不写条件时，当作true处理\n### switch\n\n- 简单形式\n  ~~~go\n  a := 1\n  switch a {\n  case 1:\n    println(1111)\n  default:\n  }\n  ~~~\n\n\n- 复合形式\n  - 1\n    ~~~go\n\n    switch a := 1; a {\n    case 1:\n      println(1111)\n    case 2,3,4:\n      println(222,333,444)\n    default:\n    }\n    ~~~\n\n  - 2\n\n    ~~~go\n    a := 4\n    switch  {\n    case a>=0:\n      println(\">=0\")\n    case a<=5:\n      println(\"<=4\")\n    }\n    ~~~\n    当不写条件时，当作true处理。此处只会输出一种情况`>=0`，switch处理时只要满足一种情况就不会再进行判断\n    \n#### switch穿透 fallthrough\n  ~~~go\n  a := 1\n  switch a {\n  case 1:\n    println(1111)\n    fallthrough\n case 2:\n    println(2222)\n  default:\n  }\n  \n  =======输出为=======\n  1111\n  2222\n  ~~~\nfallthrough 可以穿透case，链接上下两个case一起执行\n\n> 注意：\n> a := 1\n> switch a {\n>\n> default:\n>     println(\"default\")\n>\n>   case 1:\n>     println(1111)\n>\n> }\n> =================输出为===========\n> 1111\n\n\n## 循环语句\n\ngo语言里面没有while，do while 等其他循环结构，只有for\n\n\n\n- 简单形式\n\n  ~~~go\n  for i := 0; i < 10; i++ {\n\n  }\n  ~~~\n\n- 复合形式\n\n  - 1\n    \n    ~~~go\n    for {\n    \n    }\n    ~~~\n    不写条件，当作true处理\n    \n  - 2 \n  \n    ~~~go\n    for index,value := range []int{1,2,3,4} {\n      fmt.Printf(\"index:%d,value:%d \\n\",index,value)\n    }\n    ~~~\n    range关键字可以取出数组，切片，集合等容器里面的数据\n\n\n\n## defer关键字\n\ndefer 延迟，推迟执行。遵循栈的执行原则先进后出，参数变量是已经传递，是在return语句前执行\n\n\n## 函数\n\n\nfunc name(a int,b int) (int){\n\nreturn 0\n\n}\n\n### 函数返回值\n\n~~~go\nfunc name ()(int){\n\nreturn 1\n\n}\n\n\n\nfunc name ()int{\n\nreturn 1\n\n}\n\n\n\nfunc name ()(sum int){\n\nsum:=1\n\nreturn\n\n}\n\n~~~\n\n\n\n\n\n## 结构体\n深拷贝，值传递\n- 简单\n  ~~~go\n  type\tname\tstruct {\n    a int\n    b string\n  }\n  ~~~\n\n- 匿名结构体\n\n  ~~~go\n  struct {\n    a int\n    b string\n  }\n  ~~~\n\n- 匿名结构体字段\n\n  ~~~go\n  type\tname\tstruct {\n   int\n   string\n  }\n  ~~~\n\n  匿名结构体字段访问时，使用匿名字段类型`name.int`，`name.string`，匿名的字段类型不能重复\n\n  ~~~go\n  type\tname\tstruct {\n   int\n   string\n   int\t//不可以\n  }\n  ~~~\n\n\n### 提升字段\n结构体可以嵌套，当一个结构体内嵌套另一个匿名结构体时，可以直接使用字段名称访问被嵌套结构体的字段，这叫做字段提升。\n字段提升只有在被嵌套结构体为匿名的时候可用。\n如果结构体中的字段与被嵌套结构体的字段一样，则访问的为本结构体字段\n\n\n~~~go\ntype Person struct {\n\tname string\n\tage int\n}\n\ntype Student struct {\n\tPerson\n\taddre string\n\tname string\n}\n\np:=Person{\"nihao\",10}\nfmt.Println(p)\n\ns:=Student{Person{\"wohao\",20},\"beij\",\"djh\"}\nfmt.Println(s)\nfmt.Println(s.Person.name,s.Person.age,s.addre,s.name)\nfmt.Println(s.name,s.age,s.addre)\n\n\n======================输出为============================\n\n{nihao 10}\n{{wohao 20} beij djh}\nwohao 20 beij djh\ndjh 20 beij\n~~~\n\n\n\n## 方法\n方法是一个作用在struct结构体上的函数\n\n\n~~~go\nfunc (s Struct) name() {\n\n}\n~~~\n\n实例\n\n~~~go\ntype Person struct {\n\tname string\n\tage int\n}\n\ntype Student struct {\n\tPerson\n\taddre string\n\tname string\n}\nfunc (p Person) run(){\n\tfmt.Println(\"p run\")\n}\n\nfunc (s Student) run()  {\n\tfmt.Println(\"s run\")\n}\n\n\n\np:=Person{\"lisi\",10}\nfmt.Println(p)\np.run()\ns:=Student{Person{\"wangwu\",20},\"beij\",\"xiaowangwu\"}\nfmt.Println(s)\ns.Person.run()\ns.run()\n\n\n\n\n\n===============输出为================\n{lisi 10}\np run\n{{wangwu 20} beij xiaowangwu}\np run\ns run\n~~~\n\n## 接口（interface）\n\n接口可以看作是一些方法的集合。接口是为了解耦合，go语言的接口是非侵入式的。空接口可以看作是任意类型\n\n~~~go\ntype name interface{\n  start()\n  end()\n}\n~~~\n\n### 接口断言\n利用接口来判断类型\n\n- 1\n  instance := 接口对象.(实际类型)   //不安全，会panic（）\n  instance,err := 接口对象.(实际类型)\t//安全\n- 2\n  switch instance := 接口对象.(type) {\n    case 实际类型：\n      xxx\n    case 实际类型：\n      xxxx\n  }\n\n\n\n## type 关键字\n\n- 定义新类型\n  type myint int\n  定义一个int类型的myint类型，但是int和myint类型不一样不能通用\n- 给类型其别名\n  type myint = int \n  给一个int类型起一个别名，int和myint可以通用\n\n## 创建对象\n\n### new\n\n### make\n\n- slice\n  - make([]int,10)\t\n    长度（len）和容量（cap）都为10，默认值为int的零值\n  - make([]int,0,10)\t\n    长度（len）为0，和容量（cap）为10，因为0个长度所以没有值\n- map\n  - make(map[string]string)\n    \n  - make(map[string]string,10)\n  \n- chan\n  - make(chan bool)\n    没有缓存的chan\n  - make(chan bool,10)\n    长度为10的chan\n\n## 访问权限\n名称首字母大写时，可以在其他地方导入，小写其他地方访问不了\n\n\n## IO\n\n## 协程（Gorutine）\n\n## 管道（chan）\n\n## 反射（reflect）\n\n### 基本数据类型反射使用\n\n#### 修改值\n- step1:\n  获取反射对象Value。要修改对象，就要获取对象的地址，用对象的引用地址来更改里面的具体值\n  ~~~go\n  var a int = 0\n  value := reflect.ValueOf(&a)\n  ~~~\n- step2:\n  获取反射对象的指针对象\n  ~~~go\n  elem := value.Elem()\n  ~~~\n- step3:\n  修改值\n  ~~~go\n  elem.SetInt(9)\n  ~~~\n\n完整步骤：\n~~~go\nvar a int = 0\nvalue := reflect.ValueOf(&a)\nelem := value.Elem()\nif !elem.CanSet {  //判断反射对象是否可以修改，不可以直接返回不做修改\n  return\n}\n\nif elem.Kind() ==reflect.Int{ //判断对象是否是int类型\n  elem.SetInt(9)\n}\n\n~~~\n\n### 函数调用\n\n~~~go\nfunc star()  {\n  fmt.Println(\"call this func\")\n}\n\nvalueOf := reflect.ValueOf(star)  //这里star不能加（）\n\nif valueOf.Kind() == reflect.Func {\n  valueOf.Call(nil)\n}\n~~~\n\n### struct 的反射使用\n\n#### 获取字段名称和具体值\n\n- step1:\n  获取反射valueOf和typeOf实例\n  ~~~go\n  type Person struct {\n    Name string\n    Age  int\n  }\n  p:=Person{\"zhangshan\",30}\n\n  valueOf := reflect.ValueOf(p)\n  typeOf := reflect.TypeOf(p)\n  ~~~\n\n\n- step2:\n  通过实例获取字段名称和字段实际值\n  \n  ~~~go\n  for i := 0; i < typeOf.NumField(); i++ {\n    fmt.Println(\"fieldname:  \",typeOf.Field(i).Name)\n    fmt.Println(\"value:  \",valueOf.Field(i))\n  }\n  ~~~\n\n\n完整代码：\n~~~go\ntype Person struct {\n  Name string\n  Age  int\n}\n\np:=Person{\"zhangshan\",30}\n\nvalueOf := reflect.ValueOf(p)\ntypeOf := reflect.TypeOf(p)\n\n\nfor i := 0; i < typeOf.NumField(); i++ {\n  fmt.Println(\"fieldname:  \",typeOf.Field(i).Name)\n  fmt.Println(\"value:  \",valueOf.Field(i))\n}\n~~~\n#### 修改字段值\n\n- step1:\n  获取反射valueOf实例\n  ~~~go\n  type Person struct {\n    Name string\n    Age  int\n  }\n  p:=Person{\"zhangshan\",30}\n\n  valueOf := reflect.ValueOf(&p)  //这里要填写p的地址\n  ~~~\n  \n- step2:\n  修改相应的字段值\n  ~~~go\n  valueOf.Field(0).SetString(\"wangwu\")\n  ~~~\n  \n\n完整代码：\n~~~go\ntype Person struct {\n\tName string\n\tAge  int\n}\np:=Person{\"zhangshan\",30}\n\nvalueOf := reflect.ValueOf(&p)  //这里要填写p的地址\n\nif valueOf.Kind() == reflect.Ptr {\n  if valueOf.Elem().CanSet(){\n    elem := valueOf.Elem()\n  //  field := elem.Field(0)  //通过字段序号获取字段\n    field := elem.FieldByName(\"Name\")  //通过字段名称来获取字段\n    field.SetString(\"wangwu\")\n  }\n}\n~~~\n\n> 注意：\n> Person的字段为大写开头，为可访问字段，如果小写，则会发生程序panic\n> `reflect: reflect.flag.mustBeAssignable using value obtained using unexported field`\n\n#### 调用方法\n\n##### 调用无参数方法\n\n- step1:\n  获取反射valueOf实例\n  ~~~go\n  type Person struct {\n    Name string\n    Age  int\n  }\n  p:=Person{\"zhangshan\",30}\n  \n  func (p Person) Run() {\n    fmt.Println(\"p run\")\n  }\n  \n  valueOf := reflect.ValueOf(p)\n  ~~~\n  \n- step2:\n  通过反射实例获取方法实例\n  ~~~go\n  method := valueOf.MethodByName(\"Run\")\n  ~~~\n- step3:\n  调用方法\n  ~~~go\n  method.Call(nil)\n  ~~~\n\n完整代码：\n~~~go\ntype Person struct {\n  Name string\n  Age  int\n}\np:=Person{\"zhangshan\",30}\n  \nfunc (p Person) Run() {  //方法名称一定要大写\n  fmt.Println(\"p run\")\n}\n  \nvalueOf := reflect.ValueOf(p)\n\n// method := valueOf.Method(0)  //通过序号获取方法实例\nmethod := valueOf.MethodByName(\"Run\")\n\nif method.Kind() == reflect.Func {\n  // method.Call(make([]reflect.Value,0))  //传入一个空切片\n  method.Call(nil)  //直接传入nil空值\n}\n~~~\n\n##### 调用多参数方法\n\n调用多参数方法和无参数方法执行步骤一样，只是在调用时传入参数的切片即可`method.Call([]reflect.Value{reflect.ValueOf(\"lii\"),reflect.ValueOf(\"nihao\"),reflect.ValueOf(5)})`\n\n\n\n~~~go\nfunc (s Person) Write(name string,msg string, length int) {\n  fmt.Println(name,\"写了\",msg,\"一共\",length)\n}\n~~~\n\n\n\n## RPC\n\n### gRPC\n\n## Protobuf\n\n\n\n\n\n\n\n\n\n\n\nfallthrough   在switch 语句中进行穿透，链接两个case \n\n\n\n函数：\n\n\n\n当参数类型一致时，前一个参数可以省略类型\n\n函数参数中如果有可变参数，可变参数放到最后，参数列表中只能有一个可变参数\n\n函数返回值\n\n\n\n\n\n指针\n\n\n\n\n\n","source":"notes/Golang.md","raw":"# Golang\n\n## 数据类型\n\n### 数值类型\n\n#### bool\n\n#### byte\nbyte = uint8\n\n#### int\n有符号类型：int8，int16，int32，int64\n无符号类型：uint8，uint16，uint32，uint64\nrune = int32\n\n#### float\nfloat16，float32\n\n#### string\n\n#### 数组\n\n### 引用类型\n\n#### slice\n\n#### map\n\n\n\n## 变量\ngo语言的变量声明了就必须使用，不用就别声明，否则编译不通过\n\n### 函数变量声明\n\n#### 单一变量声明\n关键字\t变量名称\t变量类型\n~~~go\nvar a\tint\t\n~~~\n声明的同时可以赋值变量，同时赋值可以省略变量类型\n~~~go\nvar a\t= 0\t\n~~~\n#### 多变量同时声明1\n关键字\t变量名称，变量名称\t变量类型\n多变量同时声明时，必须为多个类型一样的变量\n~~~go\nvar a,b,c int\n~~~\n声明的同时可以赋值变量，同时赋值时可以省略变量类型\n~~~go\nvar a,b,c = 0,0,0\n~~~\n#### 多变量同时声明2\n关键字\t（\n变量名称\t变量类型\t\n变量名称\t变量类型\n）\n带有括号的多变量赋值时，变量类型可以不同\n~~~go\nvar (\n  a int\n  b string\n)\n~~~\n其中并且可以进行赋值操作，变量类型可以直接省略\n~~~go\nvar (\n  a = 0\n  b = \"bb\"\n)\n~~~\n\n#### 简短声明赋值\n变量名称  :=  变量值\n~~~go\na := 0\n~~~\n\n### 全局变量声明\n\n全局变量声明，包含以上**单一变量声明**，**多变量同时声明1**，**多变量同时声明2**，声明方式，但是只有**多变量同时声明2**声明方式可以同时进行赋值操作，其他方式不支持赋值操作\n\n### 指针\n\n&：取地址\n\n\\*：取值\n\n#### 指针数组\n\\*[4]Type\n首先是一个指针，存储的是数组地址\n\n\n\nvar arr [3]int{1,2,3}\n\nvar p1 *[3]int\n\np1=&arr\n\n(*p1)[2]=100 简写成：p1[2]=100。p1操作的是arr数组\n\n#### 数组指针\n首先是一个数组，存储的是指针\n\n[4]\\*Type\n\n\n\n>注意：\n>\t\\*[4]int\t//指针，4个长度的int类型数组的指针\n>\t[4]\\*int\t//数组，4个长度的int指针地址的数组\n>\t\\*[4]\\*int\t//指针，4个长度int指针地址数组的指针\n>\t\\*\\*[4]\\*int\t//指针，4个长度int指针地址数组的指针的指针\n\n\n\n\n## 条件语句\n\n### if\n- 简单形式\n  ~~~go\n  if 1==2 {\n  \n  }\n  ~~~\n\n- 复合形式\n  - 1\n    ~~~go\n    if a := 0; a ==0 {\n    \n    }\n    ~~~\n  - 2\n    ~~~go\n    if  {\n    \n    }\n    ~~~\n    当不写条件时，当作true处理\n### switch\n\n- 简单形式\n  ~~~go\n  a := 1\n  switch a {\n  case 1:\n    println(1111)\n  default:\n  }\n  ~~~\n\n\n- 复合形式\n  - 1\n    ~~~go\n\n    switch a := 1; a {\n    case 1:\n      println(1111)\n    case 2,3,4:\n      println(222,333,444)\n    default:\n    }\n    ~~~\n\n  - 2\n\n    ~~~go\n    a := 4\n    switch  {\n    case a>=0:\n      println(\">=0\")\n    case a<=5:\n      println(\"<=4\")\n    }\n    ~~~\n    当不写条件时，当作true处理。此处只会输出一种情况`>=0`，switch处理时只要满足一种情况就不会再进行判断\n    \n#### switch穿透 fallthrough\n  ~~~go\n  a := 1\n  switch a {\n  case 1:\n    println(1111)\n    fallthrough\n case 2:\n    println(2222)\n  default:\n  }\n  \n  =======输出为=======\n  1111\n  2222\n  ~~~\nfallthrough 可以穿透case，链接上下两个case一起执行\n\n> 注意：\n> a := 1\n> switch a {\n>\n> default:\n>     println(\"default\")\n>\n>   case 1:\n>     println(1111)\n>\n> }\n> =================输出为===========\n> 1111\n\n\n## 循环语句\n\ngo语言里面没有while，do while 等其他循环结构，只有for\n\n\n\n- 简单形式\n\n  ~~~go\n  for i := 0; i < 10; i++ {\n\n  }\n  ~~~\n\n- 复合形式\n\n  - 1\n    \n    ~~~go\n    for {\n    \n    }\n    ~~~\n    不写条件，当作true处理\n    \n  - 2 \n  \n    ~~~go\n    for index,value := range []int{1,2,3,4} {\n      fmt.Printf(\"index:%d,value:%d \\n\",index,value)\n    }\n    ~~~\n    range关键字可以取出数组，切片，集合等容器里面的数据\n\n\n\n## defer关键字\n\ndefer 延迟，推迟执行。遵循栈的执行原则先进后出，参数变量是已经传递，是在return语句前执行\n\n\n## 函数\n\n\nfunc name(a int,b int) (int){\n\nreturn 0\n\n}\n\n### 函数返回值\n\n~~~go\nfunc name ()(int){\n\nreturn 1\n\n}\n\n\n\nfunc name ()int{\n\nreturn 1\n\n}\n\n\n\nfunc name ()(sum int){\n\nsum:=1\n\nreturn\n\n}\n\n~~~\n\n\n\n\n\n## 结构体\n深拷贝，值传递\n- 简单\n  ~~~go\n  type\tname\tstruct {\n    a int\n    b string\n  }\n  ~~~\n\n- 匿名结构体\n\n  ~~~go\n  struct {\n    a int\n    b string\n  }\n  ~~~\n\n- 匿名结构体字段\n\n  ~~~go\n  type\tname\tstruct {\n   int\n   string\n  }\n  ~~~\n\n  匿名结构体字段访问时，使用匿名字段类型`name.int`，`name.string`，匿名的字段类型不能重复\n\n  ~~~go\n  type\tname\tstruct {\n   int\n   string\n   int\t//不可以\n  }\n  ~~~\n\n\n### 提升字段\n结构体可以嵌套，当一个结构体内嵌套另一个匿名结构体时，可以直接使用字段名称访问被嵌套结构体的字段，这叫做字段提升。\n字段提升只有在被嵌套结构体为匿名的时候可用。\n如果结构体中的字段与被嵌套结构体的字段一样，则访问的为本结构体字段\n\n\n~~~go\ntype Person struct {\n\tname string\n\tage int\n}\n\ntype Student struct {\n\tPerson\n\taddre string\n\tname string\n}\n\np:=Person{\"nihao\",10}\nfmt.Println(p)\n\ns:=Student{Person{\"wohao\",20},\"beij\",\"djh\"}\nfmt.Println(s)\nfmt.Println(s.Person.name,s.Person.age,s.addre,s.name)\nfmt.Println(s.name,s.age,s.addre)\n\n\n======================输出为============================\n\n{nihao 10}\n{{wohao 20} beij djh}\nwohao 20 beij djh\ndjh 20 beij\n~~~\n\n\n\n## 方法\n方法是一个作用在struct结构体上的函数\n\n\n~~~go\nfunc (s Struct) name() {\n\n}\n~~~\n\n实例\n\n~~~go\ntype Person struct {\n\tname string\n\tage int\n}\n\ntype Student struct {\n\tPerson\n\taddre string\n\tname string\n}\nfunc (p Person) run(){\n\tfmt.Println(\"p run\")\n}\n\nfunc (s Student) run()  {\n\tfmt.Println(\"s run\")\n}\n\n\n\np:=Person{\"lisi\",10}\nfmt.Println(p)\np.run()\ns:=Student{Person{\"wangwu\",20},\"beij\",\"xiaowangwu\"}\nfmt.Println(s)\ns.Person.run()\ns.run()\n\n\n\n\n\n===============输出为================\n{lisi 10}\np run\n{{wangwu 20} beij xiaowangwu}\np run\ns run\n~~~\n\n## 接口（interface）\n\n接口可以看作是一些方法的集合。接口是为了解耦合，go语言的接口是非侵入式的。空接口可以看作是任意类型\n\n~~~go\ntype name interface{\n  start()\n  end()\n}\n~~~\n\n### 接口断言\n利用接口来判断类型\n\n- 1\n  instance := 接口对象.(实际类型)   //不安全，会panic（）\n  instance,err := 接口对象.(实际类型)\t//安全\n- 2\n  switch instance := 接口对象.(type) {\n    case 实际类型：\n      xxx\n    case 实际类型：\n      xxxx\n  }\n\n\n\n## type 关键字\n\n- 定义新类型\n  type myint int\n  定义一个int类型的myint类型，但是int和myint类型不一样不能通用\n- 给类型其别名\n  type myint = int \n  给一个int类型起一个别名，int和myint可以通用\n\n## 创建对象\n\n### new\n\n### make\n\n- slice\n  - make([]int,10)\t\n    长度（len）和容量（cap）都为10，默认值为int的零值\n  - make([]int,0,10)\t\n    长度（len）为0，和容量（cap）为10，因为0个长度所以没有值\n- map\n  - make(map[string]string)\n    \n  - make(map[string]string,10)\n  \n- chan\n  - make(chan bool)\n    没有缓存的chan\n  - make(chan bool,10)\n    长度为10的chan\n\n## 访问权限\n名称首字母大写时，可以在其他地方导入，小写其他地方访问不了\n\n\n## IO\n\n## 协程（Gorutine）\n\n## 管道（chan）\n\n## 反射（reflect）\n\n### 基本数据类型反射使用\n\n#### 修改值\n- step1:\n  获取反射对象Value。要修改对象，就要获取对象的地址，用对象的引用地址来更改里面的具体值\n  ~~~go\n  var a int = 0\n  value := reflect.ValueOf(&a)\n  ~~~\n- step2:\n  获取反射对象的指针对象\n  ~~~go\n  elem := value.Elem()\n  ~~~\n- step3:\n  修改值\n  ~~~go\n  elem.SetInt(9)\n  ~~~\n\n完整步骤：\n~~~go\nvar a int = 0\nvalue := reflect.ValueOf(&a)\nelem := value.Elem()\nif !elem.CanSet {  //判断反射对象是否可以修改，不可以直接返回不做修改\n  return\n}\n\nif elem.Kind() ==reflect.Int{ //判断对象是否是int类型\n  elem.SetInt(9)\n}\n\n~~~\n\n### 函数调用\n\n~~~go\nfunc star()  {\n  fmt.Println(\"call this func\")\n}\n\nvalueOf := reflect.ValueOf(star)  //这里star不能加（）\n\nif valueOf.Kind() == reflect.Func {\n  valueOf.Call(nil)\n}\n~~~\n\n### struct 的反射使用\n\n#### 获取字段名称和具体值\n\n- step1:\n  获取反射valueOf和typeOf实例\n  ~~~go\n  type Person struct {\n    Name string\n    Age  int\n  }\n  p:=Person{\"zhangshan\",30}\n\n  valueOf := reflect.ValueOf(p)\n  typeOf := reflect.TypeOf(p)\n  ~~~\n\n\n- step2:\n  通过实例获取字段名称和字段实际值\n  \n  ~~~go\n  for i := 0; i < typeOf.NumField(); i++ {\n    fmt.Println(\"fieldname:  \",typeOf.Field(i).Name)\n    fmt.Println(\"value:  \",valueOf.Field(i))\n  }\n  ~~~\n\n\n完整代码：\n~~~go\ntype Person struct {\n  Name string\n  Age  int\n}\n\np:=Person{\"zhangshan\",30}\n\nvalueOf := reflect.ValueOf(p)\ntypeOf := reflect.TypeOf(p)\n\n\nfor i := 0; i < typeOf.NumField(); i++ {\n  fmt.Println(\"fieldname:  \",typeOf.Field(i).Name)\n  fmt.Println(\"value:  \",valueOf.Field(i))\n}\n~~~\n#### 修改字段值\n\n- step1:\n  获取反射valueOf实例\n  ~~~go\n  type Person struct {\n    Name string\n    Age  int\n  }\n  p:=Person{\"zhangshan\",30}\n\n  valueOf := reflect.ValueOf(&p)  //这里要填写p的地址\n  ~~~\n  \n- step2:\n  修改相应的字段值\n  ~~~go\n  valueOf.Field(0).SetString(\"wangwu\")\n  ~~~\n  \n\n完整代码：\n~~~go\ntype Person struct {\n\tName string\n\tAge  int\n}\np:=Person{\"zhangshan\",30}\n\nvalueOf := reflect.ValueOf(&p)  //这里要填写p的地址\n\nif valueOf.Kind() == reflect.Ptr {\n  if valueOf.Elem().CanSet(){\n    elem := valueOf.Elem()\n  //  field := elem.Field(0)  //通过字段序号获取字段\n    field := elem.FieldByName(\"Name\")  //通过字段名称来获取字段\n    field.SetString(\"wangwu\")\n  }\n}\n~~~\n\n> 注意：\n> Person的字段为大写开头，为可访问字段，如果小写，则会发生程序panic\n> `reflect: reflect.flag.mustBeAssignable using value obtained using unexported field`\n\n#### 调用方法\n\n##### 调用无参数方法\n\n- step1:\n  获取反射valueOf实例\n  ~~~go\n  type Person struct {\n    Name string\n    Age  int\n  }\n  p:=Person{\"zhangshan\",30}\n  \n  func (p Person) Run() {\n    fmt.Println(\"p run\")\n  }\n  \n  valueOf := reflect.ValueOf(p)\n  ~~~\n  \n- step2:\n  通过反射实例获取方法实例\n  ~~~go\n  method := valueOf.MethodByName(\"Run\")\n  ~~~\n- step3:\n  调用方法\n  ~~~go\n  method.Call(nil)\n  ~~~\n\n完整代码：\n~~~go\ntype Person struct {\n  Name string\n  Age  int\n}\np:=Person{\"zhangshan\",30}\n  \nfunc (p Person) Run() {  //方法名称一定要大写\n  fmt.Println(\"p run\")\n}\n  \nvalueOf := reflect.ValueOf(p)\n\n// method := valueOf.Method(0)  //通过序号获取方法实例\nmethod := valueOf.MethodByName(\"Run\")\n\nif method.Kind() == reflect.Func {\n  // method.Call(make([]reflect.Value,0))  //传入一个空切片\n  method.Call(nil)  //直接传入nil空值\n}\n~~~\n\n##### 调用多参数方法\n\n调用多参数方法和无参数方法执行步骤一样，只是在调用时传入参数的切片即可`method.Call([]reflect.Value{reflect.ValueOf(\"lii\"),reflect.ValueOf(\"nihao\"),reflect.ValueOf(5)})`\n\n\n\n~~~go\nfunc (s Person) Write(name string,msg string, length int) {\n  fmt.Println(name,\"写了\",msg,\"一共\",length)\n}\n~~~\n\n\n\n## RPC\n\n### gRPC\n\n## Protobuf\n\n\n\n\n\n\n\n\n\n\n\nfallthrough   在switch 语句中进行穿透，链接两个case \n\n\n\n函数：\n\n\n\n当参数类型一致时，前一个参数可以省略类型\n\n函数参数中如果有可变参数，可变参数放到最后，参数列表中只能有一个可变参数\n\n函数返回值\n\n\n\n\n\n指针\n\n\n\n\n\n","date":"2020-04-01T13:52:13.000Z","updated":"2020-04-01T13:52:13.000Z","path":"notes/Golang.html","title":"","comments":1,"layout":"page","_id":"ck8hf2uvz000mzhs6r2ffto4b","content":"<h1 id=\"Golang\"><a href=\"#Golang\" class=\"headerlink\" title=\"Golang\"></a>Golang</h1><h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"数值类型\"><a href=\"#数值类型\" class=\"headerlink\" title=\"数值类型\"></a>数值类型</h3><h4 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool\"></a>bool</h4><h4 id=\"byte\"><a href=\"#byte\" class=\"headerlink\" title=\"byte\"></a>byte</h4><p>byte = uint8</p>\n<h4 id=\"int\"><a href=\"#int\" class=\"headerlink\" title=\"int\"></a>int</h4><p>有符号类型：int8，int16，int32，int64<br>无符号类型：uint8，uint16，uint32，uint64<br>rune = int32</p>\n<h4 id=\"float\"><a href=\"#float\" class=\"headerlink\" title=\"float\"></a>float</h4><p>float16，float32</p>\n<h4 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h4><h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><h3 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h3><h4 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h4><h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>go语言的变量声明了就必须使用，不用就别声明，否则编译不通过</p>\n<h3 id=\"函数变量声明\"><a href=\"#函数变量声明\" class=\"headerlink\" title=\"函数变量声明\"></a>函数变量声明</h3><h4 id=\"单一变量声明\"><a href=\"#单一变量声明\" class=\"headerlink\" title=\"单一变量声明\"></a>单一变量声明</h4><p>关键字    变量名称    变量类型</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> a    <span class=\"token builtin\">int</span>    </code></pre>\n<p>声明的同时可以赋值变量，同时赋值可以省略变量类型</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> a    <span class=\"token operator\">=</span> <span class=\"token number\">0</span>    </code></pre>\n<h4 id=\"多变量同时声明1\"><a href=\"#多变量同时声明1\" class=\"headerlink\" title=\"多变量同时声明1\"></a>多变量同时声明1</h4><p>关键字    变量名称，变量名称    变量类型<br>多变量同时声明时，必须为多个类型一样的变量</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token builtin\">int</span></code></pre>\n<p>声明的同时可以赋值变量，同时赋值时可以省略变量类型</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span></code></pre>\n<h4 id=\"多变量同时声明2\"><a href=\"#多变量同时声明2\" class=\"headerlink\" title=\"多变量同时声明2\"></a>多变量同时声明2</h4><p>关键字    （<br>变量名称    变量类型<br>变量名称    变量类型<br>）<br>带有括号的多变量赋值时，变量类型可以不同</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> <span class=\"token punctuation\">(</span>\n  a <span class=\"token builtin\">int</span>\n  b <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">)</span></code></pre>\n<p>其中并且可以进行赋值操作，变量类型可以直接省略</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> <span class=\"token punctuation\">(</span>\n  a <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  b <span class=\"token operator\">=</span> <span class=\"token string\">\"bb\"</span>\n<span class=\"token punctuation\">)</span></code></pre>\n<h4 id=\"简短声明赋值\"><a href=\"#简短声明赋值\" class=\"headerlink\" title=\"简短声明赋值\"></a>简短声明赋值</h4><p>变量名称  :=  变量值</p>\n<pre class=\" language-go\"><code class=\"language-go\">a <span class=\"token operator\">:=</span> <span class=\"token number\">0</span></code></pre>\n<h3 id=\"全局变量声明\"><a href=\"#全局变量声明\" class=\"headerlink\" title=\"全局变量声明\"></a>全局变量声明</h3><p>全局变量声明，包含以上<strong>单一变量声明</strong>，<strong>多变量同时声明1</strong>，<strong>多变量同时声明2</strong>，声明方式，但是只有<strong>多变量同时声明2</strong>声明方式可以同时进行赋值操作，其他方式不支持赋值操作</p>\n<h3 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h3><p>&amp;：取地址</p>\n<p>*：取值</p>\n<h4 id=\"指针数组\"><a href=\"#指针数组\" class=\"headerlink\" title=\"指针数组\"></a>指针数组</h4><p>*[4]Type<br>首先是一个指针，存储的是数组地址</p>\n<p>var arr [3]int{1,2,3}</p>\n<p>var p1 *[3]int</p>\n<p>p1=&amp;arr</p>\n<p>(*p1)[2]=100 简写成：p1[2]=100。p1操作的是arr数组</p>\n<h4 id=\"数组指针\"><a href=\"#数组指针\" class=\"headerlink\" title=\"数组指针\"></a>数组指针</h4><p>首先是一个数组，存储的是指针</p>\n<p>[4]*Type</p>\n<blockquote>\n<p>注意：<br>   *[4]int    //指针，4个长度的int类型数组的指针<br>   [4]*int    //数组，4个长度的int指针地址的数组<br>   *[4]*int    //指针，4个长度int指针地址数组的指针<br>   **[4]*int    //指针，4个长度int指针地址数组的指针的指针</p>\n</blockquote>\n<h2 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h2><h3 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h3><ul>\n<li><p>简单形式</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">if</span> <span class=\"token number\">1</span><span class=\"token operator\">==</span><span class=\"token number\">2</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p>复合形式</p>\n<ul>\n<li><p>1</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">if</span> a <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> a <span class=\"token operator\">==</span><span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p>2</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">if</span>  <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<p>当不写条件时，当作true处理</p>\n<h3 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h3></li>\n</ul>\n</li>\n<li><p>简单形式</p>\n<pre class=\" language-go\"><code class=\"language-go\">a <span class=\"token operator\">:=</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">switch</span> a <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">case</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token number\">1111</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n</ul>\n<ul>\n<li><p>复合形式</p>\n<ul>\n<li><p>1</p>\n<pre class=\" language-go\"><code class=\"language-go\">\n<span class=\"token keyword\">switch</span> a <span class=\"token operator\">:=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> a <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">case</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token number\">1111</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">case</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">:</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token number\">222</span><span class=\"token punctuation\">,</span><span class=\"token number\">333</span><span class=\"token punctuation\">,</span><span class=\"token number\">444</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p>2</p>\n<pre class=\" language-go\"><code class=\"language-go\">a <span class=\"token operator\">:=</span> <span class=\"token number\">4</span>\n<span class=\"token keyword\">switch</span>  <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">case</span> a<span class=\"token operator\">>=</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\">=0\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">case</span> a<span class=\"token operator\">&lt;=</span><span class=\"token number\">5</span><span class=\"token punctuation\">:</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&lt;=4\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>当不写条件时，当作true处理。此处只会输出一种情况<code>&gt;=0</code>，switch处理时只要满足一种情况就不会再进行判断</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"switch穿透-fallthrough\"><a href=\"#switch穿透-fallthrough\" class=\"headerlink\" title=\"switch穿透 fallthrough\"></a>switch穿透 fallthrough</h4><pre class=\" language-go\"><code class=\"language-go\">  a <span class=\"token operator\">:=</span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">switch</span> a <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">case</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token number\">1111</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">fallthrough</span>\n <span class=\"token keyword\">case</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token number\">2222</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>输出为<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>\n  <span class=\"token number\">1111</span>\n  <span class=\"token number\">2222</span></code></pre>\n<p>fallthrough 可以穿透case，链接上下两个case一起执行</p>\n<blockquote>\n<p>注意：<br>a := 1<br>switch a {</p>\n<p>default:<br>    println(“default”)</p>\n<p>  case 1:<br>    println(1111)</p>\n<p>}<br>=================输出为===========<br>1111</p>\n</blockquote>\n<h2 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h2><p>go语言里面没有while，do while 等其他循环结构，只有for</p>\n<ul>\n<li><p>简单形式</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p>复合形式</p>\n<ul>\n<li><p>1</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<p>不写条件，当作true处理</p>\n</li>\n<li><p>2 </p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">for</span> index<span class=\"token punctuation\">,</span>value <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"index:%d,value:%d \\n\"</span><span class=\"token punctuation\">,</span>index<span class=\"token punctuation\">,</span>value<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>range关键字可以取出数组，切片，集合等容器里面的数据</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"defer关键字\"><a href=\"#defer关键字\" class=\"headerlink\" title=\"defer关键字\"></a>defer关键字</h2><p>defer 延迟，推迟执行。遵循栈的执行原则先进后出，参数变量是已经传递，是在return语句前执行</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>func name(a int,b int) (int){</p>\n<p>return 0</p>\n<p>}</p>\n<h3 id=\"函数返回值\"><a href=\"#函数返回值\" class=\"headerlink\" title=\"函数返回值\"></a>函数返回值</h3><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">name</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\n<span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n\n<span class=\"token punctuation\">}</span>\n\n\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">name</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">{</span>\n\n<span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n\n<span class=\"token punctuation\">}</span>\n\n\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">name</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>sum <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\nsum<span class=\"token operator\">:=</span><span class=\"token number\">1</span>\n\n<span class=\"token keyword\">return</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h2><p>深拷贝，值传递</p>\n<ul>\n<li><p>简单</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span>    name    <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  a <span class=\"token builtin\">int</span>\n  b <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p>匿名结构体</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  a <span class=\"token builtin\">int</span>\n  b <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p>匿名结构体字段</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span>    name    <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n <span class=\"token builtin\">int</span>\n <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>匿名结构体字段访问时，使用匿名字段类型<code>name.int</code>，<code>name.string</code>，匿名的字段类型不能重复</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span>    name    <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n <span class=\"token builtin\">int</span>\n <span class=\"token builtin\">string</span>\n <span class=\"token builtin\">int</span>    <span class=\"token comment\" spellcheck=\"true\">//不可以</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n</ul>\n<h3 id=\"提升字段\"><a href=\"#提升字段\" class=\"headerlink\" title=\"提升字段\"></a>提升字段</h3><p>结构体可以嵌套，当一个结构体内嵌套另一个匿名结构体时，可以直接使用字段名称访问被嵌套结构体的字段，这叫做字段提升。<br>字段提升只有在被嵌套结构体为匿名的时候可用。<br>如果结构体中的字段与被嵌套结构体的字段一样，则访问的为本结构体字段</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    name <span class=\"token builtin\">string</span>\n    age <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> Student <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    Person\n    addre <span class=\"token builtin\">string</span>\n    name <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\np<span class=\"token operator\">:=</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"nihao\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">}</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span>\n\ns<span class=\"token operator\">:=</span>Student<span class=\"token punctuation\">{</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"wohao\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"beij\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"djh\"</span><span class=\"token punctuation\">}</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>Person<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">.</span>Person<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">.</span>addre<span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">.</span>addre<span class=\"token punctuation\">)</span>\n\n\n<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span>输出为<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span>\n\n<span class=\"token punctuation\">{</span>nihao <span class=\"token number\">10</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>wohao <span class=\"token number\">20</span><span class=\"token punctuation\">}</span> beij djh<span class=\"token punctuation\">}</span>\nwohao <span class=\"token number\">20</span> beij djh\ndjh <span class=\"token number\">20</span> beij</code></pre>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>方法是一个作用在struct结构体上的函数</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s Struct<span class=\"token punctuation\">)</span> <span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<p>实例</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    name <span class=\"token builtin\">string</span>\n    age <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> Student <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    Person\n    addre <span class=\"token builtin\">string</span>\n    name <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>p Person<span class=\"token punctuation\">)</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"p run\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s Student<span class=\"token punctuation\">)</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">{</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"s run\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n\n\np<span class=\"token operator\">:=</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"lisi\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">}</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span>\np<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ns<span class=\"token operator\">:=</span>Student<span class=\"token punctuation\">{</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"wangwu\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"beij\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"xiaowangwu\"</span><span class=\"token punctuation\">}</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\ns<span class=\"token punctuation\">.</span>Person<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ns<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n\n\n\n\n<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>输出为<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span>\n<span class=\"token punctuation\">{</span>lisi <span class=\"token number\">10</span><span class=\"token punctuation\">}</span>\np run\n<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>wangwu <span class=\"token number\">20</span><span class=\"token punctuation\">}</span> beij xiaowangwu<span class=\"token punctuation\">}</span>\np run\ns run</code></pre>\n<h2 id=\"接口（interface）\"><a href=\"#接口（interface）\" class=\"headerlink\" title=\"接口（interface）\"></a>接口（interface）</h2><p>接口可以看作是一些方法的集合。接口是为了解耦合，go语言的接口是非侵入式的。空接口可以看作是任意类型</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> name <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"接口断言\"><a href=\"#接口断言\" class=\"headerlink\" title=\"接口断言\"></a>接口断言</h3><p>利用接口来判断类型</p>\n<ul>\n<li>1<br>instance := 接口对象.(实际类型)   //不安全，会panic（）<br>instance,err := 接口对象.(实际类型)    //安全</li>\n<li>2<br>switch instance := 接口对象.(type) {<br>  case 实际类型：<pre><code>xxx</code></pre>  case 实际类型：<pre><code>xxxx</code></pre>}</li>\n</ul>\n<h2 id=\"type-关键字\"><a href=\"#type-关键字\" class=\"headerlink\" title=\"type 关键字\"></a>type 关键字</h2><ul>\n<li>定义新类型<br>type myint int<br>定义一个int类型的myint类型，但是int和myint类型不一样不能通用</li>\n<li>给类型其别名<br>type myint = int<br>给一个int类型起一个别名，int和myint可以通用</li>\n</ul>\n<h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h3><h3 id=\"make\"><a href=\"#make\" class=\"headerlink\" title=\"make\"></a>make</h3><ul>\n<li><p>slice</p>\n<ul>\n<li>make([]int,10)<br>长度（len）和容量（cap）都为10，默认值为int的零值</li>\n<li>make([]int,0,10)<br>长度（len）为0，和容量（cap）为10，因为0个长度所以没有值</li>\n</ul>\n</li>\n<li><p>map</p>\n<ul>\n<li><p>make(map[string]string)</p>\n</li>\n<li><p>make(map[string]string,10)</p>\n</li>\n</ul>\n</li>\n<li><p>chan</p>\n<ul>\n<li>make(chan bool)<br>没有缓存的chan</li>\n<li>make(chan bool,10)<br>长度为10的chan</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"访问权限\"><a href=\"#访问权限\" class=\"headerlink\" title=\"访问权限\"></a>访问权限</h2><p>名称首字母大写时，可以在其他地方导入，小写其他地方访问不了</p>\n<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><h2 id=\"协程（Gorutine）\"><a href=\"#协程（Gorutine）\" class=\"headerlink\" title=\"协程（Gorutine）\"></a>协程（Gorutine）</h2><h2 id=\"管道（chan）\"><a href=\"#管道（chan）\" class=\"headerlink\" title=\"管道（chan）\"></a>管道（chan）</h2><h2 id=\"反射（reflect）\"><a href=\"#反射（reflect）\" class=\"headerlink\" title=\"反射（reflect）\"></a>反射（reflect）</h2><h3 id=\"基本数据类型反射使用\"><a href=\"#基本数据类型反射使用\" class=\"headerlink\" title=\"基本数据类型反射使用\"></a>基本数据类型反射使用</h3><h4 id=\"修改值\"><a href=\"#修改值\" class=\"headerlink\" title=\"修改值\"></a>修改值</h4><ul>\n<li>step1:<br>获取反射对象Value。要修改对象，就要获取对象的地址，用对象的引用地址来更改里面的具体值<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> a <span class=\"token builtin\">int</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\nvalue <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">)</span></code></pre>\n</li>\n<li>step2:<br>获取反射对象的指针对象<pre class=\" language-go\"><code class=\"language-go\">elem <span class=\"token operator\">:=</span> value<span class=\"token punctuation\">.</span><span class=\"token function\">Elem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n</li>\n<li>step3:<br>修改值<pre class=\" language-go\"><code class=\"language-go\">elem<span class=\"token punctuation\">.</span><span class=\"token function\">SetInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">9</span><span class=\"token punctuation\">)</span></code></pre>\n</li>\n</ul>\n<p>完整步骤：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> a <span class=\"token builtin\">int</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\nvalue <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">)</span>\nelem <span class=\"token operator\">:=</span> value<span class=\"token punctuation\">.</span><span class=\"token function\">Elem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>elem<span class=\"token punctuation\">.</span>CanSet <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">//判断反射对象是否可以修改，不可以直接返回不做修改</span>\n  <span class=\"token keyword\">return</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">if</span> elem<span class=\"token punctuation\">.</span><span class=\"token function\">Kind</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span>reflect<span class=\"token punctuation\">.</span>Int<span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//判断对象是否是int类型</span>\n  elem<span class=\"token punctuation\">.</span><span class=\"token function\">SetInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">9</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"函数调用\"><a href=\"#函数调用\" class=\"headerlink\" title=\"函数调用\"></a>函数调用</h3><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">star</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"call this func\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\nvalueOf <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span>star<span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">//这里star不能加（）</span>\n\n<span class=\"token keyword\">if</span> valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">Kind</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> reflect<span class=\"token punctuation\">.</span>Func <span class=\"token punctuation\">{</span>\n  valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">Call</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"struct-的反射使用\"><a href=\"#struct-的反射使用\" class=\"headerlink\" title=\"struct 的反射使用\"></a>struct 的反射使用</h3><h4 id=\"获取字段名称和具体值\"><a href=\"#获取字段名称和具体值\" class=\"headerlink\" title=\"获取字段名称和具体值\"></a>获取字段名称和具体值</h4><ul>\n<li><p>step1:<br>获取反射valueOf和typeOf实例</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  Name <span class=\"token builtin\">string</span>\n  Age  <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>\np<span class=\"token operator\">:=</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"zhangshan\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">30</span><span class=\"token punctuation\">}</span>\n\nvalueOf <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span>\ntypeOf <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">TypeOf</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span></code></pre>\n</li>\n</ul>\n<ul>\n<li><p>step2:<br>通过实例获取字段名称和字段实际值</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> typeOf<span class=\"token punctuation\">.</span><span class=\"token function\">NumField</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fieldname:  \"</span><span class=\"token punctuation\">,</span>typeOf<span class=\"token punctuation\">.</span><span class=\"token function\">Field</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">)</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"value:  \"</span><span class=\"token punctuation\">,</span>valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">Field</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n</ul>\n<p>完整代码：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  Name <span class=\"token builtin\">string</span>\n  Age  <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>\n\np<span class=\"token operator\">:=</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"zhangshan\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">30</span><span class=\"token punctuation\">}</span>\n\nvalueOf <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span>\ntypeOf <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">TypeOf</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span>\n\n\n<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> typeOf<span class=\"token punctuation\">.</span><span class=\"token function\">NumField</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fieldname:  \"</span><span class=\"token punctuation\">,</span>typeOf<span class=\"token punctuation\">.</span><span class=\"token function\">Field</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">)</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"value:  \"</span><span class=\"token punctuation\">,</span>valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">Field</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"修改字段值\"><a href=\"#修改字段值\" class=\"headerlink\" title=\"修改字段值\"></a>修改字段值</h4><ul>\n<li><p>step1:<br>获取反射valueOf实例</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  Name <span class=\"token builtin\">string</span>\n  Age  <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>\np<span class=\"token operator\">:=</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"zhangshan\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">30</span><span class=\"token punctuation\">}</span>\n\nvalueOf <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">//这里要填写p的地址</span></code></pre>\n</li>\n<li><p>step2:<br>修改相应的字段值</p>\n<pre class=\" language-go\"><code class=\"language-go\">valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">Field</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">SetString</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"wangwu\"</span><span class=\"token punctuation\">)</span></code></pre>\n</li>\n</ul>\n<p>完整代码：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    Name <span class=\"token builtin\">string</span>\n    Age  <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>\np<span class=\"token operator\">:=</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"zhangshan\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">30</span><span class=\"token punctuation\">}</span>\n\nvalueOf <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">//这里要填写p的地址</span>\n\n<span class=\"token keyword\">if</span> valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">Kind</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> reflect<span class=\"token punctuation\">.</span>Ptr <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">Elem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">CanSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    elem <span class=\"token operator\">:=</span> valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">Elem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\" spellcheck=\"true\">//  field := elem.Field(0)  //通过字段序号获取字段</span>\n    field <span class=\"token operator\">:=</span> elem<span class=\"token punctuation\">.</span><span class=\"token function\">FieldByName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Name\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">//通过字段名称来获取字段</span>\n    field<span class=\"token punctuation\">.</span><span class=\"token function\">SetString</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"wangwu\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<blockquote>\n<p>注意：<br>Person的字段为大写开头，为可访问字段，如果小写，则会发生程序panic<br><code>reflect: reflect.flag.mustBeAssignable using value obtained using unexported field</code></p>\n</blockquote>\n<h4 id=\"调用方法\"><a href=\"#调用方法\" class=\"headerlink\" title=\"调用方法\"></a>调用方法</h4><h5 id=\"调用无参数方法\"><a href=\"#调用无参数方法\" class=\"headerlink\" title=\"调用无参数方法\"></a>调用无参数方法</h5><ul>\n<li><p>step1:<br>获取反射valueOf实例</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  Name <span class=\"token builtin\">string</span>\n  Age  <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>\np<span class=\"token operator\">:=</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"zhangshan\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">30</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>p Person<span class=\"token punctuation\">)</span> <span class=\"token function\">Run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"p run\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\nvalueOf <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span></code></pre>\n</li>\n<li><p>step2:<br>通过反射实例获取方法实例</p>\n<pre class=\" language-go\"><code class=\"language-go\">method <span class=\"token operator\">:=</span> valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">MethodByName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Run\"</span><span class=\"token punctuation\">)</span></code></pre>\n</li>\n<li><p>step3:<br>调用方法</p>\n<pre class=\" language-go\"><code class=\"language-go\">method<span class=\"token punctuation\">.</span><span class=\"token function\">Call</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span></code></pre>\n</li>\n</ul>\n<p>完整代码：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  Name <span class=\"token builtin\">string</span>\n  Age  <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>\np<span class=\"token operator\">:=</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"zhangshan\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">30</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>p Person<span class=\"token punctuation\">)</span> <span class=\"token function\">Run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">//方法名称一定要大写</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"p run\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\nvalueOf <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// method := valueOf.Method(0)  //通过序号获取方法实例</span>\nmethod <span class=\"token operator\">:=</span> valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">MethodByName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Run\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">if</span> method<span class=\"token punctuation\">.</span><span class=\"token function\">Kind</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> reflect<span class=\"token punctuation\">.</span>Func <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// method.Call(make([]reflect.Value,0))  //传入一个空切片</span>\n  method<span class=\"token punctuation\">.</span><span class=\"token function\">Call</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">//直接传入nil空值</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h5 id=\"调用多参数方法\"><a href=\"#调用多参数方法\" class=\"headerlink\" title=\"调用多参数方法\"></a>调用多参数方法</h5><p>调用多参数方法和无参数方法执行步骤一样，只是在调用时传入参数的切片即可<code>method.Call([]reflect.Value{reflect.ValueOf(&quot;lii&quot;),reflect.ValueOf(&quot;nihao&quot;),reflect.ValueOf(5)})</code></p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s Person<span class=\"token punctuation\">)</span> <span class=\"token function\">Write</span><span class=\"token punctuation\">(</span>name <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span>msg <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> length <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span><span class=\"token string\">\"写了\"</span><span class=\"token punctuation\">,</span>msg<span class=\"token punctuation\">,</span><span class=\"token string\">\"一共\"</span><span class=\"token punctuation\">,</span>length<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h2><h3 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h3><h2 id=\"Protobuf\"><a href=\"#Protobuf\" class=\"headerlink\" title=\"Protobuf\"></a>Protobuf</h2><p>fallthrough   在switch 语句中进行穿透，链接两个case </p>\n<p>函数：</p>\n<p>当参数类型一致时，前一个参数可以省略类型</p>\n<p>函数参数中如果有可变参数，可变参数放到最后，参数列表中只能有一个可变参数</p>\n<p>函数返回值</p>\n<p>指针</p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":"<h1 id=\"Golang\"><a href=\"#Golang\" class=\"headerlink\" title=\"Golang\"></a>Golang</h1><h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"数值类型\"><a href=\"#数值类型\" class=\"headerlink\" title=\"数值类型\"></a>数值类型</h3><h4 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool\"></a>bool</h4><h4 id=\"byte\"><a href=\"#byte\" class=\"headerlink\" title=\"byte\"></a>byte</h4><p>byte = uint8</p>\n<h4 id=\"int\"><a href=\"#int\" class=\"headerlink\" title=\"int\"></a>int</h4><p>有符号类型：int8，int16，int32，int64<br>无符号类型：uint8，uint16，uint32，uint64<br>rune = int32</p>\n<h4 id=\"float\"><a href=\"#float\" class=\"headerlink\" title=\"float\"></a>float</h4><p>float16，float32</p>\n<h4 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h4><h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><h3 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h3><h4 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h4><h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>go语言的变量声明了就必须使用，不用就别声明，否则编译不通过</p>\n<h3 id=\"函数变量声明\"><a href=\"#函数变量声明\" class=\"headerlink\" title=\"函数变量声明\"></a>函数变量声明</h3><h4 id=\"单一变量声明\"><a href=\"#单一变量声明\" class=\"headerlink\" title=\"单一变量声明\"></a>单一变量声明</h4><p>关键字    变量名称    变量类型</p>\n<pre><code class=\"go\">var a    int    </code></pre>\n<p>声明的同时可以赋值变量，同时赋值可以省略变量类型</p>\n<pre><code class=\"go\">var a    = 0    </code></pre>\n<h4 id=\"多变量同时声明1\"><a href=\"#多变量同时声明1\" class=\"headerlink\" title=\"多变量同时声明1\"></a>多变量同时声明1</h4><p>关键字    变量名称，变量名称    变量类型<br>多变量同时声明时，必须为多个类型一样的变量</p>\n<pre><code class=\"go\">var a,b,c int</code></pre>\n<p>声明的同时可以赋值变量，同时赋值时可以省略变量类型</p>\n<pre><code class=\"go\">var a,b,c = 0,0,0</code></pre>\n<h4 id=\"多变量同时声明2\"><a href=\"#多变量同时声明2\" class=\"headerlink\" title=\"多变量同时声明2\"></a>多变量同时声明2</h4><p>关键字    （<br>变量名称    变量类型<br>变量名称    变量类型<br>）<br>带有括号的多变量赋值时，变量类型可以不同</p>\n<pre><code class=\"go\">var (\n  a int\n  b string\n)</code></pre>\n<p>其中并且可以进行赋值操作，变量类型可以直接省略</p>\n<pre><code class=\"go\">var (\n  a = 0\n  b = &quot;bb&quot;\n)</code></pre>\n<h4 id=\"简短声明赋值\"><a href=\"#简短声明赋值\" class=\"headerlink\" title=\"简短声明赋值\"></a>简短声明赋值</h4><p>变量名称  :=  变量值</p>\n<pre><code class=\"go\">a := 0</code></pre>\n<h3 id=\"全局变量声明\"><a href=\"#全局变量声明\" class=\"headerlink\" title=\"全局变量声明\"></a>全局变量声明</h3><p>全局变量声明，包含以上<strong>单一变量声明</strong>，<strong>多变量同时声明1</strong>，<strong>多变量同时声明2</strong>，声明方式，但是只有<strong>多变量同时声明2</strong>声明方式可以同时进行赋值操作，其他方式不支持赋值操作</p>\n<h3 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h3><p>&amp;：取地址</p>\n<p>*：取值</p>\n<h4 id=\"指针数组\"><a href=\"#指针数组\" class=\"headerlink\" title=\"指针数组\"></a>指针数组</h4><p>*[4]Type<br>首先是一个指针，存储的是数组地址</p>\n<p>var arr [3]int{1,2,3}</p>\n<p>var p1 *[3]int</p>\n<p>p1=&amp;arr</p>\n<p>(*p1)[2]=100 简写成：p1[2]=100。p1操作的是arr数组</p>\n<h4 id=\"数组指针\"><a href=\"#数组指针\" class=\"headerlink\" title=\"数组指针\"></a>数组指针</h4><p>首先是一个数组，存储的是指针</p>\n<p>[4]*Type</p>\n<blockquote>\n<p>注意：<br>   *[4]int    //指针，4个长度的int类型数组的指针<br>   [4]*int    //数组，4个长度的int指针地址的数组<br>   *[4]*int    //指针，4个长度int指针地址数组的指针<br>   **[4]*int    //指针，4个长度int指针地址数组的指针的指针</p>\n</blockquote>\n<h2 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h2><h3 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h3><ul>\n<li><p>简单形式</p>\n<pre><code class=\"go\">if 1==2 {\n\n}</code></pre>\n</li>\n<li><p>复合形式</p>\n<ul>\n<li><p>1</p>\n<pre><code class=\"go\">if a := 0; a ==0 {\n\n}</code></pre>\n</li>\n<li><p>2</p>\n<pre><code class=\"go\">if  {\n\n}</code></pre>\n<p>当不写条件时，当作true处理</p>\n<h3 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h3></li>\n</ul>\n</li>\n<li><p>简单形式</p>\n<pre><code class=\"go\">a := 1\nswitch a {\ncase 1:\n  println(1111)\ndefault:\n}</code></pre>\n</li>\n</ul>\n<ul>\n<li><p>复合形式</p>\n<ul>\n<li><p>1</p>\n<pre><code class=\"go\">\nswitch a := 1; a {\ncase 1:\n  println(1111)\ncase 2,3,4:\n  println(222,333,444)\ndefault:\n}</code></pre>\n</li>\n<li><p>2</p>\n<pre><code class=\"go\">a := 4\nswitch  {\ncase a&gt;=0:\n  println(&quot;&gt;=0&quot;)\ncase a&lt;=5:\n  println(&quot;&lt;=4&quot;)\n}</code></pre>\n<p>当不写条件时，当作true处理。此处只会输出一种情况<code>&gt;=0</code>，switch处理时只要满足一种情况就不会再进行判断</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"switch穿透-fallthrough\"><a href=\"#switch穿透-fallthrough\" class=\"headerlink\" title=\"switch穿透 fallthrough\"></a>switch穿透 fallthrough</h4><pre><code class=\"go\">  a := 1\n  switch a {\n  case 1:\n    println(1111)\n    fallthrough\n case 2:\n    println(2222)\n  default:\n  }\n\n  =======输出为=======\n  1111\n  2222</code></pre>\n<p>fallthrough 可以穿透case，链接上下两个case一起执行</p>\n<blockquote>\n<p>注意：<br>a := 1<br>switch a {</p>\n<p>default:<br>    println(“default”)</p>\n<p>  case 1:<br>    println(1111)</p>\n<p>}<br>=================输出为===========<br>1111</p>\n</blockquote>\n<h2 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h2><p>go语言里面没有while，do while 等其他循环结构，只有for</p>\n<ul>\n<li><p>简单形式</p>\n<pre><code class=\"go\">for i := 0; i &lt; 10; i++ {\n\n}</code></pre>\n</li>\n<li><p>复合形式</p>\n<ul>\n<li><p>1</p>\n<pre><code class=\"go\">for {\n\n}</code></pre>\n<p>不写条件，当作true处理</p>\n</li>\n<li><p>2 </p>\n<pre><code class=\"go\">for index,value := range []int{1,2,3,4} {\n  fmt.Printf(&quot;index:%d,value:%d \\n&quot;,index,value)\n}</code></pre>\n<p>range关键字可以取出数组，切片，集合等容器里面的数据</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"defer关键字\"><a href=\"#defer关键字\" class=\"headerlink\" title=\"defer关键字\"></a>defer关键字</h2><p>defer 延迟，推迟执行。遵循栈的执行原则先进后出，参数变量是已经传递，是在return语句前执行</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>func name(a int,b int) (int){</p>\n<p>return 0</p>\n<p>}</p>\n<h3 id=\"函数返回值\"><a href=\"#函数返回值\" class=\"headerlink\" title=\"函数返回值\"></a>函数返回值</h3><pre><code class=\"go\">func name ()(int){\n\nreturn 1\n\n}\n\n\n\nfunc name ()int{\n\nreturn 1\n\n}\n\n\n\nfunc name ()(sum int){\n\nsum:=1\n\nreturn\n\n}\n</code></pre>\n<h2 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h2><p>深拷贝，值传递</p>\n<ul>\n<li><p>简单</p>\n<pre><code class=\"go\">type    name    struct {\n  a int\n  b string\n}</code></pre>\n</li>\n<li><p>匿名结构体</p>\n<pre><code class=\"go\">struct {\n  a int\n  b string\n}</code></pre>\n</li>\n<li><p>匿名结构体字段</p>\n<pre><code class=\"go\">type    name    struct {\n int\n string\n}</code></pre>\n<p>匿名结构体字段访问时，使用匿名字段类型<code>name.int</code>，<code>name.string</code>，匿名的字段类型不能重复</p>\n<pre><code class=\"go\">type    name    struct {\n int\n string\n int    //不可以\n}</code></pre>\n</li>\n</ul>\n<h3 id=\"提升字段\"><a href=\"#提升字段\" class=\"headerlink\" title=\"提升字段\"></a>提升字段</h3><p>结构体可以嵌套，当一个结构体内嵌套另一个匿名结构体时，可以直接使用字段名称访问被嵌套结构体的字段，这叫做字段提升。<br>字段提升只有在被嵌套结构体为匿名的时候可用。<br>如果结构体中的字段与被嵌套结构体的字段一样，则访问的为本结构体字段</p>\n<pre><code class=\"go\">type Person struct {\n    name string\n    age int\n}\n\ntype Student struct {\n    Person\n    addre string\n    name string\n}\n\np:=Person{&quot;nihao&quot;,10}\nfmt.Println(p)\n\ns:=Student{Person{&quot;wohao&quot;,20},&quot;beij&quot;,&quot;djh&quot;}\nfmt.Println(s)\nfmt.Println(s.Person.name,s.Person.age,s.addre,s.name)\nfmt.Println(s.name,s.age,s.addre)\n\n\n======================输出为============================\n\n{nihao 10}\n{{wohao 20} beij djh}\nwohao 20 beij djh\ndjh 20 beij</code></pre>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>方法是一个作用在struct结构体上的函数</p>\n<pre><code class=\"go\">func (s Struct) name() {\n\n}</code></pre>\n<p>实例</p>\n<pre><code class=\"go\">type Person struct {\n    name string\n    age int\n}\n\ntype Student struct {\n    Person\n    addre string\n    name string\n}\nfunc (p Person) run(){\n    fmt.Println(&quot;p run&quot;)\n}\n\nfunc (s Student) run()  {\n    fmt.Println(&quot;s run&quot;)\n}\n\n\n\np:=Person{&quot;lisi&quot;,10}\nfmt.Println(p)\np.run()\ns:=Student{Person{&quot;wangwu&quot;,20},&quot;beij&quot;,&quot;xiaowangwu&quot;}\nfmt.Println(s)\ns.Person.run()\ns.run()\n\n\n\n\n\n===============输出为================\n{lisi 10}\np run\n{{wangwu 20} beij xiaowangwu}\np run\ns run</code></pre>\n<h2 id=\"接口（interface）\"><a href=\"#接口（interface）\" class=\"headerlink\" title=\"接口（interface）\"></a>接口（interface）</h2><p>接口可以看作是一些方法的集合。接口是为了解耦合，go语言的接口是非侵入式的。空接口可以看作是任意类型</p>\n<pre><code class=\"go\">type name interface{\n  start()\n  end()\n}</code></pre>\n<h3 id=\"接口断言\"><a href=\"#接口断言\" class=\"headerlink\" title=\"接口断言\"></a>接口断言</h3><p>利用接口来判断类型</p>\n<ul>\n<li>1<br>instance := 接口对象.(实际类型)   //不安全，会panic（）<br>instance,err := 接口对象.(实际类型)    //安全</li>\n<li>2<br>switch instance := 接口对象.(type) {<br>  case 实际类型：<pre><code>xxx</code></pre>  case 实际类型：<pre><code>xxxx</code></pre>}</li>\n</ul>\n<h2 id=\"type-关键字\"><a href=\"#type-关键字\" class=\"headerlink\" title=\"type 关键字\"></a>type 关键字</h2><ul>\n<li>定义新类型<br>type myint int<br>定义一个int类型的myint类型，但是int和myint类型不一样不能通用</li>\n<li>给类型其别名<br>type myint = int<br>给一个int类型起一个别名，int和myint可以通用</li>\n</ul>\n<h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h3><h3 id=\"make\"><a href=\"#make\" class=\"headerlink\" title=\"make\"></a>make</h3><ul>\n<li><p>slice</p>\n<ul>\n<li>make([]int,10)<br>长度（len）和容量（cap）都为10，默认值为int的零值</li>\n<li>make([]int,0,10)<br>长度（len）为0，和容量（cap）为10，因为0个长度所以没有值</li>\n</ul>\n</li>\n<li><p>map</p>\n<ul>\n<li><p>make(map[string]string)</p>\n</li>\n<li><p>make(map[string]string,10)</p>\n</li>\n</ul>\n</li>\n<li><p>chan</p>\n<ul>\n<li>make(chan bool)<br>没有缓存的chan</li>\n<li>make(chan bool,10)<br>长度为10的chan</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"访问权限\"><a href=\"#访问权限\" class=\"headerlink\" title=\"访问权限\"></a>访问权限</h2><p>名称首字母大写时，可以在其他地方导入，小写其他地方访问不了</p>\n<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><h2 id=\"协程（Gorutine）\"><a href=\"#协程（Gorutine）\" class=\"headerlink\" title=\"协程（Gorutine）\"></a>协程（Gorutine）</h2><h2 id=\"管道（chan）\"><a href=\"#管道（chan）\" class=\"headerlink\" title=\"管道（chan）\"></a>管道（chan）</h2><h2 id=\"反射（reflect）\"><a href=\"#反射（reflect）\" class=\"headerlink\" title=\"反射（reflect）\"></a>反射（reflect）</h2><h3 id=\"基本数据类型反射使用\"><a href=\"#基本数据类型反射使用\" class=\"headerlink\" title=\"基本数据类型反射使用\"></a>基本数据类型反射使用</h3><h4 id=\"修改值\"><a href=\"#修改值\" class=\"headerlink\" title=\"修改值\"></a>修改值</h4><ul>\n<li>step1:<br>获取反射对象Value。要修改对象，就要获取对象的地址，用对象的引用地址来更改里面的具体值<pre><code class=\"go\">var a int = 0\nvalue := reflect.ValueOf(&amp;a)</code></pre>\n</li>\n<li>step2:<br>获取反射对象的指针对象<pre><code class=\"go\">elem := value.Elem()</code></pre>\n</li>\n<li>step3:<br>修改值<pre><code class=\"go\">elem.SetInt(9)</code></pre>\n</li>\n</ul>\n<p>完整步骤：</p>\n<pre><code class=\"go\">var a int = 0\nvalue := reflect.ValueOf(&amp;a)\nelem := value.Elem()\nif !elem.CanSet {  //判断反射对象是否可以修改，不可以直接返回不做修改\n  return\n}\n\nif elem.Kind() ==reflect.Int{ //判断对象是否是int类型\n  elem.SetInt(9)\n}\n</code></pre>\n<h3 id=\"函数调用\"><a href=\"#函数调用\" class=\"headerlink\" title=\"函数调用\"></a>函数调用</h3><pre><code class=\"go\">func star()  {\n  fmt.Println(&quot;call this func&quot;)\n}\n\nvalueOf := reflect.ValueOf(star)  //这里star不能加（）\n\nif valueOf.Kind() == reflect.Func {\n  valueOf.Call(nil)\n}</code></pre>\n<h3 id=\"struct-的反射使用\"><a href=\"#struct-的反射使用\" class=\"headerlink\" title=\"struct 的反射使用\"></a>struct 的反射使用</h3><h4 id=\"获取字段名称和具体值\"><a href=\"#获取字段名称和具体值\" class=\"headerlink\" title=\"获取字段名称和具体值\"></a>获取字段名称和具体值</h4><ul>\n<li><p>step1:<br>获取反射valueOf和typeOf实例</p>\n<pre><code class=\"go\">type Person struct {\n  Name string\n  Age  int\n}\np:=Person{&quot;zhangshan&quot;,30}\n\nvalueOf := reflect.ValueOf(p)\ntypeOf := reflect.TypeOf(p)</code></pre>\n</li>\n</ul>\n<ul>\n<li><p>step2:<br>通过实例获取字段名称和字段实际值</p>\n<pre><code class=\"go\">for i := 0; i &lt; typeOf.NumField(); i++ {\n  fmt.Println(&quot;fieldname:  &quot;,typeOf.Field(i).Name)\n  fmt.Println(&quot;value:  &quot;,valueOf.Field(i))\n}</code></pre>\n</li>\n</ul>\n<p>完整代码：</p>\n<pre><code class=\"go\">type Person struct {\n  Name string\n  Age  int\n}\n\np:=Person{&quot;zhangshan&quot;,30}\n\nvalueOf := reflect.ValueOf(p)\ntypeOf := reflect.TypeOf(p)\n\n\nfor i := 0; i &lt; typeOf.NumField(); i++ {\n  fmt.Println(&quot;fieldname:  &quot;,typeOf.Field(i).Name)\n  fmt.Println(&quot;value:  &quot;,valueOf.Field(i))\n}</code></pre>\n<h4 id=\"修改字段值\"><a href=\"#修改字段值\" class=\"headerlink\" title=\"修改字段值\"></a>修改字段值</h4><ul>\n<li><p>step1:<br>获取反射valueOf实例</p>\n<pre><code class=\"go\">type Person struct {\n  Name string\n  Age  int\n}\np:=Person{&quot;zhangshan&quot;,30}\n\nvalueOf := reflect.ValueOf(&amp;p)  //这里要填写p的地址</code></pre>\n</li>\n<li><p>step2:<br>修改相应的字段值</p>\n<pre><code class=\"go\">valueOf.Field(0).SetString(&quot;wangwu&quot;)</code></pre>\n</li>\n</ul>\n<p>完整代码：</p>\n<pre><code class=\"go\">type Person struct {\n    Name string\n    Age  int\n}\np:=Person{&quot;zhangshan&quot;,30}\n\nvalueOf := reflect.ValueOf(&amp;p)  //这里要填写p的地址\n\nif valueOf.Kind() == reflect.Ptr {\n  if valueOf.Elem().CanSet(){\n    elem := valueOf.Elem()\n  //  field := elem.Field(0)  //通过字段序号获取字段\n    field := elem.FieldByName(&quot;Name&quot;)  //通过字段名称来获取字段\n    field.SetString(&quot;wangwu&quot;)\n  }\n}</code></pre>\n<blockquote>\n<p>注意：<br>Person的字段为大写开头，为可访问字段，如果小写，则会发生程序panic<br><code>reflect: reflect.flag.mustBeAssignable using value obtained using unexported field</code></p>\n</blockquote>\n<h4 id=\"调用方法\"><a href=\"#调用方法\" class=\"headerlink\" title=\"调用方法\"></a>调用方法</h4><h5 id=\"调用无参数方法\"><a href=\"#调用无参数方法\" class=\"headerlink\" title=\"调用无参数方法\"></a>调用无参数方法</h5><ul>\n<li><p>step1:<br>获取反射valueOf实例</p>\n<pre><code class=\"go\">type Person struct {\n  Name string\n  Age  int\n}\np:=Person{&quot;zhangshan&quot;,30}\n\nfunc (p Person) Run() {\n  fmt.Println(&quot;p run&quot;)\n}\n\nvalueOf := reflect.ValueOf(p)</code></pre>\n</li>\n<li><p>step2:<br>通过反射实例获取方法实例</p>\n<pre><code class=\"go\">method := valueOf.MethodByName(&quot;Run&quot;)</code></pre>\n</li>\n<li><p>step3:<br>调用方法</p>\n<pre><code class=\"go\">method.Call(nil)</code></pre>\n</li>\n</ul>\n<p>完整代码：</p>\n<pre><code class=\"go\">type Person struct {\n  Name string\n  Age  int\n}\np:=Person{&quot;zhangshan&quot;,30}\n\nfunc (p Person) Run() {  //方法名称一定要大写\n  fmt.Println(&quot;p run&quot;)\n}\n\nvalueOf := reflect.ValueOf(p)\n\n// method := valueOf.Method(0)  //通过序号获取方法实例\nmethod := valueOf.MethodByName(&quot;Run&quot;)\n\nif method.Kind() == reflect.Func {\n  // method.Call(make([]reflect.Value,0))  //传入一个空切片\n  method.Call(nil)  //直接传入nil空值\n}</code></pre>\n<h5 id=\"调用多参数方法\"><a href=\"#调用多参数方法\" class=\"headerlink\" title=\"调用多参数方法\"></a>调用多参数方法</h5><p>调用多参数方法和无参数方法执行步骤一样，只是在调用时传入参数的切片即可<code>method.Call([]reflect.Value{reflect.ValueOf(&quot;lii&quot;),reflect.ValueOf(&quot;nihao&quot;),reflect.ValueOf(5)})</code></p>\n<pre><code class=\"go\">func (s Person) Write(name string,msg string, length int) {\n  fmt.Println(name,&quot;写了&quot;,msg,&quot;一共&quot;,length)\n}</code></pre>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h2><h3 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h3><h2 id=\"Protobuf\"><a href=\"#Protobuf\" class=\"headerlink\" title=\"Protobuf\"></a>Protobuf</h2><p>fallthrough   在switch 语句中进行穿透，链接两个case </p>\n<p>函数：</p>\n<p>当参数类型一致时，前一个参数可以省略类型</p>\n<p>函数参数中如果有可变参数，可变参数放到最后，参数列表中只能有一个可变参数</p>\n<p>函数返回值</p>\n<p>指针</p>\n"},{"title":"Redis","date":"2019-12-26T15:50:21.000Z","_content":"\n# Redis（Remote Dictionary Server）\n\n\n\n## Redis 运行快速的原因\n\n1. 完全基于内存操作\n\n2. 数据结构简单，数据操作也简单\n\n3. 使用多路I/O复用模型\n\n## 数据类型\n### String\n#### 单条操作\n1. 增：set\tkey\tvalue\n2. 查：get\tkey\n3. 删：del\tkey\n\n#### 多条操作\n1. 增：mset\tkey\tvalue\t[key1\tvalue1]\n2. 查：mget\tkey\t[key1]\n\n#### 其他命令\n1. strlen\tkey\t//获取字符串长度\n2. append\tkey\tvalue\t//有则追加，无则新建\n3. setnx\tkey\tvalue\t//不存在就设置，存在就不设置\n4. incr\tkey\t//自增 1\n5. incrby\tkey\tnum  //给key的值增加num（int 类型），num 正数则为加，num 为负数 则为减\n6. incrbyfloat\tkey\tnum\t//给key的值增加num（float 类型）\n7. decr\tkey  //自减 1\n8. decrby\tkey\tnum\t//给key的值减num\n9. setex\tkey\tsecond\tvalue\t//设置key的值为value存活时间为second秒\n10. psetex\tkey\tmillisecond\tvalue\t//设置key的值为value存活时间为millisecond毫秒\n\n>注：\n>字符串值最大值为512m\n\n### Hash\n和字符串相似，可理解为字符串厘米套字符串\n\n#### 单条操作\n1. 增：hset\tkey\tfield\tvalue\t\n2. 查：hget\tkey\tfield\n3. 删：hdel\tkey\tfield\n\n#### 多条操作\n1. 增：hmset\tkey\tfield\tvalue\t[field1\tvalue2]\n2. 查：hmget\tkey\tfield\t[field1]\n\n#### 其他命令\n1. hgetall\tkey\t//获取key的全部的值\n2. hlen\tkey\t//获取key的值的数量\n3. hexists\tkey\tfield\t//是否存在field\n4. hkeys\tkey\t//所有key的字段（field）\n5. hvals\tkey\t//所有key的值 \n6. hincrby\tkey\tfield\tnum\t//给key的field的值增加num （num 为int值）\n7. hincrybyfloat\tkey\tfield\tnum\t//给key的field的值增加num （num 为float）\n8. hsetnx\tkey\tfield\tvalue\t//存在不设置，不存在设置\n\n>注：\n>1. Hash类型的value只能存字符串，不允许再嵌套其他类型，如果数据为空为Nil\n>2. 每个Hash可以存储$2^{32}-1$个键的值对\n>3. Hash类型十分贴近对象的数据存储，并且可以灵活添加、删除对象属性。但Hash类型设计并不是存在量而设计的，切记不可滥用，更不可将Hash作为对象列表使用\n>4. hgetall操作可以获取全部属性，如果内部field过多，遍历整体数据时效率会降低，很有可能成为数据访问的瓶颈\n\n### String存储对象（Json） VS Hash存储对象\n1. String存在对象讲究整体性，以读为主\n2. Hash存储对象讲究分散性，以写为主\n\n### List\n讲究顺序\n#### 添加\n1. lpush\tkey\tvalue\t[value1]\t//从左添加\n2. rpush\tkey\tvalue\t[value1]\t//从右添加\n\n#### 获取\n1. lrange\tkey\tstart\tstop\n2. lindex\tkey\tindex\n3. llen\tkey\n\n#### 获取并移除\n1. lpop\tkey\t//从左出\n2. rpop\tkey\t//从右出\n\n~~~tex\nlpush\tlist\ta\tb\tc\n结果：c b a\n===============================\nrpush list a\tb\tc\n结果：a b c\n===============================\nlist=[a\tb\tc]\nlpop list\n结果：b c\n===============================\nlist=[a b c]\nrpop list\n结果：a b\n===============================\n~~~\n\n>注：\n>1. list中保存的数据都是String，数据总量是有限的，最多$2^{32}-1$个元素\n>2. list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作（或以栈的形式进行入栈出栈操作）\n>3. 当stop的值为-1时，获取的是全部数据\n>4. list对数据进行分页操作，通常第一页的数据使的信息来自list，其他页面的数据通过数据形式进行加载\n\n### Set\n#### 命令\n1. 增：sadd\tkey\tmember\t[member1]\n2. 查：smembers\tkey\n3. 删：srem\tkey\tmember\t[member1]\n4. 获取总量：scard\tkey\n5. 判定是否存在：sismember\tkey\tmember\n6. 随机获取（原集合保留）：srandmember\tkey\t[count]\n7. 随机获取（原集合不保留）：spop\tkey\n8. 集合交集：sinter\tkey\tkey1\tkey2\n9. 集合并集：sunion\tkey\tkey1\tkey2\n10. 集合差集：sdiff\tkey\tkey1\tkey2\n11. 存储集合交集：sinterstore\tdestination\tkey\tkey1\tkey2\n12. 存储集合并集：sunionstore\tdestination\tkey\tkey1\tkey2\n13. 存储集合差集：sdiffstore\tdestination\tkey\tkey1\tkey2\n14. 集合元素移动：smove\tsource\tdestination\tmember\n\n### Sorted_Set\n#### 命令\n1. 增：zadd\tkey\tscore\tmember\t[score1\tmember1]\n2. 删：zrem\tkey\tmember\t[member1]\n3. 获取全部（正序）：zrange\tkey\tstart\tstop\t[withscores]\n4. 获取全部（倒序）：zrevrange\tkey\tstart\tstop\t[withscores]\n5. 按条件查（正序）：zrangebyscore\tkey\tmin\tmax\t[withscore\tlimit]\n6. 按条件查（倒序）：zrevrangebyscore\tkey\tmax\tmin\t[withscore\tlimit]\n7. 按条件删除（索引）：zremrangebyrank\tkey\tstart\tstop\n8. 按条件删除（积分）：zremrangebyscore\tkey\tmin\tmax\n9. 获取集合总量：zcard\tkey\t|\tzcount\tkey\tmin\tmax\n10. 存储集合交集：\tzinterstore\tdestination\tnumkeys\tkey\tkey1\n11. 存储集合并集：zunionstore\tdestination\tnumkeys\tkey\tkey1\n12. 获取索引（正序）：zrank\tkey\tmember\n13. 获取索引（倒序）：zrevrank\tkey\tmember\n14. score值获取：zscore\tkey\tmember\n15. score值修改：zincrby\tkey\tnum\tmember\n\n## Key的操作\n### 命令\n1. 删除：del\tkey\n2. 判断是否存在：exists\tkey\n3. 获取key类型：type\tkey\n4. 指定有效期：\n\t1.\texpire\tkey\tseconds\n\t2.\tpexpire\tkey\tmilliseconds\n\t3.\texpireat\tkey\ttimestamp\n\t4.\tpexpireat\tkey\tmilliseconds-timestamp\n5. 获取有效期：\n\t1.\tttl\tkey\n\t2.\tpttl\tkey\n6.\t设置永久：persist\tkey\n7.\t查询key：key\tpattern\t//*,?,[]\n8.\t重命名：rename\tkey\tnewkey\t|\trenamenx\tkey\tnewkey\n9.\t对key排序：sort\n\n## 数据库操作\n### 命令\n1. 选择数据库：select\tindex\n2. 数据移动：move\tkey\tdb\n3. 数据库大小：dbsize\n4. 数据清除：\n\t1. 单库删除：flushdb\n\t2. 多库删除：flushall\n\n## 持久化\n### RDB（Relational Database）\n#### 保存数据\n1. 指令（前台）：save\t//阻塞 立即保存\n2. 指令（后台）：bgsave\t//不立即执行\n3. 配置：save\tsecond\tchanges\t//用bgsave执行操作\n\n#### 常用配置项\n1. 数据文件名称：dbfilename\tdump.rdb\t//默认\n2. 数据保存路径：dir\n3. 是否开启压缩：rdbcompression\tyes\t//默认\n4. 是否开启格式检查：rdbchecksum\tyes|no //默认no\n\n#### RDB 持久化优点\n1. RDB是一个紧凑压缩的二进制文件，存储效率高\n2. RDB存储的是Redis在某个时间点的数据快照，非常适用于数据备份全量复制等场景\n3. RDB恢复数据速度比AOF快\n\n#### RDB应用\n服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复\n\n#### RDB持久化缺点\n1. RDB方式无论是执行命令还是进行配置，无法做到实时持久化，具有较大可能丢失数据\n2. bgsave每次运行要执行fork操作创建子进程，要牺牲一些性能\n3. Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各个版本服务器之间数据格式无法兼容\n4. 存储数量较大时，效率较低\n5. 大数据量下的I／O性能较低\n6. 基于fork创建子进程，内存产生额外消耗\n7. 宕机带来的数据丢失风险\n\n### AOF（Append Only File）\n#### 保存数据策略\n每次：always\n每秒：everysec\n系统控制：no\n\n#### 配置\n1. 是否开启：appendonly\tyes|no\t//默认no\n2. 保存策略：appendfsync\talways|everysec|no\n3. 重写：\n\t手动：bgrewriteaof\n\t自动：\n\t\tauto-aof-rewrite-min-size\tsize\n\t\tauto-aof-rewrite-percentage\tpercentage\n\n### RDB 与 AOF 如何选择\n对数据非常敏感，建议使用默认的AOF持久化方案\n\tAOF策略使用everysec，每秒fsync一次，该策略仍可保持很好性能，出现问题最多丢失一秒内的数据\n数据呈现阶段有效性，建议使用RDB持久化方案\n\t数据可以做到阶段内无丢失，且恢复较快，阶段点数据恢复通常使用RDB方案\n>注意：\n>AOF文件存储体积较大，恢复速度较慢\n>利用RDB使用线紧凑的数据持久化会使Redis性能降低\n\n综合：\n1. RDB与AOF选择实际上是在一种权衡，每种都有利有弊\n2. 如果不能承受分钟内的数据丢失，对业务数据非常敏感，选用AOF\n3. 如果能承受分钟内的数据丢失，且追求大数据集的恢复速度选用RDB\n4. 灾难恢复选用RDB\n5. 双保险策略，同时开启RDB和AOF，重启后Redis优先使用AOF来恢复数据，降低丢失数据量\n\n## 事务\nRedis事务不具有回滚机制\n\n### 命令\n1. 开启：multi\n2. 结束：exec\n3. 中断：discard\n\n### 事务中的错误\n#### 命令错误\n执行事务过程中输入的命令出现错误，Redis会结束事务不再执行，并报出错误的命令\n\n#### 操作错误\n执行事务过程中输入的命令正确，其他操作错误，事务中其他命令正常执行，错误操作报错\n\n## 锁\nRedis中锁和事务是相搭配使用的，可解决对key的监控\n\n### 命令\n加锁：watch\tkey\t[key1]\n解锁：unwatch  //取消掉所有key的监控\n\n## 数据删除策略\n当key过期后执行数据删除的策略\n### 定时删除（即可删除）\n创建一个具有时效性的key时，同时会创建一个定时器来监控该key是否过期，当key过期后立即进行key的删除\n\n优点：节约内存，到时就会进行删除，快速释放占用空间\n缺点：CPU压力大影响Redis响应时间和吞吐量\n总结：用处理器性能换取存储空间\n\n### 惰性删除\n当一个具有实效性的key过期后不会有删除操作，直到下一次调用时会先检查该key是否过期，如果过期则进行删除操作，并返回nil（该key不存在）\n\n优点：节约CPU性能，发现必须删除的时候才会删除\n缺点：内存压力大，出现长期占用内存的数据\n总结：用存储空间换取处理器性能\n\n### 定期删除\nRedis会根据设置的参数，定期对具有时效性的key进行清理工作，它是定时删除和惰性删除的结合者，既不像定时删除会立即进行删除给予CPU压力，也不会像惰性删除给予内存压力\n\n#### 步骤\n1. Redis启动服务器初始化时，读取配置server.hz的值（默认为10）\n2. 每秒钟执行server.hz次serverCron（）服务（serverCron【服务器级别】->databasesCron【数据库级别】->activeExpireCyle【活跃数据级别】）\n3. acitveExpireCyle（）对每个expires[*]（数据库）逐一进行检测，每次执行250ms／server.hz\n4. 对某个expires[*]检测时，随机挑选w个key进行检测\n\t1. 如果key超时，删除key\n\t2. 如果一轮中删除的kye的数量>w*25%，循环该过程\n\t3. 如果一轮中删除的可以的数量<=w*25%检查下一个expires[*],0-15（所有的数据库）循环\n>W=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP\n>参数current_db用于记录activeExpireCyle进入哪个expires[*]执行\n\n## 数据淘汰策略\n当内存到达最大内存限制时进行的数据淘汰策略\n\n数据驱逐淘汰策略配置依据，使用info命令输出相关监控信息，查新缓存hit 命中次数和miss的次数，根据业务调优\n### 配置\n1. 最大可用内存：maxmemory\t//默认为0，一般设置全部内存50%以上\n2. 每次选取带删除数据个数：maxmemory-samples\t//采用随机获取方式\n3. 删除策略：maxmemory-policy\t//达到最大内存后，对被选取带数据进行的删除策略\n\n### 检测易失数据集（可能会过期数据server.db[i].expires）\n1. volatile-lru：挑选最近最少使用的数据淘汰（最近数据中使用时间离当前最远的数据）。**常用**\n2. volatile-lfu：挑选最近使用次数最少的数据淘汰（最近数据中使用次数最少的数据）\n3. volatile-ttl：挑选将要过期数据淘汰\n4. volatile-random：任意挑选数据淘汰\n\n>ttl：time to live\n>lru：least recently\tused\n>lfu：least frequently\tused\n\n### 检测全库数据（所有数据集server.db[i].dict）\n1. allkeys-lru：挑选最近最少使用的数据淘汰\n2. allkeys-lfu：挑选最近使用次数最少的数据淘汰\n3. allkeys-random：任意挑选数据淘汰\n\n### 放弃数据驱逐\nno-enviction\t//禁止驱逐数据\n4.0中默认策略，会引发OOM\n\n## 服务器基本配置\n1. 设置服务器守护进程方式：daemonize\tyes|no\n2. 绑定地址：bing\t127.0.0.1\n3. 设置服务器端口：port\t6379\n4. 设置数据库数量：databases\t16\n5. 设置服务器日志级别：loglevel\tdebug|verbose|notice|warning\n6. 日志文件名称：logfile\t端口号.log\n7. 设置客户端最大连接数：maxclients\t0\n8. 客户端闲置最大等待时长：timeout\t0\n\n## 高级数据类型\n### Bitmaps\n标记统计\n\n#### 命令\n1. 获取：getbit\tkey\toffset\n2. 设置：setbit\tkey\toffset\tvalue\t// 0 或 1\n3. 交、并、或异\n\tbitop\top\tdestkey\tkey1\tkey2\n\top：\n\t\t交：and\n\t\t并：or\n\t\t非：not\n\t\t异或：xor\n4. 统计指定key中1的数量：bitcount\tkey\t[start\tend]\n\n### HyperLoglog\n基数统计\n#### 命令\n1. 添加：pfadd\tkey\telement\t[element1]\n2. 统计：pfcount\tkey\t[key1]\n3. 合并：pfmerge\tdestkey\tsourcekey\t[sourcekey1]\n\n### GEO\n距离计算（只计算水平距离）\n\n#### 命令\n1. 添加：geoadd\tkey\tlongitude\tlatitude\tmember\t[longitude1\tlatitude1\tmember1]\n2. 获取：geopos\tkey\tmember\t[member1]\n3. 计算距离：geodist\tkey\tmember1\tmember2\t[count]\n4. 根据坐标求范围内数据：georadius\tkey\tlongitude\tlatitude\tradius\tm|km|ft|mi\n5. 根据点求范围内的数据：georadusbymember\tkey\tmember\tradius\tm|km|ft|mi\n6. 获取指定点对应的hash值：geohash\tkey\tmember\t[member1]\t\n\n## 主从复制\n### 创建链接\n+ 方式一：客户端发指令：slaveof\tmasterip masterport\n+\t方式二：参数启动：redis-server\t--slaveof\tmasterip masterport\n+\t方式三：服务器配置：slaveof\tmasterip masterport\n\n### 数据同步 \n#### 全量复制\n从：发送指令（psync2）\n主：执行bgsave\n主：第一个slave链接时，创建命令缓冲区\n主：生成RDB文件，通过socket发送给slave\n从：接收RDB文件，清空自己数据，执行RDB文件恢复过程\n\n#### 部分复制\n从：发送命令告知RDB恢复完成\n主：发送复制缓冲区信息\n从：接收信息，执行bgsavewriteaof，恢复数据\n\n## 哨兵模式\n### 配置\nsentinel.conf\n\n启动：redis-sentinel\n\n## 集群（cluster）\n### 配置\n1. 开启：cluster-enabled\tyes|no\n2. 配置文件名称：cluster-config-file\tfilename\n3. 节点超时时间：cluster-node-timeout\tmilliseconds\n4. master链接slave最小数：cluster-migration-barrier\tcount\n\n### 命令\n1. 查看节点信息：cluster nodes\n2. 从一个节点Redis，切换其主节点：cluster\treplicate\tmasterip\n3. 新增主节点：cluster meet\tip:port\n4. 忽略一个节点：cluster\tfoeget\tid\n5. 手动故障转移：cluster\tfailover\n\n","source":"notes/Redis.md","raw":"---\ntitle: Redis\ndate: 2019-12-26 23:50:21\n---\n\n# Redis（Remote Dictionary Server）\n\n\n\n## Redis 运行快速的原因\n\n1. 完全基于内存操作\n\n2. 数据结构简单，数据操作也简单\n\n3. 使用多路I/O复用模型\n\n## 数据类型\n### String\n#### 单条操作\n1. 增：set\tkey\tvalue\n2. 查：get\tkey\n3. 删：del\tkey\n\n#### 多条操作\n1. 增：mset\tkey\tvalue\t[key1\tvalue1]\n2. 查：mget\tkey\t[key1]\n\n#### 其他命令\n1. strlen\tkey\t//获取字符串长度\n2. append\tkey\tvalue\t//有则追加，无则新建\n3. setnx\tkey\tvalue\t//不存在就设置，存在就不设置\n4. incr\tkey\t//自增 1\n5. incrby\tkey\tnum  //给key的值增加num（int 类型），num 正数则为加，num 为负数 则为减\n6. incrbyfloat\tkey\tnum\t//给key的值增加num（float 类型）\n7. decr\tkey  //自减 1\n8. decrby\tkey\tnum\t//给key的值减num\n9. setex\tkey\tsecond\tvalue\t//设置key的值为value存活时间为second秒\n10. psetex\tkey\tmillisecond\tvalue\t//设置key的值为value存活时间为millisecond毫秒\n\n>注：\n>字符串值最大值为512m\n\n### Hash\n和字符串相似，可理解为字符串厘米套字符串\n\n#### 单条操作\n1. 增：hset\tkey\tfield\tvalue\t\n2. 查：hget\tkey\tfield\n3. 删：hdel\tkey\tfield\n\n#### 多条操作\n1. 增：hmset\tkey\tfield\tvalue\t[field1\tvalue2]\n2. 查：hmget\tkey\tfield\t[field1]\n\n#### 其他命令\n1. hgetall\tkey\t//获取key的全部的值\n2. hlen\tkey\t//获取key的值的数量\n3. hexists\tkey\tfield\t//是否存在field\n4. hkeys\tkey\t//所有key的字段（field）\n5. hvals\tkey\t//所有key的值 \n6. hincrby\tkey\tfield\tnum\t//给key的field的值增加num （num 为int值）\n7. hincrybyfloat\tkey\tfield\tnum\t//给key的field的值增加num （num 为float）\n8. hsetnx\tkey\tfield\tvalue\t//存在不设置，不存在设置\n\n>注：\n>1. Hash类型的value只能存字符串，不允许再嵌套其他类型，如果数据为空为Nil\n>2. 每个Hash可以存储$2^{32}-1$个键的值对\n>3. Hash类型十分贴近对象的数据存储，并且可以灵活添加、删除对象属性。但Hash类型设计并不是存在量而设计的，切记不可滥用，更不可将Hash作为对象列表使用\n>4. hgetall操作可以获取全部属性，如果内部field过多，遍历整体数据时效率会降低，很有可能成为数据访问的瓶颈\n\n### String存储对象（Json） VS Hash存储对象\n1. String存在对象讲究整体性，以读为主\n2. Hash存储对象讲究分散性，以写为主\n\n### List\n讲究顺序\n#### 添加\n1. lpush\tkey\tvalue\t[value1]\t//从左添加\n2. rpush\tkey\tvalue\t[value1]\t//从右添加\n\n#### 获取\n1. lrange\tkey\tstart\tstop\n2. lindex\tkey\tindex\n3. llen\tkey\n\n#### 获取并移除\n1. lpop\tkey\t//从左出\n2. rpop\tkey\t//从右出\n\n~~~tex\nlpush\tlist\ta\tb\tc\n结果：c b a\n===============================\nrpush list a\tb\tc\n结果：a b c\n===============================\nlist=[a\tb\tc]\nlpop list\n结果：b c\n===============================\nlist=[a b c]\nrpop list\n结果：a b\n===============================\n~~~\n\n>注：\n>1. list中保存的数据都是String，数据总量是有限的，最多$2^{32}-1$个元素\n>2. list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作（或以栈的形式进行入栈出栈操作）\n>3. 当stop的值为-1时，获取的是全部数据\n>4. list对数据进行分页操作，通常第一页的数据使的信息来自list，其他页面的数据通过数据形式进行加载\n\n### Set\n#### 命令\n1. 增：sadd\tkey\tmember\t[member1]\n2. 查：smembers\tkey\n3. 删：srem\tkey\tmember\t[member1]\n4. 获取总量：scard\tkey\n5. 判定是否存在：sismember\tkey\tmember\n6. 随机获取（原集合保留）：srandmember\tkey\t[count]\n7. 随机获取（原集合不保留）：spop\tkey\n8. 集合交集：sinter\tkey\tkey1\tkey2\n9. 集合并集：sunion\tkey\tkey1\tkey2\n10. 集合差集：sdiff\tkey\tkey1\tkey2\n11. 存储集合交集：sinterstore\tdestination\tkey\tkey1\tkey2\n12. 存储集合并集：sunionstore\tdestination\tkey\tkey1\tkey2\n13. 存储集合差集：sdiffstore\tdestination\tkey\tkey1\tkey2\n14. 集合元素移动：smove\tsource\tdestination\tmember\n\n### Sorted_Set\n#### 命令\n1. 增：zadd\tkey\tscore\tmember\t[score1\tmember1]\n2. 删：zrem\tkey\tmember\t[member1]\n3. 获取全部（正序）：zrange\tkey\tstart\tstop\t[withscores]\n4. 获取全部（倒序）：zrevrange\tkey\tstart\tstop\t[withscores]\n5. 按条件查（正序）：zrangebyscore\tkey\tmin\tmax\t[withscore\tlimit]\n6. 按条件查（倒序）：zrevrangebyscore\tkey\tmax\tmin\t[withscore\tlimit]\n7. 按条件删除（索引）：zremrangebyrank\tkey\tstart\tstop\n8. 按条件删除（积分）：zremrangebyscore\tkey\tmin\tmax\n9. 获取集合总量：zcard\tkey\t|\tzcount\tkey\tmin\tmax\n10. 存储集合交集：\tzinterstore\tdestination\tnumkeys\tkey\tkey1\n11. 存储集合并集：zunionstore\tdestination\tnumkeys\tkey\tkey1\n12. 获取索引（正序）：zrank\tkey\tmember\n13. 获取索引（倒序）：zrevrank\tkey\tmember\n14. score值获取：zscore\tkey\tmember\n15. score值修改：zincrby\tkey\tnum\tmember\n\n## Key的操作\n### 命令\n1. 删除：del\tkey\n2. 判断是否存在：exists\tkey\n3. 获取key类型：type\tkey\n4. 指定有效期：\n\t1.\texpire\tkey\tseconds\n\t2.\tpexpire\tkey\tmilliseconds\n\t3.\texpireat\tkey\ttimestamp\n\t4.\tpexpireat\tkey\tmilliseconds-timestamp\n5. 获取有效期：\n\t1.\tttl\tkey\n\t2.\tpttl\tkey\n6.\t设置永久：persist\tkey\n7.\t查询key：key\tpattern\t//*,?,[]\n8.\t重命名：rename\tkey\tnewkey\t|\trenamenx\tkey\tnewkey\n9.\t对key排序：sort\n\n## 数据库操作\n### 命令\n1. 选择数据库：select\tindex\n2. 数据移动：move\tkey\tdb\n3. 数据库大小：dbsize\n4. 数据清除：\n\t1. 单库删除：flushdb\n\t2. 多库删除：flushall\n\n## 持久化\n### RDB（Relational Database）\n#### 保存数据\n1. 指令（前台）：save\t//阻塞 立即保存\n2. 指令（后台）：bgsave\t//不立即执行\n3. 配置：save\tsecond\tchanges\t//用bgsave执行操作\n\n#### 常用配置项\n1. 数据文件名称：dbfilename\tdump.rdb\t//默认\n2. 数据保存路径：dir\n3. 是否开启压缩：rdbcompression\tyes\t//默认\n4. 是否开启格式检查：rdbchecksum\tyes|no //默认no\n\n#### RDB 持久化优点\n1. RDB是一个紧凑压缩的二进制文件，存储效率高\n2. RDB存储的是Redis在某个时间点的数据快照，非常适用于数据备份全量复制等场景\n3. RDB恢复数据速度比AOF快\n\n#### RDB应用\n服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复\n\n#### RDB持久化缺点\n1. RDB方式无论是执行命令还是进行配置，无法做到实时持久化，具有较大可能丢失数据\n2. bgsave每次运行要执行fork操作创建子进程，要牺牲一些性能\n3. Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各个版本服务器之间数据格式无法兼容\n4. 存储数量较大时，效率较低\n5. 大数据量下的I／O性能较低\n6. 基于fork创建子进程，内存产生额外消耗\n7. 宕机带来的数据丢失风险\n\n### AOF（Append Only File）\n#### 保存数据策略\n每次：always\n每秒：everysec\n系统控制：no\n\n#### 配置\n1. 是否开启：appendonly\tyes|no\t//默认no\n2. 保存策略：appendfsync\talways|everysec|no\n3. 重写：\n\t手动：bgrewriteaof\n\t自动：\n\t\tauto-aof-rewrite-min-size\tsize\n\t\tauto-aof-rewrite-percentage\tpercentage\n\n### RDB 与 AOF 如何选择\n对数据非常敏感，建议使用默认的AOF持久化方案\n\tAOF策略使用everysec，每秒fsync一次，该策略仍可保持很好性能，出现问题最多丢失一秒内的数据\n数据呈现阶段有效性，建议使用RDB持久化方案\n\t数据可以做到阶段内无丢失，且恢复较快，阶段点数据恢复通常使用RDB方案\n>注意：\n>AOF文件存储体积较大，恢复速度较慢\n>利用RDB使用线紧凑的数据持久化会使Redis性能降低\n\n综合：\n1. RDB与AOF选择实际上是在一种权衡，每种都有利有弊\n2. 如果不能承受分钟内的数据丢失，对业务数据非常敏感，选用AOF\n3. 如果能承受分钟内的数据丢失，且追求大数据集的恢复速度选用RDB\n4. 灾难恢复选用RDB\n5. 双保险策略，同时开启RDB和AOF，重启后Redis优先使用AOF来恢复数据，降低丢失数据量\n\n## 事务\nRedis事务不具有回滚机制\n\n### 命令\n1. 开启：multi\n2. 结束：exec\n3. 中断：discard\n\n### 事务中的错误\n#### 命令错误\n执行事务过程中输入的命令出现错误，Redis会结束事务不再执行，并报出错误的命令\n\n#### 操作错误\n执行事务过程中输入的命令正确，其他操作错误，事务中其他命令正常执行，错误操作报错\n\n## 锁\nRedis中锁和事务是相搭配使用的，可解决对key的监控\n\n### 命令\n加锁：watch\tkey\t[key1]\n解锁：unwatch  //取消掉所有key的监控\n\n## 数据删除策略\n当key过期后执行数据删除的策略\n### 定时删除（即可删除）\n创建一个具有时效性的key时，同时会创建一个定时器来监控该key是否过期，当key过期后立即进行key的删除\n\n优点：节约内存，到时就会进行删除，快速释放占用空间\n缺点：CPU压力大影响Redis响应时间和吞吐量\n总结：用处理器性能换取存储空间\n\n### 惰性删除\n当一个具有实效性的key过期后不会有删除操作，直到下一次调用时会先检查该key是否过期，如果过期则进行删除操作，并返回nil（该key不存在）\n\n优点：节约CPU性能，发现必须删除的时候才会删除\n缺点：内存压力大，出现长期占用内存的数据\n总结：用存储空间换取处理器性能\n\n### 定期删除\nRedis会根据设置的参数，定期对具有时效性的key进行清理工作，它是定时删除和惰性删除的结合者，既不像定时删除会立即进行删除给予CPU压力，也不会像惰性删除给予内存压力\n\n#### 步骤\n1. Redis启动服务器初始化时，读取配置server.hz的值（默认为10）\n2. 每秒钟执行server.hz次serverCron（）服务（serverCron【服务器级别】->databasesCron【数据库级别】->activeExpireCyle【活跃数据级别】）\n3. acitveExpireCyle（）对每个expires[*]（数据库）逐一进行检测，每次执行250ms／server.hz\n4. 对某个expires[*]检测时，随机挑选w个key进行检测\n\t1. 如果key超时，删除key\n\t2. 如果一轮中删除的kye的数量>w*25%，循环该过程\n\t3. 如果一轮中删除的可以的数量<=w*25%检查下一个expires[*],0-15（所有的数据库）循环\n>W=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP\n>参数current_db用于记录activeExpireCyle进入哪个expires[*]执行\n\n## 数据淘汰策略\n当内存到达最大内存限制时进行的数据淘汰策略\n\n数据驱逐淘汰策略配置依据，使用info命令输出相关监控信息，查新缓存hit 命中次数和miss的次数，根据业务调优\n### 配置\n1. 最大可用内存：maxmemory\t//默认为0，一般设置全部内存50%以上\n2. 每次选取带删除数据个数：maxmemory-samples\t//采用随机获取方式\n3. 删除策略：maxmemory-policy\t//达到最大内存后，对被选取带数据进行的删除策略\n\n### 检测易失数据集（可能会过期数据server.db[i].expires）\n1. volatile-lru：挑选最近最少使用的数据淘汰（最近数据中使用时间离当前最远的数据）。**常用**\n2. volatile-lfu：挑选最近使用次数最少的数据淘汰（最近数据中使用次数最少的数据）\n3. volatile-ttl：挑选将要过期数据淘汰\n4. volatile-random：任意挑选数据淘汰\n\n>ttl：time to live\n>lru：least recently\tused\n>lfu：least frequently\tused\n\n### 检测全库数据（所有数据集server.db[i].dict）\n1. allkeys-lru：挑选最近最少使用的数据淘汰\n2. allkeys-lfu：挑选最近使用次数最少的数据淘汰\n3. allkeys-random：任意挑选数据淘汰\n\n### 放弃数据驱逐\nno-enviction\t//禁止驱逐数据\n4.0中默认策略，会引发OOM\n\n## 服务器基本配置\n1. 设置服务器守护进程方式：daemonize\tyes|no\n2. 绑定地址：bing\t127.0.0.1\n3. 设置服务器端口：port\t6379\n4. 设置数据库数量：databases\t16\n5. 设置服务器日志级别：loglevel\tdebug|verbose|notice|warning\n6. 日志文件名称：logfile\t端口号.log\n7. 设置客户端最大连接数：maxclients\t0\n8. 客户端闲置最大等待时长：timeout\t0\n\n## 高级数据类型\n### Bitmaps\n标记统计\n\n#### 命令\n1. 获取：getbit\tkey\toffset\n2. 设置：setbit\tkey\toffset\tvalue\t// 0 或 1\n3. 交、并、或异\n\tbitop\top\tdestkey\tkey1\tkey2\n\top：\n\t\t交：and\n\t\t并：or\n\t\t非：not\n\t\t异或：xor\n4. 统计指定key中1的数量：bitcount\tkey\t[start\tend]\n\n### HyperLoglog\n基数统计\n#### 命令\n1. 添加：pfadd\tkey\telement\t[element1]\n2. 统计：pfcount\tkey\t[key1]\n3. 合并：pfmerge\tdestkey\tsourcekey\t[sourcekey1]\n\n### GEO\n距离计算（只计算水平距离）\n\n#### 命令\n1. 添加：geoadd\tkey\tlongitude\tlatitude\tmember\t[longitude1\tlatitude1\tmember1]\n2. 获取：geopos\tkey\tmember\t[member1]\n3. 计算距离：geodist\tkey\tmember1\tmember2\t[count]\n4. 根据坐标求范围内数据：georadius\tkey\tlongitude\tlatitude\tradius\tm|km|ft|mi\n5. 根据点求范围内的数据：georadusbymember\tkey\tmember\tradius\tm|km|ft|mi\n6. 获取指定点对应的hash值：geohash\tkey\tmember\t[member1]\t\n\n## 主从复制\n### 创建链接\n+ 方式一：客户端发指令：slaveof\tmasterip masterport\n+\t方式二：参数启动：redis-server\t--slaveof\tmasterip masterport\n+\t方式三：服务器配置：slaveof\tmasterip masterport\n\n### 数据同步 \n#### 全量复制\n从：发送指令（psync2）\n主：执行bgsave\n主：第一个slave链接时，创建命令缓冲区\n主：生成RDB文件，通过socket发送给slave\n从：接收RDB文件，清空自己数据，执行RDB文件恢复过程\n\n#### 部分复制\n从：发送命令告知RDB恢复完成\n主：发送复制缓冲区信息\n从：接收信息，执行bgsavewriteaof，恢复数据\n\n## 哨兵模式\n### 配置\nsentinel.conf\n\n启动：redis-sentinel\n\n## 集群（cluster）\n### 配置\n1. 开启：cluster-enabled\tyes|no\n2. 配置文件名称：cluster-config-file\tfilename\n3. 节点超时时间：cluster-node-timeout\tmilliseconds\n4. master链接slave最小数：cluster-migration-barrier\tcount\n\n### 命令\n1. 查看节点信息：cluster nodes\n2. 从一个节点Redis，切换其主节点：cluster\treplicate\tmasterip\n3. 新增主节点：cluster meet\tip:port\n4. 忽略一个节点：cluster\tfoeget\tid\n5. 手动故障转移：cluster\tfailover\n\n","updated":"2020-04-01T08:42:49.000Z","path":"notes/Redis.html","comments":1,"layout":"page","_id":"ck8hf2uw0000pzhs6n83nh04t","content":"<h1 id=\"Redis（Remote-Dictionary-Server）\"><a href=\"#Redis（Remote-Dictionary-Server）\" class=\"headerlink\" title=\"Redis（Remote Dictionary Server）\"></a>Redis（Remote Dictionary Server）</h1><h2 id=\"Redis-运行快速的原因\"><a href=\"#Redis-运行快速的原因\" class=\"headerlink\" title=\"Redis 运行快速的原因\"></a>Redis 运行快速的原因</h2><ol>\n<li><p>完全基于内存操作</p>\n</li>\n<li><p>数据结构简单，数据操作也简单</p>\n</li>\n<li><p>使用多路I/O复用模型</p>\n</li>\n</ol>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><h4 id=\"单条操作\"><a href=\"#单条操作\" class=\"headerlink\" title=\"单条操作\"></a>单条操作</h4><ol>\n<li>增：set    key    value</li>\n<li>查：get    key</li>\n<li>删：del    key</li>\n</ol>\n<h4 id=\"多条操作\"><a href=\"#多条操作\" class=\"headerlink\" title=\"多条操作\"></a>多条操作</h4><ol>\n<li>增：mset    key    value    [key1    value1]</li>\n<li>查：mget    key    [key1]</li>\n</ol>\n<h4 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h4><ol>\n<li>strlen    key    //获取字符串长度</li>\n<li>append    key    value    //有则追加，无则新建</li>\n<li>setnx    key    value    //不存在就设置，存在就不设置</li>\n<li>incr    key    //自增 1</li>\n<li>incrby    key    num  //给key的值增加num（int 类型），num 正数则为加，num 为负数 则为减</li>\n<li>incrbyfloat    key    num    //给key的值增加num（float 类型）</li>\n<li>decr    key  //自减 1</li>\n<li>decrby    key    num    //给key的值减num</li>\n<li>setex    key    second    value    //设置key的值为value存活时间为second秒</li>\n<li>psetex    key    millisecond    value    //设置key的值为value存活时间为millisecond毫秒</li>\n</ol>\n<blockquote>\n<p>注：<br>字符串值最大值为512m</p>\n</blockquote>\n<h3 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h3><p>和字符串相似，可理解为字符串厘米套字符串</p>\n<h4 id=\"单条操作-1\"><a href=\"#单条操作-1\" class=\"headerlink\" title=\"单条操作\"></a>单条操作</h4><ol>\n<li>增：hset    key    field    value    </li>\n<li>查：hget    key    field</li>\n<li>删：hdel    key    field</li>\n</ol>\n<h4 id=\"多条操作-1\"><a href=\"#多条操作-1\" class=\"headerlink\" title=\"多条操作\"></a>多条操作</h4><ol>\n<li>增：hmset    key    field    value    [field1    value2]</li>\n<li>查：hmget    key    field    [field1]</li>\n</ol>\n<h4 id=\"其他命令-1\"><a href=\"#其他命令-1\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h4><ol>\n<li>hgetall    key    //获取key的全部的值</li>\n<li>hlen    key    //获取key的值的数量</li>\n<li>hexists    key    field    //是否存在field</li>\n<li>hkeys    key    //所有key的字段（field）</li>\n<li>hvals    key    //所有key的值 </li>\n<li>hincrby    key    field    num    //给key的field的值增加num （num 为int值）</li>\n<li>hincrybyfloat    key    field    num    //给key的field的值增加num （num 为float）</li>\n<li>hsetnx    key    field    value    //存在不设置，不存在设置</li>\n</ol>\n<blockquote>\n<p>注：</p>\n<ol>\n<li>Hash类型的value只能存字符串，不允许再嵌套其他类型，如果数据为空为Nil</li>\n<li>每个Hash可以存储$2^{32}-1$个键的值对</li>\n<li>Hash类型十分贴近对象的数据存储，并且可以灵活添加、删除对象属性。但Hash类型设计并不是存在量而设计的，切记不可滥用，更不可将Hash作为对象列表使用</li>\n<li>hgetall操作可以获取全部属性，如果内部field过多，遍历整体数据时效率会降低，很有可能成为数据访问的瓶颈</li>\n</ol>\n</blockquote>\n<h3 id=\"String存储对象（Json）-VS-Hash存储对象\"><a href=\"#String存储对象（Json）-VS-Hash存储对象\" class=\"headerlink\" title=\"String存储对象（Json） VS Hash存储对象\"></a>String存储对象（Json） VS Hash存储对象</h3><ol>\n<li>String存在对象讲究整体性，以读为主</li>\n<li>Hash存储对象讲究分散性，以写为主</li>\n</ol>\n<h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><p>讲究顺序</p>\n<h4 id=\"添加\"><a href=\"#添加\" class=\"headerlink\" title=\"添加\"></a>添加</h4><ol>\n<li>lpush    key    value    [value1]    //从左添加</li>\n<li>rpush    key    value    [value1]    //从右添加</li>\n</ol>\n<h4 id=\"获取\"><a href=\"#获取\" class=\"headerlink\" title=\"获取\"></a>获取</h4><ol>\n<li>lrange    key    start    stop</li>\n<li>lindex    key    index</li>\n<li>llen    key</li>\n</ol>\n<h4 id=\"获取并移除\"><a href=\"#获取并移除\" class=\"headerlink\" title=\"获取并移除\"></a>获取并移除</h4><ol>\n<li>lpop    key    //从左出</li>\n<li>rpop    key    //从右出</li>\n</ol>\n<pre class=\" language-tex\"><code class=\"language-tex\">lpush    list    a    b    c\n结果：c b a\n===============================\nrpush list a    b    c\n结果：a b c\n===============================\nlist=[a    b    c]\nlpop list\n结果：b c\n===============================\nlist=[a b c]\nrpop list\n结果：a b\n===============================</code></pre>\n<blockquote>\n<p>注：</p>\n<ol>\n<li>list中保存的数据都是String，数据总量是有限的，最多$2^{32}-1$个元素</li>\n<li>list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作（或以栈的形式进行入栈出栈操作）</li>\n<li>当stop的值为-1时，获取的是全部数据</li>\n<li>list对数据进行分页操作，通常第一页的数据使的信息来自list，其他页面的数据通过数据形式进行加载</li>\n</ol>\n</blockquote>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><h4 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>增：sadd    key    member    [member1]</li>\n<li>查：smembers    key</li>\n<li>删：srem    key    member    [member1]</li>\n<li>获取总量：scard    key</li>\n<li>判定是否存在：sismember    key    member</li>\n<li>随机获取（原集合保留）：srandmember    key    [count]</li>\n<li>随机获取（原集合不保留）：spop    key</li>\n<li>集合交集：sinter    key    key1    key2</li>\n<li>集合并集：sunion    key    key1    key2</li>\n<li>集合差集：sdiff    key    key1    key2</li>\n<li>存储集合交集：sinterstore    destination    key    key1    key2</li>\n<li>存储集合并集：sunionstore    destination    key    key1    key2</li>\n<li>存储集合差集：sdiffstore    destination    key    key1    key2</li>\n<li>集合元素移动：smove    source    destination    member</li>\n</ol>\n<h3 id=\"Sorted-Set\"><a href=\"#Sorted-Set\" class=\"headerlink\" title=\"Sorted_Set\"></a>Sorted_Set</h3><h4 id=\"命令-1\"><a href=\"#命令-1\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>增：zadd    key    score    member    [score1    member1]</li>\n<li>删：zrem    key    member    [member1]</li>\n<li>获取全部（正序）：zrange    key    start    stop    [withscores]</li>\n<li>获取全部（倒序）：zrevrange    key    start    stop    [withscores]</li>\n<li>按条件查（正序）：zrangebyscore    key    min    max    [withscore    limit]</li>\n<li>按条件查（倒序）：zrevrangebyscore    key    max    min    [withscore    limit]</li>\n<li>按条件删除（索引）：zremrangebyrank    key    start    stop</li>\n<li>按条件删除（积分）：zremrangebyscore    key    min    max</li>\n<li>获取集合总量：zcard    key    |    zcount    key    min    max</li>\n<li>存储集合交集：    zinterstore    destination    numkeys    key    key1</li>\n<li>存储集合并集：zunionstore    destination    numkeys    key    key1</li>\n<li>获取索引（正序）：zrank    key    member</li>\n<li>获取索引（倒序）：zrevrank    key    member</li>\n<li>score值获取：zscore    key    member</li>\n<li>score值修改：zincrby    key    num    member</li>\n</ol>\n<h2 id=\"Key的操作\"><a href=\"#Key的操作\" class=\"headerlink\" title=\"Key的操作\"></a>Key的操作</h2><h3 id=\"命令-2\"><a href=\"#命令-2\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ol>\n<li>删除：del    key</li>\n<li>判断是否存在：exists    key</li>\n<li>获取key类型：type    key</li>\n<li>指定有效期：<ol>\n<li>expire    key    seconds</li>\n<li>pexpire    key    milliseconds</li>\n<li>expireat    key    timestamp</li>\n<li>pexpireat    key    milliseconds-timestamp</li>\n</ol>\n</li>\n<li>获取有效期：<ol>\n<li>ttl    key</li>\n<li>pttl    key</li>\n</ol>\n</li>\n<li>设置永久：persist    key</li>\n<li>查询key：key    pattern    //*,?,[]</li>\n<li>重命名：rename    key    newkey    |    renamenx    key    newkey</li>\n<li>对key排序：sort</li>\n</ol>\n<h2 id=\"数据库操作\"><a href=\"#数据库操作\" class=\"headerlink\" title=\"数据库操作\"></a>数据库操作</h2><h3 id=\"命令-3\"><a href=\"#命令-3\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ol>\n<li>选择数据库：select    index</li>\n<li>数据移动：move    key    db</li>\n<li>数据库大小：dbsize</li>\n<li>数据清除：<ol>\n<li>单库删除：flushdb</li>\n<li>多库删除：flushall</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><h3 id=\"RDB（Relational-Database）\"><a href=\"#RDB（Relational-Database）\" class=\"headerlink\" title=\"RDB（Relational Database）\"></a>RDB（Relational Database）</h3><h4 id=\"保存数据\"><a href=\"#保存数据\" class=\"headerlink\" title=\"保存数据\"></a>保存数据</h4><ol>\n<li>指令（前台）：save    //阻塞 立即保存</li>\n<li>指令（后台）：bgsave    //不立即执行</li>\n<li>配置：save    second    changes    //用bgsave执行操作</li>\n</ol>\n<h4 id=\"常用配置项\"><a href=\"#常用配置项\" class=\"headerlink\" title=\"常用配置项\"></a>常用配置项</h4><ol>\n<li>数据文件名称：dbfilename    dump.rdb    //默认</li>\n<li>数据保存路径：dir</li>\n<li>是否开启压缩：rdbcompression    yes    //默认</li>\n<li>是否开启格式检查：rdbchecksum    yes|no //默认no</li>\n</ol>\n<h4 id=\"RDB-持久化优点\"><a href=\"#RDB-持久化优点\" class=\"headerlink\" title=\"RDB 持久化优点\"></a>RDB 持久化优点</h4><ol>\n<li>RDB是一个紧凑压缩的二进制文件，存储效率高</li>\n<li>RDB存储的是Redis在某个时间点的数据快照，非常适用于数据备份全量复制等场景</li>\n<li>RDB恢复数据速度比AOF快</li>\n</ol>\n<h4 id=\"RDB应用\"><a href=\"#RDB应用\" class=\"headerlink\" title=\"RDB应用\"></a>RDB应用</h4><p>服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复</p>\n<h4 id=\"RDB持久化缺点\"><a href=\"#RDB持久化缺点\" class=\"headerlink\" title=\"RDB持久化缺点\"></a>RDB持久化缺点</h4><ol>\n<li>RDB方式无论是执行命令还是进行配置，无法做到实时持久化，具有较大可能丢失数据</li>\n<li>bgsave每次运行要执行fork操作创建子进程，要牺牲一些性能</li>\n<li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各个版本服务器之间数据格式无法兼容</li>\n<li>存储数量较大时，效率较低</li>\n<li>大数据量下的I／O性能较低</li>\n<li>基于fork创建子进程，内存产生额外消耗</li>\n<li>宕机带来的数据丢失风险</li>\n</ol>\n<h3 id=\"AOF（Append-Only-File）\"><a href=\"#AOF（Append-Only-File）\" class=\"headerlink\" title=\"AOF（Append Only File）\"></a>AOF（Append Only File）</h3><h4 id=\"保存数据策略\"><a href=\"#保存数据策略\" class=\"headerlink\" title=\"保存数据策略\"></a>保存数据策略</h4><p>每次：always<br>每秒：everysec<br>系统控制：no</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><ol>\n<li>是否开启：appendonly    yes|no    //默认no</li>\n<li>保存策略：appendfsync    always|everysec|no</li>\n<li>重写：<br> 手动：bgrewriteaof<br> 自动：<pre><code> auto-aof-rewrite-min-size    size\n auto-aof-rewrite-percentage    percentage</code></pre></li>\n</ol>\n<h3 id=\"RDB-与-AOF-如何选择\"><a href=\"#RDB-与-AOF-如何选择\" class=\"headerlink\" title=\"RDB 与 AOF 如何选择\"></a>RDB 与 AOF 如何选择</h3><p>对数据非常敏感，建议使用默认的AOF持久化方案<br>    AOF策略使用everysec，每秒fsync一次，该策略仍可保持很好性能，出现问题最多丢失一秒内的数据<br>数据呈现阶段有效性，建议使用RDB持久化方案<br>    数据可以做到阶段内无丢失，且恢复较快，阶段点数据恢复通常使用RDB方案</p>\n<blockquote>\n<p>注意：<br>AOF文件存储体积较大，恢复速度较慢<br>利用RDB使用线紧凑的数据持久化会使Redis性能降低</p>\n</blockquote>\n<p>综合：</p>\n<ol>\n<li>RDB与AOF选择实际上是在一种权衡，每种都有利有弊</li>\n<li>如果不能承受分钟内的数据丢失，对业务数据非常敏感，选用AOF</li>\n<li>如果能承受分钟内的数据丢失，且追求大数据集的恢复速度选用RDB</li>\n<li>灾难恢复选用RDB</li>\n<li>双保险策略，同时开启RDB和AOF，重启后Redis优先使用AOF来恢复数据，降低丢失数据量</li>\n</ol>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>Redis事务不具有回滚机制</p>\n<h3 id=\"命令-4\"><a href=\"#命令-4\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ol>\n<li>开启：multi</li>\n<li>结束：exec</li>\n<li>中断：discard</li>\n</ol>\n<h3 id=\"事务中的错误\"><a href=\"#事务中的错误\" class=\"headerlink\" title=\"事务中的错误\"></a>事务中的错误</h3><h4 id=\"命令错误\"><a href=\"#命令错误\" class=\"headerlink\" title=\"命令错误\"></a>命令错误</h4><p>执行事务过程中输入的命令出现错误，Redis会结束事务不再执行，并报出错误的命令</p>\n<h4 id=\"操作错误\"><a href=\"#操作错误\" class=\"headerlink\" title=\"操作错误\"></a>操作错误</h4><p>执行事务过程中输入的命令正确，其他操作错误，事务中其他命令正常执行，错误操作报错</p>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><p>Redis中锁和事务是相搭配使用的，可解决对key的监控</p>\n<h3 id=\"命令-5\"><a href=\"#命令-5\" class=\"headerlink\" title=\"命令\"></a>命令</h3><p>加锁：watch    key    [key1]<br>解锁：unwatch  //取消掉所有key的监控</p>\n<h2 id=\"数据删除策略\"><a href=\"#数据删除策略\" class=\"headerlink\" title=\"数据删除策略\"></a>数据删除策略</h2><p>当key过期后执行数据删除的策略</p>\n<h3 id=\"定时删除（即可删除）\"><a href=\"#定时删除（即可删除）\" class=\"headerlink\" title=\"定时删除（即可删除）\"></a>定时删除（即可删除）</h3><p>创建一个具有时效性的key时，同时会创建一个定时器来监控该key是否过期，当key过期后立即进行key的删除</p>\n<p>优点：节约内存，到时就会进行删除，快速释放占用空间<br>缺点：CPU压力大影响Redis响应时间和吞吐量<br>总结：用处理器性能换取存储空间</p>\n<h3 id=\"惰性删除\"><a href=\"#惰性删除\" class=\"headerlink\" title=\"惰性删除\"></a>惰性删除</h3><p>当一个具有实效性的key过期后不会有删除操作，直到下一次调用时会先检查该key是否过期，如果过期则进行删除操作，并返回nil（该key不存在）</p>\n<p>优点：节约CPU性能，发现必须删除的时候才会删除<br>缺点：内存压力大，出现长期占用内存的数据<br>总结：用存储空间换取处理器性能</p>\n<h3 id=\"定期删除\"><a href=\"#定期删除\" class=\"headerlink\" title=\"定期删除\"></a>定期删除</h3><p>Redis会根据设置的参数，定期对具有时效性的key进行清理工作，它是定时删除和惰性删除的结合者，既不像定时删除会立即进行删除给予CPU压力，也不会像惰性删除给予内存压力</p>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><ol>\n<li>Redis启动服务器初始化时，读取配置server.hz的值（默认为10）</li>\n<li>每秒钟执行server.hz次serverCron（）服务（serverCron【服务器级别】-&gt;databasesCron【数据库级别】-&gt;activeExpireCyle【活跃数据级别】）</li>\n<li>acitveExpireCyle（）对每个expires[*]（数据库）逐一进行检测，每次执行250ms／server.hz</li>\n<li>对某个expires[*]检测时，随机挑选w个key进行检测<ol>\n<li>如果key超时，删除key</li>\n<li>如果一轮中删除的kye的数量&gt;w*25%，循环该过程</li>\n<li>如果一轮中删除的可以的数量&lt;=w<em>25%检查下一个expires[</em>],0-15（所有的数据库）循环<blockquote>\n<p>W=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP<br>参数current_db用于记录activeExpireCyle进入哪个expires[*]执行</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"数据淘汰策略\"><a href=\"#数据淘汰策略\" class=\"headerlink\" title=\"数据淘汰策略\"></a>数据淘汰策略</h2><p>当内存到达最大内存限制时进行的数据淘汰策略</p>\n<p>数据驱逐淘汰策略配置依据，使用info命令输出相关监控信息，查新缓存hit 命中次数和miss的次数，根据业务调优</p>\n<h3 id=\"配置-1\"><a href=\"#配置-1\" class=\"headerlink\" title=\"配置\"></a>配置</h3><ol>\n<li>最大可用内存：maxmemory    //默认为0，一般设置全部内存50%以上</li>\n<li>每次选取带删除数据个数：maxmemory-samples    //采用随机获取方式</li>\n<li>删除策略：maxmemory-policy    //达到最大内存后，对被选取带数据进行的删除策略</li>\n</ol>\n<h3 id=\"检测易失数据集（可能会过期数据server-db-i-expires）\"><a href=\"#检测易失数据集（可能会过期数据server-db-i-expires）\" class=\"headerlink\" title=\"检测易失数据集（可能会过期数据server.db[i].expires）\"></a>检测易失数据集（可能会过期数据server.db[i].expires）</h3><ol>\n<li>volatile-lru：挑选最近最少使用的数据淘汰（最近数据中使用时间离当前最远的数据）。<strong>常用</strong></li>\n<li>volatile-lfu：挑选最近使用次数最少的数据淘汰（最近数据中使用次数最少的数据）</li>\n<li>volatile-ttl：挑选将要过期数据淘汰</li>\n<li>volatile-random：任意挑选数据淘汰</li>\n</ol>\n<blockquote>\n<p>ttl：time to live<br>lru：least recently    used<br>lfu：least frequently    used</p>\n</blockquote>\n<h3 id=\"检测全库数据（所有数据集server-db-i-dict）\"><a href=\"#检测全库数据（所有数据集server-db-i-dict）\" class=\"headerlink\" title=\"检测全库数据（所有数据集server.db[i].dict）\"></a>检测全库数据（所有数据集server.db[i].dict）</h3><ol>\n<li>allkeys-lru：挑选最近最少使用的数据淘汰</li>\n<li>allkeys-lfu：挑选最近使用次数最少的数据淘汰</li>\n<li>allkeys-random：任意挑选数据淘汰</li>\n</ol>\n<h3 id=\"放弃数据驱逐\"><a href=\"#放弃数据驱逐\" class=\"headerlink\" title=\"放弃数据驱逐\"></a>放弃数据驱逐</h3><p>no-enviction    //禁止驱逐数据<br>4.0中默认策略，会引发OOM</p>\n<h2 id=\"服务器基本配置\"><a href=\"#服务器基本配置\" class=\"headerlink\" title=\"服务器基本配置\"></a>服务器基本配置</h2><ol>\n<li>设置服务器守护进程方式：daemonize    yes|no</li>\n<li>绑定地址：bing    127.0.0.1</li>\n<li>设置服务器端口：port    6379</li>\n<li>设置数据库数量：databases    16</li>\n<li>设置服务器日志级别：loglevel    debug|verbose|notice|warning</li>\n<li>日志文件名称：logfile    端口号.log</li>\n<li>设置客户端最大连接数：maxclients    0</li>\n<li>客户端闲置最大等待时长：timeout    0</li>\n</ol>\n<h2 id=\"高级数据类型\"><a href=\"#高级数据类型\" class=\"headerlink\" title=\"高级数据类型\"></a>高级数据类型</h2><h3 id=\"Bitmaps\"><a href=\"#Bitmaps\" class=\"headerlink\" title=\"Bitmaps\"></a>Bitmaps</h3><p>标记统计</p>\n<h4 id=\"命令-6\"><a href=\"#命令-6\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>获取：getbit    key    offset</li>\n<li>设置：setbit    key    offset    value    // 0 或 1</li>\n<li>交、并、或异<br> bitop    op    destkey    key1    key2<br> op：<pre><code> 交：and\n 并：or\n 非：not\n 异或：xor</code></pre></li>\n<li>统计指定key中1的数量：bitcount    key    [start    end]</li>\n</ol>\n<h3 id=\"HyperLoglog\"><a href=\"#HyperLoglog\" class=\"headerlink\" title=\"HyperLoglog\"></a>HyperLoglog</h3><p>基数统计</p>\n<h4 id=\"命令-7\"><a href=\"#命令-7\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>添加：pfadd    key    element    [element1]</li>\n<li>统计：pfcount    key    [key1]</li>\n<li>合并：pfmerge    destkey    sourcekey    [sourcekey1]</li>\n</ol>\n<h3 id=\"GEO\"><a href=\"#GEO\" class=\"headerlink\" title=\"GEO\"></a>GEO</h3><p>距离计算（只计算水平距离）</p>\n<h4 id=\"命令-8\"><a href=\"#命令-8\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>添加：geoadd    key    longitude    latitude    member    [longitude1    latitude1    member1]</li>\n<li>获取：geopos    key    member    [member1]</li>\n<li>计算距离：geodist    key    member1    member2    [count]</li>\n<li>根据坐标求范围内数据：georadius    key    longitude    latitude    radius    m|km|ft|mi</li>\n<li>根据点求范围内的数据：georadusbymember    key    member    radius    m|km|ft|mi</li>\n<li>获取指定点对应的hash值：geohash    key    member    [member1]    </li>\n</ol>\n<h2 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h2><h3 id=\"创建链接\"><a href=\"#创建链接\" class=\"headerlink\" title=\"创建链接\"></a>创建链接</h3><ul>\n<li>方式一：客户端发指令：slaveof    masterip masterport</li>\n<li>方式二：参数启动：redis-server    –slaveof    masterip masterport</li>\n<li>方式三：服务器配置：slaveof    masterip masterport</li>\n</ul>\n<h3 id=\"数据同步\"><a href=\"#数据同步\" class=\"headerlink\" title=\"数据同步\"></a>数据同步</h3><h4 id=\"全量复制\"><a href=\"#全量复制\" class=\"headerlink\" title=\"全量复制\"></a>全量复制</h4><p>从：发送指令（psync2）<br>主：执行bgsave<br>主：第一个slave链接时，创建命令缓冲区<br>主：生成RDB文件，通过socket发送给slave<br>从：接收RDB文件，清空自己数据，执行RDB文件恢复过程</p>\n<h4 id=\"部分复制\"><a href=\"#部分复制\" class=\"headerlink\" title=\"部分复制\"></a>部分复制</h4><p>从：发送命令告知RDB恢复完成<br>主：发送复制缓冲区信息<br>从：接收信息，执行bgsavewriteaof，恢复数据</p>\n<h2 id=\"哨兵模式\"><a href=\"#哨兵模式\" class=\"headerlink\" title=\"哨兵模式\"></a>哨兵模式</h2><h3 id=\"配置-2\"><a href=\"#配置-2\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>sentinel.conf</p>\n<p>启动：redis-sentinel</p>\n<h2 id=\"集群（cluster）\"><a href=\"#集群（cluster）\" class=\"headerlink\" title=\"集群（cluster）\"></a>集群（cluster）</h2><h3 id=\"配置-3\"><a href=\"#配置-3\" class=\"headerlink\" title=\"配置\"></a>配置</h3><ol>\n<li>开启：cluster-enabled    yes|no</li>\n<li>配置文件名称：cluster-config-file    filename</li>\n<li>节点超时时间：cluster-node-timeout    milliseconds</li>\n<li>master链接slave最小数：cluster-migration-barrier    count</li>\n</ol>\n<h3 id=\"命令-9\"><a href=\"#命令-9\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ol>\n<li>查看节点信息：cluster nodes</li>\n<li>从一个节点Redis，切换其主节点：cluster    replicate    masterip</li>\n<li>新增主节点：cluster meet    ip:port</li>\n<li>忽略一个节点：cluster    foeget    id</li>\n<li>手动故障转移：cluster    failover</li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":"<h1 id=\"Redis（Remote-Dictionary-Server）\"><a href=\"#Redis（Remote-Dictionary-Server）\" class=\"headerlink\" title=\"Redis（Remote Dictionary Server）\"></a>Redis（Remote Dictionary Server）</h1><h2 id=\"Redis-运行快速的原因\"><a href=\"#Redis-运行快速的原因\" class=\"headerlink\" title=\"Redis 运行快速的原因\"></a>Redis 运行快速的原因</h2><ol>\n<li><p>完全基于内存操作</p>\n</li>\n<li><p>数据结构简单，数据操作也简单</p>\n</li>\n<li><p>使用多路I/O复用模型</p>\n</li>\n</ol>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><h4 id=\"单条操作\"><a href=\"#单条操作\" class=\"headerlink\" title=\"单条操作\"></a>单条操作</h4><ol>\n<li>增：set    key    value</li>\n<li>查：get    key</li>\n<li>删：del    key</li>\n</ol>\n<h4 id=\"多条操作\"><a href=\"#多条操作\" class=\"headerlink\" title=\"多条操作\"></a>多条操作</h4><ol>\n<li>增：mset    key    value    [key1    value1]</li>\n<li>查：mget    key    [key1]</li>\n</ol>\n<h4 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h4><ol>\n<li>strlen    key    //获取字符串长度</li>\n<li>append    key    value    //有则追加，无则新建</li>\n<li>setnx    key    value    //不存在就设置，存在就不设置</li>\n<li>incr    key    //自增 1</li>\n<li>incrby    key    num  //给key的值增加num（int 类型），num 正数则为加，num 为负数 则为减</li>\n<li>incrbyfloat    key    num    //给key的值增加num（float 类型）</li>\n<li>decr    key  //自减 1</li>\n<li>decrby    key    num    //给key的值减num</li>\n<li>setex    key    second    value    //设置key的值为value存活时间为second秒</li>\n<li>psetex    key    millisecond    value    //设置key的值为value存活时间为millisecond毫秒</li>\n</ol>\n<blockquote>\n<p>注：<br>字符串值最大值为512m</p>\n</blockquote>\n<h3 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h3><p>和字符串相似，可理解为字符串厘米套字符串</p>\n<h4 id=\"单条操作-1\"><a href=\"#单条操作-1\" class=\"headerlink\" title=\"单条操作\"></a>单条操作</h4><ol>\n<li>增：hset    key    field    value    </li>\n<li>查：hget    key    field</li>\n<li>删：hdel    key    field</li>\n</ol>\n<h4 id=\"多条操作-1\"><a href=\"#多条操作-1\" class=\"headerlink\" title=\"多条操作\"></a>多条操作</h4><ol>\n<li>增：hmset    key    field    value    [field1    value2]</li>\n<li>查：hmget    key    field    [field1]</li>\n</ol>\n<h4 id=\"其他命令-1\"><a href=\"#其他命令-1\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h4><ol>\n<li>hgetall    key    //获取key的全部的值</li>\n<li>hlen    key    //获取key的值的数量</li>\n<li>hexists    key    field    //是否存在field</li>\n<li>hkeys    key    //所有key的字段（field）</li>\n<li>hvals    key    //所有key的值 </li>\n<li>hincrby    key    field    num    //给key的field的值增加num （num 为int值）</li>\n<li>hincrybyfloat    key    field    num    //给key的field的值增加num （num 为float）</li>\n<li>hsetnx    key    field    value    //存在不设置，不存在设置</li>\n</ol>\n<blockquote>\n<p>注：</p>\n<ol>\n<li>Hash类型的value只能存字符串，不允许再嵌套其他类型，如果数据为空为Nil</li>\n<li>每个Hash可以存储$2^{32}-1$个键的值对</li>\n<li>Hash类型十分贴近对象的数据存储，并且可以灵活添加、删除对象属性。但Hash类型设计并不是存在量而设计的，切记不可滥用，更不可将Hash作为对象列表使用</li>\n<li>hgetall操作可以获取全部属性，如果内部field过多，遍历整体数据时效率会降低，很有可能成为数据访问的瓶颈</li>\n</ol>\n</blockquote>\n<h3 id=\"String存储对象（Json）-VS-Hash存储对象\"><a href=\"#String存储对象（Json）-VS-Hash存储对象\" class=\"headerlink\" title=\"String存储对象（Json） VS Hash存储对象\"></a>String存储对象（Json） VS Hash存储对象</h3><ol>\n<li>String存在对象讲究整体性，以读为主</li>\n<li>Hash存储对象讲究分散性，以写为主</li>\n</ol>\n<h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><p>讲究顺序</p>\n<h4 id=\"添加\"><a href=\"#添加\" class=\"headerlink\" title=\"添加\"></a>添加</h4><ol>\n<li>lpush    key    value    [value1]    //从左添加</li>\n<li>rpush    key    value    [value1]    //从右添加</li>\n</ol>\n<h4 id=\"获取\"><a href=\"#获取\" class=\"headerlink\" title=\"获取\"></a>获取</h4><ol>\n<li>lrange    key    start    stop</li>\n<li>lindex    key    index</li>\n<li>llen    key</li>\n</ol>\n<h4 id=\"获取并移除\"><a href=\"#获取并移除\" class=\"headerlink\" title=\"获取并移除\"></a>获取并移除</h4><ol>\n<li>lpop    key    //从左出</li>\n<li>rpop    key    //从右出</li>\n</ol>\n<pre><code class=\"tex\">lpush    list    a    b    c\n结果：c b a\n===============================\nrpush list a    b    c\n结果：a b c\n===============================\nlist=[a    b    c]\nlpop list\n结果：b c\n===============================\nlist=[a b c]\nrpop list\n结果：a b\n===============================</code></pre>\n<blockquote>\n<p>注：</p>\n<ol>\n<li>list中保存的数据都是String，数据总量是有限的，最多$2^{32}-1$个元素</li>\n<li>list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作（或以栈的形式进行入栈出栈操作）</li>\n<li>当stop的值为-1时，获取的是全部数据</li>\n<li>list对数据进行分页操作，通常第一页的数据使的信息来自list，其他页面的数据通过数据形式进行加载</li>\n</ol>\n</blockquote>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><h4 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>增：sadd    key    member    [member1]</li>\n<li>查：smembers    key</li>\n<li>删：srem    key    member    [member1]</li>\n<li>获取总量：scard    key</li>\n<li>判定是否存在：sismember    key    member</li>\n<li>随机获取（原集合保留）：srandmember    key    [count]</li>\n<li>随机获取（原集合不保留）：spop    key</li>\n<li>集合交集：sinter    key    key1    key2</li>\n<li>集合并集：sunion    key    key1    key2</li>\n<li>集合差集：sdiff    key    key1    key2</li>\n<li>存储集合交集：sinterstore    destination    key    key1    key2</li>\n<li>存储集合并集：sunionstore    destination    key    key1    key2</li>\n<li>存储集合差集：sdiffstore    destination    key    key1    key2</li>\n<li>集合元素移动：smove    source    destination    member</li>\n</ol>\n<h3 id=\"Sorted-Set\"><a href=\"#Sorted-Set\" class=\"headerlink\" title=\"Sorted_Set\"></a>Sorted_Set</h3><h4 id=\"命令-1\"><a href=\"#命令-1\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>增：zadd    key    score    member    [score1    member1]</li>\n<li>删：zrem    key    member    [member1]</li>\n<li>获取全部（正序）：zrange    key    start    stop    [withscores]</li>\n<li>获取全部（倒序）：zrevrange    key    start    stop    [withscores]</li>\n<li>按条件查（正序）：zrangebyscore    key    min    max    [withscore    limit]</li>\n<li>按条件查（倒序）：zrevrangebyscore    key    max    min    [withscore    limit]</li>\n<li>按条件删除（索引）：zremrangebyrank    key    start    stop</li>\n<li>按条件删除（积分）：zremrangebyscore    key    min    max</li>\n<li>获取集合总量：zcard    key    |    zcount    key    min    max</li>\n<li>存储集合交集：    zinterstore    destination    numkeys    key    key1</li>\n<li>存储集合并集：zunionstore    destination    numkeys    key    key1</li>\n<li>获取索引（正序）：zrank    key    member</li>\n<li>获取索引（倒序）：zrevrank    key    member</li>\n<li>score值获取：zscore    key    member</li>\n<li>score值修改：zincrby    key    num    member</li>\n</ol>\n<h2 id=\"Key的操作\"><a href=\"#Key的操作\" class=\"headerlink\" title=\"Key的操作\"></a>Key的操作</h2><h3 id=\"命令-2\"><a href=\"#命令-2\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ol>\n<li>删除：del    key</li>\n<li>判断是否存在：exists    key</li>\n<li>获取key类型：type    key</li>\n<li>指定有效期：<ol>\n<li>expire    key    seconds</li>\n<li>pexpire    key    milliseconds</li>\n<li>expireat    key    timestamp</li>\n<li>pexpireat    key    milliseconds-timestamp</li>\n</ol>\n</li>\n<li>获取有效期：<ol>\n<li>ttl    key</li>\n<li>pttl    key</li>\n</ol>\n</li>\n<li>设置永久：persist    key</li>\n<li>查询key：key    pattern    //*,?,[]</li>\n<li>重命名：rename    key    newkey    |    renamenx    key    newkey</li>\n<li>对key排序：sort</li>\n</ol>\n<h2 id=\"数据库操作\"><a href=\"#数据库操作\" class=\"headerlink\" title=\"数据库操作\"></a>数据库操作</h2><h3 id=\"命令-3\"><a href=\"#命令-3\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ol>\n<li>选择数据库：select    index</li>\n<li>数据移动：move    key    db</li>\n<li>数据库大小：dbsize</li>\n<li>数据清除：<ol>\n<li>单库删除：flushdb</li>\n<li>多库删除：flushall</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><h3 id=\"RDB（Relational-Database）\"><a href=\"#RDB（Relational-Database）\" class=\"headerlink\" title=\"RDB（Relational Database）\"></a>RDB（Relational Database）</h3><h4 id=\"保存数据\"><a href=\"#保存数据\" class=\"headerlink\" title=\"保存数据\"></a>保存数据</h4><ol>\n<li>指令（前台）：save    //阻塞 立即保存</li>\n<li>指令（后台）：bgsave    //不立即执行</li>\n<li>配置：save    second    changes    //用bgsave执行操作</li>\n</ol>\n<h4 id=\"常用配置项\"><a href=\"#常用配置项\" class=\"headerlink\" title=\"常用配置项\"></a>常用配置项</h4><ol>\n<li>数据文件名称：dbfilename    dump.rdb    //默认</li>\n<li>数据保存路径：dir</li>\n<li>是否开启压缩：rdbcompression    yes    //默认</li>\n<li>是否开启格式检查：rdbchecksum    yes|no //默认no</li>\n</ol>\n<h4 id=\"RDB-持久化优点\"><a href=\"#RDB-持久化优点\" class=\"headerlink\" title=\"RDB 持久化优点\"></a>RDB 持久化优点</h4><ol>\n<li>RDB是一个紧凑压缩的二进制文件，存储效率高</li>\n<li>RDB存储的是Redis在某个时间点的数据快照，非常适用于数据备份全量复制等场景</li>\n<li>RDB恢复数据速度比AOF快</li>\n</ol>\n<h4 id=\"RDB应用\"><a href=\"#RDB应用\" class=\"headerlink\" title=\"RDB应用\"></a>RDB应用</h4><p>服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复</p>\n<h4 id=\"RDB持久化缺点\"><a href=\"#RDB持久化缺点\" class=\"headerlink\" title=\"RDB持久化缺点\"></a>RDB持久化缺点</h4><ol>\n<li>RDB方式无论是执行命令还是进行配置，无法做到实时持久化，具有较大可能丢失数据</li>\n<li>bgsave每次运行要执行fork操作创建子进程，要牺牲一些性能</li>\n<li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各个版本服务器之间数据格式无法兼容</li>\n<li>存储数量较大时，效率较低</li>\n<li>大数据量下的I／O性能较低</li>\n<li>基于fork创建子进程，内存产生额外消耗</li>\n<li>宕机带来的数据丢失风险</li>\n</ol>\n<h3 id=\"AOF（Append-Only-File）\"><a href=\"#AOF（Append-Only-File）\" class=\"headerlink\" title=\"AOF（Append Only File）\"></a>AOF（Append Only File）</h3><h4 id=\"保存数据策略\"><a href=\"#保存数据策略\" class=\"headerlink\" title=\"保存数据策略\"></a>保存数据策略</h4><p>每次：always<br>每秒：everysec<br>系统控制：no</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><ol>\n<li>是否开启：appendonly    yes|no    //默认no</li>\n<li>保存策略：appendfsync    always|everysec|no</li>\n<li>重写：<br> 手动：bgrewriteaof<br> 自动：<pre><code> auto-aof-rewrite-min-size    size\n auto-aof-rewrite-percentage    percentage</code></pre></li>\n</ol>\n<h3 id=\"RDB-与-AOF-如何选择\"><a href=\"#RDB-与-AOF-如何选择\" class=\"headerlink\" title=\"RDB 与 AOF 如何选择\"></a>RDB 与 AOF 如何选择</h3><p>对数据非常敏感，建议使用默认的AOF持久化方案<br>    AOF策略使用everysec，每秒fsync一次，该策略仍可保持很好性能，出现问题最多丢失一秒内的数据<br>数据呈现阶段有效性，建议使用RDB持久化方案<br>    数据可以做到阶段内无丢失，且恢复较快，阶段点数据恢复通常使用RDB方案</p>\n<blockquote>\n<p>注意：<br>AOF文件存储体积较大，恢复速度较慢<br>利用RDB使用线紧凑的数据持久化会使Redis性能降低</p>\n</blockquote>\n<p>综合：</p>\n<ol>\n<li>RDB与AOF选择实际上是在一种权衡，每种都有利有弊</li>\n<li>如果不能承受分钟内的数据丢失，对业务数据非常敏感，选用AOF</li>\n<li>如果能承受分钟内的数据丢失，且追求大数据集的恢复速度选用RDB</li>\n<li>灾难恢复选用RDB</li>\n<li>双保险策略，同时开启RDB和AOF，重启后Redis优先使用AOF来恢复数据，降低丢失数据量</li>\n</ol>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>Redis事务不具有回滚机制</p>\n<h3 id=\"命令-4\"><a href=\"#命令-4\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ol>\n<li>开启：multi</li>\n<li>结束：exec</li>\n<li>中断：discard</li>\n</ol>\n<h3 id=\"事务中的错误\"><a href=\"#事务中的错误\" class=\"headerlink\" title=\"事务中的错误\"></a>事务中的错误</h3><h4 id=\"命令错误\"><a href=\"#命令错误\" class=\"headerlink\" title=\"命令错误\"></a>命令错误</h4><p>执行事务过程中输入的命令出现错误，Redis会结束事务不再执行，并报出错误的命令</p>\n<h4 id=\"操作错误\"><a href=\"#操作错误\" class=\"headerlink\" title=\"操作错误\"></a>操作错误</h4><p>执行事务过程中输入的命令正确，其他操作错误，事务中其他命令正常执行，错误操作报错</p>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><p>Redis中锁和事务是相搭配使用的，可解决对key的监控</p>\n<h3 id=\"命令-5\"><a href=\"#命令-5\" class=\"headerlink\" title=\"命令\"></a>命令</h3><p>加锁：watch    key    [key1]<br>解锁：unwatch  //取消掉所有key的监控</p>\n<h2 id=\"数据删除策略\"><a href=\"#数据删除策略\" class=\"headerlink\" title=\"数据删除策略\"></a>数据删除策略</h2><p>当key过期后执行数据删除的策略</p>\n<h3 id=\"定时删除（即可删除）\"><a href=\"#定时删除（即可删除）\" class=\"headerlink\" title=\"定时删除（即可删除）\"></a>定时删除（即可删除）</h3><p>创建一个具有时效性的key时，同时会创建一个定时器来监控该key是否过期，当key过期后立即进行key的删除</p>\n<p>优点：节约内存，到时就会进行删除，快速释放占用空间<br>缺点：CPU压力大影响Redis响应时间和吞吐量<br>总结：用处理器性能换取存储空间</p>\n<h3 id=\"惰性删除\"><a href=\"#惰性删除\" class=\"headerlink\" title=\"惰性删除\"></a>惰性删除</h3><p>当一个具有实效性的key过期后不会有删除操作，直到下一次调用时会先检查该key是否过期，如果过期则进行删除操作，并返回nil（该key不存在）</p>\n<p>优点：节约CPU性能，发现必须删除的时候才会删除<br>缺点：内存压力大，出现长期占用内存的数据<br>总结：用存储空间换取处理器性能</p>\n<h3 id=\"定期删除\"><a href=\"#定期删除\" class=\"headerlink\" title=\"定期删除\"></a>定期删除</h3><p>Redis会根据设置的参数，定期对具有时效性的key进行清理工作，它是定时删除和惰性删除的结合者，既不像定时删除会立即进行删除给予CPU压力，也不会像惰性删除给予内存压力</p>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><ol>\n<li>Redis启动服务器初始化时，读取配置server.hz的值（默认为10）</li>\n<li>每秒钟执行server.hz次serverCron（）服务（serverCron【服务器级别】-&gt;databasesCron【数据库级别】-&gt;activeExpireCyle【活跃数据级别】）</li>\n<li>acitveExpireCyle（）对每个expires[*]（数据库）逐一进行检测，每次执行250ms／server.hz</li>\n<li>对某个expires[*]检测时，随机挑选w个key进行检测<ol>\n<li>如果key超时，删除key</li>\n<li>如果一轮中删除的kye的数量&gt;w*25%，循环该过程</li>\n<li>如果一轮中删除的可以的数量&lt;=w<em>25%检查下一个expires[</em>],0-15（所有的数据库）循环<blockquote>\n<p>W=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP<br>参数current_db用于记录activeExpireCyle进入哪个expires[*]执行</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"数据淘汰策略\"><a href=\"#数据淘汰策略\" class=\"headerlink\" title=\"数据淘汰策略\"></a>数据淘汰策略</h2><p>当内存到达最大内存限制时进行的数据淘汰策略</p>\n<p>数据驱逐淘汰策略配置依据，使用info命令输出相关监控信息，查新缓存hit 命中次数和miss的次数，根据业务调优</p>\n<h3 id=\"配置-1\"><a href=\"#配置-1\" class=\"headerlink\" title=\"配置\"></a>配置</h3><ol>\n<li>最大可用内存：maxmemory    //默认为0，一般设置全部内存50%以上</li>\n<li>每次选取带删除数据个数：maxmemory-samples    //采用随机获取方式</li>\n<li>删除策略：maxmemory-policy    //达到最大内存后，对被选取带数据进行的删除策略</li>\n</ol>\n<h3 id=\"检测易失数据集（可能会过期数据server-db-i-expires）\"><a href=\"#检测易失数据集（可能会过期数据server-db-i-expires）\" class=\"headerlink\" title=\"检测易失数据集（可能会过期数据server.db[i].expires）\"></a>检测易失数据集（可能会过期数据server.db[i].expires）</h3><ol>\n<li>volatile-lru：挑选最近最少使用的数据淘汰（最近数据中使用时间离当前最远的数据）。<strong>常用</strong></li>\n<li>volatile-lfu：挑选最近使用次数最少的数据淘汰（最近数据中使用次数最少的数据）</li>\n<li>volatile-ttl：挑选将要过期数据淘汰</li>\n<li>volatile-random：任意挑选数据淘汰</li>\n</ol>\n<blockquote>\n<p>ttl：time to live<br>lru：least recently    used<br>lfu：least frequently    used</p>\n</blockquote>\n<h3 id=\"检测全库数据（所有数据集server-db-i-dict）\"><a href=\"#检测全库数据（所有数据集server-db-i-dict）\" class=\"headerlink\" title=\"检测全库数据（所有数据集server.db[i].dict）\"></a>检测全库数据（所有数据集server.db[i].dict）</h3><ol>\n<li>allkeys-lru：挑选最近最少使用的数据淘汰</li>\n<li>allkeys-lfu：挑选最近使用次数最少的数据淘汰</li>\n<li>allkeys-random：任意挑选数据淘汰</li>\n</ol>\n<h3 id=\"放弃数据驱逐\"><a href=\"#放弃数据驱逐\" class=\"headerlink\" title=\"放弃数据驱逐\"></a>放弃数据驱逐</h3><p>no-enviction    //禁止驱逐数据<br>4.0中默认策略，会引发OOM</p>\n<h2 id=\"服务器基本配置\"><a href=\"#服务器基本配置\" class=\"headerlink\" title=\"服务器基本配置\"></a>服务器基本配置</h2><ol>\n<li>设置服务器守护进程方式：daemonize    yes|no</li>\n<li>绑定地址：bing    127.0.0.1</li>\n<li>设置服务器端口：port    6379</li>\n<li>设置数据库数量：databases    16</li>\n<li>设置服务器日志级别：loglevel    debug|verbose|notice|warning</li>\n<li>日志文件名称：logfile    端口号.log</li>\n<li>设置客户端最大连接数：maxclients    0</li>\n<li>客户端闲置最大等待时长：timeout    0</li>\n</ol>\n<h2 id=\"高级数据类型\"><a href=\"#高级数据类型\" class=\"headerlink\" title=\"高级数据类型\"></a>高级数据类型</h2><h3 id=\"Bitmaps\"><a href=\"#Bitmaps\" class=\"headerlink\" title=\"Bitmaps\"></a>Bitmaps</h3><p>标记统计</p>\n<h4 id=\"命令-6\"><a href=\"#命令-6\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>获取：getbit    key    offset</li>\n<li>设置：setbit    key    offset    value    // 0 或 1</li>\n<li>交、并、或异<br> bitop    op    destkey    key1    key2<br> op：<pre><code> 交：and\n 并：or\n 非：not\n 异或：xor</code></pre></li>\n<li>统计指定key中1的数量：bitcount    key    [start    end]</li>\n</ol>\n<h3 id=\"HyperLoglog\"><a href=\"#HyperLoglog\" class=\"headerlink\" title=\"HyperLoglog\"></a>HyperLoglog</h3><p>基数统计</p>\n<h4 id=\"命令-7\"><a href=\"#命令-7\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>添加：pfadd    key    element    [element1]</li>\n<li>统计：pfcount    key    [key1]</li>\n<li>合并：pfmerge    destkey    sourcekey    [sourcekey1]</li>\n</ol>\n<h3 id=\"GEO\"><a href=\"#GEO\" class=\"headerlink\" title=\"GEO\"></a>GEO</h3><p>距离计算（只计算水平距离）</p>\n<h4 id=\"命令-8\"><a href=\"#命令-8\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>添加：geoadd    key    longitude    latitude    member    [longitude1    latitude1    member1]</li>\n<li>获取：geopos    key    member    [member1]</li>\n<li>计算距离：geodist    key    member1    member2    [count]</li>\n<li>根据坐标求范围内数据：georadius    key    longitude    latitude    radius    m|km|ft|mi</li>\n<li>根据点求范围内的数据：georadusbymember    key    member    radius    m|km|ft|mi</li>\n<li>获取指定点对应的hash值：geohash    key    member    [member1]    </li>\n</ol>\n<h2 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h2><h3 id=\"创建链接\"><a href=\"#创建链接\" class=\"headerlink\" title=\"创建链接\"></a>创建链接</h3><ul>\n<li>方式一：客户端发指令：slaveof    masterip masterport</li>\n<li>方式二：参数启动：redis-server    –slaveof    masterip masterport</li>\n<li>方式三：服务器配置：slaveof    masterip masterport</li>\n</ul>\n<h3 id=\"数据同步\"><a href=\"#数据同步\" class=\"headerlink\" title=\"数据同步\"></a>数据同步</h3><h4 id=\"全量复制\"><a href=\"#全量复制\" class=\"headerlink\" title=\"全量复制\"></a>全量复制</h4><p>从：发送指令（psync2）<br>主：执行bgsave<br>主：第一个slave链接时，创建命令缓冲区<br>主：生成RDB文件，通过socket发送给slave<br>从：接收RDB文件，清空自己数据，执行RDB文件恢复过程</p>\n<h4 id=\"部分复制\"><a href=\"#部分复制\" class=\"headerlink\" title=\"部分复制\"></a>部分复制</h4><p>从：发送命令告知RDB恢复完成<br>主：发送复制缓冲区信息<br>从：接收信息，执行bgsavewriteaof，恢复数据</p>\n<h2 id=\"哨兵模式\"><a href=\"#哨兵模式\" class=\"headerlink\" title=\"哨兵模式\"></a>哨兵模式</h2><h3 id=\"配置-2\"><a href=\"#配置-2\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>sentinel.conf</p>\n<p>启动：redis-sentinel</p>\n<h2 id=\"集群（cluster）\"><a href=\"#集群（cluster）\" class=\"headerlink\" title=\"集群（cluster）\"></a>集群（cluster）</h2><h3 id=\"配置-3\"><a href=\"#配置-3\" class=\"headerlink\" title=\"配置\"></a>配置</h3><ol>\n<li>开启：cluster-enabled    yes|no</li>\n<li>配置文件名称：cluster-config-file    filename</li>\n<li>节点超时时间：cluster-node-timeout    milliseconds</li>\n<li>master链接slave最小数：cluster-migration-barrier    count</li>\n</ol>\n<h3 id=\"命令-9\"><a href=\"#命令-9\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ol>\n<li>查看节点信息：cluster nodes</li>\n<li>从一个节点Redis，切换其主节点：cluster    replicate    masterip</li>\n<li>新增主节点：cluster meet    ip:port</li>\n<li>忽略一个节点：cluster    foeget    id</li>\n<li>手动故障转移：cluster    failover</li>\n</ol>\n"},{"title":"tags","date":"2018-09-12T15:24:17.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-09-12 23:24:17\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2020-03-19T04:51:26.000Z","path":"tags/index.html","comments":1,"_id":"ck8hf2uw1000qzhs67fmykgt3","content":"","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":""},{"_content":"# Git & GitHub\n\n\n## Git\n\n### init\n### clone\n### add\n将变化提交到working directory（工作区）\n\n- git  add filename \t\n  添加file 到working directory\n- git add . \n  提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件\n- git add -u   (git add --update)\n  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)\n- git add -A  (git add --all)\n  提交所有变化，是`git add -u `和`git add . `两个功能的合集（git add --all的缩写）\n\n### update-index\n\n- git update-index --force-remove filename\n\n  将文件从追踪中删除，本地不会删除\n\n### ls-files\n\n- git ls-files \n\n  列出追踪的所有文件\n\n### rm\n\n- git rm filename\n  从工作区和索引中删除文件\n  \n- git rm --cached filename \n  \n  保留本地文件不在跟踪文件\n\n### commit\n将变化提交到staging area（暂存区）\n\n- git commit -m 'init' \n  提交暂存区改变到本地库\n  \n- git commit -am 'init'\n  添加所有改变并提交到本地库\n\n### push\n### pull\n### diff\n比较变化\n\n- git diff \n  比较工作区与本地库中的最后一次提交\n\n- git diff --cached\n  比较暂存区与本地库中的最后一次提交\n\n- git diff HEAD\n  比较工作区与暂存区\n### reset\n- git reset filename\n  将加入暂存区中的文件撤回到工作区\n  \n- git reset --hard commitid\n  直接回到commitid状态。所有commitid之后的操作全部清空\n  \n- git reset --hard HEAD^\n  回到上次提交的状态，撤销掉最近一次提交\n  \n### restore\n- git restore filename \n  丢弃工作区的改动\n\n### log\n查看git 提交日志\n\n- git log\n  显示详细提交信息\n- git log --oneline\n  简单显示提交信息\n  \n### reflog\n如果执行了`git reset --hard commitid`后还想回到commitid以后的某个操作时可以使用此命令，这相当于git log 的log\n\n### checkout\n切换到某个提交的节点\n\n- git checkout commitid\n  切换到历史的某个commitid的状态。将HEAD的指针指向某个commitid。如果当前状态是master，要想回到master前面某个提交状态，可以使用`git checkout commitid`回到commitid中的操作环境看看。在当前状态修改的操作提交后，如果后期回到master状态，修改的操作会丢失。\n\n- git checkout branchname\n  切换到某个分支\n  \n- git checkout -b branchname\n  创建并切换到某个分支\n  \n- git checkout tagname\n  切换到某个标签\n  \n  \n### status\n查看当前状态\n\n- git status\n  显示当前状态的相信信息\n\n- git status -s \n  显示当前状态的简单信息\n\n### branch\n查看创建分支\n\n- git branch\n  查看有哪些分支，带*号的为当前分支\n  \n- git branch name\n  创建一个name的分支\n\n### merge\n合并分支\n\n- git merge branchname\n  合并某个分支到当前分支。山寨过来就是我的，不会保留信息\n\n- git merge branchname --no-ff -m 'init'\n  合并某个分支到当前分支，会保留之前分支的提交记录状态和分支信息。山寨人家，但是会保留人家的信息\n\n### tag\n给提交添加标签\n\n- git tag tagname\n  给当前提交添加标签\n\n\n### remote\n查看远端库信息\n\n- git remote \n  查看远端库简要信息\t\n\n- git remote -v //-v == --verbose\n  查看远端库信息带有url\n  \n- git remote add origin url\n  添加一个名字为origin 的远端库地址为url\n  \n  \n### push\n推送本地库到远端库\n\n- git push\n  推送本地master分支到默认远端库分支\n\n- git push -u origin \n  第一次推送时可以使用-u参数，指定默认的远端库，设定以后再提交可以直接使用`git push`\n  \n- git push  origin master\n  推送本地master的分支到名为origin远端库的master分支\n  \n- git push  origin master1:master2\n  推送本地分支master1到origin远端库分支master2\n  \n- git push  origin :master2\n  推送一个空分支到origin远端库分支master2\n\n![QQ20200318-211942@2x](Git&GitHub.assets/QQ20200318-211942@2x.png)\n\n\n\n\n\n## GitHub\n\n1. awesome\n\n   ```\n   awesome 关键词\n   ```\n\n   \n\n2. \n\n","source":"notes/Git&GitHub.md","raw":"# Git & GitHub\n\n\n## Git\n\n### init\n### clone\n### add\n将变化提交到working directory（工作区）\n\n- git  add filename \t\n  添加file 到working directory\n- git add . \n  提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件\n- git add -u   (git add --update)\n  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)\n- git add -A  (git add --all)\n  提交所有变化，是`git add -u `和`git add . `两个功能的合集（git add --all的缩写）\n\n### update-index\n\n- git update-index --force-remove filename\n\n  将文件从追踪中删除，本地不会删除\n\n### ls-files\n\n- git ls-files \n\n  列出追踪的所有文件\n\n### rm\n\n- git rm filename\n  从工作区和索引中删除文件\n  \n- git rm --cached filename \n  \n  保留本地文件不在跟踪文件\n\n### commit\n将变化提交到staging area（暂存区）\n\n- git commit -m 'init' \n  提交暂存区改变到本地库\n  \n- git commit -am 'init'\n  添加所有改变并提交到本地库\n\n### push\n### pull\n### diff\n比较变化\n\n- git diff \n  比较工作区与本地库中的最后一次提交\n\n- git diff --cached\n  比较暂存区与本地库中的最后一次提交\n\n- git diff HEAD\n  比较工作区与暂存区\n### reset\n- git reset filename\n  将加入暂存区中的文件撤回到工作区\n  \n- git reset --hard commitid\n  直接回到commitid状态。所有commitid之后的操作全部清空\n  \n- git reset --hard HEAD^\n  回到上次提交的状态，撤销掉最近一次提交\n  \n### restore\n- git restore filename \n  丢弃工作区的改动\n\n### log\n查看git 提交日志\n\n- git log\n  显示详细提交信息\n- git log --oneline\n  简单显示提交信息\n  \n### reflog\n如果执行了`git reset --hard commitid`后还想回到commitid以后的某个操作时可以使用此命令，这相当于git log 的log\n\n### checkout\n切换到某个提交的节点\n\n- git checkout commitid\n  切换到历史的某个commitid的状态。将HEAD的指针指向某个commitid。如果当前状态是master，要想回到master前面某个提交状态，可以使用`git checkout commitid`回到commitid中的操作环境看看。在当前状态修改的操作提交后，如果后期回到master状态，修改的操作会丢失。\n\n- git checkout branchname\n  切换到某个分支\n  \n- git checkout -b branchname\n  创建并切换到某个分支\n  \n- git checkout tagname\n  切换到某个标签\n  \n  \n### status\n查看当前状态\n\n- git status\n  显示当前状态的相信信息\n\n- git status -s \n  显示当前状态的简单信息\n\n### branch\n查看创建分支\n\n- git branch\n  查看有哪些分支，带*号的为当前分支\n  \n- git branch name\n  创建一个name的分支\n\n### merge\n合并分支\n\n- git merge branchname\n  合并某个分支到当前分支。山寨过来就是我的，不会保留信息\n\n- git merge branchname --no-ff -m 'init'\n  合并某个分支到当前分支，会保留之前分支的提交记录状态和分支信息。山寨人家，但是会保留人家的信息\n\n### tag\n给提交添加标签\n\n- git tag tagname\n  给当前提交添加标签\n\n\n### remote\n查看远端库信息\n\n- git remote \n  查看远端库简要信息\t\n\n- git remote -v //-v == --verbose\n  查看远端库信息带有url\n  \n- git remote add origin url\n  添加一个名字为origin 的远端库地址为url\n  \n  \n### push\n推送本地库到远端库\n\n- git push\n  推送本地master分支到默认远端库分支\n\n- git push -u origin \n  第一次推送时可以使用-u参数，指定默认的远端库，设定以后再提交可以直接使用`git push`\n  \n- git push  origin master\n  推送本地master的分支到名为origin远端库的master分支\n  \n- git push  origin master1:master2\n  推送本地分支master1到origin远端库分支master2\n  \n- git push  origin :master2\n  推送一个空分支到origin远端库分支master2\n\n![QQ20200318-211942@2x](Git&GitHub.assets/QQ20200318-211942@2x.png)\n\n\n\n\n\n## GitHub\n\n1. awesome\n\n   ```\n   awesome 关键词\n   ```\n\n   \n\n2. \n\n","date":"2020-04-01T16:24:03.000Z","updated":"2020-04-01T16:24:03.000Z","path":"notes/Git&GitHub.html","_id":"ck8hirb450000ous64hircke0","title":"","comments":1,"layout":"page","content":"<h1 id=\"Git-amp-GitHub\"><a href=\"#Git-amp-GitHub\" class=\"headerlink\" title=\"Git &amp; GitHub\"></a>Git &amp; GitHub</h1><h2 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h2><h3 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h3><h3 id=\"clone\"><a href=\"#clone\" class=\"headerlink\" title=\"clone\"></a>clone</h3><h3 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h3><p>将变化提交到working directory（工作区）</p>\n<ul>\n<li>git  add filename<br>添加file 到working directory</li>\n<li>git add .<br>提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件</li>\n<li>git add -u   (git add –update)<br>提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)</li>\n<li>git add -A  (git add –all)<br>提交所有变化，是<code>git add -u</code>和<code>git add .</code>两个功能的合集（git add –all的缩写）</li>\n</ul>\n<h3 id=\"update-index\"><a href=\"#update-index\" class=\"headerlink\" title=\"update-index\"></a>update-index</h3><ul>\n<li><p>git update-index –force-remove filename</p>\n<p>将文件从追踪中删除，本地不会删除</p>\n</li>\n</ul>\n<h3 id=\"ls-files\"><a href=\"#ls-files\" class=\"headerlink\" title=\"ls-files\"></a>ls-files</h3><ul>\n<li><p>git ls-files </p>\n<p>列出追踪的所有文件</p>\n</li>\n</ul>\n<h3 id=\"rm\"><a href=\"#rm\" class=\"headerlink\" title=\"rm\"></a>rm</h3><ul>\n<li><p>git rm filename<br>从工作区和索引中删除文件</p>\n</li>\n<li><p>git rm –cached filename </p>\n<p>保留本地文件不在跟踪文件</p>\n</li>\n</ul>\n<h3 id=\"commit\"><a href=\"#commit\" class=\"headerlink\" title=\"commit\"></a>commit</h3><p>将变化提交到staging area（暂存区）</p>\n<ul>\n<li><p>git commit -m ‘init’<br>提交暂存区改变到本地库</p>\n</li>\n<li><p>git commit -am ‘init’<br>添加所有改变并提交到本地库</p>\n</li>\n</ul>\n<h3 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push\"></a>push</h3><h3 id=\"pull\"><a href=\"#pull\" class=\"headerlink\" title=\"pull\"></a>pull</h3><h3 id=\"diff\"><a href=\"#diff\" class=\"headerlink\" title=\"diff\"></a>diff</h3><p>比较变化</p>\n<ul>\n<li><p>git diff<br>比较工作区与本地库中的最后一次提交</p>\n</li>\n<li><p>git diff –cached<br>比较暂存区与本地库中的最后一次提交</p>\n</li>\n<li><p>git diff HEAD<br>比较工作区与暂存区</p>\n<h3 id=\"reset\"><a href=\"#reset\" class=\"headerlink\" title=\"reset\"></a>reset</h3></li>\n<li><p>git reset filename<br>将加入暂存区中的文件撤回到工作区</p>\n</li>\n<li><p>git reset –hard commitid<br>直接回到commitid状态。所有commitid之后的操作全部清空</p>\n</li>\n<li><p>git reset –hard HEAD^<br>回到上次提交的状态，撤销掉最近一次提交</p>\n</li>\n</ul>\n<h3 id=\"restore\"><a href=\"#restore\" class=\"headerlink\" title=\"restore\"></a>restore</h3><ul>\n<li>git restore filename<br>丢弃工作区的改动</li>\n</ul>\n<h3 id=\"log\"><a href=\"#log\" class=\"headerlink\" title=\"log\"></a>log</h3><p>查看git 提交日志</p>\n<ul>\n<li>git log<br>显示详细提交信息</li>\n<li>git log –oneline<br>简单显示提交信息</li>\n</ul>\n<h3 id=\"reflog\"><a href=\"#reflog\" class=\"headerlink\" title=\"reflog\"></a>reflog</h3><p>如果执行了<code>git reset --hard commitid</code>后还想回到commitid以后的某个操作时可以使用此命令，这相当于git log 的log</p>\n<h3 id=\"checkout\"><a href=\"#checkout\" class=\"headerlink\" title=\"checkout\"></a>checkout</h3><p>切换到某个提交的节点</p>\n<ul>\n<li><p>git checkout commitid<br>切换到历史的某个commitid的状态。将HEAD的指针指向某个commitid。如果当前状态是master，要想回到master前面某个提交状态，可以使用<code>git checkout commitid</code>回到commitid中的操作环境看看。在当前状态修改的操作提交后，如果后期回到master状态，修改的操作会丢失。</p>\n</li>\n<li><p>git checkout branchname<br>切换到某个分支</p>\n</li>\n<li><p>git checkout -b branchname<br>创建并切换到某个分支</p>\n</li>\n<li><p>git checkout tagname<br>切换到某个标签</p>\n</li>\n</ul>\n<h3 id=\"status\"><a href=\"#status\" class=\"headerlink\" title=\"status\"></a>status</h3><p>查看当前状态</p>\n<ul>\n<li><p>git status<br>显示当前状态的相信信息</p>\n</li>\n<li><p>git status -s<br>显示当前状态的简单信息</p>\n</li>\n</ul>\n<h3 id=\"branch\"><a href=\"#branch\" class=\"headerlink\" title=\"branch\"></a>branch</h3><p>查看创建分支</p>\n<ul>\n<li><p>git branch<br>查看有哪些分支，带*号的为当前分支</p>\n</li>\n<li><p>git branch name<br>创建一个name的分支</p>\n</li>\n</ul>\n<h3 id=\"merge\"><a href=\"#merge\" class=\"headerlink\" title=\"merge\"></a>merge</h3><p>合并分支</p>\n<ul>\n<li><p>git merge branchname<br>合并某个分支到当前分支。山寨过来就是我的，不会保留信息</p>\n</li>\n<li><p>git merge branchname –no-ff -m ‘init’<br>合并某个分支到当前分支，会保留之前分支的提交记录状态和分支信息。山寨人家，但是会保留人家的信息</p>\n</li>\n</ul>\n<h3 id=\"tag\"><a href=\"#tag\" class=\"headerlink\" title=\"tag\"></a>tag</h3><p>给提交添加标签</p>\n<ul>\n<li>git tag tagname<br>给当前提交添加标签</li>\n</ul>\n<h3 id=\"remote\"><a href=\"#remote\" class=\"headerlink\" title=\"remote\"></a>remote</h3><p>查看远端库信息</p>\n<ul>\n<li><p>git remote<br>查看远端库简要信息    </p>\n</li>\n<li><p>git remote -v //-v == –verbose<br>查看远端库信息带有url</p>\n</li>\n<li><p>git remote add origin url<br>添加一个名字为origin 的远端库地址为url</p>\n</li>\n</ul>\n<h3 id=\"push-1\"><a href=\"#push-1\" class=\"headerlink\" title=\"push\"></a>push</h3><p>推送本地库到远端库</p>\n<ul>\n<li><p>git push<br>推送本地master分支到默认远端库分支</p>\n</li>\n<li><p>git push -u origin<br>第一次推送时可以使用-u参数，指定默认的远端库，设定以后再提交可以直接使用<code>git push</code></p>\n</li>\n<li><p>git push  origin master<br>推送本地master的分支到名为origin远端库的master分支</p>\n</li>\n<li><p>git push  origin master1:master2<br>推送本地分支master1到origin远端库分支master2</p>\n</li>\n<li><p>git push  origin :master2<br>推送一个空分支到origin远端库分支master2</p>\n</li>\n</ul>\n<p><img src=\"Git&GitHub.assets/QQ20200318-211942@2x.png\" alt=\"QQ20200318-211942@2x\"></p>\n<h2 id=\"GitHub\"><a href=\"#GitHub\" class=\"headerlink\" title=\"GitHub\"></a>GitHub</h2><ol>\n<li><p>awesome</p>\n<pre><code>awesome 关键词</code></pre></li>\n</ol>\n<ol start=\"2\">\n<li></li>\n</ol>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":"<h1 id=\"Git-amp-GitHub\"><a href=\"#Git-amp-GitHub\" class=\"headerlink\" title=\"Git &amp; GitHub\"></a>Git &amp; GitHub</h1><h2 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h2><h3 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h3><h3 id=\"clone\"><a href=\"#clone\" class=\"headerlink\" title=\"clone\"></a>clone</h3><h3 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h3><p>将变化提交到working directory（工作区）</p>\n<ul>\n<li>git  add filename<br>添加file 到working directory</li>\n<li>git add .<br>提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件</li>\n<li>git add -u   (git add –update)<br>提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)</li>\n<li>git add -A  (git add –all)<br>提交所有变化，是<code>git add -u</code>和<code>git add .</code>两个功能的合集（git add –all的缩写）</li>\n</ul>\n<h3 id=\"update-index\"><a href=\"#update-index\" class=\"headerlink\" title=\"update-index\"></a>update-index</h3><ul>\n<li><p>git update-index –force-remove filename</p>\n<p>将文件从追踪中删除，本地不会删除</p>\n</li>\n</ul>\n<h3 id=\"ls-files\"><a href=\"#ls-files\" class=\"headerlink\" title=\"ls-files\"></a>ls-files</h3><ul>\n<li><p>git ls-files </p>\n<p>列出追踪的所有文件</p>\n</li>\n</ul>\n<h3 id=\"rm\"><a href=\"#rm\" class=\"headerlink\" title=\"rm\"></a>rm</h3><ul>\n<li><p>git rm filename<br>从工作区和索引中删除文件</p>\n</li>\n<li><p>git rm –cached filename </p>\n<p>保留本地文件不在跟踪文件</p>\n</li>\n</ul>\n<h3 id=\"commit\"><a href=\"#commit\" class=\"headerlink\" title=\"commit\"></a>commit</h3><p>将变化提交到staging area（暂存区）</p>\n<ul>\n<li><p>git commit -m ‘init’<br>提交暂存区改变到本地库</p>\n</li>\n<li><p>git commit -am ‘init’<br>添加所有改变并提交到本地库</p>\n</li>\n</ul>\n<h3 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push\"></a>push</h3><h3 id=\"pull\"><a href=\"#pull\" class=\"headerlink\" title=\"pull\"></a>pull</h3><h3 id=\"diff\"><a href=\"#diff\" class=\"headerlink\" title=\"diff\"></a>diff</h3><p>比较变化</p>\n<ul>\n<li><p>git diff<br>比较工作区与本地库中的最后一次提交</p>\n</li>\n<li><p>git diff –cached<br>比较暂存区与本地库中的最后一次提交</p>\n</li>\n<li><p>git diff HEAD<br>比较工作区与暂存区</p>\n<h3 id=\"reset\"><a href=\"#reset\" class=\"headerlink\" title=\"reset\"></a>reset</h3></li>\n<li><p>git reset filename<br>将加入暂存区中的文件撤回到工作区</p>\n</li>\n<li><p>git reset –hard commitid<br>直接回到commitid状态。所有commitid之后的操作全部清空</p>\n</li>\n<li><p>git reset –hard HEAD^<br>回到上次提交的状态，撤销掉最近一次提交</p>\n</li>\n</ul>\n<h3 id=\"restore\"><a href=\"#restore\" class=\"headerlink\" title=\"restore\"></a>restore</h3><ul>\n<li>git restore filename<br>丢弃工作区的改动</li>\n</ul>\n<h3 id=\"log\"><a href=\"#log\" class=\"headerlink\" title=\"log\"></a>log</h3><p>查看git 提交日志</p>\n<ul>\n<li>git log<br>显示详细提交信息</li>\n<li>git log –oneline<br>简单显示提交信息</li>\n</ul>\n<h3 id=\"reflog\"><a href=\"#reflog\" class=\"headerlink\" title=\"reflog\"></a>reflog</h3><p>如果执行了<code>git reset --hard commitid</code>后还想回到commitid以后的某个操作时可以使用此命令，这相当于git log 的log</p>\n<h3 id=\"checkout\"><a href=\"#checkout\" class=\"headerlink\" title=\"checkout\"></a>checkout</h3><p>切换到某个提交的节点</p>\n<ul>\n<li><p>git checkout commitid<br>切换到历史的某个commitid的状态。将HEAD的指针指向某个commitid。如果当前状态是master，要想回到master前面某个提交状态，可以使用<code>git checkout commitid</code>回到commitid中的操作环境看看。在当前状态修改的操作提交后，如果后期回到master状态，修改的操作会丢失。</p>\n</li>\n<li><p>git checkout branchname<br>切换到某个分支</p>\n</li>\n<li><p>git checkout -b branchname<br>创建并切换到某个分支</p>\n</li>\n<li><p>git checkout tagname<br>切换到某个标签</p>\n</li>\n</ul>\n<h3 id=\"status\"><a href=\"#status\" class=\"headerlink\" title=\"status\"></a>status</h3><p>查看当前状态</p>\n<ul>\n<li><p>git status<br>显示当前状态的相信信息</p>\n</li>\n<li><p>git status -s<br>显示当前状态的简单信息</p>\n</li>\n</ul>\n<h3 id=\"branch\"><a href=\"#branch\" class=\"headerlink\" title=\"branch\"></a>branch</h3><p>查看创建分支</p>\n<ul>\n<li><p>git branch<br>查看有哪些分支，带*号的为当前分支</p>\n</li>\n<li><p>git branch name<br>创建一个name的分支</p>\n</li>\n</ul>\n<h3 id=\"merge\"><a href=\"#merge\" class=\"headerlink\" title=\"merge\"></a>merge</h3><p>合并分支</p>\n<ul>\n<li><p>git merge branchname<br>合并某个分支到当前分支。山寨过来就是我的，不会保留信息</p>\n</li>\n<li><p>git merge branchname –no-ff -m ‘init’<br>合并某个分支到当前分支，会保留之前分支的提交记录状态和分支信息。山寨人家，但是会保留人家的信息</p>\n</li>\n</ul>\n<h3 id=\"tag\"><a href=\"#tag\" class=\"headerlink\" title=\"tag\"></a>tag</h3><p>给提交添加标签</p>\n<ul>\n<li>git tag tagname<br>给当前提交添加标签</li>\n</ul>\n<h3 id=\"remote\"><a href=\"#remote\" class=\"headerlink\" title=\"remote\"></a>remote</h3><p>查看远端库信息</p>\n<ul>\n<li><p>git remote<br>查看远端库简要信息    </p>\n</li>\n<li><p>git remote -v //-v == –verbose<br>查看远端库信息带有url</p>\n</li>\n<li><p>git remote add origin url<br>添加一个名字为origin 的远端库地址为url</p>\n</li>\n</ul>\n<h3 id=\"push-1\"><a href=\"#push-1\" class=\"headerlink\" title=\"push\"></a>push</h3><p>推送本地库到远端库</p>\n<ul>\n<li><p>git push<br>推送本地master分支到默认远端库分支</p>\n</li>\n<li><p>git push -u origin<br>第一次推送时可以使用-u参数，指定默认的远端库，设定以后再提交可以直接使用<code>git push</code></p>\n</li>\n<li><p>git push  origin master<br>推送本地master的分支到名为origin远端库的master分支</p>\n</li>\n<li><p>git push  origin master1:master2<br>推送本地分支master1到origin远端库分支master2</p>\n</li>\n<li><p>git push  origin :master2<br>推送一个空分支到origin远端库分支master2</p>\n</li>\n</ul>\n<p><img src=\"Git&GitHub.assets/QQ20200318-211942@2x.png\" alt=\"QQ20200318-211942@2x\"></p>\n<h2 id=\"GitHub\"><a href=\"#GitHub\" class=\"headerlink\" title=\"GitHub\"></a>GitHub</h2><ol>\n<li><p>awesome</p>\n<pre><code>awesome 关键词</code></pre></li>\n</ol>\n<ol start=\"2\">\n<li></li>\n</ol>\n"}],"Post":[{"title":"Hello World","date":"2018-09-12T14:25:00.000Z","author":"blinkfox","_content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2018-09-12 22:25:00\nauthor: blinkfox\ncategories: 前端\ntags:\n  - Hexo\n---\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2020-03-19T04:51:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8hf2uux0001zhs6jtasqevn","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre class=\" language-bash\"><code class=\"language-bash\">$ hexo new <span class=\"token string\">\"My New Post\"</span></code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre class=\" language-bash\"><code class=\"language-bash\">$ hexo server</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre class=\" language-bash\"><code class=\"language-bash\">$ hexo generate</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre class=\" language-bash\"><code class=\"language-bash\">$ hexo deploy</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"大数据面试题","date":"2020-01-15T08:42:00.000Z","_content":"\n#  大数据面试题\n\n\n\n**1、你能简单描述一下Hbase吗？能画出它的架构图吗？**\n\n[hbase](http://lib.csdn.net/base/hbase)是一个面向列的 NoSQL 分布式[数据库](http://lib.csdn.net/base/mysql)，它利用HDFS作为底层存储系统。那么，HBase相对于传统的关系型数据库有什么不同呢？\n\n- HBase是schema-free的，它的列是可以动态增加的（仅仅定义列族），并且为空的列不占物理存储空间。\n- HBase是基于列存储的，每个列族都由几个文件保存，不同的列族的文件是分离的。\n- HBase自动切分数据，使得数据存储自动具有很好的横向扩展性。\n- HBase没有任何事务，提供了高并发读写操作的支持。\n\nHBase中的Table是一个稀疏的、多维度的、排序的映射表，这张表的索引是[RowKey, ColumnFamily, ColumnQualifier, Timestamp]，其中Timestamp表示版本，默认获取最新版本。HBase是通过RowKey来检索数据的，RowKey是Table设计的核心，它按照ASCII有序排序，因此应尽量避免顺序写入。RowKey设计应该注意三点：\n\n- 唯一原则：在HBase中rowkey可以看成是表的主键，必须保证其唯一性。\n- 散列原则：由于rowkey是按字典有序的，故应避免rowkey连续有序而导致在某一台RegionServer上堆积的现象。例如可以拼接随机数、将时间戳倒序等。\n- 长度原则：设计时RowKey要尽量短，这样可以提高有效数据的比例，节省存储空间，也可以提高查询的性能。\n\n下面是HBase的整体架构图：\n\n![img](http://img.blog.csdn.net/20160423184359154)\n\n**2、你说了解kafka，能简单描述一下Kafka吗？能画出它的架构图吗？**\n\nKafka是一个高吞吐、易扩展的分布式发布-订阅消息系统，它能够将消息持久化到磁盘，用于批量的消费。Kafka中有以下几个概念：\n\n- Topic：特指Kafka处理的消息源（feeds of messages）的不同分类。\n- Partition：Topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。\n- Broker：Kafa集群中包含一台或多台服务器，这种服务器被称为broker。\n- Producer：生产者，向Kafka的一个topic发布消息。\n- Consumers：消费者，从kafka的某个topic读取消息。\n\nKafka架构图如下：\n\n![img](http://img.blog.csdn.net/20160423204357095)\n\n详见：[Apache Kafka：下一代分布式消息系统](http://www.infoq.com/cn/articles/apache-kafka/)\n\n**3、请介绍你的一个亮点项目？你在其中做了什么？碰到了什么技术难点？**\n\n【解】介绍项目《九州卡牌》手游，我在项目中主要负责客户端逻辑与战斗效果的实现，以及网络通信模块的设计与开发。\n首先，对于网络通信我们选择使用**TCP长连接**，因为对于卡牌类手游可以容忍偶尔地延迟，并且有服务器主动给客户端推送消息的需求。\n优点：\n\n- 简单有效的长连接\n- 可靠的信息传输\n- 数据包的大小没有限制\n- 服务器可以主动向客户端推送消息（广播等）\n\n客户端每隔3s发送一次心跳包给服务器，通知服务器自己仍然在线，并获取服务器数据更新 —— 心跳包可以防止TCP的死连接问题，避免出现长时间不在线的死链接仍然出现在服务端的管理任务中。当客户端长时间切换到后台时，进程被挂起，连接会断开。\nTCP协议本身就有keep-alive机制，为什么还要在应用层实现自己的心跳检测机制呢？\n\n- TCP的keep-alive机制可能在短暂的网络异常中，将一个良好的连接给断开；\n- keep-alive设计初衷是清除和回收死亡时间长的连接，不适合实时性高的场合，而且它会先要求连接一定时间内没有活动，周期长，这样其实已经断开很长一段时间，没有及时性；\n- keep-alive不能主动通知应用层；\n- 另外，想要通过心跳包来获取服务器的数据更新，所以选择自己在应用层实现；\n\n还有一个问题就是一台机器的连接数有限制，可以通过**滚服**或者**分布式**来解决。\n\n- **滚服：**指老的服务器连接数达到上限了，就开新的服务区，不同服务区的用户不能交互。\n- **分布式：**长连接不分服的话，可以多个cluster节点连接同样的CACHE数据源，只是跨节点进行通信比较麻烦一点（如用户A连接到节点1，用户B连接到节点2，用户A向节点1发起TCP请求处理业务需要再通知到节点2的用户B）。一般来说有2种解决方案： \n  ①是建立场景服务器，即专门用一个socket server来保持所有玩家的连接，然后它只处理数据推送，不做业务，可以达到10-20W承载；②是采用发布订阅方式实现节点间的实时通信。\n\n我在[Linux](http://lib.csdn.net/base/linux)下写了一个**Socket心跳包示例程序**，见文《[TCP socket心跳包示例程序](http://blog.csdn.net/lisonglisonglisong/article/details/51327695)》。\n\n**4、请介绍一下MapReduce的工作原理。**\n\n【解】MapReduce是一个分布式计算框架，用于大规模数据集的并行运算。简单地说，MapReduce就是”任务的分解与结果的汇总”：将一个大的数据处理任务划分成许多个子任务，并将这些子任务分配给各个节点并行处理，然后通过整合各个节点的中间结果，得到最终结果。\n\nMapReduce是主从架构，在master上跑的是JobTracker/ResourceManager，负责资源分配与任务调度；而各个slave上跑的是TaskTracker/NodeManager，负责执行任务，并定期向master汇报最新状态与执行进度。\n\n对于一个MR任务，它的输入、输出以及中间结果都是`<key, value>`键值对：\n\n- Map：`<k1, v1>` ——> `list(<k2, v2>)`\n- Reduce：`<k2, list(v2)>` ——> `list(<k3, v3>)`\n\nMR程序的执行过程主要分为三步：Map阶段、Shuffle阶段、Reduce阶段，如下图：\n\n![img](http://img.blog.csdn.net/20160811132825039)\n\n1. **Map阶段**\n   - 分片（Split）：map阶段的输入通常是HDFS上文件，在运行Mapper前，FileInputFormat会将输入文件分割成多个split ——1个split至少包含1个HDFS的Block（默认为64M）；然后每一个分片运行一个map进行处理。\n   - 执行（Map）：对输入分片中的每个键值对调用`map()`函数进行运算，然后输出一个结果键值对。\n     - Partitioner：对 map 函数的输出进行partition，即根据key或value及reduce的数量来决定当前的这对键值对最终应该交由哪个reduce处理。默认是对key哈希后再以reduce task数量取模，默认的取模方式只是为了避免数据倾斜。然后该key/value对以及partitionIdx的结果都会被写入环形缓冲区。\n   - 溢写（Spill）：map输出写在内存中的环形缓冲区，默认当缓冲区满80%，启动溢写线程，将缓冲的数据写出到磁盘。\n     - Sort：在溢写到磁盘之前，使用快排对缓冲区数据按照partitionIdx, key排序。（每个partitionIdx表示一个分区，一个分区对应一个reduce）\n     - Combiner：如果设置了Combiner，那么在Sort之后，还会对具有相同key的键值对进行合并，减少溢写到磁盘的数据量。\n   - 合并（Merge）：溢写可能会生成多个文件，这时需要将多个文件合并成一个文件。合并的过程中会不断地进行 sort & combine 操作，最后合并成了一个已分区且已排序的文件。\n2. **Shuffle阶段**：广义上Shuffle阶段横跨Map端和Reduce端，在Map端包括Spill过程，在Reduce端包括copy和merge/sort过程。通常认为Shuffle阶段就是将map的输出作为reduce的输入的过程\n   - Copy过程：Reduce端启动一些copy线程，通过HTTP方式将map端输出文件中属于自己的部分拉取到本地。Reduce会从多个map端拉取数据，并且每个map的数据都是有序的。\n   - Merge过程：Copy过来的数据会先放入内存缓冲区中，这里的缓冲区比较大；当缓冲区数据量达到一定阈值时，将数据溢写到磁盘（与map端类似，溢写过程会执行 sort & combine）。如果生成了多个溢写文件，它们会被merge成一个**有序的最终文件**。这个过程也会不停地执行 sort & combine 操作。\n3. **Reduce阶段**：Shuffle阶段最终生成了一个有序的文件作为Reduce的输入，对于该文件中的每一个键值对调用`reduce()`方法，并将结果写到HDFS。\n\n参考《[了解MapReduce核心Shuff](http://www.aboutyun.com/thread-7078-1-1.html)","source":"_posts/大数据面试题.md","raw":"---\ntitle: 大数据面试题\ndate: 2020-01-15 16:42:00\ncategories: 大数据面试题\ntags: 大数据面试题\n---\n\n#  大数据面试题\n\n\n\n**1、你能简单描述一下Hbase吗？能画出它的架构图吗？**\n\n[hbase](http://lib.csdn.net/base/hbase)是一个面向列的 NoSQL 分布式[数据库](http://lib.csdn.net/base/mysql)，它利用HDFS作为底层存储系统。那么，HBase相对于传统的关系型数据库有什么不同呢？\n\n- HBase是schema-free的，它的列是可以动态增加的（仅仅定义列族），并且为空的列不占物理存储空间。\n- HBase是基于列存储的，每个列族都由几个文件保存，不同的列族的文件是分离的。\n- HBase自动切分数据，使得数据存储自动具有很好的横向扩展性。\n- HBase没有任何事务，提供了高并发读写操作的支持。\n\nHBase中的Table是一个稀疏的、多维度的、排序的映射表，这张表的索引是[RowKey, ColumnFamily, ColumnQualifier, Timestamp]，其中Timestamp表示版本，默认获取最新版本。HBase是通过RowKey来检索数据的，RowKey是Table设计的核心，它按照ASCII有序排序，因此应尽量避免顺序写入。RowKey设计应该注意三点：\n\n- 唯一原则：在HBase中rowkey可以看成是表的主键，必须保证其唯一性。\n- 散列原则：由于rowkey是按字典有序的，故应避免rowkey连续有序而导致在某一台RegionServer上堆积的现象。例如可以拼接随机数、将时间戳倒序等。\n- 长度原则：设计时RowKey要尽量短，这样可以提高有效数据的比例，节省存储空间，也可以提高查询的性能。\n\n下面是HBase的整体架构图：\n\n![img](http://img.blog.csdn.net/20160423184359154)\n\n**2、你说了解kafka，能简单描述一下Kafka吗？能画出它的架构图吗？**\n\nKafka是一个高吞吐、易扩展的分布式发布-订阅消息系统，它能够将消息持久化到磁盘，用于批量的消费。Kafka中有以下几个概念：\n\n- Topic：特指Kafka处理的消息源（feeds of messages）的不同分类。\n- Partition：Topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。\n- Broker：Kafa集群中包含一台或多台服务器，这种服务器被称为broker。\n- Producer：生产者，向Kafka的一个topic发布消息。\n- Consumers：消费者，从kafka的某个topic读取消息。\n\nKafka架构图如下：\n\n![img](http://img.blog.csdn.net/20160423204357095)\n\n详见：[Apache Kafka：下一代分布式消息系统](http://www.infoq.com/cn/articles/apache-kafka/)\n\n**3、请介绍你的一个亮点项目？你在其中做了什么？碰到了什么技术难点？**\n\n【解】介绍项目《九州卡牌》手游，我在项目中主要负责客户端逻辑与战斗效果的实现，以及网络通信模块的设计与开发。\n首先，对于网络通信我们选择使用**TCP长连接**，因为对于卡牌类手游可以容忍偶尔地延迟，并且有服务器主动给客户端推送消息的需求。\n优点：\n\n- 简单有效的长连接\n- 可靠的信息传输\n- 数据包的大小没有限制\n- 服务器可以主动向客户端推送消息（广播等）\n\n客户端每隔3s发送一次心跳包给服务器，通知服务器自己仍然在线，并获取服务器数据更新 —— 心跳包可以防止TCP的死连接问题，避免出现长时间不在线的死链接仍然出现在服务端的管理任务中。当客户端长时间切换到后台时，进程被挂起，连接会断开。\nTCP协议本身就有keep-alive机制，为什么还要在应用层实现自己的心跳检测机制呢？\n\n- TCP的keep-alive机制可能在短暂的网络异常中，将一个良好的连接给断开；\n- keep-alive设计初衷是清除和回收死亡时间长的连接，不适合实时性高的场合，而且它会先要求连接一定时间内没有活动，周期长，这样其实已经断开很长一段时间，没有及时性；\n- keep-alive不能主动通知应用层；\n- 另外，想要通过心跳包来获取服务器的数据更新，所以选择自己在应用层实现；\n\n还有一个问题就是一台机器的连接数有限制，可以通过**滚服**或者**分布式**来解决。\n\n- **滚服：**指老的服务器连接数达到上限了，就开新的服务区，不同服务区的用户不能交互。\n- **分布式：**长连接不分服的话，可以多个cluster节点连接同样的CACHE数据源，只是跨节点进行通信比较麻烦一点（如用户A连接到节点1，用户B连接到节点2，用户A向节点1发起TCP请求处理业务需要再通知到节点2的用户B）。一般来说有2种解决方案： \n  ①是建立场景服务器，即专门用一个socket server来保持所有玩家的连接，然后它只处理数据推送，不做业务，可以达到10-20W承载；②是采用发布订阅方式实现节点间的实时通信。\n\n我在[Linux](http://lib.csdn.net/base/linux)下写了一个**Socket心跳包示例程序**，见文《[TCP socket心跳包示例程序](http://blog.csdn.net/lisonglisonglisong/article/details/51327695)》。\n\n**4、请介绍一下MapReduce的工作原理。**\n\n【解】MapReduce是一个分布式计算框架，用于大规模数据集的并行运算。简单地说，MapReduce就是”任务的分解与结果的汇总”：将一个大的数据处理任务划分成许多个子任务，并将这些子任务分配给各个节点并行处理，然后通过整合各个节点的中间结果，得到最终结果。\n\nMapReduce是主从架构，在master上跑的是JobTracker/ResourceManager，负责资源分配与任务调度；而各个slave上跑的是TaskTracker/NodeManager，负责执行任务，并定期向master汇报最新状态与执行进度。\n\n对于一个MR任务，它的输入、输出以及中间结果都是`<key, value>`键值对：\n\n- Map：`<k1, v1>` ——> `list(<k2, v2>)`\n- Reduce：`<k2, list(v2)>` ——> `list(<k3, v3>)`\n\nMR程序的执行过程主要分为三步：Map阶段、Shuffle阶段、Reduce阶段，如下图：\n\n![img](http://img.blog.csdn.net/20160811132825039)\n\n1. **Map阶段**\n   - 分片（Split）：map阶段的输入通常是HDFS上文件，在运行Mapper前，FileInputFormat会将输入文件分割成多个split ——1个split至少包含1个HDFS的Block（默认为64M）；然后每一个分片运行一个map进行处理。\n   - 执行（Map）：对输入分片中的每个键值对调用`map()`函数进行运算，然后输出一个结果键值对。\n     - Partitioner：对 map 函数的输出进行partition，即根据key或value及reduce的数量来决定当前的这对键值对最终应该交由哪个reduce处理。默认是对key哈希后再以reduce task数量取模，默认的取模方式只是为了避免数据倾斜。然后该key/value对以及partitionIdx的结果都会被写入环形缓冲区。\n   - 溢写（Spill）：map输出写在内存中的环形缓冲区，默认当缓冲区满80%，启动溢写线程，将缓冲的数据写出到磁盘。\n     - Sort：在溢写到磁盘之前，使用快排对缓冲区数据按照partitionIdx, key排序。（每个partitionIdx表示一个分区，一个分区对应一个reduce）\n     - Combiner：如果设置了Combiner，那么在Sort之后，还会对具有相同key的键值对进行合并，减少溢写到磁盘的数据量。\n   - 合并（Merge）：溢写可能会生成多个文件，这时需要将多个文件合并成一个文件。合并的过程中会不断地进行 sort & combine 操作，最后合并成了一个已分区且已排序的文件。\n2. **Shuffle阶段**：广义上Shuffle阶段横跨Map端和Reduce端，在Map端包括Spill过程，在Reduce端包括copy和merge/sort过程。通常认为Shuffle阶段就是将map的输出作为reduce的输入的过程\n   - Copy过程：Reduce端启动一些copy线程，通过HTTP方式将map端输出文件中属于自己的部分拉取到本地。Reduce会从多个map端拉取数据，并且每个map的数据都是有序的。\n   - Merge过程：Copy过来的数据会先放入内存缓冲区中，这里的缓冲区比较大；当缓冲区数据量达到一定阈值时，将数据溢写到磁盘（与map端类似，溢写过程会执行 sort & combine）。如果生成了多个溢写文件，它们会被merge成一个**有序的最终文件**。这个过程也会不停地执行 sort & combine 操作。\n3. **Reduce阶段**：Shuffle阶段最终生成了一个有序的文件作为Reduce的输入，对于该文件中的每一个键值对调用`reduce()`方法，并将结果写到HDFS。\n\n参考《[了解MapReduce核心Shuff](http://www.aboutyun.com/thread-7078-1-1.html)","slug":"大数据面试题","published":1,"updated":"2020-03-18T11:52:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8hf2uvx000jzhs6xj1n4nag","content":"<h1 id=\"大数据面试题\"><a href=\"#大数据面试题\" class=\"headerlink\" title=\"大数据面试题\"></a>大数据面试题</h1><p><strong>1、你能简单描述一下Hbase吗？能画出它的架构图吗？</strong></p>\n<p><a href=\"http://lib.csdn.net/base/hbase\" target=\"_blank\" rel=\"noopener\">hbase</a>是一个面向列的 NoSQL 分布式<a href=\"http://lib.csdn.net/base/mysql\" target=\"_blank\" rel=\"noopener\">数据库</a>，它利用HDFS作为底层存储系统。那么，HBase相对于传统的关系型数据库有什么不同呢？</p>\n<ul>\n<li>HBase是schema-free的，它的列是可以动态增加的（仅仅定义列族），并且为空的列不占物理存储空间。</li>\n<li>HBase是基于列存储的，每个列族都由几个文件保存，不同的列族的文件是分离的。</li>\n<li>HBase自动切分数据，使得数据存储自动具有很好的横向扩展性。</li>\n<li>HBase没有任何事务，提供了高并发读写操作的支持。</li>\n</ul>\n<p>HBase中的Table是一个稀疏的、多维度的、排序的映射表，这张表的索引是[RowKey, ColumnFamily, ColumnQualifier, Timestamp]，其中Timestamp表示版本，默认获取最新版本。HBase是通过RowKey来检索数据的，RowKey是Table设计的核心，它按照ASCII有序排序，因此应尽量避免顺序写入。RowKey设计应该注意三点：</p>\n<ul>\n<li>唯一原则：在HBase中rowkey可以看成是表的主键，必须保证其唯一性。</li>\n<li>散列原则：由于rowkey是按字典有序的，故应避免rowkey连续有序而导致在某一台RegionServer上堆积的现象。例如可以拼接随机数、将时间戳倒序等。</li>\n<li>长度原则：设计时RowKey要尽量短，这样可以提高有效数据的比例，节省存储空间，也可以提高查询的性能。</li>\n</ul>\n<p>下面是HBase的整体架构图：</p>\n<p><img src=\"http://img.blog.csdn.net/20160423184359154\" alt=\"img\"></p>\n<p><strong>2、你说了解kafka，能简单描述一下Kafka吗？能画出它的架构图吗？</strong></p>\n<p>Kafka是一个高吞吐、易扩展的分布式发布-订阅消息系统，它能够将消息持久化到磁盘，用于批量的消费。Kafka中有以下几个概念：</p>\n<ul>\n<li>Topic：特指Kafka处理的消息源（feeds of messages）的不同分类。</li>\n<li>Partition：Topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。</li>\n<li>Broker：Kafa集群中包含一台或多台服务器，这种服务器被称为broker。</li>\n<li>Producer：生产者，向Kafka的一个topic发布消息。</li>\n<li>Consumers：消费者，从kafka的某个topic读取消息。</li>\n</ul>\n<p>Kafka架构图如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20160423204357095\" alt=\"img\"></p>\n<p>详见：<a href=\"http://www.infoq.com/cn/articles/apache-kafka/\" target=\"_blank\" rel=\"noopener\">Apache Kafka：下一代分布式消息系统</a></p>\n<p><strong>3、请介绍你的一个亮点项目？你在其中做了什么？碰到了什么技术难点？</strong></p>\n<p>【解】介绍项目《九州卡牌》手游，我在项目中主要负责客户端逻辑与战斗效果的实现，以及网络通信模块的设计与开发。<br>首先，对于网络通信我们选择使用<strong>TCP长连接</strong>，因为对于卡牌类手游可以容忍偶尔地延迟，并且有服务器主动给客户端推送消息的需求。<br>优点：</p>\n<ul>\n<li>简单有效的长连接</li>\n<li>可靠的信息传输</li>\n<li>数据包的大小没有限制</li>\n<li>服务器可以主动向客户端推送消息（广播等）</li>\n</ul>\n<p>客户端每隔3s发送一次心跳包给服务器，通知服务器自己仍然在线，并获取服务器数据更新 —— 心跳包可以防止TCP的死连接问题，避免出现长时间不在线的死链接仍然出现在服务端的管理任务中。当客户端长时间切换到后台时，进程被挂起，连接会断开。<br>TCP协议本身就有keep-alive机制，为什么还要在应用层实现自己的心跳检测机制呢？</p>\n<ul>\n<li>TCP的keep-alive机制可能在短暂的网络异常中，将一个良好的连接给断开；</li>\n<li>keep-alive设计初衷是清除和回收死亡时间长的连接，不适合实时性高的场合，而且它会先要求连接一定时间内没有活动，周期长，这样其实已经断开很长一段时间，没有及时性；</li>\n<li>keep-alive不能主动通知应用层；</li>\n<li>另外，想要通过心跳包来获取服务器的数据更新，所以选择自己在应用层实现；</li>\n</ul>\n<p>还有一个问题就是一台机器的连接数有限制，可以通过<strong>滚服</strong>或者<strong>分布式</strong>来解决。</p>\n<ul>\n<li><strong>滚服：</strong>指老的服务器连接数达到上限了，就开新的服务区，不同服务区的用户不能交互。</li>\n<li><strong>分布式：</strong>长连接不分服的话，可以多个cluster节点连接同样的CACHE数据源，只是跨节点进行通信比较麻烦一点（如用户A连接到节点1，用户B连接到节点2，用户A向节点1发起TCP请求处理业务需要再通知到节点2的用户B）。一般来说有2种解决方案：<br>①是建立场景服务器，即专门用一个socket server来保持所有玩家的连接，然后它只处理数据推送，不做业务，可以达到10-20W承载；②是采用发布订阅方式实现节点间的实时通信。</li>\n</ul>\n<p>我在<a href=\"http://lib.csdn.net/base/linux\" target=\"_blank\" rel=\"noopener\">Linux</a>下写了一个<strong>Socket心跳包示例程序</strong>，见文《<a href=\"http://blog.csdn.net/lisonglisonglisong/article/details/51327695\" target=\"_blank\" rel=\"noopener\">TCP socket心跳包示例程序</a>》。</p>\n<p><strong>4、请介绍一下MapReduce的工作原理。</strong></p>\n<p>【解】MapReduce是一个分布式计算框架，用于大规模数据集的并行运算。简单地说，MapReduce就是”任务的分解与结果的汇总”：将一个大的数据处理任务划分成许多个子任务，并将这些子任务分配给各个节点并行处理，然后通过整合各个节点的中间结果，得到最终结果。</p>\n<p>MapReduce是主从架构，在master上跑的是JobTracker/ResourceManager，负责资源分配与任务调度；而各个slave上跑的是TaskTracker/NodeManager，负责执行任务，并定期向master汇报最新状态与执行进度。</p>\n<p>对于一个MR任务，它的输入、输出以及中间结果都是<code>&lt;key, value&gt;</code>键值对：</p>\n<ul>\n<li>Map：<code>&lt;k1, v1&gt;</code> ——&gt; <code>list(&lt;k2, v2&gt;)</code></li>\n<li>Reduce：<code>&lt;k2, list(v2)&gt;</code> ——&gt; <code>list(&lt;k3, v3&gt;)</code></li>\n</ul>\n<p>MR程序的执行过程主要分为三步：Map阶段、Shuffle阶段、Reduce阶段，如下图：</p>\n<p><img src=\"http://img.blog.csdn.net/20160811132825039\" alt=\"img\"></p>\n<ol>\n<li><strong>Map阶段</strong><ul>\n<li>分片（Split）：map阶段的输入通常是HDFS上文件，在运行Mapper前，FileInputFormat会将输入文件分割成多个split ——1个split至少包含1个HDFS的Block（默认为64M）；然后每一个分片运行一个map进行处理。</li>\n<li>执行（Map）：对输入分片中的每个键值对调用<code>map()</code>函数进行运算，然后输出一个结果键值对。<ul>\n<li>Partitioner：对 map 函数的输出进行partition，即根据key或value及reduce的数量来决定当前的这对键值对最终应该交由哪个reduce处理。默认是对key哈希后再以reduce task数量取模，默认的取模方式只是为了避免数据倾斜。然后该key/value对以及partitionIdx的结果都会被写入环形缓冲区。</li>\n</ul>\n</li>\n<li>溢写（Spill）：map输出写在内存中的环形缓冲区，默认当缓冲区满80%，启动溢写线程，将缓冲的数据写出到磁盘。<ul>\n<li>Sort：在溢写到磁盘之前，使用快排对缓冲区数据按照partitionIdx, key排序。（每个partitionIdx表示一个分区，一个分区对应一个reduce）</li>\n<li>Combiner：如果设置了Combiner，那么在Sort之后，还会对具有相同key的键值对进行合并，减少溢写到磁盘的数据量。</li>\n</ul>\n</li>\n<li>合并（Merge）：溢写可能会生成多个文件，这时需要将多个文件合并成一个文件。合并的过程中会不断地进行 sort &amp; combine 操作，最后合并成了一个已分区且已排序的文件。</li>\n</ul>\n</li>\n<li><strong>Shuffle阶段</strong>：广义上Shuffle阶段横跨Map端和Reduce端，在Map端包括Spill过程，在Reduce端包括copy和merge/sort过程。通常认为Shuffle阶段就是将map的输出作为reduce的输入的过程<ul>\n<li>Copy过程：Reduce端启动一些copy线程，通过HTTP方式将map端输出文件中属于自己的部分拉取到本地。Reduce会从多个map端拉取数据，并且每个map的数据都是有序的。</li>\n<li>Merge过程：Copy过来的数据会先放入内存缓冲区中，这里的缓冲区比较大；当缓冲区数据量达到一定阈值时，将数据溢写到磁盘（与map端类似，溢写过程会执行 sort &amp; combine）。如果生成了多个溢写文件，它们会被merge成一个<strong>有序的最终文件</strong>。这个过程也会不停地执行 sort &amp; combine 操作。</li>\n</ul>\n</li>\n<li><strong>Reduce阶段</strong>：Shuffle阶段最终生成了一个有序的文件作为Reduce的输入，对于该文件中的每一个键值对调用<code>reduce()</code>方法，并将结果写到HDFS。</li>\n</ol>\n<p>参考《<a href=\"http://www.aboutyun.com/thread-7078-1-1.html\" target=\"_blank\" rel=\"noopener\">了解MapReduce核心Shuff</a></p>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":"<h1 id=\"大数据面试题\"><a href=\"#大数据面试题\" class=\"headerlink\" title=\"大数据面试题\"></a>大数据面试题</h1><p><strong>1、你能简单描述一下Hbase吗？能画出它的架构图吗？</strong></p>\n<p><a href=\"http://lib.csdn.net/base/hbase\" target=\"_blank\" rel=\"noopener\">hbase</a>是一个面向列的 NoSQL 分布式<a href=\"http://lib.csdn.net/base/mysql\" target=\"_blank\" rel=\"noopener\">数据库</a>，它利用HDFS作为底层存储系统。那么，HBase相对于传统的关系型数据库有什么不同呢？</p>\n<ul>\n<li>HBase是schema-free的，它的列是可以动态增加的（仅仅定义列族），并且为空的列不占物理存储空间。</li>\n<li>HBase是基于列存储的，每个列族都由几个文件保存，不同的列族的文件是分离的。</li>\n<li>HBase自动切分数据，使得数据存储自动具有很好的横向扩展性。</li>\n<li>HBase没有任何事务，提供了高并发读写操作的支持。</li>\n</ul>\n<p>HBase中的Table是一个稀疏的、多维度的、排序的映射表，这张表的索引是[RowKey, ColumnFamily, ColumnQualifier, Timestamp]，其中Timestamp表示版本，默认获取最新版本。HBase是通过RowKey来检索数据的，RowKey是Table设计的核心，它按照ASCII有序排序，因此应尽量避免顺序写入。RowKey设计应该注意三点：</p>\n<ul>\n<li>唯一原则：在HBase中rowkey可以看成是表的主键，必须保证其唯一性。</li>\n<li>散列原则：由于rowkey是按字典有序的，故应避免rowkey连续有序而导致在某一台RegionServer上堆积的现象。例如可以拼接随机数、将时间戳倒序等。</li>\n<li>长度原则：设计时RowKey要尽量短，这样可以提高有效数据的比例，节省存储空间，也可以提高查询的性能。</li>\n</ul>\n<p>下面是HBase的整体架构图：</p>\n<p><img src=\"http://img.blog.csdn.net/20160423184359154\" alt=\"img\"></p>\n<p><strong>2、你说了解kafka，能简单描述一下Kafka吗？能画出它的架构图吗？</strong></p>\n<p>Kafka是一个高吞吐、易扩展的分布式发布-订阅消息系统，它能够将消息持久化到磁盘，用于批量的消费。Kafka中有以下几个概念：</p>\n<ul>\n<li>Topic：特指Kafka处理的消息源（feeds of messages）的不同分类。</li>\n<li>Partition：Topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。</li>\n<li>Broker：Kafa集群中包含一台或多台服务器，这种服务器被称为broker。</li>\n<li>Producer：生产者，向Kafka的一个topic发布消息。</li>\n<li>Consumers：消费者，从kafka的某个topic读取消息。</li>\n</ul>\n<p>Kafka架构图如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20160423204357095\" alt=\"img\"></p>\n<p>详见：<a href=\"http://www.infoq.com/cn/articles/apache-kafka/\" target=\"_blank\" rel=\"noopener\">Apache Kafka：下一代分布式消息系统</a></p>\n<p><strong>3、请介绍你的一个亮点项目？你在其中做了什么？碰到了什么技术难点？</strong></p>\n<p>【解】介绍项目《九州卡牌》手游，我在项目中主要负责客户端逻辑与战斗效果的实现，以及网络通信模块的设计与开发。<br>首先，对于网络通信我们选择使用<strong>TCP长连接</strong>，因为对于卡牌类手游可以容忍偶尔地延迟，并且有服务器主动给客户端推送消息的需求。<br>优点：</p>\n<ul>\n<li>简单有效的长连接</li>\n<li>可靠的信息传输</li>\n<li>数据包的大小没有限制</li>\n<li>服务器可以主动向客户端推送消息（广播等）</li>\n</ul>\n<p>客户端每隔3s发送一次心跳包给服务器，通知服务器自己仍然在线，并获取服务器数据更新 —— 心跳包可以防止TCP的死连接问题，避免出现长时间不在线的死链接仍然出现在服务端的管理任务中。当客户端长时间切换到后台时，进程被挂起，连接会断开。<br>TCP协议本身就有keep-alive机制，为什么还要在应用层实现自己的心跳检测机制呢？</p>\n<ul>\n<li>TCP的keep-alive机制可能在短暂的网络异常中，将一个良好的连接给断开；</li>\n<li>keep-alive设计初衷是清除和回收死亡时间长的连接，不适合实时性高的场合，而且它会先要求连接一定时间内没有活动，周期长，这样其实已经断开很长一段时间，没有及时性；</li>\n<li>keep-alive不能主动通知应用层；</li>\n<li>另外，想要通过心跳包来获取服务器的数据更新，所以选择自己在应用层实现；</li>\n</ul>\n<p>还有一个问题就是一台机器的连接数有限制，可以通过<strong>滚服</strong>或者<strong>分布式</strong>来解决。</p>\n<ul>\n<li><strong>滚服：</strong>指老的服务器连接数达到上限了，就开新的服务区，不同服务区的用户不能交互。</li>\n<li><strong>分布式：</strong>长连接不分服的话，可以多个cluster节点连接同样的CACHE数据源，只是跨节点进行通信比较麻烦一点（如用户A连接到节点1，用户B连接到节点2，用户A向节点1发起TCP请求处理业务需要再通知到节点2的用户B）。一般来说有2种解决方案：<br>①是建立场景服务器，即专门用一个socket server来保持所有玩家的连接，然后它只处理数据推送，不做业务，可以达到10-20W承载；②是采用发布订阅方式实现节点间的实时通信。</li>\n</ul>\n<p>我在<a href=\"http://lib.csdn.net/base/linux\" target=\"_blank\" rel=\"noopener\">Linux</a>下写了一个<strong>Socket心跳包示例程序</strong>，见文《<a href=\"http://blog.csdn.net/lisonglisonglisong/article/details/51327695\" target=\"_blank\" rel=\"noopener\">TCP socket心跳包示例程序</a>》。</p>\n<p><strong>4、请介绍一下MapReduce的工作原理。</strong></p>\n<p>【解】MapReduce是一个分布式计算框架，用于大规模数据集的并行运算。简单地说，MapReduce就是”任务的分解与结果的汇总”：将一个大的数据处理任务划分成许多个子任务，并将这些子任务分配给各个节点并行处理，然后通过整合各个节点的中间结果，得到最终结果。</p>\n<p>MapReduce是主从架构，在master上跑的是JobTracker/ResourceManager，负责资源分配与任务调度；而各个slave上跑的是TaskTracker/NodeManager，负责执行任务，并定期向master汇报最新状态与执行进度。</p>\n<p>对于一个MR任务，它的输入、输出以及中间结果都是<code>&lt;key, value&gt;</code>键值对：</p>\n<ul>\n<li>Map：<code>&lt;k1, v1&gt;</code> ——&gt; <code>list(&lt;k2, v2&gt;)</code></li>\n<li>Reduce：<code>&lt;k2, list(v2)&gt;</code> ——&gt; <code>list(&lt;k3, v3&gt;)</code></li>\n</ul>\n<p>MR程序的执行过程主要分为三步：Map阶段、Shuffle阶段、Reduce阶段，如下图：</p>\n<p><img src=\"http://img.blog.csdn.net/20160811132825039\" alt=\"img\"></p>\n<ol>\n<li><strong>Map阶段</strong><ul>\n<li>分片（Split）：map阶段的输入通常是HDFS上文件，在运行Mapper前，FileInputFormat会将输入文件分割成多个split ——1个split至少包含1个HDFS的Block（默认为64M）；然后每一个分片运行一个map进行处理。</li>\n<li>执行（Map）：对输入分片中的每个键值对调用<code>map()</code>函数进行运算，然后输出一个结果键值对。<ul>\n<li>Partitioner：对 map 函数的输出进行partition，即根据key或value及reduce的数量来决定当前的这对键值对最终应该交由哪个reduce处理。默认是对key哈希后再以reduce task数量取模，默认的取模方式只是为了避免数据倾斜。然后该key/value对以及partitionIdx的结果都会被写入环形缓冲区。</li>\n</ul>\n</li>\n<li>溢写（Spill）：map输出写在内存中的环形缓冲区，默认当缓冲区满80%，启动溢写线程，将缓冲的数据写出到磁盘。<ul>\n<li>Sort：在溢写到磁盘之前，使用快排对缓冲区数据按照partitionIdx, key排序。（每个partitionIdx表示一个分区，一个分区对应一个reduce）</li>\n<li>Combiner：如果设置了Combiner，那么在Sort之后，还会对具有相同key的键值对进行合并，减少溢写到磁盘的数据量。</li>\n</ul>\n</li>\n<li>合并（Merge）：溢写可能会生成多个文件，这时需要将多个文件合并成一个文件。合并的过程中会不断地进行 sort &amp; combine 操作，最后合并成了一个已分区且已排序的文件。</li>\n</ul>\n</li>\n<li><strong>Shuffle阶段</strong>：广义上Shuffle阶段横跨Map端和Reduce端，在Map端包括Spill过程，在Reduce端包括copy和merge/sort过程。通常认为Shuffle阶段就是将map的输出作为reduce的输入的过程<ul>\n<li>Copy过程：Reduce端启动一些copy线程，通过HTTP方式将map端输出文件中属于自己的部分拉取到本地。Reduce会从多个map端拉取数据，并且每个map的数据都是有序的。</li>\n<li>Merge过程：Copy过来的数据会先放入内存缓冲区中，这里的缓冲区比较大；当缓冲区数据量达到一定阈值时，将数据溢写到磁盘（与map端类似，溢写过程会执行 sort &amp; combine）。如果生成了多个溢写文件，它们会被merge成一个<strong>有序的最终文件</strong>。这个过程也会不停地执行 sort &amp; combine 操作。</li>\n</ul>\n</li>\n<li><strong>Reduce阶段</strong>：Shuffle阶段最终生成了一个有序的文件作为Reduce的输入，对于该文件中的每一个键值对调用<code>reduce()</code>方法，并将结果写到HDFS。</li>\n</ol>\n<p>参考《<a href=\"http://www.aboutyun.com/thread-7078-1-1.html\" target=\"_blank\" rel=\"noopener\">了解MapReduce核心Shuff</a></p>\n"},{"title":"手撕Spark之WordCount RDD执行流程","date":"2019-12-18T02:03:14.000Z","_content":"\n##  手撕Spark之WordCount RDD执行流程\n\n[TOC]\n\n\n\n### 写在前面\n\n一个Spark程序在初始化的时候会构造DAGScheduler、TaskSchedulerImpl、MapOutTrackerMaster等对象，DAGScheduler主要负责生成DAG、启动Job、提交Stage等操作，TaskSchedulerImpl主要负责Task Set的添加调度等，MapOutTrackerMaster主要负责数据的Shuffle等，这里不再赘述。\n\n**注意几个概念：**\n\n- Application   //一个Spark程序会有一个Application，也就拥有了唯一的一个applicationId\n- Job    //调用Action 算子 触发runJob，触发一次runJob就会产生一个Job\n- Stage  //遇到一次宽依赖就会生成一个Stage\n- Task  //Spark程序运行的最小单元\n\n> 注：一个Spark程序会有1个Application，会有1～N 个Job，会有1～N 个Stage，会有1～N 个Task\n>\n> 1 Application = [1 ~ N  ] Job\n> 1 Job = [ 1 ~ N ] Stage\n> 1 Stage = [ 1 ~ N ] Task\n>\n> Stage数 = Shuffle数 +1\n\n\n\n### 软件环境\n\n+ Spark：2.3.0\n\n### 代码\n\n写一个简单的WordCount计算代码\n\ndata.txt\n\n~~~txt\nhello world\nhello java\nhello scala\nhello hadoop\nhello spark\n~~~\n\nWCAnalyzer.scala\n\n~~~scala\n\n    //设置日志输出级别，便于观察日志\n    Logger.getLogger(\"org.apache\").setLevel(Level.ALL)\n\n    //创建sc\n    val sc = new SparkContext(new SparkConf().setMaster(\"local[1]\")\n                              .setAppName(\"WCAnalyzer\"))\n\n    //从文件读取数据\n    sc.textFile(\"data/data.txt\", 1)\n      //将数据按照空格进行切分（切分出单个单词）\n      .flatMap(_.split(\" \"))\n      //将每个单词和1组成一个Tuple\n      .map((_, 1))\n      //按照相同的单词进行聚合\n      .reduceByKey(_ + _)\n      //将聚合后的结果将（key，value）数据进行倒置 转换成（value，key）便于排序\n      .map(v => (v._2, v._1))\n      //按照聚合后的单词数量进行降序排序\n      .sortByKey(false)\n      //将排序后的数据进行倒置\n      .map(v => (v._2, v._1))\n      //将数据收集到driver\n      .collect()\n      //输出数据\n      .foreach(println)\n\n    //关闭sc\n    sc.stop()\n  }\n~~~\n\n\n\n### 过程分析\n\n本代码只会生成一个Job，3个Stage，8个RDD。\n\n+ 划分Stage\n\n  Stage的划分要从后向前，每遇到一次宽依赖就划分一个Stage，因此这个简单的WC代码可以分为3个Stage，分别是由textFile、flatMap、map算子组成的第一个Stage 0；由reduceByKey、map算子组成的Stage 1；由sortByKey、map算子组成的Stage 2。\n\n+ RDD的生成 \n\n  textFile（HadoopRDD [0] ，MapPartitionsRDD [1] ）  //[ ] 内为该rdd的序号\n\n  flatMap（MapPartitionsRDD [2] ）\n\n  map（MapPartitionsRDD [3] ）\n\n  reduceByKey（ShuffledRDD [4] ）\n\n  map（MapPartitionsRDD [5] ）\n\n  sortByKey（ShuffledRDD [6] ）\n\n  map （MapPartitionsRDD [7] ）\n\n+ 日志分析\n\n    ~~~txt\n    org.apache.spark.SparkContext                     - Starting job: collect at WCAnalyzer.scala:34\n    ~~~\n    由collect算子触发runJob 启动一个Job，代码中的`foreach(println)`其中`foreach`并不是RDD中的算子，因此不会触发runJob，也就不会生成一个Job\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler           - Got job 0 (collect at WCAnalyzer.scala:34) with 1 output partitions\n    ~~~\n\n    \t生成一个Job 0 ，这个Job是由collect算子生成，在代码第34行，有一个分区\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler          - Final stage: ResultStage 2 (collect at WCAnalyzer.scala:34)\n    org.apache.spark.scheduler.DAGScheduler          - Parents of final stage: List(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - Missing parents: List(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List(ShuffleMapStage 0)\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 0)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List()\n    ~~~\n\n    Job 的Final Stage 为ResultStage 0，ResultStage 的父依赖为ShuffleMapStage 1，遗留的父依赖为ShuffleMapStage 1。\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - submitStage(ResultStage 2)\n    ~~~\n\n    尝试提交ResultStage 2\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - missing: List(ShuffleMapStage 1)\n    ~~~\n\n    遗留一个ShuffleMapStage 1\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - submitStage(ShuffleMapStage 1)\n    ~~~\n\n    尝试提交ShuffleMapStage 1\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - missing: List(ShuffleMapStage 0)\n    ~~~\n\n    遗留一个ShuffleMapStage 0\n\n     ~~~txt\n      org.apache.spark.scheduler.DAGScheduler         - submitStage(ShuffleMapStage 0)\n     ~~~\n    \n     尝试提交ShuffleMapStage 0\n    \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - missing: List()\n    ~~~\n  \n    没有遗留的Stage\n  \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - Submitting ShuffleMapStage 0 (MapPartitionsRDD[3] at map at WCAnalyzer.scala:24), which has no missing parents\n    ~~~\n  \n    提交ShuffleMapStage 0，该Stage的最后一个RDD是MapPartitionsRDD[3]，是由map算子生成，在代码第24行\n  \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - submitMissingTasks(ShuffleMapStage 0)\n    ~~~\n  \n    提交Tasks，一个Stage就是一个Task Set集合\n  \n    ~~~txt\n    org.apache.spark.scheduler.TaskSchedulerImpl    - Adding task set 0.0 with 1 tasks\n    ~~~\n    TaskSchedulerImpl 调度器添加一个Task Set集合\n  \n    ~~~txt\n    org.apache.spark.scheduler.TaskSetManager       - Starting task 0.0 in stage 0.0 (TID 0, localhost, executor driver, partition 0, PROCESS_LOCAL, 7909 bytes)\n    ~~~\n  \n    TaskSetManager 启动stage 0.0 中的task 0.0（taskid=0.0，host=localhost，executor=driver，partition=0，taskLocality=PROCESS_LOCAL，serializedTask=7909 bytes\n  \n    ~~~txt\n    org.apache.spark.executor.Executor              - Running task 0.0 in stage 0.0 (TID 0)\n    ~~~\n  \n    Executor 端运行task\n  \n    ~~~txt\n    org.apache.spark.executor.Executor              - Finished task 0.0 in stage 0.0 (TID 0). 1159 bytes result sent to driver\n    ~~~\n  \n    Executor 端 运行完成task，将序列化后大小为1159 bytes结果数据发送回driver端\n  \n    ~~~txt\n    org.apache.spark.scheduler.TaskSetManager       - Finished task 0.0 in stage 0.0 (TID 0) in 194 ms on localhost (executor driver) (1/1)\n    ~~~\n  \n    TaskSetManager 运行完task  完成task数量／总攻task数量\n  \n    ~~~txt\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 0.0, whose tasks have all completed, from pool \n    ~~~\n  \n    TaskSchedulerImpl 移除TaskSet 集合\n  \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler          - ShuffleMapTask finished on driver\n    ~~~\n  \n    DAGScheduler 完成ShuffleMapTask 的计算\n  \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler          - ShuffleMapStage 0 (map at WCAnalyzer.scala:24) finished in 0.289 s\n    ~~~\n  \n    DAGScheduler 完成ShuffleMapStage 的计算，用时共 0.289 s\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler          - looking for newly runnable stages\n    org.apache.spark.scheduler.DAGScheduler          - running: Set()\n    org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ShuffleMapStage 1, ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n    org.apache.spark.MapOutputTrackerMaster          - Increasing epoch to 1\n    org.apache.spark.scheduler.DAGScheduler          - Checking if any dependencies of ShuffleMapStage 0 are now runnable\n    org.apache.spark.scheduler.DAGScheduler          - running: Set()\n    org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ShuffleMapStage 1, ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n    ~~~\n    \n    Stage在计算完后，DAGScheduler会查询是否还有未完成的计算，直到有新的Stage提交\n    \n    ~~~txt\n    ============================   ShuffleMapStage 1 的提交计算过程  ==========================\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List()\n    org.apache.spark.scheduler.DAGScheduler          - Submitting ShuffleMapStage 1 (MapPartitionsRDD[5] at map at WCAnalyzer.scala:28), which has no missing parents\n    org.apache.spark.scheduler.DAGScheduler          - submitMissingTasks(ShuffleMapStage 1)\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Adding task set 1.0 with 1 tasks\n    org.apache.spark.scheduler.TaskSetManager        - Starting task 0.0 in stage 1.0 (TID 1, localhost, executor driver, partition 0, ANY, 7638 bytes)\n    org.apache.spark.executor.Executor               - Running task 0.0 in stage 1.0 (TID 1)\n    org.apache.spark.executor.Executor               - Finished task 0.0 in stage 1.0 (TID 1). 1331 bytes result sent to driver\n    org.apache.spark.scheduler.TaskSetManager        - Finished task 0.0 in stage 1.0 (TID 1) in 102 ms on localhost (executor driver) (1/1)\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 1.0, whose tasks have all completed, from pool \n    org.apache.spark.scheduler.DAGScheduler          - ShuffleMapTask finished on driver\n    org.apache.spark.scheduler.DAGScheduler          - ShuffleMapStage 1 (map at WCAnalyzer.scala:28) finished in 0.117 s\n    ============================   ResultStage 2 的提交计算过程  =============================\n    org.apache.spark.scheduler.DAGScheduler          - looking for newly runnable stages\n    org.apache.spark.scheduler.DAGScheduler          - running: Set()\n    org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n    org.apache.spark.MapOutputTrackerMaster          - Increasing epoch to 2\n    org.apache.spark.scheduler.DAGScheduler          - Checking if any dependencies of ShuffleMapStage 1 are now runnable\n    org.apache.spark.scheduler.DAGScheduler          - running: Set()\n    org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List()\n    org.apache.spark.scheduler.DAGScheduler          - Submitting ResultStage 2 (MapPartitionsRDD[7] at map at WCAnalyzer.scala:32), which has no missing parents\n    org.apache.spark.scheduler.DAGScheduler          - submitMissingTasks(ResultStage 2)\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Adding task set 2.0 with 1 tasks\n    org.apache.spark.scheduler.TaskSetManager        - Starting task 0.0 in stage 2.0 (TID 2, localhost, executor driver, partition 0, ANY, 7649 bytes)\n    org.apache.spark.executor.Executor               - Running task 0.0 in stage 2.0 (TID 2)\n    org.apache.spark.executor.Executor               - Finished task 0.0 in stage 2.0 (TID 2). 1387 bytes result sent to driver\n    org.apache.spark.scheduler.TaskSetManager        - Finished task 0.0 in stage 2.0 (TID 2) in 44 ms on localhost (executor driver) (1/1)\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 2.0, whose tasks have all completed, from pool \n    org.apache.spark.scheduler.DAGScheduler          - ResultStage 2 (collect at WCAnalyzer.scala:34) finished in 0.057 s\n    ~~~\n    \n    以上是ShuffleMapStage 1和ResultStage 2的提交计算过程，与ShuffleMapStage 0一样，不再赘述\n    \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - Job 0 finished: collect at WCAnalyzer.scala:34, took 0.770898 s\n    ~~~\n    \n    DAGScheduler 当所有的Stage 提交计算完成 结束Job\n\n\n\n\n","source":"_posts/手撕Spark之WordCount RDD执行流程.md","raw":"---\ntitle: 手撕Spark之WordCount RDD执行流程\ndate: 2019-12-18 10:03:14\ncategories: Spark\ntags: Spark\n---\n\n##  手撕Spark之WordCount RDD执行流程\n\n[TOC]\n\n\n\n### 写在前面\n\n一个Spark程序在初始化的时候会构造DAGScheduler、TaskSchedulerImpl、MapOutTrackerMaster等对象，DAGScheduler主要负责生成DAG、启动Job、提交Stage等操作，TaskSchedulerImpl主要负责Task Set的添加调度等，MapOutTrackerMaster主要负责数据的Shuffle等，这里不再赘述。\n\n**注意几个概念：**\n\n- Application   //一个Spark程序会有一个Application，也就拥有了唯一的一个applicationId\n- Job    //调用Action 算子 触发runJob，触发一次runJob就会产生一个Job\n- Stage  //遇到一次宽依赖就会生成一个Stage\n- Task  //Spark程序运行的最小单元\n\n> 注：一个Spark程序会有1个Application，会有1～N 个Job，会有1～N 个Stage，会有1～N 个Task\n>\n> 1 Application = [1 ~ N  ] Job\n> 1 Job = [ 1 ~ N ] Stage\n> 1 Stage = [ 1 ~ N ] Task\n>\n> Stage数 = Shuffle数 +1\n\n\n\n### 软件环境\n\n+ Spark：2.3.0\n\n### 代码\n\n写一个简单的WordCount计算代码\n\ndata.txt\n\n~~~txt\nhello world\nhello java\nhello scala\nhello hadoop\nhello spark\n~~~\n\nWCAnalyzer.scala\n\n~~~scala\n\n    //设置日志输出级别，便于观察日志\n    Logger.getLogger(\"org.apache\").setLevel(Level.ALL)\n\n    //创建sc\n    val sc = new SparkContext(new SparkConf().setMaster(\"local[1]\")\n                              .setAppName(\"WCAnalyzer\"))\n\n    //从文件读取数据\n    sc.textFile(\"data/data.txt\", 1)\n      //将数据按照空格进行切分（切分出单个单词）\n      .flatMap(_.split(\" \"))\n      //将每个单词和1组成一个Tuple\n      .map((_, 1))\n      //按照相同的单词进行聚合\n      .reduceByKey(_ + _)\n      //将聚合后的结果将（key，value）数据进行倒置 转换成（value，key）便于排序\n      .map(v => (v._2, v._1))\n      //按照聚合后的单词数量进行降序排序\n      .sortByKey(false)\n      //将排序后的数据进行倒置\n      .map(v => (v._2, v._1))\n      //将数据收集到driver\n      .collect()\n      //输出数据\n      .foreach(println)\n\n    //关闭sc\n    sc.stop()\n  }\n~~~\n\n\n\n### 过程分析\n\n本代码只会生成一个Job，3个Stage，8个RDD。\n\n+ 划分Stage\n\n  Stage的划分要从后向前，每遇到一次宽依赖就划分一个Stage，因此这个简单的WC代码可以分为3个Stage，分别是由textFile、flatMap、map算子组成的第一个Stage 0；由reduceByKey、map算子组成的Stage 1；由sortByKey、map算子组成的Stage 2。\n\n+ RDD的生成 \n\n  textFile（HadoopRDD [0] ，MapPartitionsRDD [1] ）  //[ ] 内为该rdd的序号\n\n  flatMap（MapPartitionsRDD [2] ）\n\n  map（MapPartitionsRDD [3] ）\n\n  reduceByKey（ShuffledRDD [4] ）\n\n  map（MapPartitionsRDD [5] ）\n\n  sortByKey（ShuffledRDD [6] ）\n\n  map （MapPartitionsRDD [7] ）\n\n+ 日志分析\n\n    ~~~txt\n    org.apache.spark.SparkContext                     - Starting job: collect at WCAnalyzer.scala:34\n    ~~~\n    由collect算子触发runJob 启动一个Job，代码中的`foreach(println)`其中`foreach`并不是RDD中的算子，因此不会触发runJob，也就不会生成一个Job\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler           - Got job 0 (collect at WCAnalyzer.scala:34) with 1 output partitions\n    ~~~\n\n    \t生成一个Job 0 ，这个Job是由collect算子生成，在代码第34行，有一个分区\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler          - Final stage: ResultStage 2 (collect at WCAnalyzer.scala:34)\n    org.apache.spark.scheduler.DAGScheduler          - Parents of final stage: List(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - Missing parents: List(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List(ShuffleMapStage 0)\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 0)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List()\n    ~~~\n\n    Job 的Final Stage 为ResultStage 0，ResultStage 的父依赖为ShuffleMapStage 1，遗留的父依赖为ShuffleMapStage 1。\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - submitStage(ResultStage 2)\n    ~~~\n\n    尝试提交ResultStage 2\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - missing: List(ShuffleMapStage 1)\n    ~~~\n\n    遗留一个ShuffleMapStage 1\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - submitStage(ShuffleMapStage 1)\n    ~~~\n\n    尝试提交ShuffleMapStage 1\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - missing: List(ShuffleMapStage 0)\n    ~~~\n\n    遗留一个ShuffleMapStage 0\n\n     ~~~txt\n      org.apache.spark.scheduler.DAGScheduler         - submitStage(ShuffleMapStage 0)\n     ~~~\n    \n     尝试提交ShuffleMapStage 0\n    \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - missing: List()\n    ~~~\n  \n    没有遗留的Stage\n  \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - Submitting ShuffleMapStage 0 (MapPartitionsRDD[3] at map at WCAnalyzer.scala:24), which has no missing parents\n    ~~~\n  \n    提交ShuffleMapStage 0，该Stage的最后一个RDD是MapPartitionsRDD[3]，是由map算子生成，在代码第24行\n  \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - submitMissingTasks(ShuffleMapStage 0)\n    ~~~\n  \n    提交Tasks，一个Stage就是一个Task Set集合\n  \n    ~~~txt\n    org.apache.spark.scheduler.TaskSchedulerImpl    - Adding task set 0.0 with 1 tasks\n    ~~~\n    TaskSchedulerImpl 调度器添加一个Task Set集合\n  \n    ~~~txt\n    org.apache.spark.scheduler.TaskSetManager       - Starting task 0.0 in stage 0.0 (TID 0, localhost, executor driver, partition 0, PROCESS_LOCAL, 7909 bytes)\n    ~~~\n  \n    TaskSetManager 启动stage 0.0 中的task 0.0（taskid=0.0，host=localhost，executor=driver，partition=0，taskLocality=PROCESS_LOCAL，serializedTask=7909 bytes\n  \n    ~~~txt\n    org.apache.spark.executor.Executor              - Running task 0.0 in stage 0.0 (TID 0)\n    ~~~\n  \n    Executor 端运行task\n  \n    ~~~txt\n    org.apache.spark.executor.Executor              - Finished task 0.0 in stage 0.0 (TID 0). 1159 bytes result sent to driver\n    ~~~\n  \n    Executor 端 运行完成task，将序列化后大小为1159 bytes结果数据发送回driver端\n  \n    ~~~txt\n    org.apache.spark.scheduler.TaskSetManager       - Finished task 0.0 in stage 0.0 (TID 0) in 194 ms on localhost (executor driver) (1/1)\n    ~~~\n  \n    TaskSetManager 运行完task  完成task数量／总攻task数量\n  \n    ~~~txt\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 0.0, whose tasks have all completed, from pool \n    ~~~\n  \n    TaskSchedulerImpl 移除TaskSet 集合\n  \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler          - ShuffleMapTask finished on driver\n    ~~~\n  \n    DAGScheduler 完成ShuffleMapTask 的计算\n  \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler          - ShuffleMapStage 0 (map at WCAnalyzer.scala:24) finished in 0.289 s\n    ~~~\n  \n    DAGScheduler 完成ShuffleMapStage 的计算，用时共 0.289 s\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler          - looking for newly runnable stages\n    org.apache.spark.scheduler.DAGScheduler          - running: Set()\n    org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ShuffleMapStage 1, ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n    org.apache.spark.MapOutputTrackerMaster          - Increasing epoch to 1\n    org.apache.spark.scheduler.DAGScheduler          - Checking if any dependencies of ShuffleMapStage 0 are now runnable\n    org.apache.spark.scheduler.DAGScheduler          - running: Set()\n    org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ShuffleMapStage 1, ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n    ~~~\n    \n    Stage在计算完后，DAGScheduler会查询是否还有未完成的计算，直到有新的Stage提交\n    \n    ~~~txt\n    ============================   ShuffleMapStage 1 的提交计算过程  ==========================\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List()\n    org.apache.spark.scheduler.DAGScheduler          - Submitting ShuffleMapStage 1 (MapPartitionsRDD[5] at map at WCAnalyzer.scala:28), which has no missing parents\n    org.apache.spark.scheduler.DAGScheduler          - submitMissingTasks(ShuffleMapStage 1)\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Adding task set 1.0 with 1 tasks\n    org.apache.spark.scheduler.TaskSetManager        - Starting task 0.0 in stage 1.0 (TID 1, localhost, executor driver, partition 0, ANY, 7638 bytes)\n    org.apache.spark.executor.Executor               - Running task 0.0 in stage 1.0 (TID 1)\n    org.apache.spark.executor.Executor               - Finished task 0.0 in stage 1.0 (TID 1). 1331 bytes result sent to driver\n    org.apache.spark.scheduler.TaskSetManager        - Finished task 0.0 in stage 1.0 (TID 1) in 102 ms on localhost (executor driver) (1/1)\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 1.0, whose tasks have all completed, from pool \n    org.apache.spark.scheduler.DAGScheduler          - ShuffleMapTask finished on driver\n    org.apache.spark.scheduler.DAGScheduler          - ShuffleMapStage 1 (map at WCAnalyzer.scala:28) finished in 0.117 s\n    ============================   ResultStage 2 的提交计算过程  =============================\n    org.apache.spark.scheduler.DAGScheduler          - looking for newly runnable stages\n    org.apache.spark.scheduler.DAGScheduler          - running: Set()\n    org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n    org.apache.spark.MapOutputTrackerMaster          - Increasing epoch to 2\n    org.apache.spark.scheduler.DAGScheduler          - Checking if any dependencies of ShuffleMapStage 1 are now runnable\n    org.apache.spark.scheduler.DAGScheduler          - running: Set()\n    org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List()\n    org.apache.spark.scheduler.DAGScheduler          - Submitting ResultStage 2 (MapPartitionsRDD[7] at map at WCAnalyzer.scala:32), which has no missing parents\n    org.apache.spark.scheduler.DAGScheduler          - submitMissingTasks(ResultStage 2)\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Adding task set 2.0 with 1 tasks\n    org.apache.spark.scheduler.TaskSetManager        - Starting task 0.0 in stage 2.0 (TID 2, localhost, executor driver, partition 0, ANY, 7649 bytes)\n    org.apache.spark.executor.Executor               - Running task 0.0 in stage 2.0 (TID 2)\n    org.apache.spark.executor.Executor               - Finished task 0.0 in stage 2.0 (TID 2). 1387 bytes result sent to driver\n    org.apache.spark.scheduler.TaskSetManager        - Finished task 0.0 in stage 2.0 (TID 2) in 44 ms on localhost (executor driver) (1/1)\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 2.0, whose tasks have all completed, from pool \n    org.apache.spark.scheduler.DAGScheduler          - ResultStage 2 (collect at WCAnalyzer.scala:34) finished in 0.057 s\n    ~~~\n    \n    以上是ShuffleMapStage 1和ResultStage 2的提交计算过程，与ShuffleMapStage 0一样，不再赘述\n    \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - Job 0 finished: collect at WCAnalyzer.scala:34, took 0.770898 s\n    ~~~\n    \n    DAGScheduler 当所有的Stage 提交计算完成 结束Job\n\n\n\n\n","slug":"手撕Spark之WordCount RDD执行流程","published":1,"updated":"2020-03-18T11:52:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8hf2uvy000lzhs6l50o678v","content":"<h2 id=\"手撕Spark之WordCount-RDD执行流程\"><a href=\"#手撕Spark之WordCount-RDD执行流程\" class=\"headerlink\" title=\"手撕Spark之WordCount RDD执行流程\"></a>手撕Spark之WordCount RDD执行流程</h2><p>[TOC]</p>\n<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><p>一个Spark程序在初始化的时候会构造DAGScheduler、TaskSchedulerImpl、MapOutTrackerMaster等对象，DAGScheduler主要负责生成DAG、启动Job、提交Stage等操作，TaskSchedulerImpl主要负责Task Set的添加调度等，MapOutTrackerMaster主要负责数据的Shuffle等，这里不再赘述。</p>\n<p><strong>注意几个概念：</strong></p>\n<ul>\n<li>Application   //一个Spark程序会有一个Application，也就拥有了唯一的一个applicationId</li>\n<li>Job    //调用Action 算子 触发runJob，触发一次runJob就会产生一个Job</li>\n<li>Stage  //遇到一次宽依赖就会生成一个Stage</li>\n<li>Task  //Spark程序运行的最小单元</li>\n</ul>\n<blockquote>\n<p>注：一个Spark程序会有1个Application，会有1～N 个Job，会有1～N 个Stage，会有1～N 个Task</p>\n<p>1 Application = [1 ~ N  ] Job<br>1 Job = [ 1 ~ N ] Stage<br>1 Stage = [ 1 ~ N ] Task</p>\n<p>Stage数 = Shuffle数 +1</p>\n</blockquote>\n<h3 id=\"软件环境\"><a href=\"#软件环境\" class=\"headerlink\" title=\"软件环境\"></a>软件环境</h3><ul>\n<li>Spark：2.3.0</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>写一个简单的WordCount计算代码</p>\n<p>data.txt</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">hello world\nhello java\nhello scala\nhello hadoop\nhello spark</code></pre>\n<p>WCAnalyzer.scala</p>\n<pre class=\" language-scala\"><code class=\"language-scala\">\n    <span class=\"token comment\" spellcheck=\"true\">//设置日志输出级别，便于观察日志</span>\n    Logger<span class=\"token punctuation\">.</span>getLogger<span class=\"token punctuation\">(</span><span class=\"token string\">\"org.apache\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>setLevel<span class=\"token punctuation\">(</span>Level<span class=\"token punctuation\">.</span>ALL<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//创建sc</span>\n    <span class=\"token keyword\">val</span> sc <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> SparkContext<span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> SparkConf<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>setMaster<span class=\"token punctuation\">(</span><span class=\"token string\">\"local[1]\"</span><span class=\"token punctuation\">)</span>\n                              <span class=\"token punctuation\">.</span>setAppName<span class=\"token punctuation\">(</span><span class=\"token string\">\"WCAnalyzer\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//从文件读取数据</span>\n    sc<span class=\"token punctuation\">.</span>textFile<span class=\"token punctuation\">(</span><span class=\"token string\">\"data/data.txt\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">//将数据按照空格进行切分（切分出单个单词）</span>\n      <span class=\"token punctuation\">.</span>flatMap<span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">//将每个单词和1组成一个Tuple</span>\n      <span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">//按照相同的单词进行聚合</span>\n      <span class=\"token punctuation\">.</span>reduceByKey<span class=\"token punctuation\">(</span>_ <span class=\"token operator\">+</span> _<span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">//将聚合后的结果将（key，value）数据进行倒置 转换成（value，key）便于排序</span>\n      <span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>v <span class=\"token keyword\">=></span> <span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span>_2<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">.</span>_1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">//按照聚合后的单词数量进行降序排序</span>\n      <span class=\"token punctuation\">.</span>sortByKey<span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">//将排序后的数据进行倒置</span>\n      <span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>v <span class=\"token keyword\">=></span> <span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span>_2<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">.</span>_1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">//将数据收集到driver</span>\n      <span class=\"token punctuation\">.</span>collect<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">//输出数据</span>\n      <span class=\"token punctuation\">.</span>foreach<span class=\"token punctuation\">(</span>println<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//关闭sc</span>\n    sc<span class=\"token punctuation\">.</span>stop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"过程分析\"><a href=\"#过程分析\" class=\"headerlink\" title=\"过程分析\"></a>过程分析</h3><p>本代码只会生成一个Job，3个Stage，8个RDD。</p>\n<ul>\n<li><p>划分Stage</p>\n<p>Stage的划分要从后向前，每遇到一次宽依赖就划分一个Stage，因此这个简单的WC代码可以分为3个Stage，分别是由textFile、flatMap、map算子组成的第一个Stage 0；由reduceByKey、map算子组成的Stage 1；由sortByKey、map算子组成的Stage 2。</p>\n</li>\n<li><p>RDD的生成 </p>\n<p>textFile（HadoopRDD [0] ，MapPartitionsRDD [1] ）  //[ ] 内为该rdd的序号</p>\n<p>flatMap（MapPartitionsRDD [2] ）</p>\n<p>map（MapPartitionsRDD [3] ）</p>\n<p>reduceByKey（ShuffledRDD [4] ）</p>\n<p>map（MapPartitionsRDD [5] ）</p>\n<p>sortByKey（ShuffledRDD [6] ）</p>\n<p>map （MapPartitionsRDD [7] ）</p>\n</li>\n<li><p>日志分析</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.SparkContext                     - Starting job: collect at WCAnalyzer.scala:34</code></pre>\n<p>  由collect算子触发runJob 启动一个Job，代码中的<code>foreach(println)</code>其中<code>foreach</code>并不是RDD中的算子，因此不会触发runJob，也就不会生成一个Job</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler           - Got job 0 (collect at WCAnalyzer.scala:34) with 1 output partitions</code></pre>\n<pre><code>  生成一个Job 0 ，这个Job是由collect算子生成，在代码第34行，有一个分区</code></pre><pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler          - Final stage: ResultStage 2 (collect at WCAnalyzer.scala:34)\n  org.apache.spark.scheduler.DAGScheduler          - Parents of final stage: List(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - Missing parents: List(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List(ShuffleMapStage 0)\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 0)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List()</code></pre>\n<p>  Job 的Final Stage 为ResultStage 0，ResultStage 的父依赖为ShuffleMapStage 1，遗留的父依赖为ShuffleMapStage 1。</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler         - submitStage(ResultStage 2)</code></pre>\n<p>  尝试提交ResultStage 2</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler         - missing: List(ShuffleMapStage 1)</code></pre>\n<p>  遗留一个ShuffleMapStage 1</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler         - submitStage(ShuffleMapStage 1)</code></pre>\n<p>  尝试提交ShuffleMapStage 1</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler         - missing: List(ShuffleMapStage 0)</code></pre>\n<p>  遗留一个ShuffleMapStage 0</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">    org.apache.spark.scheduler.DAGScheduler         - submitStage(ShuffleMapStage 0)</code></pre>\n<p>   尝试提交ShuffleMapStage 0</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler         - missing: List()</code></pre>\n<p>  没有遗留的Stage</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler         - Submitting ShuffleMapStage 0 (MapPartitionsRDD[3] at map at WCAnalyzer.scala:24), which has no missing parents</code></pre>\n<p>  提交ShuffleMapStage 0，该Stage的最后一个RDD是MapPartitionsRDD[3]，是由map算子生成，在代码第24行</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler         - submitMissingTasks(ShuffleMapStage 0)</code></pre>\n<p>  提交Tasks，一个Stage就是一个Task Set集合</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.TaskSchedulerImpl    - Adding task set 0.0 with 1 tasks</code></pre>\n<p>  TaskSchedulerImpl 调度器添加一个Task Set集合</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.TaskSetManager       - Starting task 0.0 in stage 0.0 (TID 0, localhost, executor driver, partition 0, PROCESS_LOCAL, 7909 bytes)</code></pre>\n<p>  TaskSetManager 启动stage 0.0 中的task 0.0（taskid=0.0，host=localhost，executor=driver，partition=0，taskLocality=PROCESS_LOCAL，serializedTask=7909 bytes</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.executor.Executor              - Running task 0.0 in stage 0.0 (TID 0)</code></pre>\n<p>  Executor 端运行task</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.executor.Executor              - Finished task 0.0 in stage 0.0 (TID 0). 1159 bytes result sent to driver</code></pre>\n<p>  Executor 端 运行完成task，将序列化后大小为1159 bytes结果数据发送回driver端</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.TaskSetManager       - Finished task 0.0 in stage 0.0 (TID 0) in 194 ms on localhost (executor driver) (1/1)</code></pre>\n<p>  TaskSetManager 运行完task  完成task数量／总攻task数量</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 0.0, whose tasks have all completed, from pool </code></pre>\n<p>  TaskSchedulerImpl 移除TaskSet 集合</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler          - ShuffleMapTask finished on driver</code></pre>\n<p>  DAGScheduler 完成ShuffleMapTask 的计算</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler          - ShuffleMapStage 0 (map at WCAnalyzer.scala:24) finished in 0.289 s</code></pre>\n<p>  DAGScheduler 完成ShuffleMapStage 的计算，用时共 0.289 s</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler          - looking for newly runnable stages\n  org.apache.spark.scheduler.DAGScheduler          - running: Set()\n  org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ShuffleMapStage 1, ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n  org.apache.spark.MapOutputTrackerMaster          - Increasing epoch to 1\n  org.apache.spark.scheduler.DAGScheduler          - Checking if any dependencies of ShuffleMapStage 0 are now runnable\n  org.apache.spark.scheduler.DAGScheduler          - running: Set()\n  org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ShuffleMapStage 1, ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - failed: Set()</code></pre>\n<p>  Stage在计算完后，DAGScheduler会查询是否还有未完成的计算，直到有新的Stage提交</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  ============================   ShuffleMapStage 1 的提交计算过程  ==========================\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List()\n  org.apache.spark.scheduler.DAGScheduler          - Submitting ShuffleMapStage 1 (MapPartitionsRDD[5] at map at WCAnalyzer.scala:28), which has no missing parents\n  org.apache.spark.scheduler.DAGScheduler          - submitMissingTasks(ShuffleMapStage 1)\n  org.apache.spark.scheduler.TaskSchedulerImpl     - Adding task set 1.0 with 1 tasks\n  org.apache.spark.scheduler.TaskSetManager        - Starting task 0.0 in stage 1.0 (TID 1, localhost, executor driver, partition 0, ANY, 7638 bytes)\n  org.apache.spark.executor.Executor               - Running task 0.0 in stage 1.0 (TID 1)\n  org.apache.spark.executor.Executor               - Finished task 0.0 in stage 1.0 (TID 1). 1331 bytes result sent to driver\n  org.apache.spark.scheduler.TaskSetManager        - Finished task 0.0 in stage 1.0 (TID 1) in 102 ms on localhost (executor driver) (1/1)\n  org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 1.0, whose tasks have all completed, from pool \n  org.apache.spark.scheduler.DAGScheduler          - ShuffleMapTask finished on driver\n  org.apache.spark.scheduler.DAGScheduler          - ShuffleMapStage 1 (map at WCAnalyzer.scala:28) finished in 0.117 s\n  ============================   ResultStage 2 的提交计算过程  =============================\n  org.apache.spark.scheduler.DAGScheduler          - looking for newly runnable stages\n  org.apache.spark.scheduler.DAGScheduler          - running: Set()\n  org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n  org.apache.spark.MapOutputTrackerMaster          - Increasing epoch to 2\n  org.apache.spark.scheduler.DAGScheduler          - Checking if any dependencies of ShuffleMapStage 1 are now runnable\n  org.apache.spark.scheduler.DAGScheduler          - running: Set()\n  org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List()\n  org.apache.spark.scheduler.DAGScheduler          - Submitting ResultStage 2 (MapPartitionsRDD[7] at map at WCAnalyzer.scala:32), which has no missing parents\n  org.apache.spark.scheduler.DAGScheduler          - submitMissingTasks(ResultStage 2)\n  org.apache.spark.scheduler.TaskSchedulerImpl     - Adding task set 2.0 with 1 tasks\n  org.apache.spark.scheduler.TaskSetManager        - Starting task 0.0 in stage 2.0 (TID 2, localhost, executor driver, partition 0, ANY, 7649 bytes)\n  org.apache.spark.executor.Executor               - Running task 0.0 in stage 2.0 (TID 2)\n  org.apache.spark.executor.Executor               - Finished task 0.0 in stage 2.0 (TID 2). 1387 bytes result sent to driver\n  org.apache.spark.scheduler.TaskSetManager        - Finished task 0.0 in stage 2.0 (TID 2) in 44 ms on localhost (executor driver) (1/1)\n  org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 2.0, whose tasks have all completed, from pool \n  org.apache.spark.scheduler.DAGScheduler          - ResultStage 2 (collect at WCAnalyzer.scala:34) finished in 0.057 s</code></pre>\n<p>  以上是ShuffleMapStage 1和ResultStage 2的提交计算过程，与ShuffleMapStage 0一样，不再赘述</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler         - Job 0 finished: collect at WCAnalyzer.scala:34, took 0.770898 s</code></pre>\n<p>  DAGScheduler 当所有的Stage 提交计算完成 结束Job</p>\n</li>\n</ul>\n","site":{"data":{"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}],"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]}},"excerpt":"","more":"<h2 id=\"手撕Spark之WordCount-RDD执行流程\"><a href=\"#手撕Spark之WordCount-RDD执行流程\" class=\"headerlink\" title=\"手撕Spark之WordCount RDD执行流程\"></a>手撕Spark之WordCount RDD执行流程</h2><p>[TOC]</p>\n<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><p>一个Spark程序在初始化的时候会构造DAGScheduler、TaskSchedulerImpl、MapOutTrackerMaster等对象，DAGScheduler主要负责生成DAG、启动Job、提交Stage等操作，TaskSchedulerImpl主要负责Task Set的添加调度等，MapOutTrackerMaster主要负责数据的Shuffle等，这里不再赘述。</p>\n<p><strong>注意几个概念：</strong></p>\n<ul>\n<li>Application   //一个Spark程序会有一个Application，也就拥有了唯一的一个applicationId</li>\n<li>Job    //调用Action 算子 触发runJob，触发一次runJob就会产生一个Job</li>\n<li>Stage  //遇到一次宽依赖就会生成一个Stage</li>\n<li>Task  //Spark程序运行的最小单元</li>\n</ul>\n<blockquote>\n<p>注：一个Spark程序会有1个Application，会有1～N 个Job，会有1～N 个Stage，会有1～N 个Task</p>\n<p>1 Application = [1 ~ N  ] Job<br>1 Job = [ 1 ~ N ] Stage<br>1 Stage = [ 1 ~ N ] Task</p>\n<p>Stage数 = Shuffle数 +1</p>\n</blockquote>\n<h3 id=\"软件环境\"><a href=\"#软件环境\" class=\"headerlink\" title=\"软件环境\"></a>软件环境</h3><ul>\n<li>Spark：2.3.0</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>写一个简单的WordCount计算代码</p>\n<p>data.txt</p>\n<pre><code class=\"txt\">hello world\nhello java\nhello scala\nhello hadoop\nhello spark</code></pre>\n<p>WCAnalyzer.scala</p>\n<pre><code class=\"scala\">\n    //设置日志输出级别，便于观察日志\n    Logger.getLogger(&quot;org.apache&quot;).setLevel(Level.ALL)\n\n    //创建sc\n    val sc = new SparkContext(new SparkConf().setMaster(&quot;local[1]&quot;)\n                              .setAppName(&quot;WCAnalyzer&quot;))\n\n    //从文件读取数据\n    sc.textFile(&quot;data/data.txt&quot;, 1)\n      //将数据按照空格进行切分（切分出单个单词）\n      .flatMap(_.split(&quot; &quot;))\n      //将每个单词和1组成一个Tuple\n      .map((_, 1))\n      //按照相同的单词进行聚合\n      .reduceByKey(_ + _)\n      //将聚合后的结果将（key，value）数据进行倒置 转换成（value，key）便于排序\n      .map(v =&gt; (v._2, v._1))\n      //按照聚合后的单词数量进行降序排序\n      .sortByKey(false)\n      //将排序后的数据进行倒置\n      .map(v =&gt; (v._2, v._1))\n      //将数据收集到driver\n      .collect()\n      //输出数据\n      .foreach(println)\n\n    //关闭sc\n    sc.stop()\n  }</code></pre>\n<h3 id=\"过程分析\"><a href=\"#过程分析\" class=\"headerlink\" title=\"过程分析\"></a>过程分析</h3><p>本代码只会生成一个Job，3个Stage，8个RDD。</p>\n<ul>\n<li><p>划分Stage</p>\n<p>Stage的划分要从后向前，每遇到一次宽依赖就划分一个Stage，因此这个简单的WC代码可以分为3个Stage，分别是由textFile、flatMap、map算子组成的第一个Stage 0；由reduceByKey、map算子组成的Stage 1；由sortByKey、map算子组成的Stage 2。</p>\n</li>\n<li><p>RDD的生成 </p>\n<p>textFile（HadoopRDD [0] ，MapPartitionsRDD [1] ）  //[ ] 内为该rdd的序号</p>\n<p>flatMap（MapPartitionsRDD [2] ）</p>\n<p>map（MapPartitionsRDD [3] ）</p>\n<p>reduceByKey（ShuffledRDD [4] ）</p>\n<p>map（MapPartitionsRDD [5] ）</p>\n<p>sortByKey（ShuffledRDD [6] ）</p>\n<p>map （MapPartitionsRDD [7] ）</p>\n</li>\n<li><p>日志分析</p>\n<pre><code class=\"txt\">  org.apache.spark.SparkContext                     - Starting job: collect at WCAnalyzer.scala:34</code></pre>\n<p>  由collect算子触发runJob 启动一个Job，代码中的<code>foreach(println)</code>其中<code>foreach</code>并不是RDD中的算子，因此不会触发runJob，也就不会生成一个Job</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler           - Got job 0 (collect at WCAnalyzer.scala:34) with 1 output partitions</code></pre>\n<pre><code>  生成一个Job 0 ，这个Job是由collect算子生成，在代码第34行，有一个分区</code></pre><pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler          - Final stage: ResultStage 2 (collect at WCAnalyzer.scala:34)\n  org.apache.spark.scheduler.DAGScheduler          - Parents of final stage: List(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - Missing parents: List(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List(ShuffleMapStage 0)\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 0)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List()</code></pre>\n<p>  Job 的Final Stage 为ResultStage 0，ResultStage 的父依赖为ShuffleMapStage 1，遗留的父依赖为ShuffleMapStage 1。</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler         - submitStage(ResultStage 2)</code></pre>\n<p>  尝试提交ResultStage 2</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler         - missing: List(ShuffleMapStage 1)</code></pre>\n<p>  遗留一个ShuffleMapStage 1</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler         - submitStage(ShuffleMapStage 1)</code></pre>\n<p>  尝试提交ShuffleMapStage 1</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler         - missing: List(ShuffleMapStage 0)</code></pre>\n<p>  遗留一个ShuffleMapStage 0</p>\n<pre><code class=\"txt\">    org.apache.spark.scheduler.DAGScheduler         - submitStage(ShuffleMapStage 0)</code></pre>\n<p>   尝试提交ShuffleMapStage 0</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler         - missing: List()</code></pre>\n<p>  没有遗留的Stage</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler         - Submitting ShuffleMapStage 0 (MapPartitionsRDD[3] at map at WCAnalyzer.scala:24), which has no missing parents</code></pre>\n<p>  提交ShuffleMapStage 0，该Stage的最后一个RDD是MapPartitionsRDD[3]，是由map算子生成，在代码第24行</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler         - submitMissingTasks(ShuffleMapStage 0)</code></pre>\n<p>  提交Tasks，一个Stage就是一个Task Set集合</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.TaskSchedulerImpl    - Adding task set 0.0 with 1 tasks</code></pre>\n<p>  TaskSchedulerImpl 调度器添加一个Task Set集合</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.TaskSetManager       - Starting task 0.0 in stage 0.0 (TID 0, localhost, executor driver, partition 0, PROCESS_LOCAL, 7909 bytes)</code></pre>\n<p>  TaskSetManager 启动stage 0.0 中的task 0.0（taskid=0.0，host=localhost，executor=driver，partition=0，taskLocality=PROCESS_LOCAL，serializedTask=7909 bytes</p>\n<pre><code class=\"txt\">  org.apache.spark.executor.Executor              - Running task 0.0 in stage 0.0 (TID 0)</code></pre>\n<p>  Executor 端运行task</p>\n<pre><code class=\"txt\">  org.apache.spark.executor.Executor              - Finished task 0.0 in stage 0.0 (TID 0). 1159 bytes result sent to driver</code></pre>\n<p>  Executor 端 运行完成task，将序列化后大小为1159 bytes结果数据发送回driver端</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.TaskSetManager       - Finished task 0.0 in stage 0.0 (TID 0) in 194 ms on localhost (executor driver) (1/1)</code></pre>\n<p>  TaskSetManager 运行完task  完成task数量／总攻task数量</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 0.0, whose tasks have all completed, from pool </code></pre>\n<p>  TaskSchedulerImpl 移除TaskSet 集合</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler          - ShuffleMapTask finished on driver</code></pre>\n<p>  DAGScheduler 完成ShuffleMapTask 的计算</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler          - ShuffleMapStage 0 (map at WCAnalyzer.scala:24) finished in 0.289 s</code></pre>\n<p>  DAGScheduler 完成ShuffleMapStage 的计算，用时共 0.289 s</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler          - looking for newly runnable stages\n  org.apache.spark.scheduler.DAGScheduler          - running: Set()\n  org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ShuffleMapStage 1, ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n  org.apache.spark.MapOutputTrackerMaster          - Increasing epoch to 1\n  org.apache.spark.scheduler.DAGScheduler          - Checking if any dependencies of ShuffleMapStage 0 are now runnable\n  org.apache.spark.scheduler.DAGScheduler          - running: Set()\n  org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ShuffleMapStage 1, ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - failed: Set()</code></pre>\n<p>  Stage在计算完后，DAGScheduler会查询是否还有未完成的计算，直到有新的Stage提交</p>\n<pre><code class=\"txt\">  ============================   ShuffleMapStage 1 的提交计算过程  ==========================\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List()\n  org.apache.spark.scheduler.DAGScheduler          - Submitting ShuffleMapStage 1 (MapPartitionsRDD[5] at map at WCAnalyzer.scala:28), which has no missing parents\n  org.apache.spark.scheduler.DAGScheduler          - submitMissingTasks(ShuffleMapStage 1)\n  org.apache.spark.scheduler.TaskSchedulerImpl     - Adding task set 1.0 with 1 tasks\n  org.apache.spark.scheduler.TaskSetManager        - Starting task 0.0 in stage 1.0 (TID 1, localhost, executor driver, partition 0, ANY, 7638 bytes)\n  org.apache.spark.executor.Executor               - Running task 0.0 in stage 1.0 (TID 1)\n  org.apache.spark.executor.Executor               - Finished task 0.0 in stage 1.0 (TID 1). 1331 bytes result sent to driver\n  org.apache.spark.scheduler.TaskSetManager        - Finished task 0.0 in stage 1.0 (TID 1) in 102 ms on localhost (executor driver) (1/1)\n  org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 1.0, whose tasks have all completed, from pool \n  org.apache.spark.scheduler.DAGScheduler          - ShuffleMapTask finished on driver\n  org.apache.spark.scheduler.DAGScheduler          - ShuffleMapStage 1 (map at WCAnalyzer.scala:28) finished in 0.117 s\n  ============================   ResultStage 2 的提交计算过程  =============================\n  org.apache.spark.scheduler.DAGScheduler          - looking for newly runnable stages\n  org.apache.spark.scheduler.DAGScheduler          - running: Set()\n  org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n  org.apache.spark.MapOutputTrackerMaster          - Increasing epoch to 2\n  org.apache.spark.scheduler.DAGScheduler          - Checking if any dependencies of ShuffleMapStage 1 are now runnable\n  org.apache.spark.scheduler.DAGScheduler          - running: Set()\n  org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List()\n  org.apache.spark.scheduler.DAGScheduler          - Submitting ResultStage 2 (MapPartitionsRDD[7] at map at WCAnalyzer.scala:32), which has no missing parents\n  org.apache.spark.scheduler.DAGScheduler          - submitMissingTasks(ResultStage 2)\n  org.apache.spark.scheduler.TaskSchedulerImpl     - Adding task set 2.0 with 1 tasks\n  org.apache.spark.scheduler.TaskSetManager        - Starting task 0.0 in stage 2.0 (TID 2, localhost, executor driver, partition 0, ANY, 7649 bytes)\n  org.apache.spark.executor.Executor               - Running task 0.0 in stage 2.0 (TID 2)\n  org.apache.spark.executor.Executor               - Finished task 0.0 in stage 2.0 (TID 2). 1387 bytes result sent to driver\n  org.apache.spark.scheduler.TaskSetManager        - Finished task 0.0 in stage 2.0 (TID 2) in 44 ms on localhost (executor driver) (1/1)\n  org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 2.0, whose tasks have all completed, from pool \n  org.apache.spark.scheduler.DAGScheduler          - ResultStage 2 (collect at WCAnalyzer.scala:34) finished in 0.057 s</code></pre>\n<p>  以上是ShuffleMapStage 1和ResultStage 2的提交计算过程，与ShuffleMapStage 0一样，不再赘述</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler         - Job 0 finished: collect at WCAnalyzer.scala:34, took 0.770898 s</code></pre>\n<p>  DAGScheduler 当所有的Stage 提交计算完成 结束Job</p>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck8hf2uux0001zhs6jtasqevn","category_id":"ck8hf2uv40004zhs6l0rreuuy","_id":"ck8hf2uv9000bzhs6tzwrl5rr"},{"post_id":"ck8hf2uvx000jzhs6xj1n4nag","category_id":"ck8hf2uw0000nzhs69gboj7xu","_id":"ck8hf2uw3000uzhs6up5p8tah"},{"post_id":"ck8hf2uvy000lzhs6l50o678v","category_id":"ck8hf2uw2000rzhs6ewut5nrx","_id":"ck8hf2uw3000wzhs6c8hinaxc"}],"PostTag":[{"post_id":"ck8hf2uux0001zhs6jtasqevn","tag_id":"ck8hf2uv50005zhs6zk8ssoe9","_id":"ck8hf2uv80009zhs6awtrk16z"},{"post_id":"ck8hf2uvx000jzhs6xj1n4nag","tag_id":"ck8hf2uw0000ozhs65j6b4tz3","_id":"ck8hf2uw2000tzhs6mv754uqw"},{"post_id":"ck8hf2uvy000lzhs6l50o678v","tag_id":"ck8hf2uw2000szhs6atgt2ed8","_id":"ck8hf2uw3000vzhs6jx0dt12n"}],"Tag":[{"name":"Hexo","_id":"ck8hf2uv50005zhs6zk8ssoe9"},{"name":"大数据面试题","_id":"ck8hf2uw0000ozhs65j6b4tz3"},{"name":"Spark","_id":"ck8hf2uw2000szhs6atgt2ed8"}]}}