{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/matery/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"source/notes/Git&GitHub.assets/QQ20200318-211942@2x.png","path":"notes/Git&GitHub.assets/QQ20200318-211942@2x.png","modified":0,"renderable":0},{"_id":"source/notes/Java.assets/Java线程内存模型JMM2.png","path":"notes/Java.assets/Java线程内存模型JMM2.png","modified":0,"renderable":0},{"_id":"themes/matery/source/css/gitment.css","path":"css/gitment.css","modified":0,"renderable":1},{"_id":"themes/matery/source/css/my-gitalk.css","path":"css/my-gitalk.css","modified":0,"renderable":1},{"_id":"themes/matery/source/css/matery.css","path":"css/matery.css","modified":0,"renderable":1},{"_id":"themes/matery/source/js/matery.js","path":"js/matery.js","modified":0,"renderable":1},{"_id":"themes/matery/source/css/my.css","path":"css/my.css","modified":0,"renderable":1},{"_id":"themes/matery/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/avatar.jpg","path":"medias/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/logo.png","path":"medias/logo.png","modified":0,"renderable":1},{"_id":"source/notes/Bigdata.assets/mapreduce原理全剖析--段氏六脉神剑.png","path":"notes/Bigdata.assets/mapreduce原理全剖析--段氏六脉神剑.png","modified":0,"renderable":0},{"_id":"source/notes/Java.assets/QQ20200314-123059@2x-4161427.png","path":"notes/Java.assets/QQ20200314-123059@2x-4161427.png","modified":0,"renderable":0},{"_id":"source/notes/Java.assets/QQ20200314-123059@2x.png","path":"notes/Java.assets/QQ20200314-123059@2x.png","modified":0,"renderable":0},{"_id":"source/notes/Java.assets/QQ20200314-123059@2x-4161454.png","path":"notes/Java.assets/QQ20200314-123059@2x-4161454.png","modified":0,"renderable":0},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","path":"libs/aplayer/APlayer.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aos/aos.js","path":"libs/aos/aos.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","path":"libs/aplayer/APlayer.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/background/canvas-nest.js","path":"libs/background/canvas-nest.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","path":"libs/cryptojs/crypto-js.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/background/ribbon-dynamic.js","path":"libs/background/ribbon-dynamic.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/background/ribbon-refresh.min.js","path":"libs/background/ribbon-refresh.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/background/ribbon.min.js","path":"libs/background/ribbon.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","path":"libs/dplayer/DPlayer.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","path":"libs/gitalk/gitalk.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","path":"libs/gitment/gitment-default.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","path":"libs/jqcloud/jqcloud-1.0.4.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","path":"libs/jqcloud/jqcloud.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","path":"libs/others/busuanzi.pure.mini.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/others/clicklove.js","path":"libs/others/clicklove.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","path":"libs/masonry/masonry.pkgd.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","path":"libs/tocbot/tocbot.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","path":"libs/scrollprogress/scrollProgress.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","path":"libs/tocbot/tocbot.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/cover.jpg","path":"medias/cover.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/15.jpg","path":"medias/featureimages/15.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/16.jpg","path":"medias/featureimages/16.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/2.jpg","path":"medias/featureimages/2.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/22.jpg","path":"medias/featureimages/22.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/21.jpg","path":"medias/featureimages/21.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/23.jpg","path":"medias/featureimages/23.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/5.jpg","path":"medias/featureimages/5.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/7.jpg","path":"medias/featureimages/7.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/8.jpg","path":"medias/featureimages/8.jpg","modified":0,"renderable":1},{"_id":"source/notes/Bigdata.assets/mapreduce&yarn的工作机制----吸星大法.png","path":"notes/Bigdata.assets/mapreduce&yarn的工作机制----吸星大法.png","modified":0,"renderable":0},{"_id":"themes/matery/source/medias/reward/wechat.png","path":"medias/reward/wechat.png","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/reward/alipay.jpg","path":"medias/reward/alipay.jpg","modified":0,"renderable":1},{"_id":"source/notes/img/零拷贝.png","path":"notes/img/零拷贝.png","modified":0,"renderable":0},{"_id":"themes/matery/source/libs/aos/aos.css","path":"libs/aos/aos.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/animate/animate.min.css","path":"libs/animate/animate.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","path":"libs/dplayer/DPlayer.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitment/gitment.js","path":"libs/gitment/gitment.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","path":"libs/jquery/jquery-2.2.0.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/valine/Valine.min.js","path":"libs/valine/Valine.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/0.jpg","path":"medias/banner/0.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/0.jpg","path":"medias/featureimages/0.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/1.jpg","path":"medias/featureimages/1.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/10.jpg","path":"medias/featureimages/10.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/11.jpg","path":"medias/featureimages/11.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/14.jpg","path":"medias/featureimages/14.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/13.jpg","path":"medias/featureimages/13.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/12.jpg","path":"medias/featureimages/12.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/18.jpg","path":"medias/featureimages/18.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/17.jpg","path":"medias/featureimages/17.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/19.jpg","path":"medias/featureimages/19.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/20.jpg","path":"medias/featureimages/20.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/3.jpg","path":"medias/featureimages/3.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/4.jpg","path":"medias/featureimages/4.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/featureimages/6.jpg","path":"medias/featureimages/6.jpg","modified":0,"renderable":1},{"_id":"source/notes/Bigdata.assets/mapreduce&yarn的工作机制----吸星大法-5821159.png","path":"notes/Bigdata.assets/mapreduce&yarn的工作机制----吸星大法-5821159.png","modified":0,"renderable":0},{"_id":"source/notes/Java.assets/QQ20200314-123059@2x-4161442.png","path":"notes/Java.assets/QQ20200314-123059@2x-4161442.png","modified":0,"renderable":0},{"_id":"themes/matery/source/medias/featureimages/9.jpg","path":"medias/featureimages/9.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","path":"libs/awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","path":"libs/gitalk/gitalk.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","path":"libs/lightGallery/css/lightgallery.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","path":"libs/lightGallery/fonts/lg.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","path":"libs/lightGallery/fonts/lg.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","path":"libs/lightGallery/fonts/lg.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","path":"libs/lightGallery/img/loading.gif","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","path":"libs/lightGallery/img/video-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","path":"libs/lightGallery/fonts/lg.woff","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","path":"libs/lightGallery/img/vimeo-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","path":"libs/lightGallery/img/youtube-play.png","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/css/share.min.css","path":"libs/share/css/share.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","path":"libs/share/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","path":"libs/share/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","path":"libs/share/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","path":"libs/share/js/jquery.share.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","path":"libs/share/js/social-share.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","path":"libs/materialize/materialize.min.css","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","path":"libs/materialize/materialize.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/valine/av-min.js","path":"libs/valine/av-min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/1.jpg","path":"medias/banner/1.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/2.jpg","path":"medias/banner/2.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/3.jpg","path":"medias/banner/3.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/5.jpg","path":"medias/banner/5.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/6.jpg","path":"medias/banner/6.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","path":"libs/awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","path":"libs/lightGallery/js/lightgallery-all.min.js","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","path":"libs/share/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"source/notes/img/kafka架构.png","path":"notes/img/kafka架构.png","modified":0,"renderable":0},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","path":"libs/awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","path":"libs/awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"source/notes/Java.assets/image-20200309203737822.png","path":"notes/Java.assets/image-20200309203737822.png","modified":0,"renderable":0},{"_id":"source/notes/img/普通拷贝.png","path":"notes/img/普通拷贝.png","modified":0,"renderable":0},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","path":"libs/awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/matery/source/medias/banner/4.jpg","path":"medias/banner/4.jpg","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","path":"libs/awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","path":"libs/awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"source/notes/Java.assets/image-20200309214325839.png","path":"notes/Java.assets/image-20200309214325839.png","modified":0,"renderable":0},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","path":"libs/echarts/echarts.min.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/404.md","hash":"6e12eb0f1ff042b3de34c89bd87739dd0e521695","modified":1584532336000},{"_id":"source/.DS_Store","hash":"c592d62692e04ccc4f328c218824e70fd0424bfa","modified":1586936167619},{"_id":"themes/matery/.gitignore","hash":"eaa3d84cb77d92a21b111fd1e37f53edc1ff9de0","modified":1585745692000},{"_id":"themes/matery/README.md","hash":"d07e122e05c7c78991132b1e6ad39638adf00749","modified":1585745692000},{"_id":"themes/matery/.DS_Store","hash":"61d4653525ee800306d888d998f91174144e6d64","modified":1584602821000},{"_id":"themes/matery/LICENSE","hash":"7df059597099bb7dcf25d2a9aedfaf4465f72d8d","modified":1585745692000},{"_id":"themes/matery/README_CN.md","hash":"74be780ca50b0e31abf95786cd54b57ff4679b82","modified":1585745692000},{"_id":"themes/matery/_config.yml","hash":"ea7b8c642fe3317424c2ae98a220ccf4f194855e","modified":1585745692000},{"_id":"source/_data/musics.json","hash":"46588a16b735cfb95b8083e39e2b9f6dec517dcb","modified":1584593486000},{"_id":"source/_data/friends.json","hash":"2b4d18d300da957dd5750ac6567d86139ff8fae4","modified":1584593486000},{"_id":"source/_posts/.DS_Store","hash":"48e72c58c6bbb67b2a47ed53f04a42393748623e","modified":1586151456000},{"_id":"source/_posts/Go插件工具安装问题.md","hash":"b78159810f3d46ecc008dfcb857d55a098aa0180","modified":1586151330000},{"_id":"source/_posts/hello-world.md","hash":"63a86441b2092fb816b8cedd39516d50dcd03d6f","modified":1584593486000},{"_id":"source/_posts/SSL.md","hash":"cb18b9129faf11f59f57ef19707b4568cdd9bb08","modified":1586056933000},{"_id":"source/_posts/大数据面试题.md","hash":"7a18bf89e075a192e7b8934133fc59c347b5c6c1","modified":1584532336000},{"_id":"source/_posts/手撕Spark之WordCount RDD执行流程.md","hash":"82b95d51e11911c056f77a9d4c42152f0b7f9cec","modified":1584532336000},{"_id":"source/_posts/自建CA证书认证.md","hash":"8920e2f8d1181485fca9cfe51a7712d948c048e7","modified":1586056875000},{"_id":"source/categories/index.md","hash":"9758f1d8d7131ee10e4b1e3004ce298760c4be5c","modified":1584593486000},{"_id":"source/friends/index.md","hash":"f447cb37394634a9eb3fd0e57a81242c7b3529ff","modified":1584593486000},{"_id":"source/about/index.md","hash":"a8b3286480991942a0e608f5c83651e91fe292dc","modified":1585905781000},{"_id":"source/about/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1585053071000},{"_id":"source/notes/.DS_Store","hash":"02f8f60a56e873971513b68dfa99b43e0149fd63","modified":1586056796000},{"_id":"source/notes/Bigdata.md","hash":"b5c20969e26995e73fa74ab067c090661140cfb2","modified":1585821184000},{"_id":"source/notes/Docker.md","hash":"5b76d0cb91f5564b4b8db2405a47c39ab6544e5f","modified":1584532336000},{"_id":"source/notes/Flink-Trouble.md","hash":"f181c4efe5d722f88a7697fc5a0523da23b44d91","modified":1584532336000},{"_id":"source/notes/Flink.md","hash":"da1753acb3692cd69c06eb63aee20d1414463626","modified":1584532336000},{"_id":"source/notes/Git&GitHub.md","hash":"b948edcb09a8f5ffd65b12ab8d1b1e337e7708d8","modified":1585758243000},{"_id":"source/notes/Golang.md","hash":"16db0686e11b5f8364517c65b7e0e41c557132d3","modified":1586751983252},{"_id":"source/notes/Hive.md","hash":"f138b5ced327157702a11685c49e896bc369a8a3","modified":1584532336000},{"_id":"source/notes/Kafka.md","hash":"edeb9a607de62b7659665945f9b5aa98852c7d65","modified":1584532336000},{"_id":"source/notes/Linux.md","hash":"28d3cda8809bcdf22e9cfd1991c1b898935c0d1e","modified":1584532336000},{"_id":"source/notes/Redis.md","hash":"61d1a50da3da768c488ee42e7383ef63906f4749","modified":1585730569000},{"_id":"source/notes/Scala.md","hash":"7846d29be76f40f7c820d5bb27c6722202db6f72","modified":1584532336000},{"_id":"source/notes/Spark.md","hash":"83c02049edad7c794fbb7d0ecb07dea360e1b76e","modified":1584532336000},{"_id":"source/notes/index.md","hash":"0526331665f8ab635e8dad4f595aa795ed4a0132","modified":1585909451000},{"_id":"source/tags/index.md","hash":"5a056cf0f7a89b20cfffae3546e9b80e89095056","modified":1584593486000},{"_id":"themes/matery/languages/zh-CN.yml","hash":"db4b71662d408255eebd633fa3ded8d039122df3","modified":1585745692000},{"_id":"themes/matery/languages/default.yml","hash":"2c4d4e72f0fb3431260643dcb85af11655fabe13","modified":1585745692000},{"_id":"themes/matery/layout/about.ejs","hash":"e9c48455a86aa3faf37de8cc8b860d465c0de2dd","modified":1585745692000},{"_id":"themes/matery/layout/categories.ejs","hash":"8e54665cc25d7c333da7d9f312987190be6215da","modified":1585745692000},{"_id":"themes/matery/layout/archive.ejs","hash":"c8459660e87a0a07a6e007a99a2303b142bb7744","modified":1585745692000},{"_id":"themes/matery/layout/category.ejs","hash":"95176564ea32e65ddc9fdbe9074332239d6a1305","modified":1585745692000},{"_id":"themes/matery/layout/friends.ejs","hash":"89c47cf1eb2cf1feb8a8d06f4eb7c76b713f79c0","modified":1585745692000},{"_id":"themes/matery/layout/index.ejs","hash":"489f2fe7e4171613504f58e7e0462d81d2f7f546","modified":1585745692000},{"_id":"themes/matery/layout/.DS_Store","hash":"c65c9d1aa3e98324aaca09da74ae56a88212485c","modified":1584598009000},{"_id":"themes/matery/layout/layout.ejs","hash":"94a6b3764faaf85ae0c71dc0fa9fdf80da26b3e5","modified":1585745692000},{"_id":"themes/matery/layout/post.ejs","hash":"f9662a96d0f497a3b2731472b8ad871c7cbdf13a","modified":1585745692000},{"_id":"themes/matery/layout/tag.ejs","hash":"4305eeeb3434c24ba2493fa08d1f1bd9f2efa9aa","modified":1585745692000},{"_id":"themes/matery/layout/tags.ejs","hash":"cf9517aa6a0111355121f44615d6923e312283c7","modified":1585745692000},{"_id":"themes/matery/source/.DS_Store","hash":"43907e13c4e0262600c2a3bf0ea779f5946943be","modified":1584612343000},{"_id":"themes/matery/source/favicon.png","hash":"fc9a1d2894e2a302646a177af15cf078a6da70b9","modified":1585745692000},{"_id":"source/notes/Java.md","hash":"16e598937b6347c888838ba356b19c26f000c97c","modified":1585909620000},{"_id":"source/_posts/Go插件工具安装问题.assets/QQ20200406-095236@2x-6150876.png","hash":"928c9e83b9bbc422626c6d10e4cc32be98d2ec79","modified":1586137960000},{"_id":"source/_posts/Go插件工具安装问题.assets/QQ20200406-095236@2x.png","hash":"928c9e83b9bbc422626c6d10e4cc32be98d2ec79","modified":1586137960000},{"_id":"source/notes/Git&GitHub.assets/QQ20200318-211942@2x.png","hash":"79e9dd32dc1662a34707fe8412e48da3b99db9a5","modified":1585749133000},{"_id":"source/notes/Java.assets/Java线程内存模型JMM2.png","hash":"152c23a582941ee311a0ccb948f9d5103fc645fd","modified":1574941076000},{"_id":"themes/matery/layout/_partial/back-top.ejs","hash":"8c91d2088c9bb323246b054d4940bde6cead6828","modified":1585745692000},{"_id":"themes/matery/layout/_partial/bg-cover-content.ejs","hash":"2d9a44f6fbed4d117bbc403095d9a810cb05303c","modified":1585745692000},{"_id":"themes/matery/layout/_partial/bg-cover.ejs","hash":"02191109712f61c0e487b8f0b8466597181a9004","modified":1585745692000},{"_id":"themes/matery/layout/_partial/disqus.ejs","hash":"a0f53d1a9b579d52e52ccad8c6e330bf3b89547e","modified":1585745692000},{"_id":"themes/matery/layout/_partial/footer.ejs","hash":"4cc761891333f5e8ac6b6bf48fc2e87c98d85e6f","modified":1585745692000},{"_id":"themes/matery/layout/_partial/gitalk.ejs","hash":"e4c5bf28ddc29519eee8debe79cce45bf279adeb","modified":1585745692000},{"_id":"themes/matery/layout/_partial/github-link.ejs","hash":"3aeb581bd78ab8e15b858e4c44c03bcf92f20b9e","modified":1585745692000},{"_id":"themes/matery/layout/_partial/google-analytics.ejs","hash":"5f4992205617da5f8cc5863c62b5ec46e414e2fb","modified":1585745692000},{"_id":"themes/matery/layout/_partial/gitment.ejs","hash":"0abfb51dc80ad063fb2118bee28de6bb8d99ed4e","modified":1585745692000},{"_id":"themes/matery/layout/_partial/head.ejs","hash":"1f337fe1343f87fc958eded799a9ac93fc194e87","modified":1585745692000},{"_id":"themes/matery/layout/_partial/header.ejs","hash":"0f43d6593936fef1cc5703572dff6d0c41b60642","modified":1585745692000},{"_id":"themes/matery/layout/_partial/index-cover.ejs","hash":"6583c00323d891a03343b6a621a0484a68d74f8a","modified":1585745692000},{"_id":"themes/matery/layout/_partial/livere.ejs","hash":"9c3401b42ea7f26410a5593bae93ada7e57b43be","modified":1585745692000},{"_id":"themes/matery/layout/_partial/mobile-nav.ejs","hash":"b70a2d40677d64d6b56fc51ac1331ad3a50e777c","modified":1585745692000},{"_id":"themes/matery/layout/_partial/navigation.ejs","hash":"20216e7ad6b48d4a4f8d11d6881e667e5186820f","modified":1585745692000},{"_id":"themes/matery/layout/_partial/paging.ejs","hash":"68a24cad2b2049c4dc3a250aa30bf4256f9e50cb","modified":1585745692000},{"_id":"themes/matery/layout/_partial/post-cover.ejs","hash":"5b423384b9c0fe77acc4247a8a85304022e5bd2a","modified":1585745692000},{"_id":"themes/matery/layout/_partial/post-detail-toc.ejs","hash":"b7320ccb822f9969c58401a0bc946a8a7a1fea9c","modified":1585745692000},{"_id":"themes/matery/layout/_partial/post-detail.ejs","hash":"0fe9b13b06cb64123ddbf7ad48cf5bb3dab01ea4","modified":1585745692000},{"_id":"themes/matery/layout/_partial/post-statis.ejs","hash":"2b2fe8e8e94e65c52a4dbd454168e9b9df6baf10","modified":1585745692000},{"_id":"themes/matery/layout/_partial/prev-next.ejs","hash":"3f73f077b05b6bf41150b00f43870a41d3fa390f","modified":1585745692000},{"_id":"themes/matery/layout/_partial/reward.ejs","hash":"3dff4f6a73973b0b32f40604244255f3c2a5bb78","modified":1585745692000},{"_id":"themes/matery/layout/_partial/search.ejs","hash":"942609b9240d5c8c09b24562fc8fb31eabe1cae4","modified":1585745692000},{"_id":"themes/matery/layout/_partial/social-link.ejs","hash":"62e10bf4577946190e9c31dcdc2799a4ad1d00dd","modified":1585745692000},{"_id":"themes/matery/layout/_partial/share.ejs","hash":"34f8e4250bb66012026aa50686a7c89a0414ca1b","modified":1585745692000},{"_id":"themes/matery/layout/_partial/valine.ejs","hash":"90527186fc8ed906eb1f20b59bc7f86caab9087b","modified":1585745692000},{"_id":"themes/matery/layout/_widget/category-cloud.ejs","hash":"a5a10d6fa66a389d0253d7a52e0a646af6e8e9be","modified":1585745692000},{"_id":"themes/matery/layout/_widget/category-radar.ejs","hash":"f5561dd7d53d68897a33090bf677719213459b19","modified":1585745692000},{"_id":"themes/matery/layout/_widget/dream.ejs","hash":"684450f0b42f89ab70370c5248b34e55b7adf6fc","modified":1585745692000},{"_id":"themes/matery/layout/_widget/music.ejs","hash":"8eafddbd73fed80e85c66d49837c1a241b087258","modified":1585745692000},{"_id":"themes/matery/layout/_widget/my-gallery.ejs","hash":"f81eb2891bea326908057029e2a063001371ba9b","modified":1585745692000},{"_id":"themes/matery/layout/_widget/my-projects.ejs","hash":"b9bf70ec5d97b0e14bb1b4f60f92db7680be5949","modified":1585745692000},{"_id":"themes/matery/layout/_widget/my-skills.ejs","hash":"bd0edf8dad95b2255890d59fb6d6ed6f2eab9c2f","modified":1585745692000},{"_id":"themes/matery/layout/_widget/person-resume.ejs","hash":"812f39e5d2233d0d3c28b192f78478072c3e4f9c","modified":1585745692000},{"_id":"themes/matery/layout/_widget/post-calendar.ejs","hash":"0b0a3eb6af29bf0d55d535958c44b01c0f18d10d","modified":1585745692000},{"_id":"themes/matery/layout/_widget/post-charts.ejs","hash":"af0604623db37ef800bb7ad48028d18d99efbbc3","modified":1585745692000},{"_id":"themes/matery/layout/_widget/recommend.ejs","hash":"babaa0cb32146870785449c70748721235e4eff0","modified":1585745692000},{"_id":"themes/matery/layout/_widget/tag-wordcloud.ejs","hash":"cb7a0151cd20e90351e151c22bca9d4c3112f234","modified":1585745692000},{"_id":"themes/matery/layout/_widget/tag-cloud.ejs","hash":"a3725f0e3a405acb595b04630a27765b537fb580","modified":1585745692000},{"_id":"themes/matery/layout/_widget/video.ejs","hash":"bda810cc135b52f834f1c1ccf52defccacace714","modified":1585745692000},{"_id":"themes/matery/source/css/gitment.css","hash":"2bd15cc17dca35ac3ecc0acf167a23a1dd362acd","modified":1585745692000},{"_id":"themes/matery/source/css/my-gitalk.css","hash":"eeda46a83d0db1cc239a9cd27d544faf663f9883","modified":1585745692000},{"_id":"themes/matery/source/css/matery.css","hash":"d136162e907de9ff3ba170dfbea220b1e688e593","modified":1585745692000},{"_id":"themes/matery/source/js/matery.js","hash":"92f07106944f5ef7cd72e84bb3534513d00eebe1","modified":1585745692000},{"_id":"themes/matery/source/css/my.css","hash":"3d3ce7c84fce447b3531432537b79117b08b8818","modified":1585745692000},{"_id":"themes/matery/source/js/search.js","hash":"499e11786efbb04815b54a1de317cc8606a37555","modified":1585745692000},{"_id":"themes/matery/source/libs/.DS_Store","hash":"3f3af900a25b1dffdbabc54702b837c114199ba4","modified":1584602933000},{"_id":"themes/matery/source/medias/avatar.jpg","hash":"b7f8ca0c682f95d93f002c845aafbcb508ec2b0f","modified":1585745692000},{"_id":"themes/matery/source/medias/.DS_Store","hash":"6e4c55ff5d134f6fae0c9199961e9409d02e9f12","modified":1584611927000},{"_id":"themes/matery/source/medias/logo.png","hash":"fc9a1d2894e2a302646a177af15cf078a6da70b9","modified":1585745692000},{"_id":"source/_posts/Go插件工具安装问题.assets/QQ20200406-101042@2x-6150888.png","hash":"a2a49f8360206cae7d34b13a689bef779f9760ce","modified":1586139044000},{"_id":"source/_posts/Go插件工具安装问题.assets/QQ20200406-101042@2x.png","hash":"a2a49f8360206cae7d34b13a689bef779f9760ce","modified":1586139044000},{"_id":"source/_posts/Go插件工具安装问题.assets/QQ20200406-101332@2x-6150899.png","hash":"0e13e8c5efd9af4be77128250c45f50834611e03","modified":1586139214000},{"_id":"source/_posts/Go插件工具安装问题.assets/QQ20200406-101332@2x.png","hash":"0e13e8c5efd9af4be77128250c45f50834611e03","modified":1586139214000},{"_id":"source/notes/Bigdata.assets/mapreduce原理全剖析--段氏六脉神剑.png","hash":"a9af5f4e4c075e87077009c083c4bde496d9b5d2","modified":1571191034000},{"_id":"source/notes/Java.assets/QQ20200314-123059@2x-4161427.png","hash":"c831975cfc442cc380f6e769cd79ce7a026a77ab","modified":1584160263000},{"_id":"source/notes/Java.assets/QQ20200314-123059@2x.png","hash":"c831975cfc442cc380f6e769cd79ce7a026a77ab","modified":1584160263000},{"_id":"source/notes/Java.assets/QQ20200314-123059@2x-4161454.png","hash":"c831975cfc442cc380f6e769cd79ce7a026a77ab","modified":1584160263000},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.css","hash":"07372a2ba507388d0fed166d761b1c2c2a659dce","modified":1585745692000},{"_id":"themes/matery/source/libs/aos/aos.js","hash":"02bfb40b0c4b6e9b0b4081218357145cbb327d74","modified":1585745692000},{"_id":"themes/matery/source/libs/aplayer/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1585745692000},{"_id":"themes/matery/source/libs/awesome/.DS_Store","hash":"f373e7b9b6d3b211049d1fdca9ee91d900953168","modified":1584602900000},{"_id":"themes/matery/source/libs/background/canvas-nest.js","hash":"65333d0dbb9c1173a1b13031b230161fc42c8b2f","modified":1585745692000},{"_id":"themes/matery/source/libs/cryptojs/crypto-js.min.js","hash":"5989527a378b55011a59522f41eeb3981518325c","modified":1585745692000},{"_id":"themes/matery/source/libs/background/ribbon-dynamic.js","hash":"052b80c29e6bc585aa28d4504b743bdbac220a88","modified":1585745692000},{"_id":"themes/matery/source/libs/background/ribbon-refresh.min.js","hash":"6d98692b2cad8c746a562db18b170b35c24402f4","modified":1585745692000},{"_id":"themes/matery/source/libs/background/ribbon.min.js","hash":"6a99d494c030388f96f6086a7aaa0f03f3fe532e","modified":1585745692000},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.css","hash":"f7d19655f873b813ffba5d1a17145c91f82631b8","modified":1585745692000},{"_id":"themes/matery/source/libs/gitalk/gitalk.css","hash":"3aac1db83b0135c521187254ff302d125cc30706","modified":1585745692000},{"_id":"themes/matery/source/libs/gitment/gitment-default.css","hash":"2903c59ee06b965bef32e937bd69f5b0b2190717","modified":1585745692000},{"_id":"themes/matery/source/libs/jqcloud/jqcloud-1.0.4.min.js","hash":"257eaae3020599e4939f50d5008a743827f25b8c","modified":1585745692000},{"_id":"themes/matery/source/libs/jqcloud/jqcloud.css","hash":"20d9f11a19d95c70e27cb922e0d6dccbec4eae89","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/.DS_Store","hash":"8983992a301632f377142eb0de9b7125c7a7c97a","modified":1584602915000},{"_id":"themes/matery/source/libs/others/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1585745692000},{"_id":"themes/matery/source/libs/others/clicklove.js","hash":"6a39b8c683ba5dcd92f70c6ab45d1cfac3213e8e","modified":1585745692000},{"_id":"themes/matery/source/libs/masonry/masonry.pkgd.min.js","hash":"ff940b4ea68368ca0e4d5560cbb79fb147dfc3c5","modified":1585745692000},{"_id":"themes/matery/source/libs/tocbot/tocbot.css","hash":"15601837bf8557c2fd111e4450ed4c8495fd11a0","modified":1585745692000},{"_id":"themes/matery/source/libs/scrollprogress/scrollProgress.min.js","hash":"777ffe5d07e85a14fbe97d846f45ffc0087251cc","modified":1585745692000},{"_id":"themes/matery/source/libs/tocbot/tocbot.min.js","hash":"5ec27317f0270b8cf6b884c6f12025700b9a565c","modified":1585745692000},{"_id":"themes/matery/source/medias/cover.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/15.jpg","hash":"5cf9fc64d5d74ab6ba69bb8bff580fdc22ba32d0","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/16.jpg","hash":"9cac6b80b0cc8959fc8aabfbd1adcab79ebebfc9","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/2.jpg","hash":"16f1d89cdba4dce935ac0f12599e0fcfda543a93","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/22.jpg","hash":"bf5b59d193e5ca089a7fff034c222bfa2c4dc41f","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/21.jpg","hash":"d70b088850c3565e5b5bb9eb8fe4abe688c964cf","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/23.jpg","hash":"ed5ac9f616d3b99af5188a10b1761884c37e93e5","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/5.jpg","hash":"c3c1f36a1b1886037db604f151f335cd4599e970","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/7.jpg","hash":"a0246a4a560438938489cdd154e35f172b3f31b0","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/8.jpg","hash":"5a46ca4ab4c4ab2101a2af77a31a8878bccc483c","modified":1585745692000},{"_id":"source/notes/Bigdata.assets/mapreduce&yarn的工作机制----吸星大法.png","hash":"5884736f00461bdb42bf677455fe401bd04b793d","modified":1571189795000},{"_id":"themes/matery/source/medias/reward/wechat.png","hash":"fe93385aa92fe328e01c8221a80b039be9e4e140","modified":1585745692000},{"_id":"themes/matery/source/medias/reward/alipay.jpg","hash":"1abc719b95d1b26f1f898e6b0a9b7609146e332f","modified":1585745692000},{"_id":"source/notes/img/零拷贝.png","hash":"b2e42de0f335105eb56aecc3fb6e653d71029ea6","modified":1584532336000},{"_id":"themes/matery/source/libs/aos/aos.css","hash":"191a3705a8f63e589a50a0ff2f2c5559f1a1b6b2","modified":1585745692000},{"_id":"themes/matery/source/libs/animate/animate.min.css","hash":"97afa151569f046b2e01f27c1871646e9cd87caf","modified":1585745692000},{"_id":"themes/matery/source/libs/dplayer/DPlayer.min.js","hash":"c3bad7b265574fab0ae4d45867422ea1cb9d6599","modified":1585745692000},{"_id":"themes/matery/source/libs/gitment/gitment.js","hash":"28c02c45ce568e084cd1041dc493f83f9c6c88c6","modified":1585745692000},{"_id":"themes/matery/source/libs/jquery/jquery-2.2.0.min.js","hash":"5d7e5bbfa540f0e53bd599e4305e1a4e815b5dd1","modified":1585745692000},{"_id":"themes/matery/source/libs/valine/Valine.min.js","hash":"031c1a5640d64ab3b829395ad5a7596b9fb122e6","modified":1585745692000},{"_id":"themes/matery/source/medias/banner/0.jpg","hash":"1f2ec55fe7825475fde2601573bb622f0bf2acba","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/0.jpg","hash":"2066cdda98ad0035071cd4aa7bd696eb078c0b6d","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/1.jpg","hash":"d16e28bd23ea3a63643826dde5eea6b7a9bdda5d","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/10.jpg","hash":"838e704942de076c60894d14e5f280e2724b6f68","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/11.jpg","hash":"9ed45f95b83626e3d91d6c405eb8bfe6fcb9736a","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/14.jpg","hash":"8aeb816faca2d5eaea4cce9e881d6ff87b8c7cf1","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/13.jpg","hash":"66706dfde7d910182c2f1dbadd0e9e917630b8dd","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/12.jpg","hash":"047be4239dd7e0be83243ee6b49a392a61f16b9a","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/18.jpg","hash":"ae23fdfaa59bc57b7ed49e90c5d59e4b68e1eea5","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/17.jpg","hash":"f168ca5b046d10a878a7b0bcfab540e2c4428887","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/19.jpg","hash":"57bc7c804b78b5cceb4eb1f9e51b734b75151b71","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/20.jpg","hash":"8271c4a327632b566ea62f546c083d08a0528e72","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/3.jpg","hash":"5e879652e032f02961a331b598a50b60ebe80a39","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/4.jpg","hash":"4eea5bdb5724ef1ed65790e481eda0d2fb176bf0","modified":1585745692000},{"_id":"themes/matery/source/medias/featureimages/6.jpg","hash":"c63ff64bdd5f6c82da8804c7248fc519d23eaf0b","modified":1585745692000},{"_id":"source/notes/Bigdata.assets/mapreduce&yarn的工作机制----吸星大法-5821159.png","hash":"5884736f00461bdb42bf677455fe401bd04b793d","modified":1571189795000},{"_id":"source/notes/Java.assets/QQ20200314-123059@2x-4161442.png","hash":"c831975cfc442cc380f6e769cd79ce7a026a77ab","modified":1584160263000},{"_id":"themes/matery/source/medias/featureimages/9.jpg","hash":"815c84778b721e3606c2bd7c099c7de7c53251ba","modified":1585745692000},{"_id":"themes/matery/source/libs/awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1585745692000},{"_id":"themes/matery/source/libs/gitalk/gitalk.min.js","hash":"734f56442e62fe55f677e8ccae7f175445667767","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/css/lightgallery.min.css","hash":"1b7227237f9785c66062a4811508916518e4132c","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.svg","hash":"9a732790adc004b22022cc60fd5f77ec4c8e3e5a","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.eot","hash":"54caf05a81e33d7bf04f2e420736ce6f1de5f936","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.ttf","hash":"f6421c0c397311ae09f9257aa58bcd5e9720f493","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/img/loading.gif","hash":"15a76af2739482d8de7354abc6d8dc4fca8d145e","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/img/video-play.png","hash":"fbfdbe06aebf7d0c00da175a4810cf888d128f11","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/fonts/lg.woff","hash":"3048de344dd5cad4624e0127e58eaae4b576f574","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/img/vimeo-play.png","hash":"1142b47de219dddfba2e712cd3189dec0c8b7bee","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/img/youtube-play.png","hash":"39150b45ec5fc03155b7ebeaa44f1829281788e2","modified":1585745692000},{"_id":"themes/matery/source/libs/share/css/share.min.css","hash":"8a778a86f3ce9a042df6be63a9f1039631e351a5","modified":1585745692000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.eot","hash":"00ff749c8e202401190cc98d56087cdda716abe4","modified":1585745692000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.svg","hash":"f0a1b849868a6bf351ff98dc3924a4e7254eb88b","modified":1585745692000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.woff","hash":"2e3fce1dcfbd6e2114e7bfbeaf72d3c62e15a1bd","modified":1585745692000},{"_id":"themes/matery/source/libs/share/js/jquery.share.min.js","hash":"16ce82901ca0e302cf47a35fb10f59009a5e7eb9","modified":1585745692000},{"_id":"themes/matery/source/libs/share/js/social-share.min.js","hash":"4df722bafde2c5d8faaace0d1f894798385a8793","modified":1585745692000},{"_id":"themes/matery/source/libs/materialize/materialize.min.css","hash":"5063376f12a8f554d338b7f1eb69e63a0a6d42aa","modified":1585745692000},{"_id":"themes/matery/source/libs/materialize/materialize.min.js","hash":"c8b4c65651921d888cf5f27430dfe2ad190d35bf","modified":1585745692000},{"_id":"themes/matery/source/libs/valine/av-min.js","hash":"2577e72b52b736d99649f9e95be8976d58563333","modified":1585745692000},{"_id":"themes/matery/source/medias/banner/1.jpg","hash":"c3d5ab183b39a7140941b8375e29498f9d24f343","modified":1585745692000},{"_id":"themes/matery/source/medias/banner/2.jpg","hash":"8d3c8391ff161eec70f66d69e5545a9468cc52ef","modified":1585745692000},{"_id":"themes/matery/source/medias/banner/3.jpg","hash":"d4957ff7cc5e88555cd840f2956ab0561e6f1ccf","modified":1585745692000},{"_id":"themes/matery/source/medias/banner/5.jpg","hash":"4a08deec1dd5b4f1490e8fc23adfb75a0f88b0c4","modified":1585745692000},{"_id":"themes/matery/source/medias/banner/6.jpg","hash":"62e9586a8cec91a160f147c424a3d1d1aea360f9","modified":1585745692000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1585745692000},{"_id":"themes/matery/source/libs/lightGallery/js/lightgallery-all.min.js","hash":"9f5ef4bc8a0a3c746ca4f3c3e6d64493b1a977d8","modified":1585745692000},{"_id":"themes/matery/source/libs/share/fonts/iconfont.ttf","hash":"afd898f59d363887418669520b24d175f966a083","modified":1585745692000},{"_id":"source/notes/img/kafka架构.png","hash":"f0e0406e5310d389605609ce3c3225fa245280a1","modified":1584532336000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1585745692000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1585745692000},{"_id":"source/notes/Java.assets/image-20200309203737822.png","hash":"e1299eb1bdfe2f8d8b85bf24c93aaa5dfc9448ee","modified":1583757457000},{"_id":"source/notes/img/普通拷贝.png","hash":"07b5d706b386ce490c66160d9cf9eb6d6d651b62","modified":1584532336000},{"_id":"themes/matery/source/libs/awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1585745692000},{"_id":"themes/matery/source/medias/banner/4.jpg","hash":"56850c3139cbd72a0eff0c35d8fac32c9c66dd6a","modified":1585745692000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1585745692000},{"_id":"themes/matery/source/libs/awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1585745692000},{"_id":"source/notes/Java.assets/image-20200309214325839.png","hash":"048cd8d3e49f591ed8d5a3c8a66821bd78aaac42","modified":1583761405000},{"_id":"themes/matery/source/libs/echarts/echarts.min.js","hash":"9496f386a0da4601cad22c479cc5543913a4d67f","modified":1585745692000}],"Category":[{"name":"前端","_id":"ck8o1haa1000513s61lvxdac6"},{"name":"Kafka","_id":"ck8o1haa7000a13s6f855bt9p"},{"name":"Linux,Web","_id":"ck8o1haab000h13s6vccdih26"},{"name":"大数据面试题","_id":"ck8o1hab2001013s6zsdhqks3"},{"name":"Spark","_id":"ck8o1hab4001413s6nyslk83x"}],"Data":[{"_id":"musics","data":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}]},{"_id":"friends","data":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}],"Page":[{"title":"404","date":"2020-03-19T05:09:33.000Z","type":"404","layout":"404","description":"Oops～，你来到了没有知识的荒原！ :(","_content":"\n","source":"404.md","raw":"---\ntitle: 404\ndate: \ntype: \"404\"\nlayout: \"404\"\ndescription: \"Oops～，你来到了没有知识的荒原！ :(\"\n---\n\n","updated":"2020-03-18T11:52:16.000Z","path":"404.html","comments":1,"_id":"ck8o1ha8i000013s63ygsgjpn","content":"","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":""},{"title":"categories","date":"2018-10-01T16:47:23.000Z","type":"categories","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-10-02 00:47:23\ntype: \"categories\"\nlayout: \"categories\"\n---\n","updated":"2020-03-19T04:51:26.000Z","path":"categories/index.html","comments":1,"_id":"ck8o1ha9y000213s6b38d8g5l","content":"","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":""},{"title":"friends","date":"2018-12-13T15:43:47.000Z","type":"friends","layout":"friends","_content":"","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2018-12-13 23:43:47\ntype: \"friends\"\nlayout: \"friends\"\n---\n","updated":"2020-03-19T04:51:26.000Z","path":"friends/index.html","comments":1,"_id":"ck8o1haa1000413s6mjvxxxgh","content":"","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":""},{"title":"个人简历","date":"2019-12-25T03:50:00.000Z","type":"about","layout":"post","password":"nihao","message":"请输入访问本文章的密码","_content":"\n<h1 align=\"center\">步连伟</h1>\n<div align=\"center\">18851659629 | bulianwei@gmail.com</div>\n<div align=\"center\">博客：https://blog.csdn.net/branwel | http://bulianwei.github.io </div>\n> ## 技能清单\n\n- 熟悉Hadoop大数据生态体系，能够搭建高可用的Hadoop生态集群\n\n- 熟悉HDFS组成架构、存储原理、数据的读写流程，及优化HDFS工作性能\n\n- 熟悉MapReduce工作机制与运行原理，用Tez替换计算引擎，提升Hive计算查询速度。\n\n- 理解Flink基本架构，能够使用Flink分析处理有界和无界数据流，以事件为驱动达到最低延迟。能够处理以EventTime为时间准则的数据分析，能够使用CEP捕捉数据流里面的综合事件\n\n- 熟悉使用 Spark Core、SparkSql、SparkStreaming处理离线数据、实时数据，理解Spark 任务提交流程，优化Spark处理过程\n\n- 理解HBase核心架构，数据的读写流程、存储机制，理解RowKey的设计原则以及HRegion的热点问题\n\n- 熟悉数据仓库的设计、搭建、表关系的模型构建，使用Hive 实现海量结构化日志的分层管理与查询分析\n\n- 熟悉Kafka消息队列，理解数据的生产、存储、消费过程，能够搭建高吞吐量，易扩展，高可用架构，提高消费能力，实现Exactly-once语义\n\n- 熟悉Redis内存数据库，能搭建Redis高可用集群并编程，优化缓存穿透问题\n\n- 了解常见的Java设计模式和熟悉常用的排序算法，搭建程序结构，优化程序性能\n\n-\t熟练掌握Scala编程，能运用Scala进行Spark RDD，Spark Streaming编程\n\n-\t理解JVM模型，常见的GC垃圾回收器和算法，能够通过调整JVM常用参数配置，优化程序性能解决OOM问题\n\n- 熟悉常用的JUC高并发\n\n-\t熟悉常用的Linux的Shell命令，能在Linux系统下搭建开发环境，及主机性能分析\n\n- 熟悉了解Docker，CDH等大数据部署组件\n\n- 熟悉使用JProfile，MAT对JVM虚拟机进行内存分析和性能调优\n\n- 熟悉了解Golang，熟悉gRPC、Goroutine\n\n- 可以使用Shell和Python编写常用脚本\n\n- 熟练使用Maven，Git，Confluence，GitLab，JIRA等管理开发工具\n\n\n> ## 工作经历\n\n### 2017/12 ~ 2019/6\t\n\n#### 轻图信息技术(北京)有限公司\t\t\t数据治理\t\t\t大数据开发工程师 |项目技术负责人\t\n\n我们公司前身是某运营商大数据研发部门，主要业务是负责国内两个运营商的数仓治理解决方案。\n\n全国31个省每个省的数据通过Flume采集后，一份数据直接入Kafka进行其他计算需要，一份数据直接接入数仓底层HDFS（同时冷冻一份数据）。数仓使用MapReduce、Hive、Spark进行离线数据处理，准实时使用Spark、Flink计算，最后将指标数据放到HBase或者K-V集群，前台将数据转化为接口分配权限，对外销售和大屏展示。\n\n我属于数据治理组，负责对数仓内的数据进行建模、统计分析并将指标数据写到外部系统。主要负责位置业务的数据处理工作，需要将六种数据源的结构化数据进一步格式统一、单位统一、数据校验，然后将这些数据按用户、分钟级别粒度并按照优先级进行提取。将数据提取后进行去超速、去乒乓操作，过滤后的数据写入HDFS并创建Hive表进行数据映射供上层业务调用。同时针对项目进行优化和迭代，使业务代码可以尽量保证不增加资源的情况下以应对数据持续增长的需求。\n\n##### 数仓拓扑结构\n 数仓分为四层:数据原始层（ods）、数据明细层（dwi）、数据服务层（dws）、数据应用层（dal），保证了数据间解耦、分层处理、便于管理。严格按照划分的服务域主题和子主题规范建表，便于后期维护。\n\n- 数据原始层（ods）：加载用户行为日志和业务数据，保持数据原貌\n\n- 数据明细层（dwi）：使用自定义UDF函数对用户行为日志进行解析，并过滤脏数据，对敏感数据加密，对用户重要信息脱敏，对表降维处理\n\n- 数据服务层（dws）：对数据轻度聚合，并将查询频度较高的表联合起来制作宽表，一表多用，解决大部分需求，提高工作效率\n\n- 数据应用层（dal）：对dws层的数据从不同维度聚合，结果写入HBase或者K-V集群\n\n##### 数据治理、优化\n\n- Hive计算引擎由MapReduce引擎改换使用Tez引擎，运行提升速度两倍左右\n- 数仓中通过数据建模理论，对数仓中的数据采用多冗余，低范式构建星型模型，减少关联查询，提高查询效率\n- 合理设置小表阈值，在资源允许的情况下尽量使用MapJoin以避免Shuffle\n- 避免小文件，在Map操作之前合并小文件，在任务结束时合并小文件\n- 使用自研数据一体化平台，从开发、测试、运维环节组织监控项目研发过程，保留中间过程数据方便后期可追溯\n- 使用自研数据一体化平台管理数仓元数据，血缘关系地图和数据资产统计\n\n##### 负责项目\n\n- 位置融合集市\n\n  设计分批两段式式及单Job全量与多Job分摊并行的方式对数据进行处理，分摊队列资源利用峰值，平滑队列资源利用率，使原来8:30之前完成的任务可以提前到5:30之前，提高数据处理效率30% ～ 40%。设计中间过程可配置的监控、报警机制，使数据处理过程实现阶段和完成度的透明显示。\n\n- 旅游集市\n\n  修改原基础架构替换计算引擎，将原来Spark+Redis的数据处理过程修改为使用Flink进行Stateful计算，对每个用户近2个小时内的状态数据进行保存更新，简化数据计算流程，使数据计算效率提高10% ～ 20%左右。\n\n- 商业地产集市\n\n  设计集市核心商圈人员归属算法，圈定固定范围商圈用户，用于指标统计运算。研发HQL脚本通用模版，固化通用性配置，使开发人员只注重业务逻辑开发，省去繁琐过程，使两人开发的工作量一个人就可以完成。研发脚本逻辑测试工具，三人一个项目减少为两人一个项目，提高测试效率。\n\n- 掌合天下数仓\n\n  负责订单、用户集市的设计和开发。Azkaban调度维护，并且与甲方进行数据核对，针对问题数据进行问题排查。\n\n### 2016/3 ~ 2017/10\n\n#### 北京中科弘睿科技有限公司\t\t\t大数据研发\t\t\t\t\t\t大数据开发工程师\n\n公司的数据主要是通过Web的日志数据，APP端的行为数据，埋点数据。使用Flume采集数据存储到HDFS，在数仓对数据进行清洗、脱敏和统计分析，最后将指标数据存入MySQL数据库，供前台展示。\n\n我是属于数据分析组，主要负责用Hive、Spark对数据进行清洗、脱敏和统计分析。清洗脱敏后的数据按照不同纬度进行数据建模，然后根据不同业务需求对数据进行多维指标统计。并将最后生成的指标数据放到MySQL供其他组同事进行展示使用。同时对一些临时项目需求进行报表统计。\n\n- 电子商城离线分析系统\n对数仓进行重新构造，按照业务进行集市划分，专人开发测试，针对大段HQL进行分拆，分表加分区。优化后提升代码效率10% ～ 20%，同时制定HQL开发标准，制作代码模版和数据测试流程。\n\n- 驾车习性系统\n设计路线契合度算法，使行车轨迹符合率达到85%以上。\n\n\n### 2015/3 ~ 2016/1\n\n#### 联想（北京）有限公司\t\tE&T\t\t移动互联产品开发助理\n\n- 移动互联网应用项目\n\n  开发比赛软件项目代码（Android），担任过两届全国8个省省赛的软件技术支持和评委，国赛的软件支持工作。撰写Android开发教材数据存储模块\n\n\n\n> ## 教育背景\n\n- 2012.9 ～ 2015.7\t\t山东劳动职业技术学院\t大专\t软件工程\t\n\n\n\n> ## 其他\n\n- 荣誉/奖项：移动互联网全国软件开发二等奖\n","source":"about/index.md","raw":"---\ntitle:  个人简历\ndate: 2019-12-25 11:50:00\ntype: about\nlayout: post\npassword: nihao\nmessage: 请输入访问本文章的密码\n---\n\n<h1 align=\"center\">步连伟</h1>\n<div align=\"center\">18851659629 | bulianwei@gmail.com</div>\n<div align=\"center\">博客：https://blog.csdn.net/branwel | http://bulianwei.github.io </div>\n> ## 技能清单\n\n- 熟悉Hadoop大数据生态体系，能够搭建高可用的Hadoop生态集群\n\n- 熟悉HDFS组成架构、存储原理、数据的读写流程，及优化HDFS工作性能\n\n- 熟悉MapReduce工作机制与运行原理，用Tez替换计算引擎，提升Hive计算查询速度。\n\n- 理解Flink基本架构，能够使用Flink分析处理有界和无界数据流，以事件为驱动达到最低延迟。能够处理以EventTime为时间准则的数据分析，能够使用CEP捕捉数据流里面的综合事件\n\n- 熟悉使用 Spark Core、SparkSql、SparkStreaming处理离线数据、实时数据，理解Spark 任务提交流程，优化Spark处理过程\n\n- 理解HBase核心架构，数据的读写流程、存储机制，理解RowKey的设计原则以及HRegion的热点问题\n\n- 熟悉数据仓库的设计、搭建、表关系的模型构建，使用Hive 实现海量结构化日志的分层管理与查询分析\n\n- 熟悉Kafka消息队列，理解数据的生产、存储、消费过程，能够搭建高吞吐量，易扩展，高可用架构，提高消费能力，实现Exactly-once语义\n\n- 熟悉Redis内存数据库，能搭建Redis高可用集群并编程，优化缓存穿透问题\n\n- 了解常见的Java设计模式和熟悉常用的排序算法，搭建程序结构，优化程序性能\n\n-\t熟练掌握Scala编程，能运用Scala进行Spark RDD，Spark Streaming编程\n\n-\t理解JVM模型，常见的GC垃圾回收器和算法，能够通过调整JVM常用参数配置，优化程序性能解决OOM问题\n\n- 熟悉常用的JUC高并发\n\n-\t熟悉常用的Linux的Shell命令，能在Linux系统下搭建开发环境，及主机性能分析\n\n- 熟悉了解Docker，CDH等大数据部署组件\n\n- 熟悉使用JProfile，MAT对JVM虚拟机进行内存分析和性能调优\n\n- 熟悉了解Golang，熟悉gRPC、Goroutine\n\n- 可以使用Shell和Python编写常用脚本\n\n- 熟练使用Maven，Git，Confluence，GitLab，JIRA等管理开发工具\n\n\n> ## 工作经历\n\n### 2017/12 ~ 2019/6\t\n\n#### 轻图信息技术(北京)有限公司\t\t\t数据治理\t\t\t大数据开发工程师 |项目技术负责人\t\n\n我们公司前身是某运营商大数据研发部门，主要业务是负责国内两个运营商的数仓治理解决方案。\n\n全国31个省每个省的数据通过Flume采集后，一份数据直接入Kafka进行其他计算需要，一份数据直接接入数仓底层HDFS（同时冷冻一份数据）。数仓使用MapReduce、Hive、Spark进行离线数据处理，准实时使用Spark、Flink计算，最后将指标数据放到HBase或者K-V集群，前台将数据转化为接口分配权限，对外销售和大屏展示。\n\n我属于数据治理组，负责对数仓内的数据进行建模、统计分析并将指标数据写到外部系统。主要负责位置业务的数据处理工作，需要将六种数据源的结构化数据进一步格式统一、单位统一、数据校验，然后将这些数据按用户、分钟级别粒度并按照优先级进行提取。将数据提取后进行去超速、去乒乓操作，过滤后的数据写入HDFS并创建Hive表进行数据映射供上层业务调用。同时针对项目进行优化和迭代，使业务代码可以尽量保证不增加资源的情况下以应对数据持续增长的需求。\n\n##### 数仓拓扑结构\n 数仓分为四层:数据原始层（ods）、数据明细层（dwi）、数据服务层（dws）、数据应用层（dal），保证了数据间解耦、分层处理、便于管理。严格按照划分的服务域主题和子主题规范建表，便于后期维护。\n\n- 数据原始层（ods）：加载用户行为日志和业务数据，保持数据原貌\n\n- 数据明细层（dwi）：使用自定义UDF函数对用户行为日志进行解析，并过滤脏数据，对敏感数据加密，对用户重要信息脱敏，对表降维处理\n\n- 数据服务层（dws）：对数据轻度聚合，并将查询频度较高的表联合起来制作宽表，一表多用，解决大部分需求，提高工作效率\n\n- 数据应用层（dal）：对dws层的数据从不同维度聚合，结果写入HBase或者K-V集群\n\n##### 数据治理、优化\n\n- Hive计算引擎由MapReduce引擎改换使用Tez引擎，运行提升速度两倍左右\n- 数仓中通过数据建模理论，对数仓中的数据采用多冗余，低范式构建星型模型，减少关联查询，提高查询效率\n- 合理设置小表阈值，在资源允许的情况下尽量使用MapJoin以避免Shuffle\n- 避免小文件，在Map操作之前合并小文件，在任务结束时合并小文件\n- 使用自研数据一体化平台，从开发、测试、运维环节组织监控项目研发过程，保留中间过程数据方便后期可追溯\n- 使用自研数据一体化平台管理数仓元数据，血缘关系地图和数据资产统计\n\n##### 负责项目\n\n- 位置融合集市\n\n  设计分批两段式式及单Job全量与多Job分摊并行的方式对数据进行处理，分摊队列资源利用峰值，平滑队列资源利用率，使原来8:30之前完成的任务可以提前到5:30之前，提高数据处理效率30% ～ 40%。设计中间过程可配置的监控、报警机制，使数据处理过程实现阶段和完成度的透明显示。\n\n- 旅游集市\n\n  修改原基础架构替换计算引擎，将原来Spark+Redis的数据处理过程修改为使用Flink进行Stateful计算，对每个用户近2个小时内的状态数据进行保存更新，简化数据计算流程，使数据计算效率提高10% ～ 20%左右。\n\n- 商业地产集市\n\n  设计集市核心商圈人员归属算法，圈定固定范围商圈用户，用于指标统计运算。研发HQL脚本通用模版，固化通用性配置，使开发人员只注重业务逻辑开发，省去繁琐过程，使两人开发的工作量一个人就可以完成。研发脚本逻辑测试工具，三人一个项目减少为两人一个项目，提高测试效率。\n\n- 掌合天下数仓\n\n  负责订单、用户集市的设计和开发。Azkaban调度维护，并且与甲方进行数据核对，针对问题数据进行问题排查。\n\n### 2016/3 ~ 2017/10\n\n#### 北京中科弘睿科技有限公司\t\t\t大数据研发\t\t\t\t\t\t大数据开发工程师\n\n公司的数据主要是通过Web的日志数据，APP端的行为数据，埋点数据。使用Flume采集数据存储到HDFS，在数仓对数据进行清洗、脱敏和统计分析，最后将指标数据存入MySQL数据库，供前台展示。\n\n我是属于数据分析组，主要负责用Hive、Spark对数据进行清洗、脱敏和统计分析。清洗脱敏后的数据按照不同纬度进行数据建模，然后根据不同业务需求对数据进行多维指标统计。并将最后生成的指标数据放到MySQL供其他组同事进行展示使用。同时对一些临时项目需求进行报表统计。\n\n- 电子商城离线分析系统\n对数仓进行重新构造，按照业务进行集市划分，专人开发测试，针对大段HQL进行分拆，分表加分区。优化后提升代码效率10% ～ 20%，同时制定HQL开发标准，制作代码模版和数据测试流程。\n\n- 驾车习性系统\n设计路线契合度算法，使行车轨迹符合率达到85%以上。\n\n\n### 2015/3 ~ 2016/1\n\n#### 联想（北京）有限公司\t\tE&T\t\t移动互联产品开发助理\n\n- 移动互联网应用项目\n\n  开发比赛软件项目代码（Android），担任过两届全国8个省省赛的软件技术支持和评委，国赛的软件支持工作。撰写Android开发教材数据存储模块\n\n\n\n> ## 教育背景\n\n- 2012.9 ～ 2015.7\t\t山东劳动职业技术学院\t大专\t软件工程\t\n\n\n\n> ## 其他\n\n- 荣誉/奖项：移动互联网全国软件开发二等奖\n","updated":"2020-04-03T09:23:01.000Z","path":"about/index.html","comments":1,"_id":"ck8o1haa5000813s6f28k2s4i","content":"<div id=\"hexo-blog-encrypt\" data-wpm=\"Oh, this is an invalid password. Check and try again, please.\" data-whm=\"OOPS, these decrypted content may changed, but you can still have a look.\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" id=\"hbePass\" placeholder=\"\" />\n    <label for=\"hbePass\">请输入访问本文章的密码</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n  <script id=\"hbeData\" type=\"hbeData\" data-hmacdigest=\"f8f06247c299b24ffcc59547ecb1e66200a50d11c1928fe64371fd1a7014f802\">589649e44508d99ffe98b80afd6055bbbf9ad90bac9e251074fab76c3d6d499f86d5f7c719ce32af3e5b1766c48304a01311a46bb08784f208807729e08eacf45d5c7d68f217cd7a54f1d7d0c6770c5c16a09b1f665a18a4151d59dbdf5dc99c89af4794bb10120ee74e774d00ab161d524be7fed0904823682d949145939ededa814b2d27959a64de9428261f53f666745e39da06f79b15a85a3da1de0d5ca69d95aae65cebb6194dfe07525cf24fc302bd07dacc2ba8b9fa5930f52e31373c87381df97f2cfb4c9dc94db2efa8e281703a00f52300752059e55d8531646c0baec17310b751e449868aaedad1f17d358cc34050abfbc662842eeadacc3bbae6837ea9c79ac6ceb475fc20ddc1daf29049bbac8b5d0f2e740cc4a22c1491b0a6555af9a319ea34299d76d275fe85fc503d0c08f75538357b43ec7e029efddcb126c4bbaccc472229ab876dd978c27385e89ff5549c2f520193f5a51c4139f87ecf8a516b1d4b26a7470b17a25a04494346bd44f1c18aec286eebbac49354280385ae640d35ef53ebb951f5e9c53c31ad01a23bc468abbd5d35acc4ae52e46ab202a209fed0431d7aa2684859bafb9f6f277ae43b440775e1c2efa9322656b406f9183d300fe018ee1a2f8a6af663133ba53264af18e4674a25620fbded4c08d71716cda4071cf8f5acc3871bd661a2a97d77ddc3b576db13c285afb17aae593f50e0b58caa38a1778e1a9099930a290b489a8446ced1f4fcd6c4ea8a64886991d8214de341337664cb306825f064de150fe5d7ef9f7619fa51d86f95de8009fda3e21f4fbcffeedd74b3ea83bea708323c2fd17fa589ab12bc550cd80d223c7d8fd7403dcc62149862f8165badaa116dac252ef92a094a710e748a3cbf600b3b121196e0aac16e1ecf3c7b6a79c444f9b76234c7ba5faa006b944a70fe6fc95c24e01add4b9bb07ae458be8b180b021e77536e2ad8b044c0544dde76a313091a6e7212cf51591de1ae70d15a4d5380b200d13220ab8dfbe6dafe6ad9455b95993ba7036c316158b6ab3f879a915aff7b0b46fd7a8d9214f6f6c77d1bd144c6ceec137e60db803c92f928fc4ba1655b4db00f9e88cf5e093101b079e5787dc9889e8498a71cbe26e5554be4efd28abc74d4330c1e8466a12b720005cad1f6574cfbc34ec5d5ed83739eb480faecbfc9d687ece18f13234a8f04d381621b113e6974250198c20503cb0eed16245fae1702781ba79b55f8189611b909452d937cb4e498d4673f3f68c342d6729b50f99766270d8c91de8ef761dd1a09c1611bea8cb4daac4d0c4562ea6141e774e75fb0d3cb8959eaa415613ccb50530a16196a0d33a6205adae0498d0e860cdf8ceb3cf7e26577e2356ef333fabef388bd0d532182db91c62d7ac084bb6f588edaded4edffa93a69430380a3cfd217d853fb30571a09babdf41a468d76adb6fbac9442ef42c54baab543a60eb7b38a076d96d8c894b862ab003274a2d2a5d6521f0a86410ba9f6344dde1f2f8c5340e0f7b5fe2547163e3ef6462f754232aed9a5c6476a6fbb74e126887621edceebd41c88671b336c78479e681472dc7426bd3e64e9532b4553a6845a2038330111103afa226d55839bf13e34b7e6f234f1a5dd378ff695716c43b7ded81239d4519e6eae6664242ae957073fcdde7c7cb697ab5d626615a5bc746d54674ce524c94aa608d83e0cdd2eff1a5dc9fcc84f404d1ce72af10701a154fa64e7862d56f31f396199ac2c6ed2bef98cda2d350685a6bcdda7d8fb320ba33e16ac6e48efbad00ef8db48287805ba4c02a1efb7ab0f2aaf8c5c735e6bc1c924f838bde24fd4e612128fa6ce2445d177daf1b41cdd5267bcee6e6bbb1dc70e39f29404a6de194a7d1a580bb2421fb665dc141b67250e5a6455f0a904ee11a1d146f97bdf9d7358f1e821cb8c58cb02173a76948591df0d44a365b34dc206900435bf9e81dd313c33ff88a92a3c9233288606cc30172d6c4ce9508c288bedd63810ee47695aa7d9ea1eec7184f4302b261323e32f6d745e87883298e3e15efac8ea51b3da437f5fafc3fb28d61be76f6195f0fd65d580d8b5719474ca6f7145d6c9f9b246f09b9a7410ff0c2d278d8738b89771d69fccaeb1fc2633b69fd65c6a94df6232ea1cdf27027429cfdbd3a71ecbb5d68d51d6bdf265394fdedb6a4924b99de2b5a5b4d2d0cf49d3429294adbf6818034e213fb56b45777ad9feaa5604f6c615e633da58a9cdf3ba07714446b46824130735863b521f1b2ec2af2855301d867af80c06ad322beacb213872f93008790e19871fa704d6d1603401549f5548674bb8e6f489cdd7ff60b6f1d7de42e677e0c91df6898e7d11c3ba93ffe94c33f641234f05abef4d93df8667847a29193cf5d1eb52d5339e2de893889514d55425ad24b6dd496732cfbd319236d79ce4cd40deeafc7a354c71402db0f537914905b4e0042f2185239d8427770cdf953c72a572cd457eaf719b4b6b586ffc61cd1822c21d6f53ff914a4efbb2a640d1f2943eeca3b40a53c3239e8466d6a3d4c08b1e63c55ec3b45b2c956c642b6d85e528e8345e59865eb1daf15de7ba044b124788769d896f24c6287b5f6d356c7f552a4f3bcbdf7cd86e5d68957e809f7698d4f40f4191138111cf0d88e9fa1a64a2c89253a8a8d212f4b3cd664b1f5940477b6be85483c124b33519db0d83729eb2392253a5129d429eda1e50042b3a03cfa580c7c28432d98d4d3419d459d1f6e633f8a5dcdd123f845ab3f7789fce87a7936a3f194dd857f61f98323bdf2acfa7c44d7acab6e556d53907b036ac77a06f92e493e85989c93382db747d52083e66ab1801dbed24aa9f7db07a14a6897fe6f29e784fc000fe38017afb9c0c5b825ec2021cd5e1d7585b00581361caec836be44764579a7310b7afbf38a2ff60aa7aff8cb4dabefb81a54e838ad3afc81a29eaa749f9c5accc24e6e54b566d33883f562fc28eae98223cbd74d8d369bd11099e449525931c118efd92c0d20d586d158e909b737817c3e2e20d69b7b06b56caf52787cfbce2671f34d2a39fc701a9094442b643c5eea4d69e123ef5afbfeb3d4dae33095c91ecd279e72b4ea5136aacab1f1101c2d34504351cced912d738b6e82ec347b45da8e7eefa58959d7f0f2b111e4d1f6269b84678a38deb7afffa784a9442efde62ce0f276ebbd1dbff3395cfb7bdc6bfab40fbf39d67976b434d8010c51cf9e6a8b65b94513e8ef595db7d36d3fbf1e6e330f933a556f324fa6ff212ceaf3f4ba74d152a4d06a21ab0725327c03540056b3ea8cecea2b49fc5e611b6ff9f69ef75babc38594abb974ff9f34c9867c56238f13fcb72d1a65b97b8473e9469bd223b3de6822994f359acf1630d1c836bb36078e56844ce721605c07c8592fb6eefbcbc9965b82d692aff119c6dd759789c94403f8fd5c8ce184862b6bf6d1e083dc225b2e74ddc1896fb92925f5193345f42eadb50b27b5dd1a482fd1ddcf2bf9c1e5f8d3a9604ed8bb9f9dba06e8c26b0d7d6ae9b3adfd4084cc1836d9acbc567856c8679d150a60ec9cb5b880255059d1e87d0b2a534d6049d0809c364265a6a397236c362ad026ac685df27b05f2140df9eb87081637f98621d7c5fd8d6e9c7164092d09e83760e25b92a2a9947673ec0b3bb5e321d858a5bc2c44791cc7ee87157b1beafaa02cc5193bf27c14f191714f747d0497036777e935bfde8e617b5f9d8d627384b791c44c1bb079a59179adc872ae271cf4858abe430c970fbaa4f8e0f5ca2a26be6353d9009be8cfdd50c46611f35567685e2c0389fa5fd31bcc1c872b81b71fec74a694d2f7adff32f1ab98636821c39749d646430202fd5c170e9f3c33a3db4d8677eecc2dc2c64182c04a90c8a412074d1f37cfec5208af0defa2ae12124f4fbfabcdc976ace3dc2623cc9fcbfb0fca7a300d02c1d9a7eed4c05a3bc995722448f5345c52ed2274eb257d625b010fd1b57a960687ff326aacde6bb129aff73318f06d064170d37775fcb5216f473b35034cb46f74307744d95152307d1e2165c5115d2f3a06c944ab2d9a9b9178e981b1697d7f4eb272147fb3239b48fc341b5ff0184572eb5f8a788ad129e237b9992219cdef442341f17501ecdf52697ebc5d632e2217154ef7bac812ae2cb08063b36333e3e7eb853ec6933c94520bbb28f28131532ff1607e8ef77e7a8760c6c664d48e2217a15f6144667185472966290e2991595c363cf6bb2bd5971e931314ff7fe9d8497c56c18da28e94cb5d01fca9cfa50e75ebd0406a6ec63a7cbae962e5b6c787ba4c248469b567b016dc083dbd9c233927279bd0f553f39288ff11d587c4c217a220076524086d5c7c973859860bd0e8ed02623fb95d363a0275abe49b799431c7f135e5d41b3736aa96109ae2a072c235a5029ca61a5bb95b1074f6342ce5f281c2bb620291e8e8fcd583ea3f3207fa1486f97ee4cb1ec86cb4ff738cd248bc79da6f83797a8ddb7e0bae499e183c14712480286169270b09ffdd3e4557a68ea40141a2e5de246d9ff5a45f70b547ff1a2013fa0f2a170630a67736b070b74465f3d416a498ebeb40a8ec58e08ba586f18f492b5116ecf1589e38ec286509ccfa2f5e8f3d2163ec375596f00eb8733569cfcbd0872aa85b65cdd420702e31b3fec2c184d385140e42b3053e2f10cbdadd8203c9fe2a6077f2eecef76b6fae7bfa8ac38ffd3b4fec85d2ca96b7be742881a6571612706e33842aaba9ef6755448edd7a507eed15953e12df9972791b42295a40b345e17392003b23751c65f7a0d012f1c715f8c7931f19bfb1c5414ea37c218a6ea49fea729536ae22ad8682153d7c1ba37006104074faa7202c6952552be8a81c83c855329909c7c64fde69cacf62250daa1b0faada65a4bd648c56fc3aa21cfae6b3a1c963190ae7d7cd349ce733c9d1c21fa692582f7465c370bf026da7f217de766880a77b395eb0f674eec666470f6dd4463474a215237fc68fdd6ed229c9ff4ec8c2a45d92da9582f44d3d4cf2e9b8a7e71ad6bc00d0b0f830419892556ecc72b5ecb3d5514ed14d96dde8507fcfbdfe9df3b230cc492b2447905b5c99379634adfe610002accceac596aa4a57b63adf1c878173780e930d4ff22c69e7583d71a36ebcc6af937bbbc2f22be91cdcb16d9b49e98b3fbc43a246ca17a9441b74c39fc093a5b39ee917b1776ca6f7cd26317a5d5552e3d99fac9e283db6dae7fe6d8d1b024a3aee702df56fcf3909865cb5196313c0786601153193af793efd87ca42ca300b71e81c024882549af4915777b4a299d217370ead9d2536c3508678cecd39caabaeaf9cf085e7e8c5a918587159a307c829a2326c0946ac7d4d26331b97e597db1b7e56427ea35a7549e599cfaedffc82828683c7e432b23a0f8bf9d4c9c2fe225f7dedb121b3154202375b32847e96d3515f0751a2da695c5529dce30db158cd3a227c66f238398a1a2e15d4717a361bbf498b15362c0be828128d033a5eaa3d6895a59dfaa08a8290914ddf54c28cc4a142f362027432f36eed8957a6fd437ce90ccef5f6ad4c580f485afcea37152737d425e957a6fb422e079e49c455dcb7ab44d1ad6f53fdee1a06af4994b76987668508f7d03e483f40c4af25e7e87fd33facf58e488f0e4fd540d5f817b25a206793e79f674acedd7e2decb3e6ba71bf10f6331f9da363f793d07d6c2d9524e22642746c7467cc9e365ecb19206bd3b61ec49de6d7e2cc564efbfc246b64a1ff4662165b95eb4183acf94ca14534990e43d0306cf3472a89a0583515730d5eef6b7039561ddedfdbe7de278c3c66d9d88007dd5701f99a57e0cdea8534a86c050dc07681271f43853fbd4aa49875ac334731732a9ba3a2501ac3aaaedcfdf33364c4cbda45fc764d06ccffafc7103a47067b878f0f64652bf488adc8953e40f1b324825c5923b2951e4ab94096a0cb3ea0f3905aacf33a42129bfc4f96bd4a795f9c4cbdc05543ca29d87589e7b271a61d2865ea9fb80d97e991442cb0907f8cbb471190bff5743fac96a0a76c850c6877d1fa6d0d253068f217edc3fef24b59fafef8db4bfb60325aa77942cc37b7c2eda6a029f584ceb22e49f68462682937e8ca7833f2616aeafaeaef140d689545d559b9abea3ace6c9f23e46f56bec51103f9a8a9853cfc35652a9c9e6622fedec88cb97e9f267b59fec288368ba6b4ec9e625f40ba29850ca8e840af087601edd1aec32d46e19cceffbb6af6b60deb697442d84b679a8c62e4fbfe3ebe1048479438caaf25d88bb02e6beddd0f80a0f391055895d99fdf5117e7946266b2154242fffb5f8ca459503d570f5a4d21fce12048fbfcdf78dcd1b1c968ba7e782739771f6f94d937da8f1009dba07bde6ea0824458269697c0ba14194b680b4a4090d20eb43d02e165c6f0f39f48711835a543f2936d99ee372f81161e66965b3a235d82f3bf9594fd96b44be9a1a7b47407ea6ab9de3384c583604c107f52aa2d69653c76df2dd5f34ad97327667daed1b56d33f200be972e0a5887c69bfdcc792d5bf794fcf6abe40319af06d36bcb9a91ff245e40eae4bc39307e4d33e13baa860f4ffe59c0c623df7942942e778220cbdb5f54acdb028b5c8696803ff00275b8af43f12e9794847fc975496c3f33e7656bfd3432ea5534cf70830d9f06598eec14a5ecd04fb14de071ae99406950d96bdf0cc21e3d759e79ae0bbfeeb3b17e79b36606d1d3a25cb5bab7cdade1262069803f79d04cead34bd5c3c6b88041dacbed87de54103690f5bdd042733ee37ff870144d4054f39c6b411932187d99a3b11efd47212cb70cbb26cb8da11ceb17f3cd8785e2e226383405067888c59ad0aab87137b1df3990da8d2e3202d21c0e2b24e6869ee6684fe6a712c0e8c0f6a1740d163128fd834b456f612df85ae4aaf4ad938f5f6b808bcf0e076886eab1b6dafbb1b4cf740c5265b1aa6d7abee803b654849f0d7e246dcc8d93edd199a23d8f8039c78932743df0ff1763a1ca7eb6094ae77d9dcf17b1bf42eb3aebf9147e8d3a8bda22b936619781ab6722e5d9772778238b0f158af79161204b88d4d78854186509808e4174a1ac13490c909c61db0b9db1ec97ba5222d958529b128e742acc82f0f1579ea1b640d25ea452c50ef6fddc40dd606a6e567f79b8d28e14185fd2529ee05a476240967bc159a6a03e63fe4e9ea7d2a2bc9c7d4812b2110192b8d84865a603da21320c4bc3bfe6e08bcae7d8dbec04fae2096b40af4882f948c5136e73321d0f98d06be008f24c2500c9444e4c6951f67f080244fdb5a07cdab38f6a93115c242b18329f06b37c23dd45a3da2ff62a0689a92e4eca179d62a779f8e158518c752a1a45b5e687bbeee06f47665b34e120db05709031e3a3ca4578081aba496b5dd52ca01a4890dc6876a7dbabfecf4c1e9cf9798dca03e398a6ce83cd7356a80314bc5603119be445e86c43513b8d805f8d99e1b73b875ada530389b9915f0235feaeaeacec97c8fc20f3c0d63b71fcf0b510faf03c46ea51e165148fed24f2677bb4fedd42f3e3c72d7bc82d56577e46b817a1eea04007a647161e20e3d3f2b55b9b523d62afbc9ee5fbc9f0783250e6b72641ffd321f137676ae228a0afc03e29b84b6da67ce212190aa448d916fa734696a4117a5dab989d0437171540ca6a2e2a2646f2bc916716bd9ec6be0c778a2e6b8c2d3b3c9aeb8574ee49230817222879074b4a7527b8b65dc700327e330a6992ce757bc069c93b36303e5a456b6e87c4575b988ea1fafb60ce49747b4b34ef54686379da25b4e9586471a400168b2c1a5b333db29a17442902bbc15917514bb0c00b7d268959d80746808226f6299f68ff95d663a6c50f9d5bbfe6b90d3801e6b47819f85a58adb2f8ea085c77eeb8f9449a9049e65b78ff17901fcbdf03253dd702938c751d97e7719b3c0716937a19d8ab29c893a38a20c93193c599383d5d65e39a12c391cee501085c15f4f41654431ab2d78dee41c9ab4ad83781eb8ceb9f4df6dad095f9b112a8d1909e8e162a3a83867f5a58072dce3cba0978b0ddf900037e000e2dae5b75d7c1f5677817ded917d574f0357b0c3a0eab3e75063e2678d349c6482a176b4a5b15b4b62c8a09f7f3ee471329a4b7010d38d6f87a900e1f335b349e63b9483d1bb25e6f89d586f54e19f51fcda66c78db9b03db5006f6a1f4e29b2ecb9b4bf9ff2e4a22259123f8fc6c24bc3ad05437c49eb78cf574543efb78a308e08a8880e76b45005aa13b54966ef7c13e313cb5c38d849f02f4b91adc6dfe45cf153c4c123d2e257bf48b75576463bc1234cccaf62ebca631e6e8801f568c2250807e77d93475e35a0792aa878b7e19373b9d0dad22e5f3be0b4a1c584f89446fa03d613f39b63efdb9abca11af60b3220bf54b3febc0b90dfb84ca5f8c8fc6eb7b737029bb8202abfea48b7e4661c3804409b2166faa75f7b5954b73ecc380d60d0e695584e6283d6f0ffd6985a7cf5f06577c73096f41e8616f4d3ae93aabfc63fd160e082549acacc7e9a5088b47acb7598cda2cc4af3e0beb00be297dfa21b520e0f985083049f8d3561cf33614cd9de410a87189d08b0f31a6306b7e827560a463332d28714b314b331cfb172db9a4f710f73308559181b9ca8b6ddb8d8e6f3949059b7bbe48edaf9d2c4d9c66caa338bcab1472a7ebbcfc3eb36f616f030aea2d344d3156dbdecff73b9118faafb1f314a84c8d9e82cc9cfe692f8e98fa662b04a6b2118edbb6c1c8881d5bf604396cc7ea395bad040eed8cfcd6d4c923f58b10bdfef189c8ec5444a796ccf6d12eb8f53b1cfcd01a8e47db24a745501f897752e4c872b2f0d50109a6114e1dad97b9f6cc2725891634eff43fd5ca5a8cf934a94ac0c8531125fb23abd07739fb88f78c08c33e7b5f625e578eebb1f47f96df90985d65db2206f1c683d311178770a225031e6f9a77e0a46756a49daf037b1582fb95abd53de03619572adf219170ecbcf4c50ed1bdbe8d4603b54d545670ab20ecc3c634cf4e0cc7a1e9f0d02bfc02185cfeb1231b4e5d0296387550bc4e3bda063c13868d296f8cce0c930cca7472b825aa1b181593aa4f8dc51a6f4ea77dc82ffba175d9917a57fcb85d13ddaf9808dacc3b412ad7df270bd4a53a625a167aa3619de9e69ee7c21e82ce35bef4838f08d3fc2ec9ca849159cb99fce980dc8b4889457ba112aa2f440ef96693c4482239df55f20b929b57732be17ac36301efdecab1cb5e53f9f9f038b8d0a74f17af04774a1bb656e518d7b5aa76ee069271466898ee85c70625a1b9fdfcea2baf4eab67ee2574937b59451d8832dc99d9afaa7159ae446bdd496d83e79f879603b78cc7d317a41356e29c0d4e1895f9882a1220fbcd3d2419a52186386b182781c97e3506a63c1117e4d49a4185141e2ba9ffa1f89c57c1430275bb60b4cfc4f12f4c0b0e3f2da9c116f1c193a7120da69262b69803fa7e75865165cbffe65dc7a168c7310ae457edda5fcde557b1c4f597527610f63ff0689a9b522206506931711bea59b3da09b2acecf1b41d9ddae156257a3f48b7cbf5fa75103061442da16d908ec1c921f9b06c8ea27410fd16dfff9ef721355acbe6cdce3e4da8b7acd45d8988b22a5c2413defe3c1cbcf97b2aa3bb039635e17c3757ac9cfade49f448588ce6f9aaef44c2f1fe945dd3e0849e832ec7ecb48bf96cf9da788ac9a2dc0962fb6c88b6699ef1e13f86227764574f3e2b9a458b134644113bb3e9ef786f2a205d92b8dfd467c921863bc9cacd510d9d7618c50b8253222d4206829ab251e8a9197c0b18365266c3ed387889fc513584c8db68004e936d3637554b233a2969b562ce5aee5f1aaf70f408e1ebe23b519cb7f1548cb2e3b3b08aad13d3e29a3f4efedefb5f7b882f114d5c97db0b1c6482a32566f11e19b9ae70513b17a66daa00298dd17ed9dd02217dd3ac9a1f54740daedc79984609e5ff69bff31c0aa0c574e3380ab0b8ed6d161b25a8109ea8e890222c6bc9f37be68cf20a599f2e78cf1c57396e3a5c250a815b921f65cdebba7b6d4bb997ceb8d7ea282fe62f96de60f3e89bd0525db269e8060c37c1f80292bdefebb6ce9f90b0e7fad3f174a542e7d6d86f806f0863365f9f3ef5aaa9d06f119bba00be2501550e0e4167c00fcc931f6d5ff514fe86a10b79f59631ce34f49a03edb4b8382ace131100b334986fadb2e093c3a4c2d4f514b8eda81b4080a87cbac3838be5320d6e2e149af45d240d3db18c9c95cd0443e76269bce19d3f6316bb131ae1049746b59e22267b7f8023f551ad766d329992f2498fee84639df6cb96250ed6d9cd05958a3969cc5edb4dc669ba13634ca62225f340b3ab84c3616214956bd53d2ca2dc295a7e006b6944fe275cbe7796a1b2d6a24fad85b54630a1be0022c2cc02d7154ed531eaf01c03637940689c734cde55731c991912073c1b9574b302898b7341cdf109da9ac440b50c2f368585c1d1cd58e55de07c4997db857b5bcfc406e5d25de99e722a3f195255d66d5651753d87593f50e9e29ca0199135ab0be57d5ac13281da17bb8eb570cb01d078d28e186386cbbc59f1bb172337e01cf7d0c77dc21ab8705098779aa8ecee473b18d8c045263017afd7033cd77de10dd772bd301ae8f2bcf4d21959c1a137d3e8731010d59428930e9c56398b91253ba0b457dc6fbd81b1a766f99271e3c0a926cfc8fe9a67909527f32c5140dfccf0fa303016609c2131a286f88142110851f264b404b35846582ae17952e5b2852e8b5146c1bc24d81a60c2230d00e77c707edca9a4a27e79b4f66d679805467a966e7811a88eed9a90b257b80dd083432a4143b9cd145185ebe549cd6493ee45a9d56c98d78cb4d1ea99d28b4d6227f209e91756975ae0631cb96d2efa198b575f818ae65ad8190b602eda6d4ec7e8d317468059b581dfd5a3554d5e2053884f98f4f4792783eebb78e2def152a467edc18e8d5964d3f05649eda5ebdd5354dacecf6457e41e2fe5bdbbdae8daa114be9050f6ca07f8bcb101fa442c92c33b29b0326d04bbf88c55d116c7f6818e12f1f75cb8f62b5a687273220875add2ea2d227d3e926e32ae885c3e2de63eae82c9f987bc91b4966cf4cac589dcbb066142c3ea3d6351b9fb4883c876da39144a3d9b3bfb982c47d023e690c038014014ece0a4621fc9c082ee068b7d81de4908914f82e96e1d1029a5025aaac56b4e2c2ad597e9ad5f46f37debafa4ca0973bdf28a27b46e212a3b7ecd2fca63f083e189b9ef52d68acefa924c9034edb5d0db2aef2c3d8f0c298ef38f3ead650b9a673568dce47e000175d0abb2f988fd6ee7394dd9ce4b7d4f0a0ab7edafc313d825b4eff237d87b6b0325c1aa752f653267a3b43b7f42a8a5e9a94b429cc9479e60f81a6bb91d4c5393233db3c2094008af0e4efcf4ed5578971e87f40d7db3b04633d68258f3d00ba8d8c6134bc8949dfa97f74ca26de2b2d33249eb1bfd8facbc50a2ecb3b682405c2571a7ea1af8b9ad2bfb81ddfb0de704bfc222d0644059b24a10edbe061abc36814802e64f7513946cbe0b058cd7a25d4801c293e53a27b8b602f371ef8a935cabac7b64924dd10c7884067803587f3efa261e502ffd06b88ca439ca9a41b2d00adfc85b8cfd0aae1fae0564665488df20af61c9adb1b425502bccb7a1a4c7cf75541671e123a86d28c3cf59bcdc66a34b69dcccfed752bb14b3bd8569a61555ae49a4f21375d7e6d5f0ef8bebdfe8cd07af76811da5d34be6dc596941e945c02dd4863ffdea2f998c81a399df6c411160a5b03094d284b4716f37e01b2b77d719dffb5f142c8dabf4f4963ad8661fc2647b6bd25aba37c173e0a71daae4324409fc76458e94ff4321dbf95126bcda7f969cb3164cc4aa5e3a7efa284b37ba1f7738a8ec25edcb36460e223b5dce87decd2d0e7ae10c2a7bd418d3c27b0c60d985e233b1beb31dafed7d03b3c3c0d7361557c3d2a4987e7c945eaf726fc5591a125a3f9f3b47ffb1e87b540e94df49b4f063afa974228714dc05105394ac2029ad68d4fb4908bbbed62d1a3a4f01d93758a4d9e8db51d8acb1f00497393bb7b80977b87461a94ddaa76983bbbc0366d21efb55b4fc4a366a9d1602bf549f7df8e9cf5f96df42fe76f1275eac9ab6c3e0b8dffedea4ef0f562beadc0f5ff9324710c4f596ed694e39ca105c004be65d1ddbfcc6f25e5d96bdc3bb1a20e39cdbf238fe04edfd7c1c728faf304fb89a0f51ae426e005b9754712ea9960b8dbee12ce28f58449cf647d7e061b2d0f21c364de11c140ee8f2a063b5504a4275c893659b64b92f1535c26df6be4ca6e3395fe7cd2192693ab4777d15a257fe88366e352aad8414b1505cb8b66f30063d9dbaaf0e4a14698bf235ddaa2abca6cc48d0bb22147072308d355f1662e4de44c63d3ed36b1784d1650eec47cb9deb6aba21787d11c1b8570a905e31205aea4e2bab8dd21df4b03901ecccab72ec26d72b24941cbc644ec614d0e183238bc58521217f8c47b50e1d43650902056f2155185570aec7e55b80eb02d730c82f7bf2384b58ea369619fc2b080f50c1133984385b1fc651fd1980271a715a052128dc43c2eabc6fa10433ddb2529baa358ef59652151f77d1af94f9bd2facb87421c00a4945b39c018da954079650bba362f5489e902ed639764d342d616c188c65956baaf18c8fc9e9f9dfcd546e8830055a31cbcd57a4edb23798c16dc78914ba2601a30885412190f4a54740395f9ca99227f5df72a0a63cbef503aa4e209d2957b781151bd122cdb3fe937e3681ca1b5b2df987afac80b497dbc41e0c73a033216d6fe1702c5bd237f3a6ab2d93e657a2a43793885296a653d648da236f513ce29a17ad8608992ec63faac3a481864709583385a7c637dbef2296bc411704812c93efbf615d0404bf449270d33c925706468db315e16d0238f890b1ad9a077d13f830ea8e051d14c59c0855427fe55de314d86a03b03fb4503bd32d0e5812650380029f2ca08dd3d811314b0565c163a0afad757993a790af0b7e7ae2140ec4ed89859e5c7dea242b42ae7a6a8b37590fe81e1157ee08ea70d47549a616a01becb2aab163aef1732b2f79f298da46655a56d4ae0d8ec20182c8fa5e111d068a14ed071f03f6c95ffd88807050c0d5af64be92167ddb3f8ad32a9a4337aa5f7e759270c69392dd1a3913e424ce483758000022a46fbb337f4ca59da1bc02dde326a7622d644fe077baad28cf2f2c3319d5a230af0fa41fed065e24b6358f7a7ab8c43c6c05cabfd59871a5a5d1f5b0ca9210a04a416154d7c8596adb92f02214971aa719f08e8839172fc7ba39c8886670f0ede53ddad8e145006e0a6c07a5c1984ec49e2c5223c8176f794e167a2da05da976650785749833ced31ce1a4d72c3782cab48e9d907312f66cda5566ca3a9a83cb3ff42028384454186ae1d13c5b575f7a9a928ffa61016c72b98193aebca1bce374e9d9372e7d960760827b6fab228301a858a920807acc299158b6ef94500c31449e5c45cb99f6ef8d36782f64b58428f4edd9b66a401bdc8f6fec797510e629a0261359880bf5b273295fac9632d9fdb9b91a305af43e1d3449d3f6a34ba29d0d04488a16a8f2f75bd067d7cd853e0d6183ac6bbb4e2d778594bfc48514873263225fa8407d959a40a4053fd4b244957072ffe68cd0069b5e44b06e541e266bef2df6ec44bae662d161cce56c20664ed486b9ded99906086b1b61ad800cd09d613fa7f1732ce3a734e9f0f3b66ddbe5a9289861f54122fbf23d649bb2845c1b68ea3ef53ba85840bb181ae8e0e3cac848c13431053b95d4d4aa6fa06885ba543f9022e94861797e52c0fe12c1249600511e74caa249db0869f3f025cb03c6e1b4a2f5c759498e5195e76bbd398e5f41ea550a8fe747770b2e7c78e7780c78f0a6bfd5dfac9e9f154f0a71b2bdb6f2a7f9e36d8df2335eddd27a4dfe221c2add15b4f156e70f2bdb7f7b63d6e2b87fd668effd9a2d01a1cff56f499438379be54ef7cda8424f0e466329cb307a3673800c0a44795fb5087dbf3a65c33c150756a4fe857fb64c29e271282ac9addfd391d4c158c6df125a8f63844fe428e185f6d6d638e4c04cc230034171f181e540d008191653e4701c99ccbf2cf056d70765a97fb3cf277b301f875f76469215a3ec735b27db2dad7088078eab88f623257cfc682cf72bb0d57b5630326f4bbaf7a8d8f859ad4fc96c80fe4b4e3509947b1ac24b940056f77f33e92d60b1aa945f2c5ec46fc3cd03d50514cde74f0d25238ef74744db6df39ad06c88bd78346b7c90e3d5bc3ffc45e7cdceae791fdbc517e0118030febd535df6a4fc01ecd2179b4c7c37800267d8c536855083a3b983331f4de8ae50ca591aacbcc0b698b7b9252e869bd47d45ce6a64f0821af65084ee9eb581fb5341de23faaf0c8f814987127e69e590565f57c69c95f9c1d352214d945bc79daec48a324b68317d0189fa06ff384e9172adfcd5af3140e71f7b81e61a0165328bbd4adc57c2dc6dcb20399694daf5e4d48e01d937250eff3d1ac2221c30ecf6809aca41cb2cba01463706b0ffca4dd0d5205d64c5f5fb4b9474d1b8ef2957229f7e57c3fc3dd808de80e05bdc6c3a77fd340ccb993fb6faf713e5719569048b8af76cd0ad2698edcb5f609ff7783404302e26c44178874666a884ec88665e377d82537274635086ccd9bdf5de506b36a9370cd3dbf356f2e7d7b479af52d6e54a01957d6</script>\n</div>\n<script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"Here's something encrypted, password is required to continue reading.","more":"Here's something encrypted, password is required to continue reading.","origin":"<h1 align=\"center\">步连伟</h1>\n<div align=\"center\">18851659629 | bulianwei@gmail.com</div>\n<div align=\"center\">博客：https://blog.csdn.net/branwel | http://bulianwei.github.io </div>\n> ## 技能清单\n\n<ul>\n<li><p>熟悉Hadoop大数据生态体系，能够搭建高可用的Hadoop生态集群</p>\n</li>\n<li><p>熟悉HDFS组成架构、存储原理、数据的读写流程，及优化HDFS工作性能</p>\n</li>\n<li><p>熟悉MapReduce工作机制与运行原理，用Tez替换计算引擎，提升Hive计算查询速度。</p>\n</li>\n<li><p>理解Flink基本架构，能够使用Flink分析处理有界和无界数据流，以事件为驱动达到最低延迟。能够处理以EventTime为时间准则的数据分析，能够使用CEP捕捉数据流里面的综合事件</p>\n</li>\n<li><p>熟悉使用 Spark Core、SparkSql、SparkStreaming处理离线数据、实时数据，理解Spark 任务提交流程，优化Spark处理过程</p>\n</li>\n<li><p>理解HBase核心架构，数据的读写流程、存储机制，理解RowKey的设计原则以及HRegion的热点问题</p>\n</li>\n<li><p>熟悉数据仓库的设计、搭建、表关系的模型构建，使用Hive 实现海量结构化日志的分层管理与查询分析</p>\n</li>\n<li><p>熟悉Kafka消息队列，理解数据的生产、存储、消费过程，能够搭建高吞吐量，易扩展，高可用架构，提高消费能力，实现Exactly-once语义</p>\n</li>\n<li><p>熟悉Redis内存数据库，能搭建Redis高可用集群并编程，优化缓存穿透问题</p>\n</li>\n<li><p>了解常见的Java设计模式和熟悉常用的排序算法，搭建程序结构，优化程序性能</p>\n</li>\n<li><p>熟练掌握Scala编程，能运用Scala进行Spark RDD，Spark Streaming编程</p>\n</li>\n<li><p>理解JVM模型，常见的GC垃圾回收器和算法，能够通过调整JVM常用参数配置，优化程序性能解决OOM问题</p>\n</li>\n<li><p>熟悉常用的JUC高并发</p>\n</li>\n<li><p>熟悉常用的Linux的Shell命令，能在Linux系统下搭建开发环境，及主机性能分析</p>\n</li>\n<li><p>熟悉了解Docker，CDH等大数据部署组件</p>\n</li>\n<li><p>熟悉使用JProfile，MAT对JVM虚拟机进行内存分析和性能调优</p>\n</li>\n<li><p>熟悉了解Golang，熟悉gRPC、Goroutine</p>\n</li>\n<li><p>可以使用Shell和Python编写常用脚本</p>\n</li>\n<li><p>熟练使用Maven，Git，Confluence，GitLab，JIRA等管理开发工具</p>\n</li>\n</ul>\n<blockquote>\n<h2 id=\"工作经历\"><a href=\"#工作经历\" class=\"headerlink\" title=\"工作经历\"></a>工作经历</h2></blockquote>\n<h3 id=\"2017-12-2019-6\"><a href=\"#2017-12-2019-6\" class=\"headerlink\" title=\"2017/12 ~ 2019/6\"></a>2017/12 ~ 2019/6</h3><h4 id=\"轻图信息技术-北京-有限公司-数据治理-大数据开发工程师-项目技术负责人\"><a href=\"#轻图信息技术-北京-有限公司-数据治理-大数据开发工程师-项目技术负责人\" class=\"headerlink\" title=\"轻图信息技术(北京)有限公司            数据治理            大数据开发工程师 |项目技术负责人\"></a>轻图信息技术(北京)有限公司            数据治理            大数据开发工程师 |项目技术负责人</h4><p>我们公司前身是某运营商大数据研发部门，主要业务是负责国内两个运营商的数仓治理解决方案。</p>\n<p>全国31个省每个省的数据通过Flume采集后，一份数据直接入Kafka进行其他计算需要，一份数据直接接入数仓底层HDFS（同时冷冻一份数据）。数仓使用MapReduce、Hive、Spark进行离线数据处理，准实时使用Spark、Flink计算，最后将指标数据放到HBase或者K-V集群，前台将数据转化为接口分配权限，对外销售和大屏展示。</p>\n<p>我属于数据治理组，负责对数仓内的数据进行建模、统计分析并将指标数据写到外部系统。主要负责位置业务的数据处理工作，需要将六种数据源的结构化数据进一步格式统一、单位统一、数据校验，然后将这些数据按用户、分钟级别粒度并按照优先级进行提取。将数据提取后进行去超速、去乒乓操作，过滤后的数据写入HDFS并创建Hive表进行数据映射供上层业务调用。同时针对项目进行优化和迭代，使业务代码可以尽量保证不增加资源的情况下以应对数据持续增长的需求。</p>\n<h5 id=\"数仓拓扑结构\"><a href=\"#数仓拓扑结构\" class=\"headerlink\" title=\"数仓拓扑结构\"></a>数仓拓扑结构</h5><p> 数仓分为四层:数据原始层（ods）、数据明细层（dwi）、数据服务层（dws）、数据应用层（dal），保证了数据间解耦、分层处理、便于管理。严格按照划分的服务域主题和子主题规范建表，便于后期维护。</p>\n<ul>\n<li><p>数据原始层（ods）：加载用户行为日志和业务数据，保持数据原貌</p>\n</li>\n<li><p>数据明细层（dwi）：使用自定义UDF函数对用户行为日志进行解析，并过滤脏数据，对敏感数据加密，对用户重要信息脱敏，对表降维处理</p>\n</li>\n<li><p>数据服务层（dws）：对数据轻度聚合，并将查询频度较高的表联合起来制作宽表，一表多用，解决大部分需求，提高工作效率</p>\n</li>\n<li><p>数据应用层（dal）：对dws层的数据从不同维度聚合，结果写入HBase或者K-V集群</p>\n</li>\n</ul>\n<h5 id=\"数据治理、优化\"><a href=\"#数据治理、优化\" class=\"headerlink\" title=\"数据治理、优化\"></a>数据治理、优化</h5><ul>\n<li>Hive计算引擎由MapReduce引擎改换使用Tez引擎，运行提升速度两倍左右</li>\n<li>数仓中通过数据建模理论，对数仓中的数据采用多冗余，低范式构建星型模型，减少关联查询，提高查询效率</li>\n<li>合理设置小表阈值，在资源允许的情况下尽量使用MapJoin以避免Shuffle</li>\n<li>避免小文件，在Map操作之前合并小文件，在任务结束时合并小文件</li>\n<li>使用自研数据一体化平台，从开发、测试、运维环节组织监控项目研发过程，保留中间过程数据方便后期可追溯</li>\n<li>使用自研数据一体化平台管理数仓元数据，血缘关系地图和数据资产统计</li>\n</ul>\n<h5 id=\"负责项目\"><a href=\"#负责项目\" class=\"headerlink\" title=\"负责项目\"></a>负责项目</h5><ul>\n<li><p>位置融合集市</p>\n<p>设计分批两段式式及单Job全量与多Job分摊并行的方式对数据进行处理，分摊队列资源利用峰值，平滑队列资源利用率，使原来8:30之前完成的任务可以提前到5:30之前，提高数据处理效率30% ～ 40%。设计中间过程可配置的监控、报警机制，使数据处理过程实现阶段和完成度的透明显示。</p>\n</li>\n<li><p>旅游集市</p>\n<p>修改原基础架构替换计算引擎，将原来Spark+Redis的数据处理过程修改为使用Flink进行Stateful计算，对每个用户近2个小时内的状态数据进行保存更新，简化数据计算流程，使数据计算效率提高10% ～ 20%左右。</p>\n</li>\n<li><p>商业地产集市</p>\n<p>设计集市核心商圈人员归属算法，圈定固定范围商圈用户，用于指标统计运算。研发HQL脚本通用模版，固化通用性配置，使开发人员只注重业务逻辑开发，省去繁琐过程，使两人开发的工作量一个人就可以完成。研发脚本逻辑测试工具，三人一个项目减少为两人一个项目，提高测试效率。</p>\n</li>\n<li><p>掌合天下数仓</p>\n<p>负责订单、用户集市的设计和开发。Azkaban调度维护，并且与甲方进行数据核对，针对问题数据进行问题排查。</p>\n</li>\n</ul>\n<h3 id=\"2016-3-2017-10\"><a href=\"#2016-3-2017-10\" class=\"headerlink\" title=\"2016/3 ~ 2017/10\"></a>2016/3 ~ 2017/10</h3><h4 id=\"北京中科弘睿科技有限公司-大数据研发-大数据开发工程师\"><a href=\"#北京中科弘睿科技有限公司-大数据研发-大数据开发工程师\" class=\"headerlink\" title=\"北京中科弘睿科技有限公司            大数据研发                        大数据开发工程师\"></a>北京中科弘睿科技有限公司            大数据研发                        大数据开发工程师</h4><p>公司的数据主要是通过Web的日志数据，APP端的行为数据，埋点数据。使用Flume采集数据存储到HDFS，在数仓对数据进行清洗、脱敏和统计分析，最后将指标数据存入MySQL数据库，供前台展示。</p>\n<p>我是属于数据分析组，主要负责用Hive、Spark对数据进行清洗、脱敏和统计分析。清洗脱敏后的数据按照不同纬度进行数据建模，然后根据不同业务需求对数据进行多维指标统计。并将最后生成的指标数据放到MySQL供其他组同事进行展示使用。同时对一些临时项目需求进行报表统计。</p>\n<ul>\n<li><p>电子商城离线分析系统<br>对数仓进行重新构造，按照业务进行集市划分，专人开发测试，针对大段HQL进行分拆，分表加分区。优化后提升代码效率10% ～ 20%，同时制定HQL开发标准，制作代码模版和数据测试流程。</p>\n</li>\n<li><p>驾车习性系统<br>设计路线契合度算法，使行车轨迹符合率达到85%以上。</p>\n</li>\n</ul>\n<h3 id=\"2015-3-2016-1\"><a href=\"#2015-3-2016-1\" class=\"headerlink\" title=\"2015/3 ~ 2016/1\"></a>2015/3 ~ 2016/1</h3><h4 id=\"联想（北京）有限公司-E-amp-T-移动互联产品开发助理\"><a href=\"#联想（北京）有限公司-E-amp-T-移动互联产品开发助理\" class=\"headerlink\" title=\"联想（北京）有限公司        E&amp;T        移动互联产品开发助理\"></a>联想（北京）有限公司        E&amp;T        移动互联产品开发助理</h4><ul>\n<li><p>移动互联网应用项目</p>\n<p>开发比赛软件项目代码（Android），担任过两届全国8个省省赛的软件技术支持和评委，国赛的软件支持工作。撰写Android开发教材数据存储模块</p>\n</li>\n</ul>\n<blockquote>\n<h2 id=\"教育背景\"><a href=\"#教育背景\" class=\"headerlink\" title=\"教育背景\"></a>教育背景</h2></blockquote>\n<ul>\n<li>2012.9 ～ 2015.7        山东劳动职业技术学院    大专    软件工程    </li>\n</ul>\n<blockquote>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2></blockquote>\n<ul>\n<li>荣誉/奖项：移动互联网全国软件开发二等奖</li>\n</ul>\n","encrypt":true},{"_content":"\n# Bigdata\n\n## 1. Hadoop\n~~~\n1.hdfs集群：负责文件读写\n2.yarn集群：负责为mapredece程序分配运算硬件资源\nHadoop配置：\n1.core-site.xml：fs.DefaultFS\thadoop.tmp.dir\n2.hadoop.env.sh:  JAVA_HOME\n3.mapred-site.xml:  mapreduce.framework.name\n4.hdfs-site.xml:  dfs.replication\n5.yarn-site.xml:   yarn.resourcemanager.hostname  yarn.nodemanager.aux-services    \nslaves：自动化脚本使用的配置文件\n修改Linux启动等待时间  vi /etc/fstab\nmkdir -p  /aa/bb/cc      可以直接建立aa下的bb下的cc  创建层级文件\n挂载光驱：mount -t iso9660 -o ro\t /dev/cdrom  /mnt/cdrom \n设置光驱开机挂载：vi /etc/fstab\t增加 /dev/cdrom\t/mnt/cdrom\tiso9660\tdefaults\t0 0\nrename\t文件重命名\t\n与mv的区别\nmv 支持单个文件重命名\nrename 支持多个文件重命名\ncp /aa/*  /bb\t复制aa下的所有文件到bb下面\nhadoop  fs -put  filename / \t\t上传文件\nhadoop  fs  -get   filename\t\t下载文件\nhadoop 副本数由客户端决定（conf.set 》自定义配置文件》jar包中的配置）\nnamenode和datanode两个的工作目录不能在同一个文件夹下，否则会启动不起来。\neclipse 本地运行代码时遇到调用远程路径权限不够时，在eclipse客户端运行配置时添加VM arguments参数使用hadoop用户运行，参数为“\t-DHADOOP_USER_NAME=hadoop\t”\nmr程序：\nconfiguration参数设置：\nconf.set（”mapreduce.framework.name\",\"local\"）#是否为本地运行模式，默认为local本地模式\nconf.set(\"fs.defaultFS\",\"file:///\")\t#输入输出数据的文件路径，默认为file\nconf.set(\"fs.defaultFS\",\"hdfs://hadoop01:9000/\") #输入输出文件路径\n本地运行模式文件可以用file也可以用hdfs\n设置在yarn上运行程序（要想设置在集群上运行程序 一下三个参数必须设置）\nconf.set（“mapreduce.framework.name”,\"yarn\"）#设置运行模式为在集群上运行\nconf.set(\"yarn.resourcename.hostname\",\"hadoop01\")\t#设置yarn的管理者resourcename在那一台机器上\nconf.set(\"fs.defaultFS\",\"hdfs://hadoop01:9000/\") #程序在设置在yarn上运行时必须设置文件存储为hdfs\n程序里面systemout的日子存在于hadoop里面的logs的userlogs里面对应job_id下的container里的syslog里面\nnamenode在刚启动时只包含block的数量和blockid不知道块所在datanode，要等待datanode向他汇报后才会在namenode元数据中补全文件块的位置信息，只有在namenode找到999.8%的块的位置信息才会退出安全模式正常对外提供服务。\n~~~\n\n![mapreduce&yarn的工作机制----吸星大法](Bigdata.assets/mapreduce&yarn的工作机制----吸星大法-5821159.png)\n\n![mapreduce原理全剖析--段氏六脉神剑](Bigdata.assets/mapreduce原理全剖析--段氏六脉神剑.png)","source":"notes/Bigdata.md","raw":"\n# Bigdata\n\n## 1. Hadoop\n~~~\n1.hdfs集群：负责文件读写\n2.yarn集群：负责为mapredece程序分配运算硬件资源\nHadoop配置：\n1.core-site.xml：fs.DefaultFS\thadoop.tmp.dir\n2.hadoop.env.sh:  JAVA_HOME\n3.mapred-site.xml:  mapreduce.framework.name\n4.hdfs-site.xml:  dfs.replication\n5.yarn-site.xml:   yarn.resourcemanager.hostname  yarn.nodemanager.aux-services    \nslaves：自动化脚本使用的配置文件\n修改Linux启动等待时间  vi /etc/fstab\nmkdir -p  /aa/bb/cc      可以直接建立aa下的bb下的cc  创建层级文件\n挂载光驱：mount -t iso9660 -o ro\t /dev/cdrom  /mnt/cdrom \n设置光驱开机挂载：vi /etc/fstab\t增加 /dev/cdrom\t/mnt/cdrom\tiso9660\tdefaults\t0 0\nrename\t文件重命名\t\n与mv的区别\nmv 支持单个文件重命名\nrename 支持多个文件重命名\ncp /aa/*  /bb\t复制aa下的所有文件到bb下面\nhadoop  fs -put  filename / \t\t上传文件\nhadoop  fs  -get   filename\t\t下载文件\nhadoop 副本数由客户端决定（conf.set 》自定义配置文件》jar包中的配置）\nnamenode和datanode两个的工作目录不能在同一个文件夹下，否则会启动不起来。\neclipse 本地运行代码时遇到调用远程路径权限不够时，在eclipse客户端运行配置时添加VM arguments参数使用hadoop用户运行，参数为“\t-DHADOOP_USER_NAME=hadoop\t”\nmr程序：\nconfiguration参数设置：\nconf.set（”mapreduce.framework.name\",\"local\"）#是否为本地运行模式，默认为local本地模式\nconf.set(\"fs.defaultFS\",\"file:///\")\t#输入输出数据的文件路径，默认为file\nconf.set(\"fs.defaultFS\",\"hdfs://hadoop01:9000/\") #输入输出文件路径\n本地运行模式文件可以用file也可以用hdfs\n设置在yarn上运行程序（要想设置在集群上运行程序 一下三个参数必须设置）\nconf.set（“mapreduce.framework.name”,\"yarn\"）#设置运行模式为在集群上运行\nconf.set(\"yarn.resourcename.hostname\",\"hadoop01\")\t#设置yarn的管理者resourcename在那一台机器上\nconf.set(\"fs.defaultFS\",\"hdfs://hadoop01:9000/\") #程序在设置在yarn上运行时必须设置文件存储为hdfs\n程序里面systemout的日子存在于hadoop里面的logs的userlogs里面对应job_id下的container里的syslog里面\nnamenode在刚启动时只包含block的数量和blockid不知道块所在datanode，要等待datanode向他汇报后才会在namenode元数据中补全文件块的位置信息，只有在namenode找到999.8%的块的位置信息才会退出安全模式正常对外提供服务。\n~~~\n\n![mapreduce&yarn的工作机制----吸星大法](Bigdata.assets/mapreduce&yarn的工作机制----吸星大法-5821159.png)\n\n![mapreduce原理全剖析--段氏六脉神剑](Bigdata.assets/mapreduce原理全剖析--段氏六脉神剑.png)","date":"2020-04-02T09:53:04.000Z","updated":"2020-04-02T09:53:04.000Z","path":"notes/Bigdata.html","title":"","comments":1,"layout":"page","_id":"ck8o1haa6000913s63jwlio0q","content":"<h1 id=\"Bigdata\"><a href=\"#Bigdata\" class=\"headerlink\" title=\"Bigdata\"></a>Bigdata</h1><h2 id=\"1-Hadoop\"><a href=\"#1-Hadoop\" class=\"headerlink\" title=\"1. Hadoop\"></a>1. Hadoop</h2><pre><code>1.hdfs集群：负责文件读写\n2.yarn集群：负责为mapredece程序分配运算硬件资源\nHadoop配置：\n1.core-site.xml：fs.DefaultFS    hadoop.tmp.dir\n2.hadoop.env.sh:  JAVA_HOME\n3.mapred-site.xml:  mapreduce.framework.name\n4.hdfs-site.xml:  dfs.replication\n5.yarn-site.xml:   yarn.resourcemanager.hostname  yarn.nodemanager.aux-services    \nslaves：自动化脚本使用的配置文件\n修改Linux启动等待时间  vi /etc/fstab\nmkdir -p  /aa/bb/cc      可以直接建立aa下的bb下的cc  创建层级文件\n挂载光驱：mount -t iso9660 -o ro     /dev/cdrom  /mnt/cdrom \n设置光驱开机挂载：vi /etc/fstab    增加 /dev/cdrom    /mnt/cdrom    iso9660    defaults    0 0\nrename    文件重命名    \n与mv的区别\nmv 支持单个文件重命名\nrename 支持多个文件重命名\ncp /aa/*  /bb    复制aa下的所有文件到bb下面\nhadoop  fs -put  filename /         上传文件\nhadoop  fs  -get   filename        下载文件\nhadoop 副本数由客户端决定（conf.set 》自定义配置文件》jar包中的配置）\nnamenode和datanode两个的工作目录不能在同一个文件夹下，否则会启动不起来。\neclipse 本地运行代码时遇到调用远程路径权限不够时，在eclipse客户端运行配置时添加VM arguments参数使用hadoop用户运行，参数为“    -DHADOOP_USER_NAME=hadoop    ”\nmr程序：\nconfiguration参数设置：\nconf.set（”mapreduce.framework.name&quot;,&quot;local&quot;）#是否为本地运行模式，默认为local本地模式\nconf.set(&quot;fs.defaultFS&quot;,&quot;file:///&quot;)    #输入输出数据的文件路径，默认为file\nconf.set(&quot;fs.defaultFS&quot;,&quot;hdfs://hadoop01:9000/&quot;) #输入输出文件路径\n本地运行模式文件可以用file也可以用hdfs\n设置在yarn上运行程序（要想设置在集群上运行程序 一下三个参数必须设置）\nconf.set（“mapreduce.framework.name”,&quot;yarn&quot;）#设置运行模式为在集群上运行\nconf.set(&quot;yarn.resourcename.hostname&quot;,&quot;hadoop01&quot;)    #设置yarn的管理者resourcename在那一台机器上\nconf.set(&quot;fs.defaultFS&quot;,&quot;hdfs://hadoop01:9000/&quot;) #程序在设置在yarn上运行时必须设置文件存储为hdfs\n程序里面systemout的日子存在于hadoop里面的logs的userlogs里面对应job_id下的container里的syslog里面\nnamenode在刚启动时只包含block的数量和blockid不知道块所在datanode，要等待datanode向他汇报后才会在namenode元数据中补全文件块的位置信息，只有在namenode找到999.8%的块的位置信息才会退出安全模式正常对外提供服务。</code></pre><p><img src=\"Bigdata.assets/mapreduce&yarn%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6----%E5%90%B8%E6%98%9F%E5%A4%A7%E6%B3%95-5821159.png\" alt=\"mapreduce&amp;yarn的工作机制----吸星大法\"></p>\n<p><img src=\"Bigdata.assets/mapreduce%E5%8E%9F%E7%90%86%E5%85%A8%E5%89%96%E6%9E%90--%E6%AE%B5%E6%B0%8F%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91.png\" alt=\"mapreduce原理全剖析--段氏六脉神剑\"></p>\n","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<h1 id=\"Bigdata\"><a href=\"#Bigdata\" class=\"headerlink\" title=\"Bigdata\"></a>Bigdata</h1><h2 id=\"1-Hadoop\"><a href=\"#1-Hadoop\" class=\"headerlink\" title=\"1. Hadoop\"></a>1. Hadoop</h2><pre><code>1.hdfs集群：负责文件读写\n2.yarn集群：负责为mapredece程序分配运算硬件资源\nHadoop配置：\n1.core-site.xml：fs.DefaultFS    hadoop.tmp.dir\n2.hadoop.env.sh:  JAVA_HOME\n3.mapred-site.xml:  mapreduce.framework.name\n4.hdfs-site.xml:  dfs.replication\n5.yarn-site.xml:   yarn.resourcemanager.hostname  yarn.nodemanager.aux-services    \nslaves：自动化脚本使用的配置文件\n修改Linux启动等待时间  vi /etc/fstab\nmkdir -p  /aa/bb/cc      可以直接建立aa下的bb下的cc  创建层级文件\n挂载光驱：mount -t iso9660 -o ro     /dev/cdrom  /mnt/cdrom \n设置光驱开机挂载：vi /etc/fstab    增加 /dev/cdrom    /mnt/cdrom    iso9660    defaults    0 0\nrename    文件重命名    \n与mv的区别\nmv 支持单个文件重命名\nrename 支持多个文件重命名\ncp /aa/*  /bb    复制aa下的所有文件到bb下面\nhadoop  fs -put  filename /         上传文件\nhadoop  fs  -get   filename        下载文件\nhadoop 副本数由客户端决定（conf.set 》自定义配置文件》jar包中的配置）\nnamenode和datanode两个的工作目录不能在同一个文件夹下，否则会启动不起来。\neclipse 本地运行代码时遇到调用远程路径权限不够时，在eclipse客户端运行配置时添加VM arguments参数使用hadoop用户运行，参数为“    -DHADOOP_USER_NAME=hadoop    ”\nmr程序：\nconfiguration参数设置：\nconf.set（”mapreduce.framework.name&quot;,&quot;local&quot;）#是否为本地运行模式，默认为local本地模式\nconf.set(&quot;fs.defaultFS&quot;,&quot;file:///&quot;)    #输入输出数据的文件路径，默认为file\nconf.set(&quot;fs.defaultFS&quot;,&quot;hdfs://hadoop01:9000/&quot;) #输入输出文件路径\n本地运行模式文件可以用file也可以用hdfs\n设置在yarn上运行程序（要想设置在集群上运行程序 一下三个参数必须设置）\nconf.set（“mapreduce.framework.name”,&quot;yarn&quot;）#设置运行模式为在集群上运行\nconf.set(&quot;yarn.resourcename.hostname&quot;,&quot;hadoop01&quot;)    #设置yarn的管理者resourcename在那一台机器上\nconf.set(&quot;fs.defaultFS&quot;,&quot;hdfs://hadoop01:9000/&quot;) #程序在设置在yarn上运行时必须设置文件存储为hdfs\n程序里面systemout的日子存在于hadoop里面的logs的userlogs里面对应job_id下的container里的syslog里面\nnamenode在刚启动时只包含block的数量和blockid不知道块所在datanode，要等待datanode向他汇报后才会在namenode元数据中补全文件块的位置信息，只有在namenode找到999.8%的块的位置信息才会退出安全模式正常对外提供服务。</code></pre><p><img src=\"Bigdata.assets/mapreduce&yarn%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6----%E5%90%B8%E6%98%9F%E5%A4%A7%E6%B3%95-5821159.png\" alt=\"mapreduce&amp;yarn的工作机制----吸星大法\"></p>\n<p><img src=\"Bigdata.assets/mapreduce%E5%8E%9F%E7%90%86%E5%85%A8%E5%89%96%E6%9E%90--%E6%AE%B5%E6%B0%8F%E5%85%AD%E8%84%89%E7%A5%9E%E5%89%91.png\" alt=\"mapreduce原理全剖析--段氏六脉神剑\"></p>\n"},{"_content":"# Flink-Trouble\n\n## 1. 处理时间窗口数据时未添加窗口或者设置处理的时间类型\n### 错误现象\n```\nCaused by: java.lang.RuntimeException: Record has Long.MIN_VALUE timestamp (= no timestamp marker). Is the time characteristic set to 'ProcessingTime', or did you forget to call 'DataStream.assignTimestampsAndWatermarks(...)'?\n```\n### 解决方案\n+ assignTimestampsAndWatermarks\n+ env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\n## 2. 程序重写(删除算子)导致使用savepoint数据快照无法恢复启动\n### 错误现象\n```\nFailed to rollback to checkpoint/savepoint file:/Users/bulianwei/workspace/project/idea/flink_demo/data/test/savepoint-18c72f-803ce50127dc. Cannot map checkpoint/savepoint state for operator c27dcf7b54ef6bfd6cff02ca8870b681 to the new program, because the operator is not available in the new program. If you want to allow to skip this, you can set the --allowNonRestoredState option on the CLI.\n```\n### 解决方案\n启动时使用 --allowNonRestoredState 或者 -n 跳过删除算子恢复\nflink run -s savepointdir -n -c mainclasspath jarpath\n\n## 3. 使用flink stop 停止job时出现无法停止现象\n### 错误现象\n```\n[org.apache.flink.runtime.rest.handler.RestHandlerException: Config key [state.savepoints.dir] is not set. Property [targetDirectory] must be provided.\n```\n### 解决方案\n使用flink stop jobid停止job时会保存数据快照，如果未设置savepointpath会导致无法保存快照，会导致无法停止job\nflink stop jobid -p savepointpath\n\n## 4.\n### 错误现象\n```\n\n```\n### 解决方案","source":"notes/Flink-Trouble.md","raw":"# Flink-Trouble\n\n## 1. 处理时间窗口数据时未添加窗口或者设置处理的时间类型\n### 错误现象\n```\nCaused by: java.lang.RuntimeException: Record has Long.MIN_VALUE timestamp (= no timestamp marker). Is the time characteristic set to 'ProcessingTime', or did you forget to call 'DataStream.assignTimestampsAndWatermarks(...)'?\n```\n### 解决方案\n+ assignTimestampsAndWatermarks\n+ env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n\n## 2. 程序重写(删除算子)导致使用savepoint数据快照无法恢复启动\n### 错误现象\n```\nFailed to rollback to checkpoint/savepoint file:/Users/bulianwei/workspace/project/idea/flink_demo/data/test/savepoint-18c72f-803ce50127dc. Cannot map checkpoint/savepoint state for operator c27dcf7b54ef6bfd6cff02ca8870b681 to the new program, because the operator is not available in the new program. If you want to allow to skip this, you can set the --allowNonRestoredState option on the CLI.\n```\n### 解决方案\n启动时使用 --allowNonRestoredState 或者 -n 跳过删除算子恢复\nflink run -s savepointdir -n -c mainclasspath jarpath\n\n## 3. 使用flink stop 停止job时出现无法停止现象\n### 错误现象\n```\n[org.apache.flink.runtime.rest.handler.RestHandlerException: Config key [state.savepoints.dir] is not set. Property [targetDirectory] must be provided.\n```\n### 解决方案\n使用flink stop jobid停止job时会保存数据快照，如果未设置savepointpath会导致无法保存快照，会导致无法停止job\nflink stop jobid -p savepointpath\n\n## 4.\n### 错误现象\n```\n\n```\n### 解决方案","date":"2020-03-19T05:09:33.000Z","updated":"2020-03-18T11:52:16.000Z","path":"notes/Flink-Trouble.html","title":"","comments":1,"layout":"page","_id":"ck8o1haa7000c13s6zolw1pf5","content":"<h1 id=\"Flink-Trouble\"><a href=\"#Flink-Trouble\" class=\"headerlink\" title=\"Flink-Trouble\"></a>Flink-Trouble</h1><h2 id=\"1-处理时间窗口数据时未添加窗口或者设置处理的时间类型\"><a href=\"#1-处理时间窗口数据时未添加窗口或者设置处理的时间类型\" class=\"headerlink\" title=\"1. 处理时间窗口数据时未添加窗口或者设置处理的时间类型\"></a>1. 处理时间窗口数据时未添加窗口或者设置处理的时间类型</h2><h3 id=\"错误现象\"><a href=\"#错误现象\" class=\"headerlink\" title=\"错误现象\"></a>错误现象</h3><pre><code>Caused by: java.lang.RuntimeException: Record has Long.MIN_VALUE timestamp (= no timestamp marker). Is the time characteristic set to &#39;ProcessingTime&#39;, or did you forget to call &#39;DataStream.assignTimestampsAndWatermarks(...)&#39;?</code></pre><h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><ul>\n<li>assignTimestampsAndWatermarks</li>\n<li>env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</li>\n</ul>\n<h2 id=\"2-程序重写-删除算子-导致使用savepoint数据快照无法恢复启动\"><a href=\"#2-程序重写-删除算子-导致使用savepoint数据快照无法恢复启动\" class=\"headerlink\" title=\"2. 程序重写(删除算子)导致使用savepoint数据快照无法恢复启动\"></a>2. 程序重写(删除算子)导致使用savepoint数据快照无法恢复启动</h2><h3 id=\"错误现象-1\"><a href=\"#错误现象-1\" class=\"headerlink\" title=\"错误现象\"></a>错误现象</h3><pre><code>Failed to rollback to checkpoint/savepoint file:/Users/bulianwei/workspace/project/idea/flink_demo/data/test/savepoint-18c72f-803ce50127dc. Cannot map checkpoint/savepoint state for operator c27dcf7b54ef6bfd6cff02ca8870b681 to the new program, because the operator is not available in the new program. If you want to allow to skip this, you can set the --allowNonRestoredState option on the CLI.</code></pre><h3 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>启动时使用 –allowNonRestoredState 或者 -n 跳过删除算子恢复<br>flink run -s savepointdir -n -c mainclasspath jarpath</p>\n<h2 id=\"3-使用flink-stop-停止job时出现无法停止现象\"><a href=\"#3-使用flink-stop-停止job时出现无法停止现象\" class=\"headerlink\" title=\"3. 使用flink stop 停止job时出现无法停止现象\"></a>3. 使用flink stop 停止job时出现无法停止现象</h2><h3 id=\"错误现象-2\"><a href=\"#错误现象-2\" class=\"headerlink\" title=\"错误现象\"></a>错误现象</h3><pre><code>[org.apache.flink.runtime.rest.handler.RestHandlerException: Config key [state.savepoints.dir] is not set. Property [targetDirectory] must be provided.</code></pre><h3 id=\"解决方案-2\"><a href=\"#解决方案-2\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>使用flink stop jobid停止job时会保存数据快照，如果未设置savepointpath会导致无法保存快照，会导致无法停止job<br>flink stop jobid -p savepointpath</p>\n<h2 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4.\"></a>4.</h2><h3 id=\"错误现象-3\"><a href=\"#错误现象-3\" class=\"headerlink\" title=\"错误现象\"></a>错误现象</h3><pre><code></code></pre><h3 id=\"解决方案-3\"><a href=\"#解决方案-3\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3>","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<h1 id=\"Flink-Trouble\"><a href=\"#Flink-Trouble\" class=\"headerlink\" title=\"Flink-Trouble\"></a>Flink-Trouble</h1><h2 id=\"1-处理时间窗口数据时未添加窗口或者设置处理的时间类型\"><a href=\"#1-处理时间窗口数据时未添加窗口或者设置处理的时间类型\" class=\"headerlink\" title=\"1. 处理时间窗口数据时未添加窗口或者设置处理的时间类型\"></a>1. 处理时间窗口数据时未添加窗口或者设置处理的时间类型</h2><h3 id=\"错误现象\"><a href=\"#错误现象\" class=\"headerlink\" title=\"错误现象\"></a>错误现象</h3><pre><code>Caused by: java.lang.RuntimeException: Record has Long.MIN_VALUE timestamp (= no timestamp marker). Is the time characteristic set to &#39;ProcessingTime&#39;, or did you forget to call &#39;DataStream.assignTimestampsAndWatermarks(...)&#39;?</code></pre><h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><ul>\n<li>assignTimestampsAndWatermarks</li>\n<li>env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</li>\n</ul>\n<h2 id=\"2-程序重写-删除算子-导致使用savepoint数据快照无法恢复启动\"><a href=\"#2-程序重写-删除算子-导致使用savepoint数据快照无法恢复启动\" class=\"headerlink\" title=\"2. 程序重写(删除算子)导致使用savepoint数据快照无法恢复启动\"></a>2. 程序重写(删除算子)导致使用savepoint数据快照无法恢复启动</h2><h3 id=\"错误现象-1\"><a href=\"#错误现象-1\" class=\"headerlink\" title=\"错误现象\"></a>错误现象</h3><pre><code>Failed to rollback to checkpoint/savepoint file:/Users/bulianwei/workspace/project/idea/flink_demo/data/test/savepoint-18c72f-803ce50127dc. Cannot map checkpoint/savepoint state for operator c27dcf7b54ef6bfd6cff02ca8870b681 to the new program, because the operator is not available in the new program. If you want to allow to skip this, you can set the --allowNonRestoredState option on the CLI.</code></pre><h3 id=\"解决方案-1\"><a href=\"#解决方案-1\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>启动时使用 –allowNonRestoredState 或者 -n 跳过删除算子恢复<br>flink run -s savepointdir -n -c mainclasspath jarpath</p>\n<h2 id=\"3-使用flink-stop-停止job时出现无法停止现象\"><a href=\"#3-使用flink-stop-停止job时出现无法停止现象\" class=\"headerlink\" title=\"3. 使用flink stop 停止job时出现无法停止现象\"></a>3. 使用flink stop 停止job时出现无法停止现象</h2><h3 id=\"错误现象-2\"><a href=\"#错误现象-2\" class=\"headerlink\" title=\"错误现象\"></a>错误现象</h3><pre><code>[org.apache.flink.runtime.rest.handler.RestHandlerException: Config key [state.savepoints.dir] is not set. Property [targetDirectory] must be provided.</code></pre><h3 id=\"解决方案-2\"><a href=\"#解决方案-2\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>使用flink stop jobid停止job时会保存数据快照，如果未设置savepointpath会导致无法保存快照，会导致无法停止job<br>flink stop jobid -p savepointpath</p>\n<h2 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4.\"></a>4.</h2><h3 id=\"错误现象-3\"><a href=\"#错误现象-3\" class=\"headerlink\" title=\"错误现象\"></a>错误现象</h3><pre><code></code></pre><h3 id=\"解决方案-3\"><a href=\"#解决方案-3\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3>"},{"_content":"# Docker\n\n## 命令\n\n### 镜像\n+ docker images\t//列出本地镜像\n  + -a\t//列出本地所有镜像\n  + -q\t//只显示镜像ID\n  + --digests\t//显示镜像的摘要信息\n  + --no-trunc\t//显示完整的镜像信息\n\n+ docker search\t//查找镜像\n\t+ --no-trunc\t//显示完整的镜像描述\n\t+ -s\t//列出收藏数不小于制定值的镜像\n\t+ --automated\t//只列出automated build 类型的镜像\n\n+ docker pull\t//下载镜像\n\n+ docker rmi\t//删除镜像\n\t+ -f\t//强制删除\n\n+ docker commit\t//提交容器副本使之成为一个新镜像\n\t+ -m\t//提交信息\n\t+ -a\t//作者\n\n### 容器\n+ docker run //使用镜像创建并启动容器\n\t+ -i\t//以交互模式运行容器\n\t+ -t\t//为容器重新分配一个熟人终端，通常与-i同用\n\t+ -d\t//后台运行容器\n\t+ --name\t//为容器指定名字\n\t+ -p\t//指定端口映射\n\t+ -P（大写）\t//随机端口映射\n\t+ -v\t//添加数据卷  ／宿主机绝对路径:/容器内目录\n+ docker ps\t//列出现在正在运行的容器\n\t+ -a\t//列出所有的容器\n\t+ -l\t//显示最近创建的容器\n\t+ -n\t//显示最近n个创建的容器\n\t+ -q\t//只显示容器编号\n\t+ --no-trunc\t//不截断输出\n+ docker exec\t//在运行的容器中执行命令\n+ docker attach\t//进入运行着的容器\n+ docker start\t//启动容器\n+ docker stop\t//关闭容器\n+ docker restart\t//重启容器\n+ docker top\t//查看容器内运行的进程\n+ docker inspect\t//查看容器内部细节\n+ docker cp\t//从容器内拷贝内容到主机上\n+ docker kill\t//杀掉容器\n+ docker rm\t//删除容器\n+ docker logs\t//查看日志\n\t+ -t\t//加入时间戳\n\t+ -f\t//跟进最新日志打印\n\t+ --tail\t//显示最新多少条\n\n\n## 容器数据卷\n容器的持久化，容器间继承+数据共享\n### 数据卷\ndocker run -v /宿主机绝对路径:/容器内目录 镜像名\n### 数据卷容器\ndocker run --volumes-from 父容器\n\n## DockerFile\n是一个由一系列命令和参数组成的构建Docker镜像的文件\n### 关键字\n+ FROM\t//父镜像，依赖镜像\n+ MAINTAINER\t//镜像维护姓名和邮箱\n+ RUN\t//容器构建时需要执行的命令\n+ EXPOSE\t//当前容器对外暴露出的端口\n+ WORKDIR\t//指定容器创建后，登陆进来的工作目录\n+ ENV\t//用来在构建镜像过程中设置的环境变量\n+ ADD\t//将宿主目录下的文件加载进容器里（自动处理url和解压）\n+ COPY\t//将宿主目录下的文件复制到容器相关目录\n+ VOLUME\t//容器数据卷，用于数据共享和持久化\n+ CMD\t//指定容器启动时要运行的命令（多个命令时只有最后一个生效，运行时指定的命令耶会覆盖cmd 命令）\n+ ENTRYPOINT\t//指定容器启动时要运行的命令，运行时指定的命令会被追加）\n+ ONBUILD\t//当构建一个被继承的DockerFile时的运行命令，父镜像的onbuild 在子镜像被build时触发\n\n\n\n\n\n\n\n\n\n\n","source":"notes/Docker.md","raw":"# Docker\n\n## 命令\n\n### 镜像\n+ docker images\t//列出本地镜像\n  + -a\t//列出本地所有镜像\n  + -q\t//只显示镜像ID\n  + --digests\t//显示镜像的摘要信息\n  + --no-trunc\t//显示完整的镜像信息\n\n+ docker search\t//查找镜像\n\t+ --no-trunc\t//显示完整的镜像描述\n\t+ -s\t//列出收藏数不小于制定值的镜像\n\t+ --automated\t//只列出automated build 类型的镜像\n\n+ docker pull\t//下载镜像\n\n+ docker rmi\t//删除镜像\n\t+ -f\t//强制删除\n\n+ docker commit\t//提交容器副本使之成为一个新镜像\n\t+ -m\t//提交信息\n\t+ -a\t//作者\n\n### 容器\n+ docker run //使用镜像创建并启动容器\n\t+ -i\t//以交互模式运行容器\n\t+ -t\t//为容器重新分配一个熟人终端，通常与-i同用\n\t+ -d\t//后台运行容器\n\t+ --name\t//为容器指定名字\n\t+ -p\t//指定端口映射\n\t+ -P（大写）\t//随机端口映射\n\t+ -v\t//添加数据卷  ／宿主机绝对路径:/容器内目录\n+ docker ps\t//列出现在正在运行的容器\n\t+ -a\t//列出所有的容器\n\t+ -l\t//显示最近创建的容器\n\t+ -n\t//显示最近n个创建的容器\n\t+ -q\t//只显示容器编号\n\t+ --no-trunc\t//不截断输出\n+ docker exec\t//在运行的容器中执行命令\n+ docker attach\t//进入运行着的容器\n+ docker start\t//启动容器\n+ docker stop\t//关闭容器\n+ docker restart\t//重启容器\n+ docker top\t//查看容器内运行的进程\n+ docker inspect\t//查看容器内部细节\n+ docker cp\t//从容器内拷贝内容到主机上\n+ docker kill\t//杀掉容器\n+ docker rm\t//删除容器\n+ docker logs\t//查看日志\n\t+ -t\t//加入时间戳\n\t+ -f\t//跟进最新日志打印\n\t+ --tail\t//显示最新多少条\n\n\n## 容器数据卷\n容器的持久化，容器间继承+数据共享\n### 数据卷\ndocker run -v /宿主机绝对路径:/容器内目录 镜像名\n### 数据卷容器\ndocker run --volumes-from 父容器\n\n## DockerFile\n是一个由一系列命令和参数组成的构建Docker镜像的文件\n### 关键字\n+ FROM\t//父镜像，依赖镜像\n+ MAINTAINER\t//镜像维护姓名和邮箱\n+ RUN\t//容器构建时需要执行的命令\n+ EXPOSE\t//当前容器对外暴露出的端口\n+ WORKDIR\t//指定容器创建后，登陆进来的工作目录\n+ ENV\t//用来在构建镜像过程中设置的环境变量\n+ ADD\t//将宿主目录下的文件加载进容器里（自动处理url和解压）\n+ COPY\t//将宿主目录下的文件复制到容器相关目录\n+ VOLUME\t//容器数据卷，用于数据共享和持久化\n+ CMD\t//指定容器启动时要运行的命令（多个命令时只有最后一个生效，运行时指定的命令耶会覆盖cmd 命令）\n+ ENTRYPOINT\t//指定容器启动时要运行的命令，运行时指定的命令会被追加）\n+ ONBUILD\t//当构建一个被继承的DockerFile时的运行命令，父镜像的onbuild 在子镜像被build时触发\n\n\n\n\n\n\n\n\n\n\n","date":"2020-03-19T05:09:33.000Z","updated":"2020-03-18T11:52:16.000Z","path":"notes/Docker.html","title":"","comments":1,"layout":"page","_id":"ck8o1haa9000e13s6rmodxsxt","content":"<h1 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h1><h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><h3 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h3><ul>\n<li><p>docker images    //列出本地镜像</p>\n<ul>\n<li>-a    //列出本地所有镜像</li>\n<li>-q    //只显示镜像ID</li>\n<li>–digests    //显示镜像的摘要信息</li>\n<li>–no-trunc    //显示完整的镜像信息</li>\n</ul>\n</li>\n<li><p>docker search    //查找镜像</p>\n<ul>\n<li>–no-trunc    //显示完整的镜像描述</li>\n<li>-s    //列出收藏数不小于制定值的镜像</li>\n<li>–automated    //只列出automated build 类型的镜像</li>\n</ul>\n</li>\n<li><p>docker pull    //下载镜像</p>\n</li>\n<li><p>docker rmi    //删除镜像</p>\n<ul>\n<li>-f    //强制删除</li>\n</ul>\n</li>\n<li><p>docker commit    //提交容器副本使之成为一个新镜像</p>\n<ul>\n<li>-m    //提交信息</li>\n<li>-a    //作者</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><ul>\n<li>docker run //使用镜像创建并启动容器<ul>\n<li>-i    //以交互模式运行容器</li>\n<li>-t    //为容器重新分配一个熟人终端，通常与-i同用</li>\n<li>-d    //后台运行容器</li>\n<li>–name    //为容器指定名字</li>\n<li>-p    //指定端口映射</li>\n<li>-P（大写）    //随机端口映射</li>\n<li>-v    //添加数据卷  ／宿主机绝对路径:/容器内目录</li>\n</ul>\n</li>\n<li>docker ps    //列出现在正在运行的容器<ul>\n<li>-a    //列出所有的容器</li>\n<li>-l    //显示最近创建的容器</li>\n<li>-n    //显示最近n个创建的容器</li>\n<li>-q    //只显示容器编号</li>\n<li>–no-trunc    //不截断输出</li>\n</ul>\n</li>\n<li>docker exec    //在运行的容器中执行命令</li>\n<li>docker attach    //进入运行着的容器</li>\n<li>docker start    //启动容器</li>\n<li>docker stop    //关闭容器</li>\n<li>docker restart    //重启容器</li>\n<li>docker top    //查看容器内运行的进程</li>\n<li>docker inspect    //查看容器内部细节</li>\n<li>docker cp    //从容器内拷贝内容到主机上</li>\n<li>docker kill    //杀掉容器</li>\n<li>docker rm    //删除容器</li>\n<li>docker logs    //查看日志<ul>\n<li>-t    //加入时间戳</li>\n<li>-f    //跟进最新日志打印</li>\n<li>–tail    //显示最新多少条</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"容器数据卷\"><a href=\"#容器数据卷\" class=\"headerlink\" title=\"容器数据卷\"></a>容器数据卷</h2><p>容器的持久化，容器间继承+数据共享</p>\n<h3 id=\"数据卷\"><a href=\"#数据卷\" class=\"headerlink\" title=\"数据卷\"></a>数据卷</h3><p>docker run -v /宿主机绝对路径:/容器内目录 镜像名</p>\n<h3 id=\"数据卷容器\"><a href=\"#数据卷容器\" class=\"headerlink\" title=\"数据卷容器\"></a>数据卷容器</h3><p>docker run –volumes-from 父容器</p>\n<h2 id=\"DockerFile\"><a href=\"#DockerFile\" class=\"headerlink\" title=\"DockerFile\"></a>DockerFile</h2><p>是一个由一系列命令和参数组成的构建Docker镜像的文件</p>\n<h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><ul>\n<li>FROM    //父镜像，依赖镜像</li>\n<li>MAINTAINER    //镜像维护姓名和邮箱</li>\n<li>RUN    //容器构建时需要执行的命令</li>\n<li>EXPOSE    //当前容器对外暴露出的端口</li>\n<li>WORKDIR    //指定容器创建后，登陆进来的工作目录</li>\n<li>ENV    //用来在构建镜像过程中设置的环境变量</li>\n<li>ADD    //将宿主目录下的文件加载进容器里（自动处理url和解压）</li>\n<li>COPY    //将宿主目录下的文件复制到容器相关目录</li>\n<li>VOLUME    //容器数据卷，用于数据共享和持久化</li>\n<li>CMD    //指定容器启动时要运行的命令（多个命令时只有最后一个生效，运行时指定的命令耶会覆盖cmd 命令）</li>\n<li>ENTRYPOINT    //指定容器启动时要运行的命令，运行时指定的命令会被追加）</li>\n<li>ONBUILD    //当构建一个被继承的DockerFile时的运行命令，父镜像的onbuild 在子镜像被build时触发</li>\n</ul>\n","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<h1 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h1><h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><h3 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h3><ul>\n<li><p>docker images    //列出本地镜像</p>\n<ul>\n<li>-a    //列出本地所有镜像</li>\n<li>-q    //只显示镜像ID</li>\n<li>–digests    //显示镜像的摘要信息</li>\n<li>–no-trunc    //显示完整的镜像信息</li>\n</ul>\n</li>\n<li><p>docker search    //查找镜像</p>\n<ul>\n<li>–no-trunc    //显示完整的镜像描述</li>\n<li>-s    //列出收藏数不小于制定值的镜像</li>\n<li>–automated    //只列出automated build 类型的镜像</li>\n</ul>\n</li>\n<li><p>docker pull    //下载镜像</p>\n</li>\n<li><p>docker rmi    //删除镜像</p>\n<ul>\n<li>-f    //强制删除</li>\n</ul>\n</li>\n<li><p>docker commit    //提交容器副本使之成为一个新镜像</p>\n<ul>\n<li>-m    //提交信息</li>\n<li>-a    //作者</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h3><ul>\n<li>docker run //使用镜像创建并启动容器<ul>\n<li>-i    //以交互模式运行容器</li>\n<li>-t    //为容器重新分配一个熟人终端，通常与-i同用</li>\n<li>-d    //后台运行容器</li>\n<li>–name    //为容器指定名字</li>\n<li>-p    //指定端口映射</li>\n<li>-P（大写）    //随机端口映射</li>\n<li>-v    //添加数据卷  ／宿主机绝对路径:/容器内目录</li>\n</ul>\n</li>\n<li>docker ps    //列出现在正在运行的容器<ul>\n<li>-a    //列出所有的容器</li>\n<li>-l    //显示最近创建的容器</li>\n<li>-n    //显示最近n个创建的容器</li>\n<li>-q    //只显示容器编号</li>\n<li>–no-trunc    //不截断输出</li>\n</ul>\n</li>\n<li>docker exec    //在运行的容器中执行命令</li>\n<li>docker attach    //进入运行着的容器</li>\n<li>docker start    //启动容器</li>\n<li>docker stop    //关闭容器</li>\n<li>docker restart    //重启容器</li>\n<li>docker top    //查看容器内运行的进程</li>\n<li>docker inspect    //查看容器内部细节</li>\n<li>docker cp    //从容器内拷贝内容到主机上</li>\n<li>docker kill    //杀掉容器</li>\n<li>docker rm    //删除容器</li>\n<li>docker logs    //查看日志<ul>\n<li>-t    //加入时间戳</li>\n<li>-f    //跟进最新日志打印</li>\n<li>–tail    //显示最新多少条</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"容器数据卷\"><a href=\"#容器数据卷\" class=\"headerlink\" title=\"容器数据卷\"></a>容器数据卷</h2><p>容器的持久化，容器间继承+数据共享</p>\n<h3 id=\"数据卷\"><a href=\"#数据卷\" class=\"headerlink\" title=\"数据卷\"></a>数据卷</h3><p>docker run -v /宿主机绝对路径:/容器内目录 镜像名</p>\n<h3 id=\"数据卷容器\"><a href=\"#数据卷容器\" class=\"headerlink\" title=\"数据卷容器\"></a>数据卷容器</h3><p>docker run –volumes-from 父容器</p>\n<h2 id=\"DockerFile\"><a href=\"#DockerFile\" class=\"headerlink\" title=\"DockerFile\"></a>DockerFile</h2><p>是一个由一系列命令和参数组成的构建Docker镜像的文件</p>\n<h3 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h3><ul>\n<li>FROM    //父镜像，依赖镜像</li>\n<li>MAINTAINER    //镜像维护姓名和邮箱</li>\n<li>RUN    //容器构建时需要执行的命令</li>\n<li>EXPOSE    //当前容器对外暴露出的端口</li>\n<li>WORKDIR    //指定容器创建后，登陆进来的工作目录</li>\n<li>ENV    //用来在构建镜像过程中设置的环境变量</li>\n<li>ADD    //将宿主目录下的文件加载进容器里（自动处理url和解压）</li>\n<li>COPY    //将宿主目录下的文件复制到容器相关目录</li>\n<li>VOLUME    //容器数据卷，用于数据共享和持久化</li>\n<li>CMD    //指定容器启动时要运行的命令（多个命令时只有最后一个生效，运行时指定的命令耶会覆盖cmd 命令）</li>\n<li>ENTRYPOINT    //指定容器启动时要运行的命令，运行时指定的命令会被追加）</li>\n<li>ONBUILD    //当构建一个被继承的DockerFile时的运行命令，父镜像的onbuild 在子镜像被build时触发</li>\n</ul>\n"},{"_content":"# Git & GitHub\n\n\n## Git\n\n### init\n### clone\n### add\n将变化提交到working directory（工作区）\n\n- git  add filename \t\n  添加file 到working directory\n- git add . \n  提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件\n- git add -u   (git add --update)\n  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)\n- git add -A  (git add --all)\n  提交所有变化，是`git add -u `和`git add . `两个功能的合集（git add --all的缩写）\n\n### update-index\n\n- git update-index --force-remove filename\n\n  将文件从追踪中删除，本地不会删除\n\n### ls-files\n\n- git ls-files \n\n  列出追踪的所有文件\n\n### rm\n\n- git rm filename\n  从工作区和索引中删除文件\n  \n- git rm --cached filename \n  \n  保留本地文件不在跟踪文件\n\n### commit\n将变化提交到staging area（暂存区）\n\n- git commit -m 'init' \n  提交暂存区改变到本地库\n  \n- git commit -am 'init'\n  添加所有改变并提交到本地库\n\n### push\n### pull\n### diff\n比较变化\n\n- git diff \n  比较工作区与本地库中的最后一次提交\n\n- git diff --cached\n  比较暂存区与本地库中的最后一次提交\n\n- git diff HEAD\n  比较工作区与暂存区\n### reset\n- git reset filename\n  将加入暂存区中的文件撤回到工作区\n  \n- git reset --hard commitid\n  直接回到commitid状态。所有commitid之后的操作全部清空\n  \n- git reset --hard HEAD^\n  回到上次提交的状态，撤销掉最近一次提交\n  \n### restore\n- git restore filename \n  丢弃工作区的改动\n\n### log\n查看git 提交日志\n\n- git log\n  显示详细提交信息\n- git log --oneline\n  简单显示提交信息\n  \n### reflog\n如果执行了`git reset --hard commitid`后还想回到commitid以后的某个操作时可以使用此命令，这相当于git log 的log\n\n### checkout\n切换到某个提交的节点\n\n- git checkout commitid\n  切换到历史的某个commitid的状态。将HEAD的指针指向某个commitid。如果当前状态是master，要想回到master前面某个提交状态，可以使用`git checkout commitid`回到commitid中的操作环境看看。在当前状态修改的操作提交后，如果后期回到master状态，修改的操作会丢失。\n\n- git checkout branchname\n  切换到某个分支\n  \n- git checkout -b branchname\n  创建并切换到某个分支\n  \n- git checkout tagname\n  切换到某个标签\n  \n  \n### status\n查看当前状态\n\n- git status\n  显示当前状态的相信信息\n\n- git status -s \n  显示当前状态的简单信息\n\n### branch\n查看创建分支\n\n- git branch\n  查看有哪些分支，带*号的为当前分支\n  \n- git branch name\n  创建一个name的分支\n\n### merge\n合并分支\n\n- git merge branchname\n  合并某个分支到当前分支。山寨过来就是我的，不会保留信息\n\n- git merge branchname --no-ff -m 'init'\n  合并某个分支到当前分支，会保留之前分支的提交记录状态和分支信息。山寨人家，但是会保留人家的信息\n\n### tag\n给提交添加标签\n\n- git tag tagname\n  给当前提交添加标签\n\n\n### remote\n查看远端库信息\n\n- git remote \n  查看远端库简要信息\t\n\n- git remote -v //-v == --verbose\n  查看远端库信息带有url\n  \n- git remote add origin url\n  添加一个名字为origin 的远端库地址为url\n  \n  \n### push\n推送本地库到远端库\n\n- git push\n  推送本地master分支到默认远端库分支\n\n- git push -u origin \n  第一次推送时可以使用-u参数，指定默认的远端库，设定以后再提交可以直接使用`git push`\n  \n- git push  origin master\n  推送本地master的分支到名为origin远端库的master分支\n  \n- git push  origin master1:master2\n  推送本地分支master1到origin远端库分支master2\n  \n- git push  origin :master2\n  推送一个空分支到origin远端库分支master2\n\n![QQ20200318-211942@2x](Git&GitHub.assets/QQ20200318-211942@2x.png)\n\n\n\n\n\n## GitHub\n\n1. awesome\n\n   ```\n   awesome 关键词\n   ```\n\n   \n\n2. \n\n","source":"notes/Git&GitHub.md","raw":"# Git & GitHub\n\n\n## Git\n\n### init\n### clone\n### add\n将变化提交到working directory（工作区）\n\n- git  add filename \t\n  添加file 到working directory\n- git add . \n  提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件\n- git add -u   (git add --update)\n  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)\n- git add -A  (git add --all)\n  提交所有变化，是`git add -u `和`git add . `两个功能的合集（git add --all的缩写）\n\n### update-index\n\n- git update-index --force-remove filename\n\n  将文件从追踪中删除，本地不会删除\n\n### ls-files\n\n- git ls-files \n\n  列出追踪的所有文件\n\n### rm\n\n- git rm filename\n  从工作区和索引中删除文件\n  \n- git rm --cached filename \n  \n  保留本地文件不在跟踪文件\n\n### commit\n将变化提交到staging area（暂存区）\n\n- git commit -m 'init' \n  提交暂存区改变到本地库\n  \n- git commit -am 'init'\n  添加所有改变并提交到本地库\n\n### push\n### pull\n### diff\n比较变化\n\n- git diff \n  比较工作区与本地库中的最后一次提交\n\n- git diff --cached\n  比较暂存区与本地库中的最后一次提交\n\n- git diff HEAD\n  比较工作区与暂存区\n### reset\n- git reset filename\n  将加入暂存区中的文件撤回到工作区\n  \n- git reset --hard commitid\n  直接回到commitid状态。所有commitid之后的操作全部清空\n  \n- git reset --hard HEAD^\n  回到上次提交的状态，撤销掉最近一次提交\n  \n### restore\n- git restore filename \n  丢弃工作区的改动\n\n### log\n查看git 提交日志\n\n- git log\n  显示详细提交信息\n- git log --oneline\n  简单显示提交信息\n  \n### reflog\n如果执行了`git reset --hard commitid`后还想回到commitid以后的某个操作时可以使用此命令，这相当于git log 的log\n\n### checkout\n切换到某个提交的节点\n\n- git checkout commitid\n  切换到历史的某个commitid的状态。将HEAD的指针指向某个commitid。如果当前状态是master，要想回到master前面某个提交状态，可以使用`git checkout commitid`回到commitid中的操作环境看看。在当前状态修改的操作提交后，如果后期回到master状态，修改的操作会丢失。\n\n- git checkout branchname\n  切换到某个分支\n  \n- git checkout -b branchname\n  创建并切换到某个分支\n  \n- git checkout tagname\n  切换到某个标签\n  \n  \n### status\n查看当前状态\n\n- git status\n  显示当前状态的相信信息\n\n- git status -s \n  显示当前状态的简单信息\n\n### branch\n查看创建分支\n\n- git branch\n  查看有哪些分支，带*号的为当前分支\n  \n- git branch name\n  创建一个name的分支\n\n### merge\n合并分支\n\n- git merge branchname\n  合并某个分支到当前分支。山寨过来就是我的，不会保留信息\n\n- git merge branchname --no-ff -m 'init'\n  合并某个分支到当前分支，会保留之前分支的提交记录状态和分支信息。山寨人家，但是会保留人家的信息\n\n### tag\n给提交添加标签\n\n- git tag tagname\n  给当前提交添加标签\n\n\n### remote\n查看远端库信息\n\n- git remote \n  查看远端库简要信息\t\n\n- git remote -v //-v == --verbose\n  查看远端库信息带有url\n  \n- git remote add origin url\n  添加一个名字为origin 的远端库地址为url\n  \n  \n### push\n推送本地库到远端库\n\n- git push\n  推送本地master分支到默认远端库分支\n\n- git push -u origin \n  第一次推送时可以使用-u参数，指定默认的远端库，设定以后再提交可以直接使用`git push`\n  \n- git push  origin master\n  推送本地master的分支到名为origin远端库的master分支\n  \n- git push  origin master1:master2\n  推送本地分支master1到origin远端库分支master2\n  \n- git push  origin :master2\n  推送一个空分支到origin远端库分支master2\n\n![QQ20200318-211942@2x](Git&GitHub.assets/QQ20200318-211942@2x.png)\n\n\n\n\n\n## GitHub\n\n1. awesome\n\n   ```\n   awesome 关键词\n   ```\n\n   \n\n2. \n\n","date":"2020-04-01T16:24:03.000Z","updated":"2020-04-01T16:24:03.000Z","path":"notes/Git&GitHub.html","title":"","comments":1,"layout":"page","_id":"ck8o1haaa000g13s6szb4ue94","content":"<h1 id=\"Git-amp-GitHub\"><a href=\"#Git-amp-GitHub\" class=\"headerlink\" title=\"Git &amp; GitHub\"></a>Git &amp; GitHub</h1><h2 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h2><h3 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h3><h3 id=\"clone\"><a href=\"#clone\" class=\"headerlink\" title=\"clone\"></a>clone</h3><h3 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h3><p>将变化提交到working directory（工作区）</p>\n<ul>\n<li>git  add filename<br>添加file 到working directory</li>\n<li>git add .<br>提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件</li>\n<li>git add -u   (git add –update)<br>提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)</li>\n<li>git add -A  (git add –all)<br>提交所有变化，是<code>git add -u</code>和<code>git add .</code>两个功能的合集（git add –all的缩写）</li>\n</ul>\n<h3 id=\"update-index\"><a href=\"#update-index\" class=\"headerlink\" title=\"update-index\"></a>update-index</h3><ul>\n<li><p>git update-index –force-remove filename</p>\n<p>将文件从追踪中删除，本地不会删除</p>\n</li>\n</ul>\n<h3 id=\"ls-files\"><a href=\"#ls-files\" class=\"headerlink\" title=\"ls-files\"></a>ls-files</h3><ul>\n<li><p>git ls-files </p>\n<p>列出追踪的所有文件</p>\n</li>\n</ul>\n<h3 id=\"rm\"><a href=\"#rm\" class=\"headerlink\" title=\"rm\"></a>rm</h3><ul>\n<li><p>git rm filename<br>从工作区和索引中删除文件</p>\n</li>\n<li><p>git rm –cached filename </p>\n<p>保留本地文件不在跟踪文件</p>\n</li>\n</ul>\n<h3 id=\"commit\"><a href=\"#commit\" class=\"headerlink\" title=\"commit\"></a>commit</h3><p>将变化提交到staging area（暂存区）</p>\n<ul>\n<li><p>git commit -m ‘init’<br>提交暂存区改变到本地库</p>\n</li>\n<li><p>git commit -am ‘init’<br>添加所有改变并提交到本地库</p>\n</li>\n</ul>\n<h3 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push\"></a>push</h3><h3 id=\"pull\"><a href=\"#pull\" class=\"headerlink\" title=\"pull\"></a>pull</h3><h3 id=\"diff\"><a href=\"#diff\" class=\"headerlink\" title=\"diff\"></a>diff</h3><p>比较变化</p>\n<ul>\n<li><p>git diff<br>比较工作区与本地库中的最后一次提交</p>\n</li>\n<li><p>git diff –cached<br>比较暂存区与本地库中的最后一次提交</p>\n</li>\n<li><p>git diff HEAD<br>比较工作区与暂存区</p>\n<h3 id=\"reset\"><a href=\"#reset\" class=\"headerlink\" title=\"reset\"></a>reset</h3></li>\n<li><p>git reset filename<br>将加入暂存区中的文件撤回到工作区</p>\n</li>\n<li><p>git reset –hard commitid<br>直接回到commitid状态。所有commitid之后的操作全部清空</p>\n</li>\n<li><p>git reset –hard HEAD^<br>回到上次提交的状态，撤销掉最近一次提交</p>\n</li>\n</ul>\n<h3 id=\"restore\"><a href=\"#restore\" class=\"headerlink\" title=\"restore\"></a>restore</h3><ul>\n<li>git restore filename<br>丢弃工作区的改动</li>\n</ul>\n<h3 id=\"log\"><a href=\"#log\" class=\"headerlink\" title=\"log\"></a>log</h3><p>查看git 提交日志</p>\n<ul>\n<li>git log<br>显示详细提交信息</li>\n<li>git log –oneline<br>简单显示提交信息</li>\n</ul>\n<h3 id=\"reflog\"><a href=\"#reflog\" class=\"headerlink\" title=\"reflog\"></a>reflog</h3><p>如果执行了<code>git reset --hard commitid</code>后还想回到commitid以后的某个操作时可以使用此命令，这相当于git log 的log</p>\n<h3 id=\"checkout\"><a href=\"#checkout\" class=\"headerlink\" title=\"checkout\"></a>checkout</h3><p>切换到某个提交的节点</p>\n<ul>\n<li><p>git checkout commitid<br>切换到历史的某个commitid的状态。将HEAD的指针指向某个commitid。如果当前状态是master，要想回到master前面某个提交状态，可以使用<code>git checkout commitid</code>回到commitid中的操作环境看看。在当前状态修改的操作提交后，如果后期回到master状态，修改的操作会丢失。</p>\n</li>\n<li><p>git checkout branchname<br>切换到某个分支</p>\n</li>\n<li><p>git checkout -b branchname<br>创建并切换到某个分支</p>\n</li>\n<li><p>git checkout tagname<br>切换到某个标签</p>\n</li>\n</ul>\n<h3 id=\"status\"><a href=\"#status\" class=\"headerlink\" title=\"status\"></a>status</h3><p>查看当前状态</p>\n<ul>\n<li><p>git status<br>显示当前状态的相信信息</p>\n</li>\n<li><p>git status -s<br>显示当前状态的简单信息</p>\n</li>\n</ul>\n<h3 id=\"branch\"><a href=\"#branch\" class=\"headerlink\" title=\"branch\"></a>branch</h3><p>查看创建分支</p>\n<ul>\n<li><p>git branch<br>查看有哪些分支，带*号的为当前分支</p>\n</li>\n<li><p>git branch name<br>创建一个name的分支</p>\n</li>\n</ul>\n<h3 id=\"merge\"><a href=\"#merge\" class=\"headerlink\" title=\"merge\"></a>merge</h3><p>合并分支</p>\n<ul>\n<li><p>git merge branchname<br>合并某个分支到当前分支。山寨过来就是我的，不会保留信息</p>\n</li>\n<li><p>git merge branchname –no-ff -m ‘init’<br>合并某个分支到当前分支，会保留之前分支的提交记录状态和分支信息。山寨人家，但是会保留人家的信息</p>\n</li>\n</ul>\n<h3 id=\"tag\"><a href=\"#tag\" class=\"headerlink\" title=\"tag\"></a>tag</h3><p>给提交添加标签</p>\n<ul>\n<li>git tag tagname<br>给当前提交添加标签</li>\n</ul>\n<h3 id=\"remote\"><a href=\"#remote\" class=\"headerlink\" title=\"remote\"></a>remote</h3><p>查看远端库信息</p>\n<ul>\n<li><p>git remote<br>查看远端库简要信息    </p>\n</li>\n<li><p>git remote -v //-v == –verbose<br>查看远端库信息带有url</p>\n</li>\n<li><p>git remote add origin url<br>添加一个名字为origin 的远端库地址为url</p>\n</li>\n</ul>\n<h3 id=\"push-1\"><a href=\"#push-1\" class=\"headerlink\" title=\"push\"></a>push</h3><p>推送本地库到远端库</p>\n<ul>\n<li><p>git push<br>推送本地master分支到默认远端库分支</p>\n</li>\n<li><p>git push -u origin<br>第一次推送时可以使用-u参数，指定默认的远端库，设定以后再提交可以直接使用<code>git push</code></p>\n</li>\n<li><p>git push  origin master<br>推送本地master的分支到名为origin远端库的master分支</p>\n</li>\n<li><p>git push  origin master1:master2<br>推送本地分支master1到origin远端库分支master2</p>\n</li>\n<li><p>git push  origin :master2<br>推送一个空分支到origin远端库分支master2</p>\n</li>\n</ul>\n<p><img src=\"Git&GitHub.assets/QQ20200318-211942@2x.png\" alt=\"QQ20200318-211942@2x\"></p>\n<h2 id=\"GitHub\"><a href=\"#GitHub\" class=\"headerlink\" title=\"GitHub\"></a>GitHub</h2><ol>\n<li><p>awesome</p>\n<pre><code>awesome 关键词</code></pre></li>\n</ol>\n<ol start=\"2\">\n<li></li>\n</ol>\n","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<h1 id=\"Git-amp-GitHub\"><a href=\"#Git-amp-GitHub\" class=\"headerlink\" title=\"Git &amp; GitHub\"></a>Git &amp; GitHub</h1><h2 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h2><h3 id=\"init\"><a href=\"#init\" class=\"headerlink\" title=\"init\"></a>init</h3><h3 id=\"clone\"><a href=\"#clone\" class=\"headerlink\" title=\"clone\"></a>clone</h3><h3 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h3><p>将变化提交到working directory（工作区）</p>\n<ul>\n<li>git  add filename<br>添加file 到working directory</li>\n<li>git add .<br>提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件</li>\n<li>git add -u   (git add –update)<br>提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)</li>\n<li>git add -A  (git add –all)<br>提交所有变化，是<code>git add -u</code>和<code>git add .</code>两个功能的合集（git add –all的缩写）</li>\n</ul>\n<h3 id=\"update-index\"><a href=\"#update-index\" class=\"headerlink\" title=\"update-index\"></a>update-index</h3><ul>\n<li><p>git update-index –force-remove filename</p>\n<p>将文件从追踪中删除，本地不会删除</p>\n</li>\n</ul>\n<h3 id=\"ls-files\"><a href=\"#ls-files\" class=\"headerlink\" title=\"ls-files\"></a>ls-files</h3><ul>\n<li><p>git ls-files </p>\n<p>列出追踪的所有文件</p>\n</li>\n</ul>\n<h3 id=\"rm\"><a href=\"#rm\" class=\"headerlink\" title=\"rm\"></a>rm</h3><ul>\n<li><p>git rm filename<br>从工作区和索引中删除文件</p>\n</li>\n<li><p>git rm –cached filename </p>\n<p>保留本地文件不在跟踪文件</p>\n</li>\n</ul>\n<h3 id=\"commit\"><a href=\"#commit\" class=\"headerlink\" title=\"commit\"></a>commit</h3><p>将变化提交到staging area（暂存区）</p>\n<ul>\n<li><p>git commit -m ‘init’<br>提交暂存区改变到本地库</p>\n</li>\n<li><p>git commit -am ‘init’<br>添加所有改变并提交到本地库</p>\n</li>\n</ul>\n<h3 id=\"push\"><a href=\"#push\" class=\"headerlink\" title=\"push\"></a>push</h3><h3 id=\"pull\"><a href=\"#pull\" class=\"headerlink\" title=\"pull\"></a>pull</h3><h3 id=\"diff\"><a href=\"#diff\" class=\"headerlink\" title=\"diff\"></a>diff</h3><p>比较变化</p>\n<ul>\n<li><p>git diff<br>比较工作区与本地库中的最后一次提交</p>\n</li>\n<li><p>git diff –cached<br>比较暂存区与本地库中的最后一次提交</p>\n</li>\n<li><p>git diff HEAD<br>比较工作区与暂存区</p>\n<h3 id=\"reset\"><a href=\"#reset\" class=\"headerlink\" title=\"reset\"></a>reset</h3></li>\n<li><p>git reset filename<br>将加入暂存区中的文件撤回到工作区</p>\n</li>\n<li><p>git reset –hard commitid<br>直接回到commitid状态。所有commitid之后的操作全部清空</p>\n</li>\n<li><p>git reset –hard HEAD^<br>回到上次提交的状态，撤销掉最近一次提交</p>\n</li>\n</ul>\n<h3 id=\"restore\"><a href=\"#restore\" class=\"headerlink\" title=\"restore\"></a>restore</h3><ul>\n<li>git restore filename<br>丢弃工作区的改动</li>\n</ul>\n<h3 id=\"log\"><a href=\"#log\" class=\"headerlink\" title=\"log\"></a>log</h3><p>查看git 提交日志</p>\n<ul>\n<li>git log<br>显示详细提交信息</li>\n<li>git log –oneline<br>简单显示提交信息</li>\n</ul>\n<h3 id=\"reflog\"><a href=\"#reflog\" class=\"headerlink\" title=\"reflog\"></a>reflog</h3><p>如果执行了<code>git reset --hard commitid</code>后还想回到commitid以后的某个操作时可以使用此命令，这相当于git log 的log</p>\n<h3 id=\"checkout\"><a href=\"#checkout\" class=\"headerlink\" title=\"checkout\"></a>checkout</h3><p>切换到某个提交的节点</p>\n<ul>\n<li><p>git checkout commitid<br>切换到历史的某个commitid的状态。将HEAD的指针指向某个commitid。如果当前状态是master，要想回到master前面某个提交状态，可以使用<code>git checkout commitid</code>回到commitid中的操作环境看看。在当前状态修改的操作提交后，如果后期回到master状态，修改的操作会丢失。</p>\n</li>\n<li><p>git checkout branchname<br>切换到某个分支</p>\n</li>\n<li><p>git checkout -b branchname<br>创建并切换到某个分支</p>\n</li>\n<li><p>git checkout tagname<br>切换到某个标签</p>\n</li>\n</ul>\n<h3 id=\"status\"><a href=\"#status\" class=\"headerlink\" title=\"status\"></a>status</h3><p>查看当前状态</p>\n<ul>\n<li><p>git status<br>显示当前状态的相信信息</p>\n</li>\n<li><p>git status -s<br>显示当前状态的简单信息</p>\n</li>\n</ul>\n<h3 id=\"branch\"><a href=\"#branch\" class=\"headerlink\" title=\"branch\"></a>branch</h3><p>查看创建分支</p>\n<ul>\n<li><p>git branch<br>查看有哪些分支，带*号的为当前分支</p>\n</li>\n<li><p>git branch name<br>创建一个name的分支</p>\n</li>\n</ul>\n<h3 id=\"merge\"><a href=\"#merge\" class=\"headerlink\" title=\"merge\"></a>merge</h3><p>合并分支</p>\n<ul>\n<li><p>git merge branchname<br>合并某个分支到当前分支。山寨过来就是我的，不会保留信息</p>\n</li>\n<li><p>git merge branchname –no-ff -m ‘init’<br>合并某个分支到当前分支，会保留之前分支的提交记录状态和分支信息。山寨人家，但是会保留人家的信息</p>\n</li>\n</ul>\n<h3 id=\"tag\"><a href=\"#tag\" class=\"headerlink\" title=\"tag\"></a>tag</h3><p>给提交添加标签</p>\n<ul>\n<li>git tag tagname<br>给当前提交添加标签</li>\n</ul>\n<h3 id=\"remote\"><a href=\"#remote\" class=\"headerlink\" title=\"remote\"></a>remote</h3><p>查看远端库信息</p>\n<ul>\n<li><p>git remote<br>查看远端库简要信息    </p>\n</li>\n<li><p>git remote -v //-v == –verbose<br>查看远端库信息带有url</p>\n</li>\n<li><p>git remote add origin url<br>添加一个名字为origin 的远端库地址为url</p>\n</li>\n</ul>\n<h3 id=\"push-1\"><a href=\"#push-1\" class=\"headerlink\" title=\"push\"></a>push</h3><p>推送本地库到远端库</p>\n<ul>\n<li><p>git push<br>推送本地master分支到默认远端库分支</p>\n</li>\n<li><p>git push -u origin<br>第一次推送时可以使用-u参数，指定默认的远端库，设定以后再提交可以直接使用<code>git push</code></p>\n</li>\n<li><p>git push  origin master<br>推送本地master的分支到名为origin远端库的master分支</p>\n</li>\n<li><p>git push  origin master1:master2<br>推送本地分支master1到origin远端库分支master2</p>\n</li>\n<li><p>git push  origin :master2<br>推送一个空分支到origin远端库分支master2</p>\n</li>\n</ul>\n<p><img src=\"Git&GitHub.assets/QQ20200318-211942@2x.png\" alt=\"QQ20200318-211942@2x\"></p>\n<h2 id=\"GitHub\"><a href=\"#GitHub\" class=\"headerlink\" title=\"GitHub\"></a>GitHub</h2><ol>\n<li><p>awesome</p>\n<pre><code>awesome 关键词</code></pre></li>\n</ol>\n<ol start=\"2\">\n<li></li>\n</ol>\n"},{"title":"Kafka","date":"2020-01-13T07:22:21.000Z","_content":"# Kafka\n\n一个分区内的数据才能保证幂等性和有序性\n\n##  架构\n\n![架构图](img/kafka架构.png \"dd\")\n\n## 名次解释\n+ Broker：Kafka服务器\n+ Producer：生产者，生产消息\n+ Consumer：消费者，消费数据\n+ Consumer Group：消费者组，某一个分区只能被同一个消费者组内的一个消费者消费\n+ Topic：消息主题。逻辑概念\n+ Partition：消息分区。消息物理存储上概念\n+ Offset：偏移量\n+ Replia：副本，同一个分区（Partition）内的副本分Leader和Follower\n+ Leader：主副本。对外提供服务\n+ Follower：从副本。做数据同步工作\n+ acks：acknowledgments，消息接收后的确认值\n+ AR（Assigned Replicas）：分区中所有副本\n+ ISR（In-Sync Replicas）：所有与Leader 部分保持一定程度的副本（包含Leader副本在内）组成ISR\n+ OSR（Out-Sync Replicas）：与Leader副本同步滞后过多的副本\n+ HW（High Watermark）：指消费者能够见到的最大Offset，ISR队列中最小的LEO。高水位，标志一个特定的Offset，消费者只能拉取到这个Offset之前的消息，Consumer可见数据的最大偏移量。保证副本数据一致性\n+ LEO（Log End Offset）：每个副本最后一个Offset。即日志末端位移，记录了该副本底层日志中下一条消息的位移值。注意是下一条消息，也就是说如果LEO=10，那么表示该副本保存了10条消息，位移值范围是[0,9]。\n>1 Topic = n Partition\n>1 Partition = n Replica\n\n## Producer（生产者）\n\n拦截器->序列化器->分区器\n\n### 命令\n\n#### 使用脚本\nkafka-console-producer.sh\n\n#### 常用参数\n+ --broker-list\t//kafka集群地址\n+ --topic\t//生产主题\n\n\n#### 举例\nkafka-console-producer.sh\t--broker-list\tlocalhost:9092\t--topic\ttest\n\n### 分区策略\n1. 指定分区（Partition）：直接按照分区号\n2. 没有分区（Partition）但是有Key：（默认）根据Key的Hash值获取分区号\n3. 即没有分区（Partition）也没有Key：第一次险随机获取一个分区号，然后在这个分区号的基础上轮训所有分区号。\n\t\n\t>如果有3个分区，0、1、2当随机获取的分区号为1时，然后1、2、0、1、2、0、1 ... 这样轮询下去\n\n### 发送返回值\nACKS值：\n+ 0：Producer不等待Leader所在的Broker的acks，这一操作保证了最低延迟，Leader所在的Broker一接到消息不等消息保存就会先将ack的值返回给Producer。此值下当Leader所在的Broker宕机时会造成数据丢失\n+ 1：Producer等待Leader所在的Broker的acks，当Leader所在Broker接收到消息保存完消息后才会将ack值返回给Producer。在Leader的消息落盘后还没等Follower同步数据其所在Broker宕机后，就会导致数据丢失。（默认）\n+ -1（all）：Producer等待Leader所在的Broker的acks，当Leader和ISR中的Follower全部将消息落盘之后所在的Broker才会将ack的值返回给Producer。但是如果Follower将消息同步完以后，Leader所在的Broker还没将ack的值返回给Producer之前，Leader所在的Broker发生故障，会造成数据重复\n\n### 幂等性\n设置：enable.idempotence=true\n解决单次会话单个分区数据重复问题\n开启幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带SequenceNumber，而Broker会对<PID，Partition，SequenceNumber>做缓存，当具有相同主键的消息提及时，Broker只会持久化一条。\n\n## Consumer（消费者）\n\n当前消费者需要提交的消费位移是offset+1\n\n### 命令\n\n#### 使用脚本\nkafka-console-consumer.sh\t\n\n#### 常用参数\n+ --bootstrap-server\t//目标服务器地址\n+ --topic\t//消费主题\n\n\n#### 举例\nkafka-console-consumer.sh\t--bootstrap-server\tlocalhost:9092\t--topic\ttest\n\n### 分配策略\n+ RoundRobin\t将订阅的所有主题看作一个整体。（按组分配）\n+ Range\t将订阅的单个主题看作整体。（按主题分配）\n\n## Topic（主题）\n\n###\t命令\n\n#### 使用脚本\nkafka-configs.sh\t//0.9中已经废弃kafka-topics.sh脚本，改用kafka-configs.sh来配置主题\n\n#### 常用参数\n+ --zookeeper\t//zookeeper地址，多个用逗号链接\n+ --create\t//创建命令\n+ --list\t//列出所有主题\n+ --alter\t//修改主题\n+ --delete\t//删除主题\n+ --topic\t//主题\n+ --partitions\t//主题分区数，分区数要小于等于broker数\n+ --replication-fator\t//主题副本数\n\n\n#### 举例\n+ 创建主题：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--create\t--topic\ttest\t--partition\t2\t--replication-fator\t3\n+ 列出所有主题：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--list\n+ 列出主题详情：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--describe\t--topic test\n+ 修改主题：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--alter\t--topic test\n+ 删除主题：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--delete\t--topic test\n\n## Kafka高读写\n\n+ 顺序读写\n+ 零复制\n\t![普通拷贝](./img/普通拷贝.png) \n\t![零拷贝 ](./img/零拷贝.png)\n\t\n\t","source":"notes/Kafka.md","raw":"---\ntitle: Kafka\ndate: 2020-01-13 15:22:21\n---\n# Kafka\n\n一个分区内的数据才能保证幂等性和有序性\n\n##  架构\n\n![架构图](img/kafka架构.png \"dd\")\n\n## 名次解释\n+ Broker：Kafka服务器\n+ Producer：生产者，生产消息\n+ Consumer：消费者，消费数据\n+ Consumer Group：消费者组，某一个分区只能被同一个消费者组内的一个消费者消费\n+ Topic：消息主题。逻辑概念\n+ Partition：消息分区。消息物理存储上概念\n+ Offset：偏移量\n+ Replia：副本，同一个分区（Partition）内的副本分Leader和Follower\n+ Leader：主副本。对外提供服务\n+ Follower：从副本。做数据同步工作\n+ acks：acknowledgments，消息接收后的确认值\n+ AR（Assigned Replicas）：分区中所有副本\n+ ISR（In-Sync Replicas）：所有与Leader 部分保持一定程度的副本（包含Leader副本在内）组成ISR\n+ OSR（Out-Sync Replicas）：与Leader副本同步滞后过多的副本\n+ HW（High Watermark）：指消费者能够见到的最大Offset，ISR队列中最小的LEO。高水位，标志一个特定的Offset，消费者只能拉取到这个Offset之前的消息，Consumer可见数据的最大偏移量。保证副本数据一致性\n+ LEO（Log End Offset）：每个副本最后一个Offset。即日志末端位移，记录了该副本底层日志中下一条消息的位移值。注意是下一条消息，也就是说如果LEO=10，那么表示该副本保存了10条消息，位移值范围是[0,9]。\n>1 Topic = n Partition\n>1 Partition = n Replica\n\n## Producer（生产者）\n\n拦截器->序列化器->分区器\n\n### 命令\n\n#### 使用脚本\nkafka-console-producer.sh\n\n#### 常用参数\n+ --broker-list\t//kafka集群地址\n+ --topic\t//生产主题\n\n\n#### 举例\nkafka-console-producer.sh\t--broker-list\tlocalhost:9092\t--topic\ttest\n\n### 分区策略\n1. 指定分区（Partition）：直接按照分区号\n2. 没有分区（Partition）但是有Key：（默认）根据Key的Hash值获取分区号\n3. 即没有分区（Partition）也没有Key：第一次险随机获取一个分区号，然后在这个分区号的基础上轮训所有分区号。\n\t\n\t>如果有3个分区，0、1、2当随机获取的分区号为1时，然后1、2、0、1、2、0、1 ... 这样轮询下去\n\n### 发送返回值\nACKS值：\n+ 0：Producer不等待Leader所在的Broker的acks，这一操作保证了最低延迟，Leader所在的Broker一接到消息不等消息保存就会先将ack的值返回给Producer。此值下当Leader所在的Broker宕机时会造成数据丢失\n+ 1：Producer等待Leader所在的Broker的acks，当Leader所在Broker接收到消息保存完消息后才会将ack值返回给Producer。在Leader的消息落盘后还没等Follower同步数据其所在Broker宕机后，就会导致数据丢失。（默认）\n+ -1（all）：Producer等待Leader所在的Broker的acks，当Leader和ISR中的Follower全部将消息落盘之后所在的Broker才会将ack的值返回给Producer。但是如果Follower将消息同步完以后，Leader所在的Broker还没将ack的值返回给Producer之前，Leader所在的Broker发生故障，会造成数据重复\n\n### 幂等性\n设置：enable.idempotence=true\n解决单次会话单个分区数据重复问题\n开启幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带SequenceNumber，而Broker会对<PID，Partition，SequenceNumber>做缓存，当具有相同主键的消息提及时，Broker只会持久化一条。\n\n## Consumer（消费者）\n\n当前消费者需要提交的消费位移是offset+1\n\n### 命令\n\n#### 使用脚本\nkafka-console-consumer.sh\t\n\n#### 常用参数\n+ --bootstrap-server\t//目标服务器地址\n+ --topic\t//消费主题\n\n\n#### 举例\nkafka-console-consumer.sh\t--bootstrap-server\tlocalhost:9092\t--topic\ttest\n\n### 分配策略\n+ RoundRobin\t将订阅的所有主题看作一个整体。（按组分配）\n+ Range\t将订阅的单个主题看作整体。（按主题分配）\n\n## Topic（主题）\n\n###\t命令\n\n#### 使用脚本\nkafka-configs.sh\t//0.9中已经废弃kafka-topics.sh脚本，改用kafka-configs.sh来配置主题\n\n#### 常用参数\n+ --zookeeper\t//zookeeper地址，多个用逗号链接\n+ --create\t//创建命令\n+ --list\t//列出所有主题\n+ --alter\t//修改主题\n+ --delete\t//删除主题\n+ --topic\t//主题\n+ --partitions\t//主题分区数，分区数要小于等于broker数\n+ --replication-fator\t//主题副本数\n\n\n#### 举例\n+ 创建主题：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--create\t--topic\ttest\t--partition\t2\t--replication-fator\t3\n+ 列出所有主题：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--list\n+ 列出主题详情：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--describe\t--topic test\n+ 修改主题：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--alter\t--topic test\n+ 删除主题：kafka-configs.sh\t--zookeeper\tlocalhost:9092\t--delete\t--topic test\n\n## Kafka高读写\n\n+ 顺序读写\n+ 零复制\n\t![普通拷贝](./img/普通拷贝.png) \n\t![零拷贝 ](./img/零拷贝.png)\n\t\n\t","updated":"2020-03-18T11:52:16.000Z","path":"notes/Kafka.html","comments":1,"layout":"page","_id":"ck8o1haab000k13s6nerybs6p","content":"<h1 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h1><p>一个分区内的数据才能保证幂等性和有序性</p>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><p><img src=\"img/kafka%E6%9E%B6%E6%9E%84.png\" alt=\"架构图\" title=\"dd\"></p>\n<h2 id=\"名次解释\"><a href=\"#名次解释\" class=\"headerlink\" title=\"名次解释\"></a>名次解释</h2><ul>\n<li>Broker：Kafka服务器</li>\n<li>Producer：生产者，生产消息</li>\n<li>Consumer：消费者，消费数据</li>\n<li>Consumer Group：消费者组，某一个分区只能被同一个消费者组内的一个消费者消费</li>\n<li>Topic：消息主题。逻辑概念</li>\n<li>Partition：消息分区。消息物理存储上概念</li>\n<li>Offset：偏移量</li>\n<li>Replia：副本，同一个分区（Partition）内的副本分Leader和Follower</li>\n<li>Leader：主副本。对外提供服务</li>\n<li>Follower：从副本。做数据同步工作</li>\n<li>acks：acknowledgments，消息接收后的确认值</li>\n<li>AR（Assigned Replicas）：分区中所有副本</li>\n<li>ISR（In-Sync Replicas）：所有与Leader 部分保持一定程度的副本（包含Leader副本在内）组成ISR</li>\n<li>OSR（Out-Sync Replicas）：与Leader副本同步滞后过多的副本</li>\n<li>HW（High Watermark）：指消费者能够见到的最大Offset，ISR队列中最小的LEO。高水位，标志一个特定的Offset，消费者只能拉取到这个Offset之前的消息，Consumer可见数据的最大偏移量。保证副本数据一致性</li>\n<li>LEO（Log End Offset）：每个副本最后一个Offset。即日志末端位移，记录了该副本底层日志中下一条消息的位移值。注意是下一条消息，也就是说如果LEO=10，那么表示该副本保存了10条消息，位移值范围是[0,9]。<blockquote>\n<p>1 Topic = n Partition<br>1 Partition = n Replica</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"Producer（生产者）\"><a href=\"#Producer（生产者）\" class=\"headerlink\" title=\"Producer（生产者）\"></a>Producer（生产者）</h2><p>拦截器-&gt;序列化器-&gt;分区器</p>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><h4 id=\"使用脚本\"><a href=\"#使用脚本\" class=\"headerlink\" title=\"使用脚本\"></a>使用脚本</h4><p>kafka-console-producer.sh</p>\n<h4 id=\"常用参数\"><a href=\"#常用参数\" class=\"headerlink\" title=\"常用参数\"></a>常用参数</h4><ul>\n<li>–broker-list    //kafka集群地址</li>\n<li>–topic    //生产主题</li>\n</ul>\n<h4 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h4><p>kafka-console-producer.sh    –broker-list    localhost:9092    –topic    test</p>\n<h3 id=\"分区策略\"><a href=\"#分区策略\" class=\"headerlink\" title=\"分区策略\"></a>分区策略</h3><ol>\n<li><p>指定分区（Partition）：直接按照分区号</p>\n</li>\n<li><p>没有分区（Partition）但是有Key：（默认）根据Key的Hash值获取分区号</p>\n</li>\n<li><p>即没有分区（Partition）也没有Key：第一次险随机获取一个分区号，然后在这个分区号的基础上轮训所有分区号。</p>\n<blockquote>\n<p>如果有3个分区，0、1、2当随机获取的分区号为1时，然后1、2、0、1、2、0、1 … 这样轮询下去</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"发送返回值\"><a href=\"#发送返回值\" class=\"headerlink\" title=\"发送返回值\"></a>发送返回值</h3><p>ACKS值：</p>\n<ul>\n<li>0：Producer不等待Leader所在的Broker的acks，这一操作保证了最低延迟，Leader所在的Broker一接到消息不等消息保存就会先将ack的值返回给Producer。此值下当Leader所在的Broker宕机时会造成数据丢失</li>\n<li>1：Producer等待Leader所在的Broker的acks，当Leader所在Broker接收到消息保存完消息后才会将ack值返回给Producer。在Leader的消息落盘后还没等Follower同步数据其所在Broker宕机后，就会导致数据丢失。（默认）</li>\n<li>-1（all）：Producer等待Leader所在的Broker的acks，当Leader和ISR中的Follower全部将消息落盘之后所在的Broker才会将ack的值返回给Producer。但是如果Follower将消息同步完以后，Leader所在的Broker还没将ack的值返回给Producer之前，Leader所在的Broker发生故障，会造成数据重复</li>\n</ul>\n<h3 id=\"幂等性\"><a href=\"#幂等性\" class=\"headerlink\" title=\"幂等性\"></a>幂等性</h3><p>设置：enable.idempotence=true<br>解决单次会话单个分区数据重复问题<br>开启幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带SequenceNumber，而Broker会对&lt;PID，Partition，SequenceNumber&gt;做缓存，当具有相同主键的消息提及时，Broker只会持久化一条。</p>\n<h2 id=\"Consumer（消费者）\"><a href=\"#Consumer（消费者）\" class=\"headerlink\" title=\"Consumer（消费者）\"></a>Consumer（消费者）</h2><p>当前消费者需要提交的消费位移是offset+1</p>\n<h3 id=\"命令-1\"><a href=\"#命令-1\" class=\"headerlink\" title=\"命令\"></a>命令</h3><h4 id=\"使用脚本-1\"><a href=\"#使用脚本-1\" class=\"headerlink\" title=\"使用脚本\"></a>使用脚本</h4><p>kafka-console-consumer.sh    </p>\n<h4 id=\"常用参数-1\"><a href=\"#常用参数-1\" class=\"headerlink\" title=\"常用参数\"></a>常用参数</h4><ul>\n<li>–bootstrap-server    //目标服务器地址</li>\n<li>–topic    //消费主题</li>\n</ul>\n<h4 id=\"举例-1\"><a href=\"#举例-1\" class=\"headerlink\" title=\"举例\"></a>举例</h4><p>kafka-console-consumer.sh    –bootstrap-server    localhost:9092    –topic    test</p>\n<h3 id=\"分配策略\"><a href=\"#分配策略\" class=\"headerlink\" title=\"分配策略\"></a>分配策略</h3><ul>\n<li>RoundRobin    将订阅的所有主题看作一个整体。（按组分配）</li>\n<li>Range    将订阅的单个主题看作整体。（按主题分配）</li>\n</ul>\n<h2 id=\"Topic（主题）\"><a href=\"#Topic（主题）\" class=\"headerlink\" title=\"Topic（主题）\"></a>Topic（主题）</h2><h3 id=\"命令-2\"><a href=\"#命令-2\" class=\"headerlink\" title=\"命令\"></a>命令</h3><h4 id=\"使用脚本-2\"><a href=\"#使用脚本-2\" class=\"headerlink\" title=\"使用脚本\"></a>使用脚本</h4><p>kafka-configs.sh    //0.9中已经废弃kafka-topics.sh脚本，改用kafka-configs.sh来配置主题</p>\n<h4 id=\"常用参数-2\"><a href=\"#常用参数-2\" class=\"headerlink\" title=\"常用参数\"></a>常用参数</h4><ul>\n<li>–zookeeper    //zookeeper地址，多个用逗号链接</li>\n<li>–create    //创建命令</li>\n<li>–list    //列出所有主题</li>\n<li>–alter    //修改主题</li>\n<li>–delete    //删除主题</li>\n<li>–topic    //主题</li>\n<li>–partitions    //主题分区数，分区数要小于等于broker数</li>\n<li>–replication-fator    //主题副本数</li>\n</ul>\n<h4 id=\"举例-2\"><a href=\"#举例-2\" class=\"headerlink\" title=\"举例\"></a>举例</h4><ul>\n<li>创建主题：kafka-configs.sh    –zookeeper    localhost:9092    –create    –topic    test    –partition    2    –replication-fator    3</li>\n<li>列出所有主题：kafka-configs.sh    –zookeeper    localhost:9092    –list</li>\n<li>列出主题详情：kafka-configs.sh    –zookeeper    localhost:9092    –describe    –topic test</li>\n<li>修改主题：kafka-configs.sh    –zookeeper    localhost:9092    –alter    –topic test</li>\n<li>删除主题：kafka-configs.sh    –zookeeper    localhost:9092    –delete    –topic test</li>\n</ul>\n<h2 id=\"Kafka高读写\"><a href=\"#Kafka高读写\" class=\"headerlink\" title=\"Kafka高读写\"></a>Kafka高读写</h2><ul>\n<li>顺序读写</li>\n<li>零复制<br>  <img src=\"./img/%E6%99%AE%E9%80%9A%E6%8B%B7%E8%B4%9D.png\" alt=\"普通拷贝\"><br>  <img src=\"./img/%E9%9B%B6%E6%8B%B7%E8%B4%9D.png\" alt=\"零拷贝 \"></li>\n</ul>\n","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<h1 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h1><p>一个分区内的数据才能保证幂等性和有序性</p>\n<h2 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h2><p><img src=\"img/kafka%E6%9E%B6%E6%9E%84.png\" alt=\"架构图\" title=\"dd\"></p>\n<h2 id=\"名次解释\"><a href=\"#名次解释\" class=\"headerlink\" title=\"名次解释\"></a>名次解释</h2><ul>\n<li>Broker：Kafka服务器</li>\n<li>Producer：生产者，生产消息</li>\n<li>Consumer：消费者，消费数据</li>\n<li>Consumer Group：消费者组，某一个分区只能被同一个消费者组内的一个消费者消费</li>\n<li>Topic：消息主题。逻辑概念</li>\n<li>Partition：消息分区。消息物理存储上概念</li>\n<li>Offset：偏移量</li>\n<li>Replia：副本，同一个分区（Partition）内的副本分Leader和Follower</li>\n<li>Leader：主副本。对外提供服务</li>\n<li>Follower：从副本。做数据同步工作</li>\n<li>acks：acknowledgments，消息接收后的确认值</li>\n<li>AR（Assigned Replicas）：分区中所有副本</li>\n<li>ISR（In-Sync Replicas）：所有与Leader 部分保持一定程度的副本（包含Leader副本在内）组成ISR</li>\n<li>OSR（Out-Sync Replicas）：与Leader副本同步滞后过多的副本</li>\n<li>HW（High Watermark）：指消费者能够见到的最大Offset，ISR队列中最小的LEO。高水位，标志一个特定的Offset，消费者只能拉取到这个Offset之前的消息，Consumer可见数据的最大偏移量。保证副本数据一致性</li>\n<li>LEO（Log End Offset）：每个副本最后一个Offset。即日志末端位移，记录了该副本底层日志中下一条消息的位移值。注意是下一条消息，也就是说如果LEO=10，那么表示该副本保存了10条消息，位移值范围是[0,9]。<blockquote>\n<p>1 Topic = n Partition<br>1 Partition = n Replica</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"Producer（生产者）\"><a href=\"#Producer（生产者）\" class=\"headerlink\" title=\"Producer（生产者）\"></a>Producer（生产者）</h2><p>拦截器-&gt;序列化器-&gt;分区器</p>\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><h4 id=\"使用脚本\"><a href=\"#使用脚本\" class=\"headerlink\" title=\"使用脚本\"></a>使用脚本</h4><p>kafka-console-producer.sh</p>\n<h4 id=\"常用参数\"><a href=\"#常用参数\" class=\"headerlink\" title=\"常用参数\"></a>常用参数</h4><ul>\n<li>–broker-list    //kafka集群地址</li>\n<li>–topic    //生产主题</li>\n</ul>\n<h4 id=\"举例\"><a href=\"#举例\" class=\"headerlink\" title=\"举例\"></a>举例</h4><p>kafka-console-producer.sh    –broker-list    localhost:9092    –topic    test</p>\n<h3 id=\"分区策略\"><a href=\"#分区策略\" class=\"headerlink\" title=\"分区策略\"></a>分区策略</h3><ol>\n<li><p>指定分区（Partition）：直接按照分区号</p>\n</li>\n<li><p>没有分区（Partition）但是有Key：（默认）根据Key的Hash值获取分区号</p>\n</li>\n<li><p>即没有分区（Partition）也没有Key：第一次险随机获取一个分区号，然后在这个分区号的基础上轮训所有分区号。</p>\n<blockquote>\n<p>如果有3个分区，0、1、2当随机获取的分区号为1时，然后1、2、0、1、2、0、1 … 这样轮询下去</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"发送返回值\"><a href=\"#发送返回值\" class=\"headerlink\" title=\"发送返回值\"></a>发送返回值</h3><p>ACKS值：</p>\n<ul>\n<li>0：Producer不等待Leader所在的Broker的acks，这一操作保证了最低延迟，Leader所在的Broker一接到消息不等消息保存就会先将ack的值返回给Producer。此值下当Leader所在的Broker宕机时会造成数据丢失</li>\n<li>1：Producer等待Leader所在的Broker的acks，当Leader所在Broker接收到消息保存完消息后才会将ack值返回给Producer。在Leader的消息落盘后还没等Follower同步数据其所在Broker宕机后，就会导致数据丢失。（默认）</li>\n<li>-1（all）：Producer等待Leader所在的Broker的acks，当Leader和ISR中的Follower全部将消息落盘之后所在的Broker才会将ack的值返回给Producer。但是如果Follower将消息同步完以后，Leader所在的Broker还没将ack的值返回给Producer之前，Leader所在的Broker发生故障，会造成数据重复</li>\n</ul>\n<h3 id=\"幂等性\"><a href=\"#幂等性\" class=\"headerlink\" title=\"幂等性\"></a>幂等性</h3><p>设置：enable.idempotence=true<br>解决单次会话单个分区数据重复问题<br>开启幂等性的Producer在初始化的时候会被分配一个PID，发往同一Partition的消息会附带SequenceNumber，而Broker会对&lt;PID，Partition，SequenceNumber&gt;做缓存，当具有相同主键的消息提及时，Broker只会持久化一条。</p>\n<h2 id=\"Consumer（消费者）\"><a href=\"#Consumer（消费者）\" class=\"headerlink\" title=\"Consumer（消费者）\"></a>Consumer（消费者）</h2><p>当前消费者需要提交的消费位移是offset+1</p>\n<h3 id=\"命令-1\"><a href=\"#命令-1\" class=\"headerlink\" title=\"命令\"></a>命令</h3><h4 id=\"使用脚本-1\"><a href=\"#使用脚本-1\" class=\"headerlink\" title=\"使用脚本\"></a>使用脚本</h4><p>kafka-console-consumer.sh    </p>\n<h4 id=\"常用参数-1\"><a href=\"#常用参数-1\" class=\"headerlink\" title=\"常用参数\"></a>常用参数</h4><ul>\n<li>–bootstrap-server    //目标服务器地址</li>\n<li>–topic    //消费主题</li>\n</ul>\n<h4 id=\"举例-1\"><a href=\"#举例-1\" class=\"headerlink\" title=\"举例\"></a>举例</h4><p>kafka-console-consumer.sh    –bootstrap-server    localhost:9092    –topic    test</p>\n<h3 id=\"分配策略\"><a href=\"#分配策略\" class=\"headerlink\" title=\"分配策略\"></a>分配策略</h3><ul>\n<li>RoundRobin    将订阅的所有主题看作一个整体。（按组分配）</li>\n<li>Range    将订阅的单个主题看作整体。（按主题分配）</li>\n</ul>\n<h2 id=\"Topic（主题）\"><a href=\"#Topic（主题）\" class=\"headerlink\" title=\"Topic（主题）\"></a>Topic（主题）</h2><h3 id=\"命令-2\"><a href=\"#命令-2\" class=\"headerlink\" title=\"命令\"></a>命令</h3><h4 id=\"使用脚本-2\"><a href=\"#使用脚本-2\" class=\"headerlink\" title=\"使用脚本\"></a>使用脚本</h4><p>kafka-configs.sh    //0.9中已经废弃kafka-topics.sh脚本，改用kafka-configs.sh来配置主题</p>\n<h4 id=\"常用参数-2\"><a href=\"#常用参数-2\" class=\"headerlink\" title=\"常用参数\"></a>常用参数</h4><ul>\n<li>–zookeeper    //zookeeper地址，多个用逗号链接</li>\n<li>–create    //创建命令</li>\n<li>–list    //列出所有主题</li>\n<li>–alter    //修改主题</li>\n<li>–delete    //删除主题</li>\n<li>–topic    //主题</li>\n<li>–partitions    //主题分区数，分区数要小于等于broker数</li>\n<li>–replication-fator    //主题副本数</li>\n</ul>\n<h4 id=\"举例-2\"><a href=\"#举例-2\" class=\"headerlink\" title=\"举例\"></a>举例</h4><ul>\n<li>创建主题：kafka-configs.sh    –zookeeper    localhost:9092    –create    –topic    test    –partition    2    –replication-fator    3</li>\n<li>列出所有主题：kafka-configs.sh    –zookeeper    localhost:9092    –list</li>\n<li>列出主题详情：kafka-configs.sh    –zookeeper    localhost:9092    –describe    –topic test</li>\n<li>修改主题：kafka-configs.sh    –zookeeper    localhost:9092    –alter    –topic test</li>\n<li>删除主题：kafka-configs.sh    –zookeeper    localhost:9092    –delete    –topic test</li>\n</ul>\n<h2 id=\"Kafka高读写\"><a href=\"#Kafka高读写\" class=\"headerlink\" title=\"Kafka高读写\"></a>Kafka高读写</h2><ul>\n<li>顺序读写</li>\n<li>零复制<br>  <img src=\"./img/%E6%99%AE%E9%80%9A%E6%8B%B7%E8%B4%9D.png\" alt=\"普通拷贝\"><br>  <img src=\"./img/%E9%9B%B6%E6%8B%B7%E8%B4%9D.png\" alt=\"零拷贝 \"></li>\n</ul>\n"},{"_content":"1. 表的数据加载\n\n   1. insert\n   2. load\n\n2. 创建分区表（外表）\n\n3. 数据导出\n\n   1. hdfs dfs -get filename\n\n   2. hdfs dfs -text filename    //查看\n\n      1. insert overwrite 【local】 directory 'filename'\n\n         【row format delimited fields terminated by '\\t'】\n\n         select col， col1 from tablename\n\n         //local 与 row。。 只能在导出到本地时使用\n\n   3. Shell 命令加管道：hive -f/e | sed/awk/gred >filename\n\n   4. sqoop\n\n   5. 动态分区\n\n      1. 设置 set hive.exec.dynamic.partition=true //设置使用动态分区\n      2. 设置 set hive.exec.dynamic.partition.mode=nonstrict //使用无限制模式\n      3. insert into table tablename partition(dt) select col,col1 as dt from tablename  //一个分区 动态设置\n      4. Insert into table tablename partition(dt='2017',value) select col,col1 as value from tablename //两个分区 ，静态分区必须在设置的动态分区前面\n\n   6. 修改表\n\n      1. 重命名表 alter table tablename rename to newtablename;\n\n      2. 修改列名 alter table tablename change column c1 c2 int comment 'xxx';\n\n      3. 移动列的位置 alter table  tablename change column c1 c2 after c3;\n\n      4. 增加列 alter table tablename add columns(c1 string comment 'xxx',c2 int);\n\n      5. 删除列 alter table tablename replace columns(col string,col1 int) \n\n         //col col1 都是保留下来的列\n\n      6. 修改分割符 alter table tablename【partition(dt='xxxx')】 set serdeproperties('field.delim'='\\t')\n\n      7. 修改location;\n\n          alter table tablename 【partition()】set location 'path'\n\n      8. 内部表改外部表 \n\n         alter table tablename set tblproperties('EXTERNAL'='TRUE')  \n\n         //外部表改内部表 EXTERNAL=FALSE；\n\n   7. group by：\n\n      select col1,col2 from tablename group by col1,col2\n\n      //查询的列 col1，col2 必须出现在group by后面；\n\n   8. sum(col)  //col可为int，double 等数字类型也可以为string类型\n\n   9. 在hive中使用python脚本\n\n      add file filenamepath //先将脚本缓存到hive集群上\n\n      select * from ( select transform (col,col1) using 'filename' 【as coll ,coll2】from tablename  ) tablename\n\n   10. 【inner】join，left 【outer】 join，right 【outer】 join, full 【outer】 join，\n\n     /* +mapjoin(tablename) */,left semi join 相当于in \n\n   11. 函数\n\n       1. nvl(col,0) //如果col非空则显示col否则显示0\n       2. 【nvl2(col1,col2,col3) //如果col1为空则显示col2否则显示col3】\n       3. 【nullif(col1,col2) //如果col1与col2相等则返回null否则返回col1】\n       4. coalesce(col1,col2,col3….) //返回第一个非空（null）值，如果都为空则返回null\n       5. concat(col1,col2….) //字符串拼接，如果col1或col2中有一个为null则返回null\n       6. concat_ws(',',col1,col2…..) //带有分隔符的字符串拼接，如果有col2为null则不会拼接，拼接的内容可以为array\n       7. cast(1 as bigint) //转化1为bigint\n       8. round(0.0089,4) //保留4位小数\n       9. if (condition,a,b) //若condition为真则返回a，否则返回b；\n       10. explode(array(or map)) //将输入的一行数组或map转换成列输出\n       11. split(str,',') //第一个参数是要分隔的字符串，第二个参数是分隔符，分隔后的数据可看成数组\n\n   12. distribute by 打散数据 长和sort by（使每一个reduce里面的数据都有序）连用。distribute by 与group by 都是安key对数据进行划分，都使用reduce操作，但是distribute by只是将数据分散，而group by 是把相同的key聚集到一起然后进行聚合操作。sort by与order by，order by 是全局排序，只会有一个reduce ，sort by是确保每一个reduce 上的数据都是有序的，如果只有一个reduce时，sort by 和order by作用是一样的。\n\n   13. cluster by\n\n   14. unoin all\n\n   15. 自定义UDF：\n\n       重写evaluate函数\n\n   16. 优化：\n\n       1. join优化\n\n          hive.optimize.skewjoin=true\n\n          hive.skewjoin.key=n //当key的数量到达n时会主动进行优化\n\n       2. mapjoin\n\n          hive.atuo.conwert.join=true\n\n          hive.mapjoin.smalltable.filesize=n\n\n          select /*+mapjoin(a) */,col1,col2 form a join b\n\n          注：a表要非常小，mapjoin因为是在map端操作可以进行不等值操作\n\n       3. group by \n\n          hive.groupby.skewindata=true\n\n          Hive.groupby.mapaggr.checkinterval=n\n\n       4. job\n\n          hive.exec.parallel=true. //设置job的并行化\n\n          hive.exec.parallel.thread.numbe=n //设置最大线程数\n\n          hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat //合并文件，文件受mapred.max.split.size大小的限制\n\n          Hive.merge.smallfiles.avgsize=n  //设置输出文件平均大小小于改值，启动job合并文件\n\n          Hive.merge.size.per.task=n //合并之后文件的大小\n\n       5. \n\n       6. \n\n          \n\n   17. yarn queue -status mt1\n\n   18. mapred【hadoop】 queue -list\n\n   19. \n\n   20. \n\n       \n\n   21. 命令：\n\n       1. mapred[hadoop] job -list | grep o2o4 //查job\n       2. ps -ef| grep xxxx.sh | grep -v grep // 查进程\n       3. mapred[hadoop] queue -list // 查队列（所有）\n       4. yarn queue -status o2o4  //查队列（单个）\n       5. du -h //查文件大小\n       6. sed -n 's/old/new/gp' filename //-n  代表行   g 全局 p 打印  \n       7. 使用”;”时，不管command1是否执行成功都会执行command2； 使用”&&”时，只有command1执行成功后，command2才会执行，否则command2不执行；使用”||”时，command1执行成功后command2 不执行，否则去执行command2，总之command1和command2总有一条命令会执行。\n       8. \n\n\n* hive 分区下有数据但是查询表没有数据\n\n  可以是表的读入设置了压缩等其他格式，单纯txt的文件，表无法读取\n\n  STORED AS INPUTFORMAT \n    'com.hadoop.mapred.DeprecatedLzoTextInputFormat'   //设置压缩为lzo 所以只能读取lzo数据\n\n* Hive count(distinct ) 优化\n\n  可以先进行group by  然后再进行count\n\n  ```sql\n  select count(*),count(distinct col) from tablename where day_id=20180708\n  ```\n\n\n  select max(cnt), max(mdn_cnt), max(day_id) from (select null  as cnt , count(*) as mdn_cnt , day_id  as day_id from (select mdn, day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by mdn,day_id )a group by  day_id union all select count(*) as cnt, null  as mdn_cnt , day_id as day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by day_id )b;//union all\n\n\n  select b.cnt,a.mdn_cnt ,a.day_id from (\n  select count(*) as mdn_cnt ,day_id from (select mdn,day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by mdn,day_id)a1 group by day_id)a\n  left join \n  (select count(*) as cnt, day_id from dwi_m.dwi_res_regn_mergelocation_msk_d  b where day_id=20180708 group by day_id)b\n  on a.day_id=b.day_id;//join\n\n\n  join 和 union all 用的时间差不多  但相对 直接count distinct 要 少很多","source":"notes/Hive.md","raw":"1. 表的数据加载\n\n   1. insert\n   2. load\n\n2. 创建分区表（外表）\n\n3. 数据导出\n\n   1. hdfs dfs -get filename\n\n   2. hdfs dfs -text filename    //查看\n\n      1. insert overwrite 【local】 directory 'filename'\n\n         【row format delimited fields terminated by '\\t'】\n\n         select col， col1 from tablename\n\n         //local 与 row。。 只能在导出到本地时使用\n\n   3. Shell 命令加管道：hive -f/e | sed/awk/gred >filename\n\n   4. sqoop\n\n   5. 动态分区\n\n      1. 设置 set hive.exec.dynamic.partition=true //设置使用动态分区\n      2. 设置 set hive.exec.dynamic.partition.mode=nonstrict //使用无限制模式\n      3. insert into table tablename partition(dt) select col,col1 as dt from tablename  //一个分区 动态设置\n      4. Insert into table tablename partition(dt='2017',value) select col,col1 as value from tablename //两个分区 ，静态分区必须在设置的动态分区前面\n\n   6. 修改表\n\n      1. 重命名表 alter table tablename rename to newtablename;\n\n      2. 修改列名 alter table tablename change column c1 c2 int comment 'xxx';\n\n      3. 移动列的位置 alter table  tablename change column c1 c2 after c3;\n\n      4. 增加列 alter table tablename add columns(c1 string comment 'xxx',c2 int);\n\n      5. 删除列 alter table tablename replace columns(col string,col1 int) \n\n         //col col1 都是保留下来的列\n\n      6. 修改分割符 alter table tablename【partition(dt='xxxx')】 set serdeproperties('field.delim'='\\t')\n\n      7. 修改location;\n\n          alter table tablename 【partition()】set location 'path'\n\n      8. 内部表改外部表 \n\n         alter table tablename set tblproperties('EXTERNAL'='TRUE')  \n\n         //外部表改内部表 EXTERNAL=FALSE；\n\n   7. group by：\n\n      select col1,col2 from tablename group by col1,col2\n\n      //查询的列 col1，col2 必须出现在group by后面；\n\n   8. sum(col)  //col可为int，double 等数字类型也可以为string类型\n\n   9. 在hive中使用python脚本\n\n      add file filenamepath //先将脚本缓存到hive集群上\n\n      select * from ( select transform (col,col1) using 'filename' 【as coll ,coll2】from tablename  ) tablename\n\n   10. 【inner】join，left 【outer】 join，right 【outer】 join, full 【outer】 join，\n\n     /* +mapjoin(tablename) */,left semi join 相当于in \n\n   11. 函数\n\n       1. nvl(col,0) //如果col非空则显示col否则显示0\n       2. 【nvl2(col1,col2,col3) //如果col1为空则显示col2否则显示col3】\n       3. 【nullif(col1,col2) //如果col1与col2相等则返回null否则返回col1】\n       4. coalesce(col1,col2,col3….) //返回第一个非空（null）值，如果都为空则返回null\n       5. concat(col1,col2….) //字符串拼接，如果col1或col2中有一个为null则返回null\n       6. concat_ws(',',col1,col2…..) //带有分隔符的字符串拼接，如果有col2为null则不会拼接，拼接的内容可以为array\n       7. cast(1 as bigint) //转化1为bigint\n       8. round(0.0089,4) //保留4位小数\n       9. if (condition,a,b) //若condition为真则返回a，否则返回b；\n       10. explode(array(or map)) //将输入的一行数组或map转换成列输出\n       11. split(str,',') //第一个参数是要分隔的字符串，第二个参数是分隔符，分隔后的数据可看成数组\n\n   12. distribute by 打散数据 长和sort by（使每一个reduce里面的数据都有序）连用。distribute by 与group by 都是安key对数据进行划分，都使用reduce操作，但是distribute by只是将数据分散，而group by 是把相同的key聚集到一起然后进行聚合操作。sort by与order by，order by 是全局排序，只会有一个reduce ，sort by是确保每一个reduce 上的数据都是有序的，如果只有一个reduce时，sort by 和order by作用是一样的。\n\n   13. cluster by\n\n   14. unoin all\n\n   15. 自定义UDF：\n\n       重写evaluate函数\n\n   16. 优化：\n\n       1. join优化\n\n          hive.optimize.skewjoin=true\n\n          hive.skewjoin.key=n //当key的数量到达n时会主动进行优化\n\n       2. mapjoin\n\n          hive.atuo.conwert.join=true\n\n          hive.mapjoin.smalltable.filesize=n\n\n          select /*+mapjoin(a) */,col1,col2 form a join b\n\n          注：a表要非常小，mapjoin因为是在map端操作可以进行不等值操作\n\n       3. group by \n\n          hive.groupby.skewindata=true\n\n          Hive.groupby.mapaggr.checkinterval=n\n\n       4. job\n\n          hive.exec.parallel=true. //设置job的并行化\n\n          hive.exec.parallel.thread.numbe=n //设置最大线程数\n\n          hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat //合并文件，文件受mapred.max.split.size大小的限制\n\n          Hive.merge.smallfiles.avgsize=n  //设置输出文件平均大小小于改值，启动job合并文件\n\n          Hive.merge.size.per.task=n //合并之后文件的大小\n\n       5. \n\n       6. \n\n          \n\n   17. yarn queue -status mt1\n\n   18. mapred【hadoop】 queue -list\n\n   19. \n\n   20. \n\n       \n\n   21. 命令：\n\n       1. mapred[hadoop] job -list | grep o2o4 //查job\n       2. ps -ef| grep xxxx.sh | grep -v grep // 查进程\n       3. mapred[hadoop] queue -list // 查队列（所有）\n       4. yarn queue -status o2o4  //查队列（单个）\n       5. du -h //查文件大小\n       6. sed -n 's/old/new/gp' filename //-n  代表行   g 全局 p 打印  \n       7. 使用”;”时，不管command1是否执行成功都会执行command2； 使用”&&”时，只有command1执行成功后，command2才会执行，否则command2不执行；使用”||”时，command1执行成功后command2 不执行，否则去执行command2，总之command1和command2总有一条命令会执行。\n       8. \n\n\n* hive 分区下有数据但是查询表没有数据\n\n  可以是表的读入设置了压缩等其他格式，单纯txt的文件，表无法读取\n\n  STORED AS INPUTFORMAT \n    'com.hadoop.mapred.DeprecatedLzoTextInputFormat'   //设置压缩为lzo 所以只能读取lzo数据\n\n* Hive count(distinct ) 优化\n\n  可以先进行group by  然后再进行count\n\n  ```sql\n  select count(*),count(distinct col) from tablename where day_id=20180708\n  ```\n\n\n  select max(cnt), max(mdn_cnt), max(day_id) from (select null  as cnt , count(*) as mdn_cnt , day_id  as day_id from (select mdn, day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by mdn,day_id )a group by  day_id union all select count(*) as cnt, null  as mdn_cnt , day_id as day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by day_id )b;//union all\n\n\n  select b.cnt,a.mdn_cnt ,a.day_id from (\n  select count(*) as mdn_cnt ,day_id from (select mdn,day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by mdn,day_id)a1 group by day_id)a\n  left join \n  (select count(*) as cnt, day_id from dwi_m.dwi_res_regn_mergelocation_msk_d  b where day_id=20180708 group by day_id)b\n  on a.day_id=b.day_id;//join\n\n\n  join 和 union all 用的时间差不多  但相对 直接count distinct 要 少很多","date":"2020-03-19T05:09:33.000Z","updated":"2020-03-18T11:52:16.000Z","path":"notes/Hive.html","title":"","comments":1,"layout":"page","_id":"ck8o1haac000l13s6xbegs2ea","content":"<ol>\n<li><p>表的数据加载</p>\n<ol>\n<li>insert</li>\n<li>load</li>\n</ol>\n</li>\n<li><p>创建分区表（外表）</p>\n</li>\n<li><p>数据导出</p>\n<ol>\n<li><p>hdfs dfs -get filename</p>\n</li>\n<li><p>hdfs dfs -text filename    //查看</p>\n<ol>\n<li><p>insert overwrite 【local】 directory ‘filename’</p>\n<p>【row format delimited fields terminated by ‘\\t’】</p>\n<p>select col， col1 from tablename</p>\n<p>//local 与 row。。 只能在导出到本地时使用</p>\n</li>\n</ol>\n</li>\n<li><p>Shell 命令加管道：hive -f/e | sed/awk/gred &gt;filename</p>\n</li>\n<li><p>sqoop</p>\n</li>\n<li><p>动态分区</p>\n<ol>\n<li>设置 set hive.exec.dynamic.partition=true //设置使用动态分区</li>\n<li>设置 set hive.exec.dynamic.partition.mode=nonstrict //使用无限制模式</li>\n<li>insert into table tablename partition(dt) select col,col1 as dt from tablename  //一个分区 动态设置</li>\n<li>Insert into table tablename partition(dt=’2017’,value) select col,col1 as value from tablename //两个分区 ，静态分区必须在设置的动态分区前面</li>\n</ol>\n</li>\n<li><p>修改表</p>\n<ol>\n<li><p>重命名表 alter table tablename rename to newtablename;</p>\n</li>\n<li><p>修改列名 alter table tablename change column c1 c2 int comment ‘xxx’;</p>\n</li>\n<li><p>移动列的位置 alter table  tablename change column c1 c2 after c3;</p>\n</li>\n<li><p>增加列 alter table tablename add columns(c1 string comment ‘xxx’,c2 int);</p>\n</li>\n<li><p>删除列 alter table tablename replace columns(col string,col1 int) </p>\n<p>//col col1 都是保留下来的列</p>\n</li>\n<li><p>修改分割符 alter table tablename【partition(dt=’xxxx’)】 set serdeproperties(‘field.delim’=’\\t’)</p>\n</li>\n<li><p>修改location;</p>\n<p> alter table tablename 【partition()】set location ‘path’</p>\n</li>\n<li><p>内部表改外部表 </p>\n<p>alter table tablename set tblproperties(‘EXTERNAL’=’TRUE’)  </p>\n<p>//外部表改内部表 EXTERNAL=FALSE；</p>\n</li>\n</ol>\n</li>\n<li><p>group by：</p>\n<p>select col1,col2 from tablename group by col1,col2</p>\n<p>//查询的列 col1，col2 必须出现在group by后面；</p>\n</li>\n<li><p>sum(col)  //col可为int，double 等数字类型也可以为string类型</p>\n</li>\n<li><p>在hive中使用python脚本</p>\n<p>add file filenamepath //先将脚本缓存到hive集群上</p>\n<p>select * from ( select transform (col,col1) using ‘filename’ 【as coll ,coll2】from tablename  ) tablename</p>\n</li>\n<li><p>【inner】join，left 【outer】 join，right 【outer】 join, full 【outer】 join，</p>\n<p>/* +mapjoin(tablename) */,left semi join 相当于in </p>\n</li>\n<li><p>函数</p>\n<ol>\n<li>nvl(col,0) //如果col非空则显示col否则显示0</li>\n<li>【nvl2(col1,col2,col3) //如果col1为空则显示col2否则显示col3】</li>\n<li>【nullif(col1,col2) //如果col1与col2相等则返回null否则返回col1】</li>\n<li>coalesce(col1,col2,col3….) //返回第一个非空（null）值，如果都为空则返回null</li>\n<li>concat(col1,col2….) //字符串拼接，如果col1或col2中有一个为null则返回null</li>\n<li>concat_ws(‘,’,col1,col2…..) //带有分隔符的字符串拼接，如果有col2为null则不会拼接，拼接的内容可以为array</li>\n<li>cast(1 as bigint) //转化1为bigint</li>\n<li>round(0.0089,4) //保留4位小数</li>\n<li>if (condition,a,b) //若condition为真则返回a，否则返回b；</li>\n<li>explode(array(or map)) //将输入的一行数组或map转换成列输出</li>\n<li>split(str,’,’) //第一个参数是要分隔的字符串，第二个参数是分隔符，分隔后的数据可看成数组</li>\n</ol>\n</li>\n<li><p>distribute by 打散数据 长和sort by（使每一个reduce里面的数据都有序）连用。distribute by 与group by 都是安key对数据进行划分，都使用reduce操作，但是distribute by只是将数据分散，而group by 是把相同的key聚集到一起然后进行聚合操作。sort by与order by，order by 是全局排序，只会有一个reduce ，sort by是确保每一个reduce 上的数据都是有序的，如果只有一个reduce时，sort by 和order by作用是一样的。</p>\n</li>\n<li><p>cluster by</p>\n</li>\n<li><p>unoin all</p>\n</li>\n<li><p>自定义UDF：</p>\n<p>重写evaluate函数</p>\n</li>\n<li><p>优化：</p>\n<ol>\n<li><p>join优化</p>\n<p>hive.optimize.skewjoin=true</p>\n<p>hive.skewjoin.key=n //当key的数量到达n时会主动进行优化</p>\n</li>\n<li><p>mapjoin</p>\n<p>hive.atuo.conwert.join=true</p>\n<p>hive.mapjoin.smalltable.filesize=n</p>\n<p>select /*+mapjoin(a) */,col1,col2 form a join b</p>\n<p>注：a表要非常小，mapjoin因为是在map端操作可以进行不等值操作</p>\n</li>\n<li><p>group by </p>\n<p>hive.groupby.skewindata=true</p>\n<p>Hive.groupby.mapaggr.checkinterval=n</p>\n</li>\n<li><p>job</p>\n<p>hive.exec.parallel=true. //设置job的并行化</p>\n<p>hive.exec.parallel.thread.numbe=n //设置最大线程数</p>\n<p>hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat //合并文件，文件受mapred.max.split.size大小的限制</p>\n<p>Hive.merge.smallfiles.avgsize=n  //设置输出文件平均大小小于改值，启动job合并文件</p>\n<p>Hive.merge.size.per.task=n //合并之后文件的大小</p>\n</li>\n<li></li>\n<li></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<ol start=\"17\">\n<li><p>yarn queue -status mt1</p>\n</li>\n<li><p>mapred【hadoop】 queue -list</p>\n</li>\n<li></li>\n<li></li>\n</ol>\n<ol start=\"21\">\n<li><p>命令：</p>\n<ol>\n<li>mapred[hadoop] job -list | grep o2o4 //查job</li>\n<li>ps -ef| grep xxxx.sh | grep -v grep // 查进程</li>\n<li>mapred[hadoop] queue -list // 查队列（所有）</li>\n<li>yarn queue -status o2o4  //查队列（单个）</li>\n<li>du -h //查文件大小</li>\n<li>sed -n ‘s/old/new/gp’ filename //-n  代表行   g 全局 p 打印  </li>\n<li>使用”;”时，不管command1是否执行成功都会执行command2； 使用”&amp;&amp;”时，只有command1执行成功后，command2才会执行，否则command2不执行；使用”||”时，command1执行成功后command2 不执行，否则去执行command2，总之command1和command2总有一条命令会执行。</li>\n<li></li>\n</ol>\n</li>\n</ol>\n<ul>\n<li><p>hive 分区下有数据但是查询表没有数据</p>\n<p>可以是表的读入设置了压缩等其他格式，单纯txt的文件，表无法读取</p>\n<p>STORED AS INPUTFORMAT<br>  ‘com.hadoop.mapred.DeprecatedLzoTextInputFormat’   //设置压缩为lzo 所以只能读取lzo数据</p>\n</li>\n<li><p>Hive count(distinct ) 优化</p>\n<p>可以先进行group by  然后再进行count</p>\n<pre class=\" language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span> <span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span><span class=\"token function\">count</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">distinct</span> col<span class=\"token punctuation\">)</span> <span class=\"token keyword\">from</span> tablename <span class=\"token keyword\">where</span> day_id<span class=\"token operator\">=</span><span class=\"token number\">20180708</span></code></pre>\n</li>\n</ul>\n<p>  select max(cnt), max(mdn_cnt), max(day_id) from (select null  as cnt , count(<em>) as mdn_cnt , day_id  as day_id from (select mdn, day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by mdn,day_id )a group by  day_id union all select count(</em>) as cnt, null  as mdn_cnt , day_id as day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by day_id )b;//union all</p>\n<p>  select b.cnt,a.mdn_cnt ,a.day_id from (<br>  select count(<em>) as mdn_cnt ,day_id from (select mdn,day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by mdn,day_id)a1 group by day_id)a<br>  left join<br>  (select count(</em>) as cnt, day_id from dwi_m.dwi_res_regn_mergelocation_msk_d  b where day_id=20180708 group by day_id)b<br>  on a.day_id=b.day_id;//join</p>\n<p>  join 和 union all 用的时间差不多  但相对 直接count distinct 要 少很多</p>\n","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<ol>\n<li><p>表的数据加载</p>\n<ol>\n<li>insert</li>\n<li>load</li>\n</ol>\n</li>\n<li><p>创建分区表（外表）</p>\n</li>\n<li><p>数据导出</p>\n<ol>\n<li><p>hdfs dfs -get filename</p>\n</li>\n<li><p>hdfs dfs -text filename    //查看</p>\n<ol>\n<li><p>insert overwrite 【local】 directory ‘filename’</p>\n<p>【row format delimited fields terminated by ‘\\t’】</p>\n<p>select col， col1 from tablename</p>\n<p>//local 与 row。。 只能在导出到本地时使用</p>\n</li>\n</ol>\n</li>\n<li><p>Shell 命令加管道：hive -f/e | sed/awk/gred &gt;filename</p>\n</li>\n<li><p>sqoop</p>\n</li>\n<li><p>动态分区</p>\n<ol>\n<li>设置 set hive.exec.dynamic.partition=true //设置使用动态分区</li>\n<li>设置 set hive.exec.dynamic.partition.mode=nonstrict //使用无限制模式</li>\n<li>insert into table tablename partition(dt) select col,col1 as dt from tablename  //一个分区 动态设置</li>\n<li>Insert into table tablename partition(dt=’2017’,value) select col,col1 as value from tablename //两个分区 ，静态分区必须在设置的动态分区前面</li>\n</ol>\n</li>\n<li><p>修改表</p>\n<ol>\n<li><p>重命名表 alter table tablename rename to newtablename;</p>\n</li>\n<li><p>修改列名 alter table tablename change column c1 c2 int comment ‘xxx’;</p>\n</li>\n<li><p>移动列的位置 alter table  tablename change column c1 c2 after c3;</p>\n</li>\n<li><p>增加列 alter table tablename add columns(c1 string comment ‘xxx’,c2 int);</p>\n</li>\n<li><p>删除列 alter table tablename replace columns(col string,col1 int) </p>\n<p>//col col1 都是保留下来的列</p>\n</li>\n<li><p>修改分割符 alter table tablename【partition(dt=’xxxx’)】 set serdeproperties(‘field.delim’=’\\t’)</p>\n</li>\n<li><p>修改location;</p>\n<p> alter table tablename 【partition()】set location ‘path’</p>\n</li>\n<li><p>内部表改外部表 </p>\n<p>alter table tablename set tblproperties(‘EXTERNAL’=’TRUE’)  </p>\n<p>//外部表改内部表 EXTERNAL=FALSE；</p>\n</li>\n</ol>\n</li>\n<li><p>group by：</p>\n<p>select col1,col2 from tablename group by col1,col2</p>\n<p>//查询的列 col1，col2 必须出现在group by后面；</p>\n</li>\n<li><p>sum(col)  //col可为int，double 等数字类型也可以为string类型</p>\n</li>\n<li><p>在hive中使用python脚本</p>\n<p>add file filenamepath //先将脚本缓存到hive集群上</p>\n<p>select * from ( select transform (col,col1) using ‘filename’ 【as coll ,coll2】from tablename  ) tablename</p>\n</li>\n<li><p>【inner】join，left 【outer】 join，right 【outer】 join, full 【outer】 join，</p>\n<p>/* +mapjoin(tablename) */,left semi join 相当于in </p>\n</li>\n<li><p>函数</p>\n<ol>\n<li>nvl(col,0) //如果col非空则显示col否则显示0</li>\n<li>【nvl2(col1,col2,col3) //如果col1为空则显示col2否则显示col3】</li>\n<li>【nullif(col1,col2) //如果col1与col2相等则返回null否则返回col1】</li>\n<li>coalesce(col1,col2,col3….) //返回第一个非空（null）值，如果都为空则返回null</li>\n<li>concat(col1,col2….) //字符串拼接，如果col1或col2中有一个为null则返回null</li>\n<li>concat_ws(‘,’,col1,col2…..) //带有分隔符的字符串拼接，如果有col2为null则不会拼接，拼接的内容可以为array</li>\n<li>cast(1 as bigint) //转化1为bigint</li>\n<li>round(0.0089,4) //保留4位小数</li>\n<li>if (condition,a,b) //若condition为真则返回a，否则返回b；</li>\n<li>explode(array(or map)) //将输入的一行数组或map转换成列输出</li>\n<li>split(str,’,’) //第一个参数是要分隔的字符串，第二个参数是分隔符，分隔后的数据可看成数组</li>\n</ol>\n</li>\n<li><p>distribute by 打散数据 长和sort by（使每一个reduce里面的数据都有序）连用。distribute by 与group by 都是安key对数据进行划分，都使用reduce操作，但是distribute by只是将数据分散，而group by 是把相同的key聚集到一起然后进行聚合操作。sort by与order by，order by 是全局排序，只会有一个reduce ，sort by是确保每一个reduce 上的数据都是有序的，如果只有一个reduce时，sort by 和order by作用是一样的。</p>\n</li>\n<li><p>cluster by</p>\n</li>\n<li><p>unoin all</p>\n</li>\n<li><p>自定义UDF：</p>\n<p>重写evaluate函数</p>\n</li>\n<li><p>优化：</p>\n<ol>\n<li><p>join优化</p>\n<p>hive.optimize.skewjoin=true</p>\n<p>hive.skewjoin.key=n //当key的数量到达n时会主动进行优化</p>\n</li>\n<li><p>mapjoin</p>\n<p>hive.atuo.conwert.join=true</p>\n<p>hive.mapjoin.smalltable.filesize=n</p>\n<p>select /*+mapjoin(a) */,col1,col2 form a join b</p>\n<p>注：a表要非常小，mapjoin因为是在map端操作可以进行不等值操作</p>\n</li>\n<li><p>group by </p>\n<p>hive.groupby.skewindata=true</p>\n<p>Hive.groupby.mapaggr.checkinterval=n</p>\n</li>\n<li><p>job</p>\n<p>hive.exec.parallel=true. //设置job的并行化</p>\n<p>hive.exec.parallel.thread.numbe=n //设置最大线程数</p>\n<p>hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat //合并文件，文件受mapred.max.split.size大小的限制</p>\n<p>Hive.merge.smallfiles.avgsize=n  //设置输出文件平均大小小于改值，启动job合并文件</p>\n<p>Hive.merge.size.per.task=n //合并之后文件的大小</p>\n</li>\n<li></li>\n<li></li>\n</ol>\n</li>\n</ol>\n</li>\n</ol>\n<ol start=\"17\">\n<li><p>yarn queue -status mt1</p>\n</li>\n<li><p>mapred【hadoop】 queue -list</p>\n</li>\n<li></li>\n<li></li>\n</ol>\n<ol start=\"21\">\n<li><p>命令：</p>\n<ol>\n<li>mapred[hadoop] job -list | grep o2o4 //查job</li>\n<li>ps -ef| grep xxxx.sh | grep -v grep // 查进程</li>\n<li>mapred[hadoop] queue -list // 查队列（所有）</li>\n<li>yarn queue -status o2o4  //查队列（单个）</li>\n<li>du -h //查文件大小</li>\n<li>sed -n ‘s/old/new/gp’ filename //-n  代表行   g 全局 p 打印  </li>\n<li>使用”;”时，不管command1是否执行成功都会执行command2； 使用”&amp;&amp;”时，只有command1执行成功后，command2才会执行，否则command2不执行；使用”||”时，command1执行成功后command2 不执行，否则去执行command2，总之command1和command2总有一条命令会执行。</li>\n<li></li>\n</ol>\n</li>\n</ol>\n<ul>\n<li><p>hive 分区下有数据但是查询表没有数据</p>\n<p>可以是表的读入设置了压缩等其他格式，单纯txt的文件，表无法读取</p>\n<p>STORED AS INPUTFORMAT<br>  ‘com.hadoop.mapred.DeprecatedLzoTextInputFormat’   //设置压缩为lzo 所以只能读取lzo数据</p>\n</li>\n<li><p>Hive count(distinct ) 优化</p>\n<p>可以先进行group by  然后再进行count</p>\n<pre><code class=\"sql\">select count(*),count(distinct col) from tablename where day_id=20180708</code></pre>\n</li>\n</ul>\n<p>  select max(cnt), max(mdn_cnt), max(day_id) from (select null  as cnt , count(<em>) as mdn_cnt , day_id  as day_id from (select mdn, day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by mdn,day_id )a group by  day_id union all select count(</em>) as cnt, null  as mdn_cnt , day_id as day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by day_id )b;//union all</p>\n<p>  select b.cnt,a.mdn_cnt ,a.day_id from (<br>  select count(<em>) as mdn_cnt ,day_id from (select mdn,day_id from dwi_m.dwi_res_regn_mergelocation_msk_d where day_id=20180708 group by mdn,day_id)a1 group by day_id)a<br>  left join<br>  (select count(</em>) as cnt, day_id from dwi_m.dwi_res_regn_mergelocation_msk_d  b where day_id=20180708 group by day_id)b<br>  on a.day_id=b.day_id;//join</p>\n<p>  join 和 union all 用的时间差不多  但相对 直接count distinct 要 少很多</p>\n"},{"_content":"\n\n#Linux\n\n### 1. 挂载\n\n~~~\nmount -t iso9660 -o ro /dev/cdrom /mnt/cdrom  //将文件类型为iso9660的文件 以只读（ro）方式从 /dev/cdrom 挂载到/mnt/cdrom\n~~~\n\n### 2. 设置开机自动挂载\n~~~\nvi /etc/fstab\n/dev/cdrom\t/mnt/cdrom\tiso9660\tdefaults\t0\t0\n~~~\n\n### 3. 关闭防火墙\n~~~\nchkconfig iptables --list\nchkconfig iptables  off   //重启时也自动关闭\n~~~\n### 4. 设置yum本地源\n~~~\ncd /etc/yum.repos.d/\n修改baseurl=file:///或http://\n~~~\n\n### 5. 将自己的包配置成yum库\n~~~\n进入到repo目录\n执行命令：createrepo  .  \n~~~\n\n### 6. rename 批量重命名\n~~~\nrename .a .b *.a   //将所有.a结尾的文件重命名成.b结尾的文件\n~~~\n\n### 7. 服务\n~~~\nservice httpd status  //查看服务状态\nservice httpd start   //开启服务\nservice httpd restart //重启服务\nservice httpd stop  //关闭服务\n~~~\n\n### 8. 关闭SELinux\n~~~\nvi /etc/selinux/config\n修改SE Linux=disabled\n~~~\n\n\n### 9. 添加字符串到文件\n~~~\n“>” 将一条命令重定向到一个文件，会覆盖原文件；\n“>>” 将一条命令追加到一个文件，不会覆盖，在文件末尾添加；\n~~~\n\n### 10. vi快捷键\n\n#### 一般模式下：\n~~~\ny\t复制，3yy 复制三行；\nd\t删除， 5dd 删除附近五行；\n~~~\n#### 命令行模式：\n~~~\n%s／abc／efg\t字符串替换。将所有的abc替换成efg\n／abc\t查找字符串abc ，按n查找下一个，N查找上一个；\n~~~\n### 11. 修改文件权限\n~~~\nchmod\tu+／-r\t文件\t\t给文件拥有者添加／减少 可读权限（u为拥有者，g为用户组，o其他用户）\nchmod\t777\t\t文件\t\t修改文件为所有人可读可写可执行（r：4，w：2，x：1）\nchmod\t-r\t把文件夹及其下子文件修改为一致；\nchown 用户 目录或文件名\t修改文件所属用户\n~~~\n### 12. 用户管理\n\n#### 添加用户：\n~~~\nuseradd\t用户名\t添加用户\npasswd\t用户名\t修改用户密码\n~~~\n### 13. 查看大小\n\n#### 查看文件夹：\n~~~\ndu\t-sh\t文件夹\n~~~\n#### 查看分区：\n~~~\ndf\t-h\n~~~\n\n### 14. 跟踪日志文件\n~~~\ntail -10\t文件\t\t跟踪显示后10行\ntail\t-f\t文件\t\t实时跟踪显示文件（只跟踪文件indo号）\ntail\t-F\t文件\t\t实时跟踪显示文件 （跟踪文件的名称）\n~~~\n### 15. cut\n~~~\ncut\t-d\t‘ ：’\t-f\t1\t截取以 ：分割的第一个\n~~~\n### 16. sort\n~~~\nsort\t-t\t' : '\t-k  2nr\t  将用  ：分割的字符串以第二列数字倒序排列\n~~~\n### 17. sed\n~~~\nsed\t‘2d’\tfilename\t删除filename第二行\t不会改变源文件里面的数据加sed -i 会改变源文件里面的数据\nsed\t‘/test/’d \tfilename\t删除匹配test的行\nsed\t‘2，$d’\tfilename\t删除filename2到结束\nsed\t‘s/aa/bb/g’\tfilename\t全局将带有aa的行替换成bb\n~~~\n### 18. awk\n~~~\nawk\t-F\t‘ ：’  ‘ { print $1 \",\" $7 }   将以 ：分割的字符串打印第1和第7列中间用 ，分割\n~~~\n### 19. expor\n~~~\nexport 定义的变量只对本会话和子会话生效（bash），要想使在子对话定义的变量在父会话中生效，要使用source  /etc/profile**1.添加字符串到文件**\n“>” 将一条命令重定向到一个文件，会覆盖原文件；\n“>>” 将一条命令追加到一个文件，不会覆盖，在文件末尾添加；\n~~~\n\n### 20. 安装centos mini版本后应该处理的问题\n\n#### 1. ifconfig后没有eth0 网卡\n~~~\nvi /etc/sysconfig/network-scripts/ifcfg-eth0 \nONBOOT=no 改为 yes\n~~~\n\n#### 2. 安装ssh\n~~~\nyum install openssh-server  安装ssh服务\nyum install opens-clients    安装ssh客户端\n查看ssh是否启动\nnetstat -antp | grep ssh    可以看到22号端口是否启动\n~~~\n\n#### 3. 永久关闭防火墙\n~~~\nchkconfig  iptables off\nservice iptables stop （重启以后不会再生效，不能永久关闭）\n~~~\n\n#### 4. 修改主机名\n~~~\nvi  /etc/sysconfig/network\nhostname=xxxx     xxx改为需要的名称\n~~~\n#### 5. 增加用户并为用户添加密码\n~~~\nadduser   xxx    xxx为用户\npasswd    xxx    xxx为用户\n~~~\n#### 6. 为用户添加权限\n~~~\nvi /etc/sudoers\n找到root all=（all） all\n添加xxx  all=（all） all\n~~~\n#### 7. 当复制一个虚拟机时网卡eth0启动不了\n~~~\nvi /etc/udev/rules.d/70-persistent-net.rules\n将eth0的删除，将eth1的改成eth0\n或者查看eth1的序列号将网卡ifcfg-eth0的序列号改成eth1的\n~~~\n#### 8. 添加几台虚拟机的网址主机名映射\n~~~\nvi /etc/hosts\n添加如192.168.1.101  hadoop01\n~~~\n#### 9. 为几台虚拟机设置免密登录\n\n### 21. Linux下轻量级的集群管理利器ClusterShell","source":"notes/Linux.md","raw":"\n\n#Linux\n\n### 1. 挂载\n\n~~~\nmount -t iso9660 -o ro /dev/cdrom /mnt/cdrom  //将文件类型为iso9660的文件 以只读（ro）方式从 /dev/cdrom 挂载到/mnt/cdrom\n~~~\n\n### 2. 设置开机自动挂载\n~~~\nvi /etc/fstab\n/dev/cdrom\t/mnt/cdrom\tiso9660\tdefaults\t0\t0\n~~~\n\n### 3. 关闭防火墙\n~~~\nchkconfig iptables --list\nchkconfig iptables  off   //重启时也自动关闭\n~~~\n### 4. 设置yum本地源\n~~~\ncd /etc/yum.repos.d/\n修改baseurl=file:///或http://\n~~~\n\n### 5. 将自己的包配置成yum库\n~~~\n进入到repo目录\n执行命令：createrepo  .  \n~~~\n\n### 6. rename 批量重命名\n~~~\nrename .a .b *.a   //将所有.a结尾的文件重命名成.b结尾的文件\n~~~\n\n### 7. 服务\n~~~\nservice httpd status  //查看服务状态\nservice httpd start   //开启服务\nservice httpd restart //重启服务\nservice httpd stop  //关闭服务\n~~~\n\n### 8. 关闭SELinux\n~~~\nvi /etc/selinux/config\n修改SE Linux=disabled\n~~~\n\n\n### 9. 添加字符串到文件\n~~~\n“>” 将一条命令重定向到一个文件，会覆盖原文件；\n“>>” 将一条命令追加到一个文件，不会覆盖，在文件末尾添加；\n~~~\n\n### 10. vi快捷键\n\n#### 一般模式下：\n~~~\ny\t复制，3yy 复制三行；\nd\t删除， 5dd 删除附近五行；\n~~~\n#### 命令行模式：\n~~~\n%s／abc／efg\t字符串替换。将所有的abc替换成efg\n／abc\t查找字符串abc ，按n查找下一个，N查找上一个；\n~~~\n### 11. 修改文件权限\n~~~\nchmod\tu+／-r\t文件\t\t给文件拥有者添加／减少 可读权限（u为拥有者，g为用户组，o其他用户）\nchmod\t777\t\t文件\t\t修改文件为所有人可读可写可执行（r：4，w：2，x：1）\nchmod\t-r\t把文件夹及其下子文件修改为一致；\nchown 用户 目录或文件名\t修改文件所属用户\n~~~\n### 12. 用户管理\n\n#### 添加用户：\n~~~\nuseradd\t用户名\t添加用户\npasswd\t用户名\t修改用户密码\n~~~\n### 13. 查看大小\n\n#### 查看文件夹：\n~~~\ndu\t-sh\t文件夹\n~~~\n#### 查看分区：\n~~~\ndf\t-h\n~~~\n\n### 14. 跟踪日志文件\n~~~\ntail -10\t文件\t\t跟踪显示后10行\ntail\t-f\t文件\t\t实时跟踪显示文件（只跟踪文件indo号）\ntail\t-F\t文件\t\t实时跟踪显示文件 （跟踪文件的名称）\n~~~\n### 15. cut\n~~~\ncut\t-d\t‘ ：’\t-f\t1\t截取以 ：分割的第一个\n~~~\n### 16. sort\n~~~\nsort\t-t\t' : '\t-k  2nr\t  将用  ：分割的字符串以第二列数字倒序排列\n~~~\n### 17. sed\n~~~\nsed\t‘2d’\tfilename\t删除filename第二行\t不会改变源文件里面的数据加sed -i 会改变源文件里面的数据\nsed\t‘/test/’d \tfilename\t删除匹配test的行\nsed\t‘2，$d’\tfilename\t删除filename2到结束\nsed\t‘s/aa/bb/g’\tfilename\t全局将带有aa的行替换成bb\n~~~\n### 18. awk\n~~~\nawk\t-F\t‘ ：’  ‘ { print $1 \",\" $7 }   将以 ：分割的字符串打印第1和第7列中间用 ，分割\n~~~\n### 19. expor\n~~~\nexport 定义的变量只对本会话和子会话生效（bash），要想使在子对话定义的变量在父会话中生效，要使用source  /etc/profile**1.添加字符串到文件**\n“>” 将一条命令重定向到一个文件，会覆盖原文件；\n“>>” 将一条命令追加到一个文件，不会覆盖，在文件末尾添加；\n~~~\n\n### 20. 安装centos mini版本后应该处理的问题\n\n#### 1. ifconfig后没有eth0 网卡\n~~~\nvi /etc/sysconfig/network-scripts/ifcfg-eth0 \nONBOOT=no 改为 yes\n~~~\n\n#### 2. 安装ssh\n~~~\nyum install openssh-server  安装ssh服务\nyum install opens-clients    安装ssh客户端\n查看ssh是否启动\nnetstat -antp | grep ssh    可以看到22号端口是否启动\n~~~\n\n#### 3. 永久关闭防火墙\n~~~\nchkconfig  iptables off\nservice iptables stop （重启以后不会再生效，不能永久关闭）\n~~~\n\n#### 4. 修改主机名\n~~~\nvi  /etc/sysconfig/network\nhostname=xxxx     xxx改为需要的名称\n~~~\n#### 5. 增加用户并为用户添加密码\n~~~\nadduser   xxx    xxx为用户\npasswd    xxx    xxx为用户\n~~~\n#### 6. 为用户添加权限\n~~~\nvi /etc/sudoers\n找到root all=（all） all\n添加xxx  all=（all） all\n~~~\n#### 7. 当复制一个虚拟机时网卡eth0启动不了\n~~~\nvi /etc/udev/rules.d/70-persistent-net.rules\n将eth0的删除，将eth1的改成eth0\n或者查看eth1的序列号将网卡ifcfg-eth0的序列号改成eth1的\n~~~\n#### 8. 添加几台虚拟机的网址主机名映射\n~~~\nvi /etc/hosts\n添加如192.168.1.101  hadoop01\n~~~\n#### 9. 为几台虚拟机设置免密登录\n\n### 21. Linux下轻量级的集群管理利器ClusterShell","date":"2020-03-19T05:09:33.000Z","updated":"2020-03-18T11:52:16.000Z","path":"notes/Linux.html","title":"","comments":1,"layout":"page","_id":"ck8o1haad000n13s6gia2roid","content":"<p>#Linux</p>\n<h3 id=\"1-挂载\"><a href=\"#1-挂载\" class=\"headerlink\" title=\"1. 挂载\"></a>1. 挂载</h3><pre><code>mount -t iso9660 -o ro /dev/cdrom /mnt/cdrom  //将文件类型为iso9660的文件 以只读（ro）方式从 /dev/cdrom 挂载到/mnt/cdrom</code></pre><h3 id=\"2-设置开机自动挂载\"><a href=\"#2-设置开机自动挂载\" class=\"headerlink\" title=\"2. 设置开机自动挂载\"></a>2. 设置开机自动挂载</h3><pre><code>vi /etc/fstab\n/dev/cdrom    /mnt/cdrom    iso9660    defaults    0    0</code></pre><h3 id=\"3-关闭防火墙\"><a href=\"#3-关闭防火墙\" class=\"headerlink\" title=\"3. 关闭防火墙\"></a>3. 关闭防火墙</h3><pre><code>chkconfig iptables --list\nchkconfig iptables  off   //重启时也自动关闭</code></pre><h3 id=\"4-设置yum本地源\"><a href=\"#4-设置yum本地源\" class=\"headerlink\" title=\"4. 设置yum本地源\"></a>4. 设置yum本地源</h3><pre><code>cd /etc/yum.repos.d/\n修改baseurl=file:///或http://</code></pre><h3 id=\"5-将自己的包配置成yum库\"><a href=\"#5-将自己的包配置成yum库\" class=\"headerlink\" title=\"5. 将自己的包配置成yum库\"></a>5. 将自己的包配置成yum库</h3><pre><code>进入到repo目录\n执行命令：createrepo  .  </code></pre><h3 id=\"6-rename-批量重命名\"><a href=\"#6-rename-批量重命名\" class=\"headerlink\" title=\"6. rename 批量重命名\"></a>6. rename 批量重命名</h3><pre><code>rename .a .b *.a   //将所有.a结尾的文件重命名成.b结尾的文件</code></pre><h3 id=\"7-服务\"><a href=\"#7-服务\" class=\"headerlink\" title=\"7. 服务\"></a>7. 服务</h3><pre><code>service httpd status  //查看服务状态\nservice httpd start   //开启服务\nservice httpd restart //重启服务\nservice httpd stop  //关闭服务</code></pre><h3 id=\"8-关闭SELinux\"><a href=\"#8-关闭SELinux\" class=\"headerlink\" title=\"8. 关闭SELinux\"></a>8. 关闭SELinux</h3><pre><code>vi /etc/selinux/config\n修改SE Linux=disabled</code></pre><h3 id=\"9-添加字符串到文件\"><a href=\"#9-添加字符串到文件\" class=\"headerlink\" title=\"9. 添加字符串到文件\"></a>9. 添加字符串到文件</h3><pre><code>“&gt;” 将一条命令重定向到一个文件，会覆盖原文件；\n“&gt;&gt;” 将一条命令追加到一个文件，不会覆盖，在文件末尾添加；</code></pre><h3 id=\"10-vi快捷键\"><a href=\"#10-vi快捷键\" class=\"headerlink\" title=\"10. vi快捷键\"></a>10. vi快捷键</h3><h4 id=\"一般模式下：\"><a href=\"#一般模式下：\" class=\"headerlink\" title=\"一般模式下：\"></a>一般模式下：</h4><pre><code>y    复制，3yy 复制三行；\nd    删除， 5dd 删除附近五行；</code></pre><h4 id=\"命令行模式：\"><a href=\"#命令行模式：\" class=\"headerlink\" title=\"命令行模式：\"></a>命令行模式：</h4><pre><code>%s／abc／efg    字符串替换。将所有的abc替换成efg\n／abc    查找字符串abc ，按n查找下一个，N查找上一个；</code></pre><h3 id=\"11-修改文件权限\"><a href=\"#11-修改文件权限\" class=\"headerlink\" title=\"11. 修改文件权限\"></a>11. 修改文件权限</h3><pre><code>chmod    u+／-r    文件        给文件拥有者添加／减少 可读权限（u为拥有者，g为用户组，o其他用户）\nchmod    777        文件        修改文件为所有人可读可写可执行（r：4，w：2，x：1）\nchmod    -r    把文件夹及其下子文件修改为一致；\nchown 用户 目录或文件名    修改文件所属用户</code></pre><h3 id=\"12-用户管理\"><a href=\"#12-用户管理\" class=\"headerlink\" title=\"12. 用户管理\"></a>12. 用户管理</h3><h4 id=\"添加用户：\"><a href=\"#添加用户：\" class=\"headerlink\" title=\"添加用户：\"></a>添加用户：</h4><pre><code>useradd    用户名    添加用户\npasswd    用户名    修改用户密码</code></pre><h3 id=\"13-查看大小\"><a href=\"#13-查看大小\" class=\"headerlink\" title=\"13. 查看大小\"></a>13. 查看大小</h3><h4 id=\"查看文件夹：\"><a href=\"#查看文件夹：\" class=\"headerlink\" title=\"查看文件夹：\"></a>查看文件夹：</h4><pre><code>du    -sh    文件夹</code></pre><h4 id=\"查看分区：\"><a href=\"#查看分区：\" class=\"headerlink\" title=\"查看分区：\"></a>查看分区：</h4><pre><code>df    -h</code></pre><h3 id=\"14-跟踪日志文件\"><a href=\"#14-跟踪日志文件\" class=\"headerlink\" title=\"14. 跟踪日志文件\"></a>14. 跟踪日志文件</h3><pre><code>tail -10    文件        跟踪显示后10行\ntail    -f    文件        实时跟踪显示文件（只跟踪文件indo号）\ntail    -F    文件        实时跟踪显示文件 （跟踪文件的名称）</code></pre><h3 id=\"15-cut\"><a href=\"#15-cut\" class=\"headerlink\" title=\"15. cut\"></a>15. cut</h3><pre><code>cut    -d    ‘ ：’    -f    1    截取以 ：分割的第一个</code></pre><h3 id=\"16-sort\"><a href=\"#16-sort\" class=\"headerlink\" title=\"16. sort\"></a>16. sort</h3><pre><code>sort    -t    &#39; : &#39;    -k  2nr      将用  ：分割的字符串以第二列数字倒序排列</code></pre><h3 id=\"17-sed\"><a href=\"#17-sed\" class=\"headerlink\" title=\"17. sed\"></a>17. sed</h3><pre><code>sed    ‘2d’    filename    删除filename第二行    不会改变源文件里面的数据加sed -i 会改变源文件里面的数据\nsed    ‘/test/’d     filename    删除匹配test的行\nsed    ‘2，$d’    filename    删除filename2到结束\nsed    ‘s/aa/bb/g’    filename    全局将带有aa的行替换成bb</code></pre><h3 id=\"18-awk\"><a href=\"#18-awk\" class=\"headerlink\" title=\"18. awk\"></a>18. awk</h3><pre><code>awk    -F    ‘ ：’  ‘ { print $1 &quot;,&quot; $7 }   将以 ：分割的字符串打印第1和第7列中间用 ，分割</code></pre><h3 id=\"19-expor\"><a href=\"#19-expor\" class=\"headerlink\" title=\"19. expor\"></a>19. expor</h3><pre><code>export 定义的变量只对本会话和子会话生效（bash），要想使在子对话定义的变量在父会话中生效，要使用source  /etc/profile**1.添加字符串到文件**\n“&gt;” 将一条命令重定向到一个文件，会覆盖原文件；\n“&gt;&gt;” 将一条命令追加到一个文件，不会覆盖，在文件末尾添加；</code></pre><h3 id=\"20-安装centos-mini版本后应该处理的问题\"><a href=\"#20-安装centos-mini版本后应该处理的问题\" class=\"headerlink\" title=\"20. 安装centos mini版本后应该处理的问题\"></a>20. 安装centos mini版本后应该处理的问题</h3><h4 id=\"1-ifconfig后没有eth0-网卡\"><a href=\"#1-ifconfig后没有eth0-网卡\" class=\"headerlink\" title=\"1. ifconfig后没有eth0 网卡\"></a>1. ifconfig后没有eth0 网卡</h4><pre><code>vi /etc/sysconfig/network-scripts/ifcfg-eth0 \nONBOOT=no 改为 yes</code></pre><h4 id=\"2-安装ssh\"><a href=\"#2-安装ssh\" class=\"headerlink\" title=\"2. 安装ssh\"></a>2. 安装ssh</h4><pre><code>yum install openssh-server  安装ssh服务\nyum install opens-clients    安装ssh客户端\n查看ssh是否启动\nnetstat -antp | grep ssh    可以看到22号端口是否启动</code></pre><h4 id=\"3-永久关闭防火墙\"><a href=\"#3-永久关闭防火墙\" class=\"headerlink\" title=\"3. 永久关闭防火墙\"></a>3. 永久关闭防火墙</h4><pre><code>chkconfig  iptables off\nservice iptables stop （重启以后不会再生效，不能永久关闭）</code></pre><h4 id=\"4-修改主机名\"><a href=\"#4-修改主机名\" class=\"headerlink\" title=\"4. 修改主机名\"></a>4. 修改主机名</h4><pre><code>vi  /etc/sysconfig/network\nhostname=xxxx     xxx改为需要的名称</code></pre><h4 id=\"5-增加用户并为用户添加密码\"><a href=\"#5-增加用户并为用户添加密码\" class=\"headerlink\" title=\"5. 增加用户并为用户添加密码\"></a>5. 增加用户并为用户添加密码</h4><pre><code>adduser   xxx    xxx为用户\npasswd    xxx    xxx为用户</code></pre><h4 id=\"6-为用户添加权限\"><a href=\"#6-为用户添加权限\" class=\"headerlink\" title=\"6. 为用户添加权限\"></a>6. 为用户添加权限</h4><pre><code>vi /etc/sudoers\n找到root all=（all） all\n添加xxx  all=（all） all</code></pre><h4 id=\"7-当复制一个虚拟机时网卡eth0启动不了\"><a href=\"#7-当复制一个虚拟机时网卡eth0启动不了\" class=\"headerlink\" title=\"7. 当复制一个虚拟机时网卡eth0启动不了\"></a>7. 当复制一个虚拟机时网卡eth0启动不了</h4><pre><code>vi /etc/udev/rules.d/70-persistent-net.rules\n将eth0的删除，将eth1的改成eth0\n或者查看eth1的序列号将网卡ifcfg-eth0的序列号改成eth1的</code></pre><h4 id=\"8-添加几台虚拟机的网址主机名映射\"><a href=\"#8-添加几台虚拟机的网址主机名映射\" class=\"headerlink\" title=\"8. 添加几台虚拟机的网址主机名映射\"></a>8. 添加几台虚拟机的网址主机名映射</h4><pre><code>vi /etc/hosts\n添加如192.168.1.101  hadoop01</code></pre><h4 id=\"9-为几台虚拟机设置免密登录\"><a href=\"#9-为几台虚拟机设置免密登录\" class=\"headerlink\" title=\"9. 为几台虚拟机设置免密登录\"></a>9. 为几台虚拟机设置免密登录</h4><h3 id=\"21-Linux下轻量级的集群管理利器ClusterShell\"><a href=\"#21-Linux下轻量级的集群管理利器ClusterShell\" class=\"headerlink\" title=\"21. Linux下轻量级的集群管理利器ClusterShell\"></a>21. Linux下轻量级的集群管理利器ClusterShell</h3>","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<p>#Linux</p>\n<h3 id=\"1-挂载\"><a href=\"#1-挂载\" class=\"headerlink\" title=\"1. 挂载\"></a>1. 挂载</h3><pre><code>mount -t iso9660 -o ro /dev/cdrom /mnt/cdrom  //将文件类型为iso9660的文件 以只读（ro）方式从 /dev/cdrom 挂载到/mnt/cdrom</code></pre><h3 id=\"2-设置开机自动挂载\"><a href=\"#2-设置开机自动挂载\" class=\"headerlink\" title=\"2. 设置开机自动挂载\"></a>2. 设置开机自动挂载</h3><pre><code>vi /etc/fstab\n/dev/cdrom    /mnt/cdrom    iso9660    defaults    0    0</code></pre><h3 id=\"3-关闭防火墙\"><a href=\"#3-关闭防火墙\" class=\"headerlink\" title=\"3. 关闭防火墙\"></a>3. 关闭防火墙</h3><pre><code>chkconfig iptables --list\nchkconfig iptables  off   //重启时也自动关闭</code></pre><h3 id=\"4-设置yum本地源\"><a href=\"#4-设置yum本地源\" class=\"headerlink\" title=\"4. 设置yum本地源\"></a>4. 设置yum本地源</h3><pre><code>cd /etc/yum.repos.d/\n修改baseurl=file:///或http://</code></pre><h3 id=\"5-将自己的包配置成yum库\"><a href=\"#5-将自己的包配置成yum库\" class=\"headerlink\" title=\"5. 将自己的包配置成yum库\"></a>5. 将自己的包配置成yum库</h3><pre><code>进入到repo目录\n执行命令：createrepo  .  </code></pre><h3 id=\"6-rename-批量重命名\"><a href=\"#6-rename-批量重命名\" class=\"headerlink\" title=\"6. rename 批量重命名\"></a>6. rename 批量重命名</h3><pre><code>rename .a .b *.a   //将所有.a结尾的文件重命名成.b结尾的文件</code></pre><h3 id=\"7-服务\"><a href=\"#7-服务\" class=\"headerlink\" title=\"7. 服务\"></a>7. 服务</h3><pre><code>service httpd status  //查看服务状态\nservice httpd start   //开启服务\nservice httpd restart //重启服务\nservice httpd stop  //关闭服务</code></pre><h3 id=\"8-关闭SELinux\"><a href=\"#8-关闭SELinux\" class=\"headerlink\" title=\"8. 关闭SELinux\"></a>8. 关闭SELinux</h3><pre><code>vi /etc/selinux/config\n修改SE Linux=disabled</code></pre><h3 id=\"9-添加字符串到文件\"><a href=\"#9-添加字符串到文件\" class=\"headerlink\" title=\"9. 添加字符串到文件\"></a>9. 添加字符串到文件</h3><pre><code>“&gt;” 将一条命令重定向到一个文件，会覆盖原文件；\n“&gt;&gt;” 将一条命令追加到一个文件，不会覆盖，在文件末尾添加；</code></pre><h3 id=\"10-vi快捷键\"><a href=\"#10-vi快捷键\" class=\"headerlink\" title=\"10. vi快捷键\"></a>10. vi快捷键</h3><h4 id=\"一般模式下：\"><a href=\"#一般模式下：\" class=\"headerlink\" title=\"一般模式下：\"></a>一般模式下：</h4><pre><code>y    复制，3yy 复制三行；\nd    删除， 5dd 删除附近五行；</code></pre><h4 id=\"命令行模式：\"><a href=\"#命令行模式：\" class=\"headerlink\" title=\"命令行模式：\"></a>命令行模式：</h4><pre><code>%s／abc／efg    字符串替换。将所有的abc替换成efg\n／abc    查找字符串abc ，按n查找下一个，N查找上一个；</code></pre><h3 id=\"11-修改文件权限\"><a href=\"#11-修改文件权限\" class=\"headerlink\" title=\"11. 修改文件权限\"></a>11. 修改文件权限</h3><pre><code>chmod    u+／-r    文件        给文件拥有者添加／减少 可读权限（u为拥有者，g为用户组，o其他用户）\nchmod    777        文件        修改文件为所有人可读可写可执行（r：4，w：2，x：1）\nchmod    -r    把文件夹及其下子文件修改为一致；\nchown 用户 目录或文件名    修改文件所属用户</code></pre><h3 id=\"12-用户管理\"><a href=\"#12-用户管理\" class=\"headerlink\" title=\"12. 用户管理\"></a>12. 用户管理</h3><h4 id=\"添加用户：\"><a href=\"#添加用户：\" class=\"headerlink\" title=\"添加用户：\"></a>添加用户：</h4><pre><code>useradd    用户名    添加用户\npasswd    用户名    修改用户密码</code></pre><h3 id=\"13-查看大小\"><a href=\"#13-查看大小\" class=\"headerlink\" title=\"13. 查看大小\"></a>13. 查看大小</h3><h4 id=\"查看文件夹：\"><a href=\"#查看文件夹：\" class=\"headerlink\" title=\"查看文件夹：\"></a>查看文件夹：</h4><pre><code>du    -sh    文件夹</code></pre><h4 id=\"查看分区：\"><a href=\"#查看分区：\" class=\"headerlink\" title=\"查看分区：\"></a>查看分区：</h4><pre><code>df    -h</code></pre><h3 id=\"14-跟踪日志文件\"><a href=\"#14-跟踪日志文件\" class=\"headerlink\" title=\"14. 跟踪日志文件\"></a>14. 跟踪日志文件</h3><pre><code>tail -10    文件        跟踪显示后10行\ntail    -f    文件        实时跟踪显示文件（只跟踪文件indo号）\ntail    -F    文件        实时跟踪显示文件 （跟踪文件的名称）</code></pre><h3 id=\"15-cut\"><a href=\"#15-cut\" class=\"headerlink\" title=\"15. cut\"></a>15. cut</h3><pre><code>cut    -d    ‘ ：’    -f    1    截取以 ：分割的第一个</code></pre><h3 id=\"16-sort\"><a href=\"#16-sort\" class=\"headerlink\" title=\"16. sort\"></a>16. sort</h3><pre><code>sort    -t    &#39; : &#39;    -k  2nr      将用  ：分割的字符串以第二列数字倒序排列</code></pre><h3 id=\"17-sed\"><a href=\"#17-sed\" class=\"headerlink\" title=\"17. sed\"></a>17. sed</h3><pre><code>sed    ‘2d’    filename    删除filename第二行    不会改变源文件里面的数据加sed -i 会改变源文件里面的数据\nsed    ‘/test/’d     filename    删除匹配test的行\nsed    ‘2，$d’    filename    删除filename2到结束\nsed    ‘s/aa/bb/g’    filename    全局将带有aa的行替换成bb</code></pre><h3 id=\"18-awk\"><a href=\"#18-awk\" class=\"headerlink\" title=\"18. awk\"></a>18. awk</h3><pre><code>awk    -F    ‘ ：’  ‘ { print $1 &quot;,&quot; $7 }   将以 ：分割的字符串打印第1和第7列中间用 ，分割</code></pre><h3 id=\"19-expor\"><a href=\"#19-expor\" class=\"headerlink\" title=\"19. expor\"></a>19. expor</h3><pre><code>export 定义的变量只对本会话和子会话生效（bash），要想使在子对话定义的变量在父会话中生效，要使用source  /etc/profile**1.添加字符串到文件**\n“&gt;” 将一条命令重定向到一个文件，会覆盖原文件；\n“&gt;&gt;” 将一条命令追加到一个文件，不会覆盖，在文件末尾添加；</code></pre><h3 id=\"20-安装centos-mini版本后应该处理的问题\"><a href=\"#20-安装centos-mini版本后应该处理的问题\" class=\"headerlink\" title=\"20. 安装centos mini版本后应该处理的问题\"></a>20. 安装centos mini版本后应该处理的问题</h3><h4 id=\"1-ifconfig后没有eth0-网卡\"><a href=\"#1-ifconfig后没有eth0-网卡\" class=\"headerlink\" title=\"1. ifconfig后没有eth0 网卡\"></a>1. ifconfig后没有eth0 网卡</h4><pre><code>vi /etc/sysconfig/network-scripts/ifcfg-eth0 \nONBOOT=no 改为 yes</code></pre><h4 id=\"2-安装ssh\"><a href=\"#2-安装ssh\" class=\"headerlink\" title=\"2. 安装ssh\"></a>2. 安装ssh</h4><pre><code>yum install openssh-server  安装ssh服务\nyum install opens-clients    安装ssh客户端\n查看ssh是否启动\nnetstat -antp | grep ssh    可以看到22号端口是否启动</code></pre><h4 id=\"3-永久关闭防火墙\"><a href=\"#3-永久关闭防火墙\" class=\"headerlink\" title=\"3. 永久关闭防火墙\"></a>3. 永久关闭防火墙</h4><pre><code>chkconfig  iptables off\nservice iptables stop （重启以后不会再生效，不能永久关闭）</code></pre><h4 id=\"4-修改主机名\"><a href=\"#4-修改主机名\" class=\"headerlink\" title=\"4. 修改主机名\"></a>4. 修改主机名</h4><pre><code>vi  /etc/sysconfig/network\nhostname=xxxx     xxx改为需要的名称</code></pre><h4 id=\"5-增加用户并为用户添加密码\"><a href=\"#5-增加用户并为用户添加密码\" class=\"headerlink\" title=\"5. 增加用户并为用户添加密码\"></a>5. 增加用户并为用户添加密码</h4><pre><code>adduser   xxx    xxx为用户\npasswd    xxx    xxx为用户</code></pre><h4 id=\"6-为用户添加权限\"><a href=\"#6-为用户添加权限\" class=\"headerlink\" title=\"6. 为用户添加权限\"></a>6. 为用户添加权限</h4><pre><code>vi /etc/sudoers\n找到root all=（all） all\n添加xxx  all=（all） all</code></pre><h4 id=\"7-当复制一个虚拟机时网卡eth0启动不了\"><a href=\"#7-当复制一个虚拟机时网卡eth0启动不了\" class=\"headerlink\" title=\"7. 当复制一个虚拟机时网卡eth0启动不了\"></a>7. 当复制一个虚拟机时网卡eth0启动不了</h4><pre><code>vi /etc/udev/rules.d/70-persistent-net.rules\n将eth0的删除，将eth1的改成eth0\n或者查看eth1的序列号将网卡ifcfg-eth0的序列号改成eth1的</code></pre><h4 id=\"8-添加几台虚拟机的网址主机名映射\"><a href=\"#8-添加几台虚拟机的网址主机名映射\" class=\"headerlink\" title=\"8. 添加几台虚拟机的网址主机名映射\"></a>8. 添加几台虚拟机的网址主机名映射</h4><pre><code>vi /etc/hosts\n添加如192.168.1.101  hadoop01</code></pre><h4 id=\"9-为几台虚拟机设置免密登录\"><a href=\"#9-为几台虚拟机设置免密登录\" class=\"headerlink\" title=\"9. 为几台虚拟机设置免密登录\"></a>9. 为几台虚拟机设置免密登录</h4><h3 id=\"21-Linux下轻量级的集群管理利器ClusterShell\"><a href=\"#21-Linux下轻量级的集群管理利器ClusterShell\" class=\"headerlink\" title=\"21. Linux下轻量级的集群管理利器ClusterShell\"></a>21. Linux下轻量级的集群管理利器ClusterShell</h3>"},{"_content":"# Scala\n\n## 1. 半生类和半生对象\n\n```scala\n//半生类\nclass A{\ndef apply()={\n\n}\n\n}\n\n//半生对象\nobject A{\n\ndef apply()={\n\n}\n\n}\n\n\nval a=A()   //调用的是object.apply\nval a1=new A()\nal()       //调用的是class.apply\n\n\n//类名()    object.apply\n//对象名()  class.apply\n\n\n最佳实践是在object的apply里面 new Class\n```\n\n\n\n## 2. 尾递归求和\n\n```scala\ndef sum(nums:Int*)={\n\tif(nums==0){\n\t\t0\n\t}else{\n\t\tnums.head+sum(nums.tail:_*)\n\t}\n\n}\n```\n\n\n\n## 3. Range\n\nto // 闭区间\n\nuntil //左闭右开\n\nRange //左闭右开\n\n```\n1 to 4 \t\t\t => [1,4]  =>  1,2,3,4\n1 until 4 \t => [1,4)  =>  1,2,3\nRange(1,4)   => [1,4)  =>  1,2,3\n```\n\n\n\n","source":"notes/Scala.md","raw":"# Scala\n\n## 1. 半生类和半生对象\n\n```scala\n//半生类\nclass A{\ndef apply()={\n\n}\n\n}\n\n//半生对象\nobject A{\n\ndef apply()={\n\n}\n\n}\n\n\nval a=A()   //调用的是object.apply\nval a1=new A()\nal()       //调用的是class.apply\n\n\n//类名()    object.apply\n//对象名()  class.apply\n\n\n最佳实践是在object的apply里面 new Class\n```\n\n\n\n## 2. 尾递归求和\n\n```scala\ndef sum(nums:Int*)={\n\tif(nums==0){\n\t\t0\n\t}else{\n\t\tnums.head+sum(nums.tail:_*)\n\t}\n\n}\n```\n\n\n\n## 3. Range\n\nto // 闭区间\n\nuntil //左闭右开\n\nRange //左闭右开\n\n```\n1 to 4 \t\t\t => [1,4]  =>  1,2,3,4\n1 until 4 \t => [1,4)  =>  1,2,3\nRange(1,4)   => [1,4)  =>  1,2,3\n```\n\n\n\n","date":"2020-03-19T05:09:33.000Z","updated":"2020-03-18T11:52:16.000Z","path":"notes/Scala.html","title":"","comments":1,"layout":"page","_id":"ck8o1haad000p13s6xmg5yjpm","content":"<h1 id=\"Scala\"><a href=\"#Scala\" class=\"headerlink\" title=\"Scala\"></a>Scala</h1><h2 id=\"1-半生类和半生对象\"><a href=\"#1-半生类和半生对象\" class=\"headerlink\" title=\"1. 半生类和半生对象\"></a>1. 半生类和半生对象</h2><pre class=\" language-scala\"><code class=\"language-scala\"><span class=\"token comment\" spellcheck=\"true\">//半生类</span>\n<span class=\"token keyword\">class</span> A<span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">def</span> apply<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">//半生对象</span>\n<span class=\"token keyword\">object</span> A<span class=\"token punctuation\">{</span>\n\n<span class=\"token keyword\">def</span> apply<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">val</span> a<span class=\"token operator\">=</span>A<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\" spellcheck=\"true\">//调用的是object.apply</span>\n<span class=\"token keyword\">val</span> a1<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> A<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nal<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>       <span class=\"token comment\" spellcheck=\"true\">//调用的是class.apply</span>\n\n\n<span class=\"token comment\" spellcheck=\"true\">//类名()    object.apply</span>\n<span class=\"token comment\" spellcheck=\"true\">//对象名()  class.apply</span>\n\n\n最佳实践是在<span class=\"token keyword\">object</span>的apply里面 <span class=\"token keyword\">new</span> Class</code></pre>\n<h2 id=\"2-尾递归求和\"><a href=\"#2-尾递归求和\" class=\"headerlink\" title=\"2. 尾递归求和\"></a>2. 尾递归求和</h2><pre class=\" language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">def</span> sum<span class=\"token punctuation\">(</span>nums<span class=\"token operator\">:</span><span class=\"token builtin\">Int</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>nums<span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token number\">0</span>\n    <span class=\"token punctuation\">}</span><span class=\"token keyword\">else</span><span class=\"token punctuation\">{</span>\n        nums<span class=\"token punctuation\">.</span>head<span class=\"token operator\">+</span>sum<span class=\"token punctuation\">(</span>nums<span class=\"token punctuation\">.</span>tail<span class=\"token operator\">:</span>_<span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"3-Range\"><a href=\"#3-Range\" class=\"headerlink\" title=\"3. Range\"></a>3. Range</h2><p>to // 闭区间</p>\n<p>until //左闭右开</p>\n<p>Range //左闭右开</p>\n<pre><code>1 to 4              =&gt; [1,4]  =&gt;  1,2,3,4\n1 until 4      =&gt; [1,4)  =&gt;  1,2,3\nRange(1,4)   =&gt; [1,4)  =&gt;  1,2,3</code></pre>","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<h1 id=\"Scala\"><a href=\"#Scala\" class=\"headerlink\" title=\"Scala\"></a>Scala</h1><h2 id=\"1-半生类和半生对象\"><a href=\"#1-半生类和半生对象\" class=\"headerlink\" title=\"1. 半生类和半生对象\"></a>1. 半生类和半生对象</h2><pre><code class=\"scala\">//半生类\nclass A{\ndef apply()={\n\n}\n\n}\n\n//半生对象\nobject A{\n\ndef apply()={\n\n}\n\n}\n\n\nval a=A()   //调用的是object.apply\nval a1=new A()\nal()       //调用的是class.apply\n\n\n//类名()    object.apply\n//对象名()  class.apply\n\n\n最佳实践是在object的apply里面 new Class</code></pre>\n<h2 id=\"2-尾递归求和\"><a href=\"#2-尾递归求和\" class=\"headerlink\" title=\"2. 尾递归求和\"></a>2. 尾递归求和</h2><pre><code class=\"scala\">def sum(nums:Int*)={\n    if(nums==0){\n        0\n    }else{\n        nums.head+sum(nums.tail:_*)\n    }\n\n}</code></pre>\n<h2 id=\"3-Range\"><a href=\"#3-Range\" class=\"headerlink\" title=\"3. Range\"></a>3. Range</h2><p>to // 闭区间</p>\n<p>until //左闭右开</p>\n<p>Range //左闭右开</p>\n<pre><code>1 to 4              =&gt; [1,4]  =&gt;  1,2,3,4\n1 until 4      =&gt; [1,4)  =&gt;  1,2,3\nRange(1,4)   =&gt; [1,4)  =&gt;  1,2,3</code></pre>"},{"_content":"# Spark 编码\n\n## 1. map 和 mapPartitions\n\n~~~\nmap是对rdd中的每一个元素进行操作；\nmapPartitions则是对rdd中的每个分区的迭代器进行操作\nMapPartitions的优点：\n如果是普通的map，比如一个partition中有1万条数据。ok，那么你的function要执行和计算1万次。\n使用MapPartitions操作之后，一个task仅仅会执行一次function，function一次接收所有\n的partition数据。只要执行一次就可以了，性能比较高。如果在map过程中需要频繁创建额外的对象(例如将rdd中的数据通过jdbc写入数据库,map需要为每个元素创建一个链接而mapPartition为每个partition创建一个链接),则mapPartitions效率比map高的多。\nSparkSql或DataFrame默认会对程序进行mapPartition的优化。\nMapPartitions的缺点：\n如果是普通的map操作，一次function的执行就处理一条数据；那么如果内存不够用的情况下， 比如处理了1千条数据了，那么这个时候内存不够了，那么就可以将已经处理完的1千条数据从内存里面垃圾回收掉，或者用其他方法，腾出空间来吧。\n所以说普通的map操作通常不会导致内存的OOM异常。 \n\n但是MapPartitions操作，对于大量数据来说，比如甚至一个partition，100万数据，\n一次传入一个function以后，那么可能一下子内存不够，但是又没有办法去腾出内存空间来，可能就OOM，内存溢出。\n\n~~~\n\n## 2. Drive 和 Executo\n\n~~~\n所有RDD算子的计算功能都是由Excutor执行\n~~~\n\n## 3. Shuffle\n\n~~~\n将RDD中一个分区的数据打乱重组到其他不同分区的操作\n~~~\n\n## 4. Task 和 Partition\n\n~~~\n一个分区划分一个任务，一个任务会被分配到一个excutor\n~~~\n\n## 5. reduceByKey 和groupByKey\n\n~~~\nreduceByKey 在shuffle之前有combine(预聚合)操作，性能相对groupByKey要好\n~~~\n\n## 6. stage 划分\n\n~~~\nstage划分根据宽依赖，stage个数=1+shuffle个数\n~~~\n\n## 7. 更新map\n\n```scala\n/**\n *简化if else 结构\n **/\nif(map.contains(v))\n\tmap+=(v->0)\nmap.update(v,map(v)+1) //if外边\n```\n\n## 8. 数组切片\n\n```scala\nval l=List(1,2,3,4,5,6,7)\nval sl=l.slice(0,l.size-1) //[1,2,3,4,5,6]\nval zl=sl.zip(sl.tail) //[(1,2),(2,3),...]\nval zl.map((x,y)=>x+\"_\"+y) //[1_2,2_3,...]\n```\n\n","source":"notes/Spark.md","raw":"# Spark 编码\n\n## 1. map 和 mapPartitions\n\n~~~\nmap是对rdd中的每一个元素进行操作；\nmapPartitions则是对rdd中的每个分区的迭代器进行操作\nMapPartitions的优点：\n如果是普通的map，比如一个partition中有1万条数据。ok，那么你的function要执行和计算1万次。\n使用MapPartitions操作之后，一个task仅仅会执行一次function，function一次接收所有\n的partition数据。只要执行一次就可以了，性能比较高。如果在map过程中需要频繁创建额外的对象(例如将rdd中的数据通过jdbc写入数据库,map需要为每个元素创建一个链接而mapPartition为每个partition创建一个链接),则mapPartitions效率比map高的多。\nSparkSql或DataFrame默认会对程序进行mapPartition的优化。\nMapPartitions的缺点：\n如果是普通的map操作，一次function的执行就处理一条数据；那么如果内存不够用的情况下， 比如处理了1千条数据了，那么这个时候内存不够了，那么就可以将已经处理完的1千条数据从内存里面垃圾回收掉，或者用其他方法，腾出空间来吧。\n所以说普通的map操作通常不会导致内存的OOM异常。 \n\n但是MapPartitions操作，对于大量数据来说，比如甚至一个partition，100万数据，\n一次传入一个function以后，那么可能一下子内存不够，但是又没有办法去腾出内存空间来，可能就OOM，内存溢出。\n\n~~~\n\n## 2. Drive 和 Executo\n\n~~~\n所有RDD算子的计算功能都是由Excutor执行\n~~~\n\n## 3. Shuffle\n\n~~~\n将RDD中一个分区的数据打乱重组到其他不同分区的操作\n~~~\n\n## 4. Task 和 Partition\n\n~~~\n一个分区划分一个任务，一个任务会被分配到一个excutor\n~~~\n\n## 5. reduceByKey 和groupByKey\n\n~~~\nreduceByKey 在shuffle之前有combine(预聚合)操作，性能相对groupByKey要好\n~~~\n\n## 6. stage 划分\n\n~~~\nstage划分根据宽依赖，stage个数=1+shuffle个数\n~~~\n\n## 7. 更新map\n\n```scala\n/**\n *简化if else 结构\n **/\nif(map.contains(v))\n\tmap+=(v->0)\nmap.update(v,map(v)+1) //if外边\n```\n\n## 8. 数组切片\n\n```scala\nval l=List(1,2,3,4,5,6,7)\nval sl=l.slice(0,l.size-1) //[1,2,3,4,5,6]\nval zl=sl.zip(sl.tail) //[(1,2),(2,3),...]\nval zl.map((x,y)=>x+\"_\"+y) //[1_2,2_3,...]\n```\n\n","date":"2020-03-19T05:09:33.000Z","updated":"2020-03-18T11:52:16.000Z","path":"notes/Spark.html","title":"","comments":1,"layout":"page","_id":"ck8o1haae000r13s6s81t7ku4","content":"<h1 id=\"Spark-编码\"><a href=\"#Spark-编码\" class=\"headerlink\" title=\"Spark 编码\"></a>Spark 编码</h1><h2 id=\"1-map-和-mapPartitions\"><a href=\"#1-map-和-mapPartitions\" class=\"headerlink\" title=\"1. map 和 mapPartitions\"></a>1. map 和 mapPartitions</h2><pre><code>map是对rdd中的每一个元素进行操作；\nmapPartitions则是对rdd中的每个分区的迭代器进行操作\nMapPartitions的优点：\n如果是普通的map，比如一个partition中有1万条数据。ok，那么你的function要执行和计算1万次。\n使用MapPartitions操作之后，一个task仅仅会执行一次function，function一次接收所有\n的partition数据。只要执行一次就可以了，性能比较高。如果在map过程中需要频繁创建额外的对象(例如将rdd中的数据通过jdbc写入数据库,map需要为每个元素创建一个链接而mapPartition为每个partition创建一个链接),则mapPartitions效率比map高的多。\nSparkSql或DataFrame默认会对程序进行mapPartition的优化。\nMapPartitions的缺点：\n如果是普通的map操作，一次function的执行就处理一条数据；那么如果内存不够用的情况下， 比如处理了1千条数据了，那么这个时候内存不够了，那么就可以将已经处理完的1千条数据从内存里面垃圾回收掉，或者用其他方法，腾出空间来吧。\n所以说普通的map操作通常不会导致内存的OOM异常。 \n\n但是MapPartitions操作，对于大量数据来说，比如甚至一个partition，100万数据，\n一次传入一个function以后，那么可能一下子内存不够，但是又没有办法去腾出内存空间来，可能就OOM，内存溢出。\n</code></pre><h2 id=\"2-Drive-和-Executo\"><a href=\"#2-Drive-和-Executo\" class=\"headerlink\" title=\"2. Drive 和 Executo\"></a>2. Drive 和 Executo</h2><pre><code>所有RDD算子的计算功能都是由Excutor执行</code></pre><h2 id=\"3-Shuffle\"><a href=\"#3-Shuffle\" class=\"headerlink\" title=\"3. Shuffle\"></a>3. Shuffle</h2><pre><code>将RDD中一个分区的数据打乱重组到其他不同分区的操作</code></pre><h2 id=\"4-Task-和-Partition\"><a href=\"#4-Task-和-Partition\" class=\"headerlink\" title=\"4. Task 和 Partition\"></a>4. Task 和 Partition</h2><pre><code>一个分区划分一个任务，一个任务会被分配到一个excutor</code></pre><h2 id=\"5-reduceByKey-和groupByKey\"><a href=\"#5-reduceByKey-和groupByKey\" class=\"headerlink\" title=\"5. reduceByKey 和groupByKey\"></a>5. reduceByKey 和groupByKey</h2><pre><code>reduceByKey 在shuffle之前有combine(预聚合)操作，性能相对groupByKey要好</code></pre><h2 id=\"6-stage-划分\"><a href=\"#6-stage-划分\" class=\"headerlink\" title=\"6. stage 划分\"></a>6. stage 划分</h2><pre><code>stage划分根据宽依赖，stage个数=1+shuffle个数</code></pre><h2 id=\"7-更新map\"><a href=\"#7-更新map\" class=\"headerlink\" title=\"7. 更新map\"></a>7. 更新map</h2><pre class=\" language-scala\"><code class=\"language-scala\"><span class=\"token comment\" spellcheck=\"true\">/**\n *简化if else 结构\n **/</span>\n<span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">.</span>contains<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    map<span class=\"token operator\">+=</span><span class=\"token punctuation\">(</span>v<span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\nmap<span class=\"token punctuation\">.</span>update<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">,</span>map<span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//if外边</span></code></pre>\n<h2 id=\"8-数组切片\"><a href=\"#8-数组切片\" class=\"headerlink\" title=\"8. 数组切片\"></a>8. 数组切片</h2><pre class=\" language-scala\"><code class=\"language-scala\"><span class=\"token keyword\">val</span> l<span class=\"token operator\">=</span>List<span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">,</span><span class=\"token number\">6</span><span class=\"token punctuation\">,</span><span class=\"token number\">7</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">val</span> sl<span class=\"token operator\">=</span>l<span class=\"token punctuation\">.</span>slice<span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span>l<span class=\"token punctuation\">.</span>size<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//[1,2,3,4,5,6]</span>\n<span class=\"token keyword\">val</span> zl<span class=\"token operator\">=</span>sl<span class=\"token punctuation\">.</span>zip<span class=\"token punctuation\">(</span>sl<span class=\"token punctuation\">.</span>tail<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//[(1,2),(2,3),...]</span>\n<span class=\"token keyword\">val</span> zl<span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">,</span>y<span class=\"token punctuation\">)</span><span class=\"token keyword\">=></span>x<span class=\"token operator\">+</span><span class=\"token string\">\"_\"</span><span class=\"token operator\">+</span>y<span class=\"token punctuation\">)</span> <span class=\"token comment\" spellcheck=\"true\">//[1_2,2_3,...]</span></code></pre>\n","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<h1 id=\"Spark-编码\"><a href=\"#Spark-编码\" class=\"headerlink\" title=\"Spark 编码\"></a>Spark 编码</h1><h2 id=\"1-map-和-mapPartitions\"><a href=\"#1-map-和-mapPartitions\" class=\"headerlink\" title=\"1. map 和 mapPartitions\"></a>1. map 和 mapPartitions</h2><pre><code>map是对rdd中的每一个元素进行操作；\nmapPartitions则是对rdd中的每个分区的迭代器进行操作\nMapPartitions的优点：\n如果是普通的map，比如一个partition中有1万条数据。ok，那么你的function要执行和计算1万次。\n使用MapPartitions操作之后，一个task仅仅会执行一次function，function一次接收所有\n的partition数据。只要执行一次就可以了，性能比较高。如果在map过程中需要频繁创建额外的对象(例如将rdd中的数据通过jdbc写入数据库,map需要为每个元素创建一个链接而mapPartition为每个partition创建一个链接),则mapPartitions效率比map高的多。\nSparkSql或DataFrame默认会对程序进行mapPartition的优化。\nMapPartitions的缺点：\n如果是普通的map操作，一次function的执行就处理一条数据；那么如果内存不够用的情况下， 比如处理了1千条数据了，那么这个时候内存不够了，那么就可以将已经处理完的1千条数据从内存里面垃圾回收掉，或者用其他方法，腾出空间来吧。\n所以说普通的map操作通常不会导致内存的OOM异常。 \n\n但是MapPartitions操作，对于大量数据来说，比如甚至一个partition，100万数据，\n一次传入一个function以后，那么可能一下子内存不够，但是又没有办法去腾出内存空间来，可能就OOM，内存溢出。\n</code></pre><h2 id=\"2-Drive-和-Executo\"><a href=\"#2-Drive-和-Executo\" class=\"headerlink\" title=\"2. Drive 和 Executo\"></a>2. Drive 和 Executo</h2><pre><code>所有RDD算子的计算功能都是由Excutor执行</code></pre><h2 id=\"3-Shuffle\"><a href=\"#3-Shuffle\" class=\"headerlink\" title=\"3. Shuffle\"></a>3. Shuffle</h2><pre><code>将RDD中一个分区的数据打乱重组到其他不同分区的操作</code></pre><h2 id=\"4-Task-和-Partition\"><a href=\"#4-Task-和-Partition\" class=\"headerlink\" title=\"4. Task 和 Partition\"></a>4. Task 和 Partition</h2><pre><code>一个分区划分一个任务，一个任务会被分配到一个excutor</code></pre><h2 id=\"5-reduceByKey-和groupByKey\"><a href=\"#5-reduceByKey-和groupByKey\" class=\"headerlink\" title=\"5. reduceByKey 和groupByKey\"></a>5. reduceByKey 和groupByKey</h2><pre><code>reduceByKey 在shuffle之前有combine(预聚合)操作，性能相对groupByKey要好</code></pre><h2 id=\"6-stage-划分\"><a href=\"#6-stage-划分\" class=\"headerlink\" title=\"6. stage 划分\"></a>6. stage 划分</h2><pre><code>stage划分根据宽依赖，stage个数=1+shuffle个数</code></pre><h2 id=\"7-更新map\"><a href=\"#7-更新map\" class=\"headerlink\" title=\"7. 更新map\"></a>7. 更新map</h2><pre><code class=\"scala\">/**\n *简化if else 结构\n **/\nif(map.contains(v))\n    map+=(v-&gt;0)\nmap.update(v,map(v)+1) //if外边</code></pre>\n<h2 id=\"8-数组切片\"><a href=\"#8-数组切片\" class=\"headerlink\" title=\"8. 数组切片\"></a>8. 数组切片</h2><pre><code class=\"scala\">val l=List(1,2,3,4,5,6,7)\nval sl=l.slice(0,l.size-1) //[1,2,3,4,5,6]\nval zl=sl.zip(sl.tail) //[(1,2),(2,3),...]\nval zl.map((x,y)=&gt;x+&quot;_&quot;+y) //[1_2,2_3,...]</code></pre>\n"},{"title":"笔记","date":"2019-12-26T15:50:21.000Z","_content":"\n[Bigdata](./Bigdata.html)\n\n[Hive](./Hive.html)\n\n[Redis](./Redis.html)\n\n[Kafka](./Kafka.html)\n\n[Linux](./Linux.html)\n\n[Docker](./Docker.html)\n\n[Git&GitHub](./Git&GitHub.html)\n\n[Golang](./Golang.html)\n\n[Java](./Java.html)\n\n","source":"notes/index.md","raw":"---\ntitle: 笔记\ndate: 2019-12-26 23:50:21\n---\n\n[Bigdata](./Bigdata.html)\n\n[Hive](./Hive.html)\n\n[Redis](./Redis.html)\n\n[Kafka](./Kafka.html)\n\n[Linux](./Linux.html)\n\n[Docker](./Docker.html)\n\n[Git&GitHub](./Git&GitHub.html)\n\n[Golang](./Golang.html)\n\n[Java](./Java.html)\n\n","updated":"2020-04-03T10:24:11.000Z","path":"notes/index.html","comments":1,"layout":"page","_id":"ck8o1haae000s13s6cfh7jzjg","content":"<p><a href=\"./Bigdata.html\">Bigdata</a></p>\n<p><a href=\"./Hive.html\">Hive</a></p>\n<p><a href=\"./Redis.html\">Redis</a></p>\n<p><a href=\"./Kafka.html\">Kafka</a></p>\n<p><a href=\"./Linux.html\">Linux</a></p>\n<p><a href=\"./Docker.html\">Docker</a></p>\n<p><a href=\"./Git&GitHub.html\">Git&amp;GitHub</a></p>\n<p><a href=\"./Golang.html\">Golang</a></p>\n<p><a href=\"./Java.html\">Java</a></p>\n","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<p><a href=\"./Bigdata.html\">Bigdata</a></p>\n<p><a href=\"./Hive.html\">Hive</a></p>\n<p><a href=\"./Redis.html\">Redis</a></p>\n<p><a href=\"./Kafka.html\">Kafka</a></p>\n<p><a href=\"./Linux.html\">Linux</a></p>\n<p><a href=\"./Docker.html\">Docker</a></p>\n<p><a href=\"./Git&GitHub.html\">Git&amp;GitHub</a></p>\n<p><a href=\"./Golang.html\">Golang</a></p>\n<p><a href=\"./Java.html\">Java</a></p>\n"},{"_content":"# Flink\n\n## Application\n+ 启动：flink run -c mainclasspath jarpath\n+ 取消：flink cancel jobid\n+ 停止：flink stop jobid\n### Job\n## Task\njob中的一个阶段就是一个task，一个task包括链条连接的多个subtask，一个task运行在一个线程里面，task平分slot里面的内存资源共享slot里面的cpu资源\n## SubTask\nflink job中最小执行单元\n## 算子\n\n### Source\n\n使用EventTime，划分滚动窗口，如果使用的是并行的Source，例如KafkaSource，创建Kafka的Topic时有多个分区，每个Source的分区都要满足触发的条件，整个窗口才会被触发\n\n### Transformation\n+ map\t//DataStream - > DataStream\n+\tflatMap\t//DataStream -> DataStream\n+\tfilter\t//DataStream -> DataStream\n+\tkeyBy\t//DataStream -> KeyStream\n### Sink\n\nwriteAsCsv必须是元组才能正常写入\n\n## WaterMark\n决定一个窗口什么时候激活（触发），这时的窗口的最大长度为\n\nmaterMark>=上一个窗口的结束边界就会触发窗口执行\n\nwatermark是flink中窗口延迟触发的机制\n\n在每个算子内部都自己有一个事件时间时钟，事件时间时钟是根据watermark来更新的，。流入算子的数据可能是单分区也可能是多分区的，每个流入算子的分区端都会有一个自己的partition watermark标记，当该分区内进入新的高于之前watermark的watermark数据时，partition watermark标记才会被更新，task内部也维护一个task的watermark数据。如果某个分区的partition watermark < task watermark，那么task watermark会更新为该partition watermark数据，然后把task 把当前更新的task watermark数据发向下游task。\n\n### AssignerWithPeriodicWatermarks\nwindowmax=watermark+windowsize\nwaterMark=数据携带的时间（窗口中最大的时间）-延迟执行的时间\n\n周期性的生成watermark，定期向分区数据流中插入时间水印。默认周期时间为200毫秒，可以使用setAutoWatermakrIntaval（）来设置\nBoundedOutOfOrdernessTimestampExtractor继承自AssignerWithPeriodicWatermarks 属于周期性watermark\n\n>周期性数据水印在特定条件下可能会造成数据错误\n>例如：env.fromCollection(List((1, \"a1\", 158324361000l), (1, \"a2\", 158324369000l), (1, \"a3\", 158324364000l), (1, \"a4\", 158324361000l), (1, \"a5\",158324365000l), (1, \"a6\", 158324362000l), (1, \"a7\",158324367000l))) \n>.assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor[(Int, String, Long)](Time.milliseconds(0)) {\n>override def extractTimestamp(element: (Int, String, Long)): Long = {\n> element._3\n> }\n> })\n> .keyBy(0)\n> .window(TumblingEventTimeWindows.of(Time.seconds(4)))\n> .sum(2)\n> .print()\n> 当使用周期性水印AssignerWithPeriodicWatermarks时就会造成数据的错误计算\n> 是因为周期性水印是定期产生的（默认200毫秒）但是在这个周期里可能会出现有多个数据已经过去，这多个数据用于一个水印从而造成数据计算错误\n\n### AssignerWithPunctuatedWatermarks\n根据事件生成watermark。可以用于根据具体数据来生成watermark，\n## Window\n\n### Keyed Window\n使用keyby后流的窗口\n#### GlobalWindow\n#### CountWindow\n#### TimeWindow\n+ Tumbling\n+ Sliding\n+ Session\n\n### Non-Keyed Windows\n未使用keyby后流的窗口\n#### windowAll\n\n## Window 之后的算子\n### Trigger\nwindow 数据触发器，keyed or non-keyed window 都可以使用\n+ EventTimeTrigger：事件时间触发器\n+ ProcessingTimeTrigger：程序时间触发器\n+ CountTrigger：数量出发器。只发送窗口触发信号\n+ PurgingTrigger：代理模式触发器，发送窗口触发和数据清理信号\n### Evictor\nwindow 数据剔除器，可以在window执行前或者执行后剔除window内的元素\n+ CountEvictor：数量剔除器。在Window中保留指定数量的元素，并从窗口头部开始丢弃其余元素。\n+ DeltaEvictor： 阈值剔除器。计算Window中最后一个元素与其余每个元素之间的增量，丢弃增量大于或等于阈值的元素。\n+ TimeEvictor：时间剔除器。保留Window中最近一段时间内的元素，并丢弃其余元素。\n### AllowedLateness\n\n决定一个窗口什么时候销毁，window 延迟数据是否保留计算，可能会造成窗口的二次触发，会导致结果数据的更新，造成数据不一致。这时窗口的最大长度为windowmax=waterma+windowsize+allowedleteness\n\n## State\n### Managed State\n#### Operator State\noperator state 绑定到每个算子的实例上，各个实例拥有自己的state，一个实例无法获取同并行的其他实例的state数据\n\noperator state ：记录的是每一个分区的偏移量\n\n#### Keyed State\n\nkeyedstate：在一个subtask中可能有多个state，一个组对应一个key的状态\n\n\n\n### Raw State\n## CheckPoint\n全自动程序管理，轻量快捷算子级数据快照\n\n开启flink checkpoint 后设置精准一次消费，kafka的offset会保存在savepoint设置的路径里面，还会降offset保存在kafka 特殊topic里面，如果程序重启时没有指定savepiont保存数据的地址会默认根据kafka 特殊topic保存的偏移量消费数据，可以设置不降offset保存在kafka 特殊topic里面使用，setCommitOffsetOnCheckpoints(false)\n\n开启检查点机制\n\n```\n// start a checkpoint every 1000 ms\nenv.enableCheckpointing(1000);\n\n// advanced options:\n\n// set mode to exactly-once (this is the default)\nenv.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);\n\n// make sure 500 ms of progress happen between checkpoints\nenv.getCheckpointConfig().setMinPauseBetweenCheckpoints(500);\n\n// checkpoints have to complete within one minute, or are discarded\nenv.getCheckpointConfig().setCheckpointTimeout(60000);\n\n// allow only one checkpoint to be in progress at the same time\nenv.getCheckpointConfig().setMaxConcurrentCheckpoints(1);\n\n// enable externalized checkpoints which are retained after job cancellation\nenv.getCheckpointConfig().enableExternalizedCheckpoints(ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);\n\n// allow job recovery fallback to checkpoint when there is a more recent savepoint\nenv.getCheckpointConfig().setPreferCheckpointForRecovery(true);\n```\n### Barrier\n算子checkpoint的依据，是exactly-once 和at-least-once语义的根据\n## SavePoint\n\n人工参与管理的application级别的数据快照\n\n### 手动保存数据快照\n+ flink stop jobid\n  停止job并保存快照，如果在flink-conf.yaml上配置了state.savepoints.dir，停止任务后会自动将快照保存。\n  \n+ flink stop jobid -p dirpath\n  停止job并将快照保存在dirpath\n  \n+ flink savepoint jobid [dirpath] \n  在不结束job的情况下保存快照。如果带有dirpath则会将快照保存在此目录否则会保存在默认配置的保存目录\n### 从数据快照恢复程序\n+ 直接从savepoint目录恢复\n  flink run -s dirpath\n  从dirpath目录恢复程序\n  \n+ 跳过无法恢复的算子恢复\n  flink run -s dirpath -n\n  \n### 手动清除数据快照\n+ flink savepoint -d itemdirpath\n  手动将数据某个具体快照删除（itemdirpath 快照具体根目录）\n  \n  \n  \n## CEP（Complex Event Processing）\n\nNFA（Nondeterministic Finite Automaton）\n\n## 反压\nflink 三层buff缓存（resultsubpartition，nettybuff，netty中通过高水位来控制buff是否还可以接收数据，socketbuff）\n\n1.5 之前是基于tcp 窗口的反压机制，发送端根据接收端返回的ack和windox size 来发送数据，当window size 为0时，发送端则不会再附上数据，而是发送一个zerowindow 的探测性数据来确定是否可以再次发送数据，当接收端继续可以接收数据时，发送端才会继续发送数据\n\n基于tcp窗口的反压机制缺点\n1.单个task造成的反压，会阻断整个TM-TM的socket，连chekcpoint barrier 也无法发送\n2.反压路径较长，导致生效延迟较大\n\n\n1.5 引入credit 机制实现反压，credit 反压机制是类似于tcp 窗口反压实现的另一种反压机制，resultsubpartition在发送数据时会带有resultbuff里面还存有的数据大小 backlog size，inputchanel在接收到时会计算自己当前还能接收到的数据大小，当inputchanel无法再接收数据时会将credit置为0，告诉result不能再接收消息。result每次发送消息时会检测当前自己的credit数据，当credit为0时 则不会再向netty发送数据从而实现反压机制\n\n\n\n## 其他\n\n两个流join 必须有等值字段必须都在同一个窗口里面\n\nduplicate key update  mysql数据库的更新插入 合为一条sql\n\n并行度： **算子级别** > **env级别** > **Client级别** > **系统默认级别**\n\n在所有Task共享资源槽点名字相同，默认情况下 （pipline）\n同一个job的同一个Task中的多个subTask不能在同一个slot槽中\n\n>具有并行度的subtask 不能在一个slot槽中\n对于同一个job，不同Task【阶段】的subTask可以在同一个资源槽中\n\n\n","source":"notes/Flink.md","raw":"# Flink\n\n## Application\n+ 启动：flink run -c mainclasspath jarpath\n+ 取消：flink cancel jobid\n+ 停止：flink stop jobid\n### Job\n## Task\njob中的一个阶段就是一个task，一个task包括链条连接的多个subtask，一个task运行在一个线程里面，task平分slot里面的内存资源共享slot里面的cpu资源\n## SubTask\nflink job中最小执行单元\n## 算子\n\n### Source\n\n使用EventTime，划分滚动窗口，如果使用的是并行的Source，例如KafkaSource，创建Kafka的Topic时有多个分区，每个Source的分区都要满足触发的条件，整个窗口才会被触发\n\n### Transformation\n+ map\t//DataStream - > DataStream\n+\tflatMap\t//DataStream -> DataStream\n+\tfilter\t//DataStream -> DataStream\n+\tkeyBy\t//DataStream -> KeyStream\n### Sink\n\nwriteAsCsv必须是元组才能正常写入\n\n## WaterMark\n决定一个窗口什么时候激活（触发），这时的窗口的最大长度为\n\nmaterMark>=上一个窗口的结束边界就会触发窗口执行\n\nwatermark是flink中窗口延迟触发的机制\n\n在每个算子内部都自己有一个事件时间时钟，事件时间时钟是根据watermark来更新的，。流入算子的数据可能是单分区也可能是多分区的，每个流入算子的分区端都会有一个自己的partition watermark标记，当该分区内进入新的高于之前watermark的watermark数据时，partition watermark标记才会被更新，task内部也维护一个task的watermark数据。如果某个分区的partition watermark < task watermark，那么task watermark会更新为该partition watermark数据，然后把task 把当前更新的task watermark数据发向下游task。\n\n### AssignerWithPeriodicWatermarks\nwindowmax=watermark+windowsize\nwaterMark=数据携带的时间（窗口中最大的时间）-延迟执行的时间\n\n周期性的生成watermark，定期向分区数据流中插入时间水印。默认周期时间为200毫秒，可以使用setAutoWatermakrIntaval（）来设置\nBoundedOutOfOrdernessTimestampExtractor继承自AssignerWithPeriodicWatermarks 属于周期性watermark\n\n>周期性数据水印在特定条件下可能会造成数据错误\n>例如：env.fromCollection(List((1, \"a1\", 158324361000l), (1, \"a2\", 158324369000l), (1, \"a3\", 158324364000l), (1, \"a4\", 158324361000l), (1, \"a5\",158324365000l), (1, \"a6\", 158324362000l), (1, \"a7\",158324367000l))) \n>.assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor[(Int, String, Long)](Time.milliseconds(0)) {\n>override def extractTimestamp(element: (Int, String, Long)): Long = {\n> element._3\n> }\n> })\n> .keyBy(0)\n> .window(TumblingEventTimeWindows.of(Time.seconds(4)))\n> .sum(2)\n> .print()\n> 当使用周期性水印AssignerWithPeriodicWatermarks时就会造成数据的错误计算\n> 是因为周期性水印是定期产生的（默认200毫秒）但是在这个周期里可能会出现有多个数据已经过去，这多个数据用于一个水印从而造成数据计算错误\n\n### AssignerWithPunctuatedWatermarks\n根据事件生成watermark。可以用于根据具体数据来生成watermark，\n## Window\n\n### Keyed Window\n使用keyby后流的窗口\n#### GlobalWindow\n#### CountWindow\n#### TimeWindow\n+ Tumbling\n+ Sliding\n+ Session\n\n### Non-Keyed Windows\n未使用keyby后流的窗口\n#### windowAll\n\n## Window 之后的算子\n### Trigger\nwindow 数据触发器，keyed or non-keyed window 都可以使用\n+ EventTimeTrigger：事件时间触发器\n+ ProcessingTimeTrigger：程序时间触发器\n+ CountTrigger：数量出发器。只发送窗口触发信号\n+ PurgingTrigger：代理模式触发器，发送窗口触发和数据清理信号\n### Evictor\nwindow 数据剔除器，可以在window执行前或者执行后剔除window内的元素\n+ CountEvictor：数量剔除器。在Window中保留指定数量的元素，并从窗口头部开始丢弃其余元素。\n+ DeltaEvictor： 阈值剔除器。计算Window中最后一个元素与其余每个元素之间的增量，丢弃增量大于或等于阈值的元素。\n+ TimeEvictor：时间剔除器。保留Window中最近一段时间内的元素，并丢弃其余元素。\n### AllowedLateness\n\n决定一个窗口什么时候销毁，window 延迟数据是否保留计算，可能会造成窗口的二次触发，会导致结果数据的更新，造成数据不一致。这时窗口的最大长度为windowmax=waterma+windowsize+allowedleteness\n\n## State\n### Managed State\n#### Operator State\noperator state 绑定到每个算子的实例上，各个实例拥有自己的state，一个实例无法获取同并行的其他实例的state数据\n\noperator state ：记录的是每一个分区的偏移量\n\n#### Keyed State\n\nkeyedstate：在一个subtask中可能有多个state，一个组对应一个key的状态\n\n\n\n### Raw State\n## CheckPoint\n全自动程序管理，轻量快捷算子级数据快照\n\n开启flink checkpoint 后设置精准一次消费，kafka的offset会保存在savepoint设置的路径里面，还会降offset保存在kafka 特殊topic里面，如果程序重启时没有指定savepiont保存数据的地址会默认根据kafka 特殊topic保存的偏移量消费数据，可以设置不降offset保存在kafka 特殊topic里面使用，setCommitOffsetOnCheckpoints(false)\n\n开启检查点机制\n\n```\n// start a checkpoint every 1000 ms\nenv.enableCheckpointing(1000);\n\n// advanced options:\n\n// set mode to exactly-once (this is the default)\nenv.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);\n\n// make sure 500 ms of progress happen between checkpoints\nenv.getCheckpointConfig().setMinPauseBetweenCheckpoints(500);\n\n// checkpoints have to complete within one minute, or are discarded\nenv.getCheckpointConfig().setCheckpointTimeout(60000);\n\n// allow only one checkpoint to be in progress at the same time\nenv.getCheckpointConfig().setMaxConcurrentCheckpoints(1);\n\n// enable externalized checkpoints which are retained after job cancellation\nenv.getCheckpointConfig().enableExternalizedCheckpoints(ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);\n\n// allow job recovery fallback to checkpoint when there is a more recent savepoint\nenv.getCheckpointConfig().setPreferCheckpointForRecovery(true);\n```\n### Barrier\n算子checkpoint的依据，是exactly-once 和at-least-once语义的根据\n## SavePoint\n\n人工参与管理的application级别的数据快照\n\n### 手动保存数据快照\n+ flink stop jobid\n  停止job并保存快照，如果在flink-conf.yaml上配置了state.savepoints.dir，停止任务后会自动将快照保存。\n  \n+ flink stop jobid -p dirpath\n  停止job并将快照保存在dirpath\n  \n+ flink savepoint jobid [dirpath] \n  在不结束job的情况下保存快照。如果带有dirpath则会将快照保存在此目录否则会保存在默认配置的保存目录\n### 从数据快照恢复程序\n+ 直接从savepoint目录恢复\n  flink run -s dirpath\n  从dirpath目录恢复程序\n  \n+ 跳过无法恢复的算子恢复\n  flink run -s dirpath -n\n  \n### 手动清除数据快照\n+ flink savepoint -d itemdirpath\n  手动将数据某个具体快照删除（itemdirpath 快照具体根目录）\n  \n  \n  \n## CEP（Complex Event Processing）\n\nNFA（Nondeterministic Finite Automaton）\n\n## 反压\nflink 三层buff缓存（resultsubpartition，nettybuff，netty中通过高水位来控制buff是否还可以接收数据，socketbuff）\n\n1.5 之前是基于tcp 窗口的反压机制，发送端根据接收端返回的ack和windox size 来发送数据，当window size 为0时，发送端则不会再附上数据，而是发送一个zerowindow 的探测性数据来确定是否可以再次发送数据，当接收端继续可以接收数据时，发送端才会继续发送数据\n\n基于tcp窗口的反压机制缺点\n1.单个task造成的反压，会阻断整个TM-TM的socket，连chekcpoint barrier 也无法发送\n2.反压路径较长，导致生效延迟较大\n\n\n1.5 引入credit 机制实现反压，credit 反压机制是类似于tcp 窗口反压实现的另一种反压机制，resultsubpartition在发送数据时会带有resultbuff里面还存有的数据大小 backlog size，inputchanel在接收到时会计算自己当前还能接收到的数据大小，当inputchanel无法再接收数据时会将credit置为0，告诉result不能再接收消息。result每次发送消息时会检测当前自己的credit数据，当credit为0时 则不会再向netty发送数据从而实现反压机制\n\n\n\n## 其他\n\n两个流join 必须有等值字段必须都在同一个窗口里面\n\nduplicate key update  mysql数据库的更新插入 合为一条sql\n\n并行度： **算子级别** > **env级别** > **Client级别** > **系统默认级别**\n\n在所有Task共享资源槽点名字相同，默认情况下 （pipline）\n同一个job的同一个Task中的多个subTask不能在同一个slot槽中\n\n>具有并行度的subtask 不能在一个slot槽中\n对于同一个job，不同Task【阶段】的subTask可以在同一个资源槽中\n\n\n","date":"2020-03-19T05:09:33.000Z","updated":"2020-03-18T11:52:16.000Z","path":"notes/Flink.html","title":"","comments":1,"layout":"page","_id":"ck8o1haay000u13s65stdydp8","content":"<h1 id=\"Flink\"><a href=\"#Flink\" class=\"headerlink\" title=\"Flink\"></a>Flink</h1><h2 id=\"Application\"><a href=\"#Application\" class=\"headerlink\" title=\"Application\"></a>Application</h2><ul>\n<li>启动：flink run -c mainclasspath jarpath</li>\n<li>取消：flink cancel jobid</li>\n<li>停止：flink stop jobid<h3 id=\"Job\"><a href=\"#Job\" class=\"headerlink\" title=\"Job\"></a>Job</h3><h2 id=\"Task\"><a href=\"#Task\" class=\"headerlink\" title=\"Task\"></a>Task</h2>job中的一个阶段就是一个task，一个task包括链条连接的多个subtask，一个task运行在一个线程里面，task平分slot里面的内存资源共享slot里面的cpu资源<h2 id=\"SubTask\"><a href=\"#SubTask\" class=\"headerlink\" title=\"SubTask\"></a>SubTask</h2>flink job中最小执行单元<h2 id=\"算子\"><a href=\"#算子\" class=\"headerlink\" title=\"算子\"></a>算子</h2></li>\n</ul>\n<h3 id=\"Source\"><a href=\"#Source\" class=\"headerlink\" title=\"Source\"></a>Source</h3><p>使用EventTime，划分滚动窗口，如果使用的是并行的Source，例如KafkaSource，创建Kafka的Topic时有多个分区，每个Source的分区都要满足触发的条件，整个窗口才会被触发</p>\n<h3 id=\"Transformation\"><a href=\"#Transformation\" class=\"headerlink\" title=\"Transformation\"></a>Transformation</h3><ul>\n<li>map    //DataStream - &gt; DataStream</li>\n<li>flatMap    //DataStream -&gt; DataStream</li>\n<li>filter    //DataStream -&gt; DataStream</li>\n<li>keyBy    //DataStream -&gt; KeyStream<h3 id=\"Sink\"><a href=\"#Sink\" class=\"headerlink\" title=\"Sink\"></a>Sink</h3></li>\n</ul>\n<p>writeAsCsv必须是元组才能正常写入</p>\n<h2 id=\"WaterMark\"><a href=\"#WaterMark\" class=\"headerlink\" title=\"WaterMark\"></a>WaterMark</h2><p>决定一个窗口什么时候激活（触发），这时的窗口的最大长度为</p>\n<p>materMark&gt;=上一个窗口的结束边界就会触发窗口执行</p>\n<p>watermark是flink中窗口延迟触发的机制</p>\n<p>在每个算子内部都自己有一个事件时间时钟，事件时间时钟是根据watermark来更新的，。流入算子的数据可能是单分区也可能是多分区的，每个流入算子的分区端都会有一个自己的partition watermark标记，当该分区内进入新的高于之前watermark的watermark数据时，partition watermark标记才会被更新，task内部也维护一个task的watermark数据。如果某个分区的partition watermark &lt; task watermark，那么task watermark会更新为该partition watermark数据，然后把task 把当前更新的task watermark数据发向下游task。</p>\n<h3 id=\"AssignerWithPeriodicWatermarks\"><a href=\"#AssignerWithPeriodicWatermarks\" class=\"headerlink\" title=\"AssignerWithPeriodicWatermarks\"></a>AssignerWithPeriodicWatermarks</h3><p>windowmax=watermark+windowsize<br>waterMark=数据携带的时间（窗口中最大的时间）-延迟执行的时间</p>\n<p>周期性的生成watermark，定期向分区数据流中插入时间水印。默认周期时间为200毫秒，可以使用setAutoWatermakrIntaval（）来设置<br>BoundedOutOfOrdernessTimestampExtractor继承自AssignerWithPeriodicWatermarks 属于周期性watermark</p>\n<blockquote>\n<p>周期性数据水印在特定条件下可能会造成数据错误<br>例如：env.fromCollection(List((1, “a1”, 158324361000l), (1, “a2”, 158324369000l), (1, “a3”, 158324364000l), (1, “a4”, 158324361000l), (1, “a5”,158324365000l), (1, “a6”, 158324362000l), (1, “a7”,158324367000l)))<br>.assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor<a href=\"Time.milliseconds(0)\">(Int, String, Long)</a> {<br>override def extractTimestamp(element: (Int, String, Long)): Long = {<br>element._3<br>}<br>})<br>.keyBy(0)<br>.window(TumblingEventTimeWindows.of(Time.seconds(4)))<br>.sum(2)<br>.print()<br>当使用周期性水印AssignerWithPeriodicWatermarks时就会造成数据的错误计算<br>是因为周期性水印是定期产生的（默认200毫秒）但是在这个周期里可能会出现有多个数据已经过去，这多个数据用于一个水印从而造成数据计算错误</p>\n</blockquote>\n<h3 id=\"AssignerWithPunctuatedWatermarks\"><a href=\"#AssignerWithPunctuatedWatermarks\" class=\"headerlink\" title=\"AssignerWithPunctuatedWatermarks\"></a>AssignerWithPunctuatedWatermarks</h3><p>根据事件生成watermark。可以用于根据具体数据来生成watermark，</p>\n<h2 id=\"Window\"><a href=\"#Window\" class=\"headerlink\" title=\"Window\"></a>Window</h2><h3 id=\"Keyed-Window\"><a href=\"#Keyed-Window\" class=\"headerlink\" title=\"Keyed Window\"></a>Keyed Window</h3><p>使用keyby后流的窗口</p>\n<h4 id=\"GlobalWindow\"><a href=\"#GlobalWindow\" class=\"headerlink\" title=\"GlobalWindow\"></a>GlobalWindow</h4><h4 id=\"CountWindow\"><a href=\"#CountWindow\" class=\"headerlink\" title=\"CountWindow\"></a>CountWindow</h4><h4 id=\"TimeWindow\"><a href=\"#TimeWindow\" class=\"headerlink\" title=\"TimeWindow\"></a>TimeWindow</h4><ul>\n<li>Tumbling</li>\n<li>Sliding</li>\n<li>Session</li>\n</ul>\n<h3 id=\"Non-Keyed-Windows\"><a href=\"#Non-Keyed-Windows\" class=\"headerlink\" title=\"Non-Keyed Windows\"></a>Non-Keyed Windows</h3><p>未使用keyby后流的窗口</p>\n<h4 id=\"windowAll\"><a href=\"#windowAll\" class=\"headerlink\" title=\"windowAll\"></a>windowAll</h4><h2 id=\"Window-之后的算子\"><a href=\"#Window-之后的算子\" class=\"headerlink\" title=\"Window 之后的算子\"></a>Window 之后的算子</h2><h3 id=\"Trigger\"><a href=\"#Trigger\" class=\"headerlink\" title=\"Trigger\"></a>Trigger</h3><p>window 数据触发器，keyed or non-keyed window 都可以使用</p>\n<ul>\n<li>EventTimeTrigger：事件时间触发器</li>\n<li>ProcessingTimeTrigger：程序时间触发器</li>\n<li>CountTrigger：数量出发器。只发送窗口触发信号</li>\n<li>PurgingTrigger：代理模式触发器，发送窗口触发和数据清理信号<h3 id=\"Evictor\"><a href=\"#Evictor\" class=\"headerlink\" title=\"Evictor\"></a>Evictor</h3>window 数据剔除器，可以在window执行前或者执行后剔除window内的元素</li>\n<li>CountEvictor：数量剔除器。在Window中保留指定数量的元素，并从窗口头部开始丢弃其余元素。</li>\n<li>DeltaEvictor： 阈值剔除器。计算Window中最后一个元素与其余每个元素之间的增量，丢弃增量大于或等于阈值的元素。</li>\n<li>TimeEvictor：时间剔除器。保留Window中最近一段时间内的元素，并丢弃其余元素。<h3 id=\"AllowedLateness\"><a href=\"#AllowedLateness\" class=\"headerlink\" title=\"AllowedLateness\"></a>AllowedLateness</h3></li>\n</ul>\n<p>决定一个窗口什么时候销毁，window 延迟数据是否保留计算，可能会造成窗口的二次触发，会导致结果数据的更新，造成数据不一致。这时窗口的最大长度为windowmax=waterma+windowsize+allowedleteness</p>\n<h2 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h2><h3 id=\"Managed-State\"><a href=\"#Managed-State\" class=\"headerlink\" title=\"Managed State\"></a>Managed State</h3><h4 id=\"Operator-State\"><a href=\"#Operator-State\" class=\"headerlink\" title=\"Operator State\"></a>Operator State</h4><p>operator state 绑定到每个算子的实例上，各个实例拥有自己的state，一个实例无法获取同并行的其他实例的state数据</p>\n<p>operator state ：记录的是每一个分区的偏移量</p>\n<h4 id=\"Keyed-State\"><a href=\"#Keyed-State\" class=\"headerlink\" title=\"Keyed State\"></a>Keyed State</h4><p>keyedstate：在一个subtask中可能有多个state，一个组对应一个key的状态</p>\n<h3 id=\"Raw-State\"><a href=\"#Raw-State\" class=\"headerlink\" title=\"Raw State\"></a>Raw State</h3><h2 id=\"CheckPoint\"><a href=\"#CheckPoint\" class=\"headerlink\" title=\"CheckPoint\"></a>CheckPoint</h2><p>全自动程序管理，轻量快捷算子级数据快照</p>\n<p>开启flink checkpoint 后设置精准一次消费，kafka的offset会保存在savepoint设置的路径里面，还会降offset保存在kafka 特殊topic里面，如果程序重启时没有指定savepiont保存数据的地址会默认根据kafka 特殊topic保存的偏移量消费数据，可以设置不降offset保存在kafka 特殊topic里面使用，setCommitOffsetOnCheckpoints(false)</p>\n<p>开启检查点机制</p>\n<pre><code>// start a checkpoint every 1000 ms\nenv.enableCheckpointing(1000);\n\n// advanced options:\n\n// set mode to exactly-once (this is the default)\nenv.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);\n\n// make sure 500 ms of progress happen between checkpoints\nenv.getCheckpointConfig().setMinPauseBetweenCheckpoints(500);\n\n// checkpoints have to complete within one minute, or are discarded\nenv.getCheckpointConfig().setCheckpointTimeout(60000);\n\n// allow only one checkpoint to be in progress at the same time\nenv.getCheckpointConfig().setMaxConcurrentCheckpoints(1);\n\n// enable externalized checkpoints which are retained after job cancellation\nenv.getCheckpointConfig().enableExternalizedCheckpoints(ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);\n\n// allow job recovery fallback to checkpoint when there is a more recent savepoint\nenv.getCheckpointConfig().setPreferCheckpointForRecovery(true);</code></pre><h3 id=\"Barrier\"><a href=\"#Barrier\" class=\"headerlink\" title=\"Barrier\"></a>Barrier</h3><p>算子checkpoint的依据，是exactly-once 和at-least-once语义的根据</p>\n<h2 id=\"SavePoint\"><a href=\"#SavePoint\" class=\"headerlink\" title=\"SavePoint\"></a>SavePoint</h2><p>人工参与管理的application级别的数据快照</p>\n<h3 id=\"手动保存数据快照\"><a href=\"#手动保存数据快照\" class=\"headerlink\" title=\"手动保存数据快照\"></a>手动保存数据快照</h3><ul>\n<li><p>flink stop jobid<br>停止job并保存快照，如果在flink-conf.yaml上配置了state.savepoints.dir，停止任务后会自动将快照保存。</p>\n</li>\n<li><p>flink stop jobid -p dirpath<br>停止job并将快照保存在dirpath</p>\n</li>\n<li><p>flink savepoint jobid [dirpath]<br>在不结束job的情况下保存快照。如果带有dirpath则会将快照保存在此目录否则会保存在默认配置的保存目录</p>\n<h3 id=\"从数据快照恢复程序\"><a href=\"#从数据快照恢复程序\" class=\"headerlink\" title=\"从数据快照恢复程序\"></a>从数据快照恢复程序</h3></li>\n<li><p>直接从savepoint目录恢复<br>flink run -s dirpath<br>从dirpath目录恢复程序</p>\n</li>\n<li><p>跳过无法恢复的算子恢复<br>flink run -s dirpath -n</p>\n</li>\n</ul>\n<h3 id=\"手动清除数据快照\"><a href=\"#手动清除数据快照\" class=\"headerlink\" title=\"手动清除数据快照\"></a>手动清除数据快照</h3><ul>\n<li>flink savepoint -d itemdirpath<br>手动将数据某个具体快照删除（itemdirpath 快照具体根目录）</li>\n</ul>\n<h2 id=\"CEP（Complex-Event-Processing）\"><a href=\"#CEP（Complex-Event-Processing）\" class=\"headerlink\" title=\"CEP（Complex Event Processing）\"></a>CEP（Complex Event Processing）</h2><p>NFA（Nondeterministic Finite Automaton）</p>\n<h2 id=\"反压\"><a href=\"#反压\" class=\"headerlink\" title=\"反压\"></a>反压</h2><p>flink 三层buff缓存（resultsubpartition，nettybuff，netty中通过高水位来控制buff是否还可以接收数据，socketbuff）</p>\n<p>1.5 之前是基于tcp 窗口的反压机制，发送端根据接收端返回的ack和windox size 来发送数据，当window size 为0时，发送端则不会再附上数据，而是发送一个zerowindow 的探测性数据来确定是否可以再次发送数据，当接收端继续可以接收数据时，发送端才会继续发送数据</p>\n<p>基于tcp窗口的反压机制缺点<br>1.单个task造成的反压，会阻断整个TM-TM的socket，连chekcpoint barrier 也无法发送<br>2.反压路径较长，导致生效延迟较大</p>\n<p>1.5 引入credit 机制实现反压，credit 反压机制是类似于tcp 窗口反压实现的另一种反压机制，resultsubpartition在发送数据时会带有resultbuff里面还存有的数据大小 backlog size，inputchanel在接收到时会计算自己当前还能接收到的数据大小，当inputchanel无法再接收数据时会将credit置为0，告诉result不能再接收消息。result每次发送消息时会检测当前自己的credit数据，当credit为0时 则不会再向netty发送数据从而实现反压机制</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>两个流join 必须有等值字段必须都在同一个窗口里面</p>\n<p>duplicate key update  mysql数据库的更新插入 合为一条sql</p>\n<p>并行度： <strong>算子级别</strong> &gt; <strong>env级别</strong> &gt; <strong>Client级别</strong> &gt; <strong>系统默认级别</strong></p>\n<p>在所有Task共享资源槽点名字相同，默认情况下 （pipline）<br>同一个job的同一个Task中的多个subTask不能在同一个slot槽中</p>\n<blockquote>\n<p>具有并行度的subtask 不能在一个slot槽中<br>对于同一个job，不同Task【阶段】的subTask可以在同一个资源槽中</p>\n</blockquote>\n","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<h1 id=\"Flink\"><a href=\"#Flink\" class=\"headerlink\" title=\"Flink\"></a>Flink</h1><h2 id=\"Application\"><a href=\"#Application\" class=\"headerlink\" title=\"Application\"></a>Application</h2><ul>\n<li>启动：flink run -c mainclasspath jarpath</li>\n<li>取消：flink cancel jobid</li>\n<li>停止：flink stop jobid<h3 id=\"Job\"><a href=\"#Job\" class=\"headerlink\" title=\"Job\"></a>Job</h3><h2 id=\"Task\"><a href=\"#Task\" class=\"headerlink\" title=\"Task\"></a>Task</h2>job中的一个阶段就是一个task，一个task包括链条连接的多个subtask，一个task运行在一个线程里面，task平分slot里面的内存资源共享slot里面的cpu资源<h2 id=\"SubTask\"><a href=\"#SubTask\" class=\"headerlink\" title=\"SubTask\"></a>SubTask</h2>flink job中最小执行单元<h2 id=\"算子\"><a href=\"#算子\" class=\"headerlink\" title=\"算子\"></a>算子</h2></li>\n</ul>\n<h3 id=\"Source\"><a href=\"#Source\" class=\"headerlink\" title=\"Source\"></a>Source</h3><p>使用EventTime，划分滚动窗口，如果使用的是并行的Source，例如KafkaSource，创建Kafka的Topic时有多个分区，每个Source的分区都要满足触发的条件，整个窗口才会被触发</p>\n<h3 id=\"Transformation\"><a href=\"#Transformation\" class=\"headerlink\" title=\"Transformation\"></a>Transformation</h3><ul>\n<li>map    //DataStream - &gt; DataStream</li>\n<li>flatMap    //DataStream -&gt; DataStream</li>\n<li>filter    //DataStream -&gt; DataStream</li>\n<li>keyBy    //DataStream -&gt; KeyStream<h3 id=\"Sink\"><a href=\"#Sink\" class=\"headerlink\" title=\"Sink\"></a>Sink</h3></li>\n</ul>\n<p>writeAsCsv必须是元组才能正常写入</p>\n<h2 id=\"WaterMark\"><a href=\"#WaterMark\" class=\"headerlink\" title=\"WaterMark\"></a>WaterMark</h2><p>决定一个窗口什么时候激活（触发），这时的窗口的最大长度为</p>\n<p>materMark&gt;=上一个窗口的结束边界就会触发窗口执行</p>\n<p>watermark是flink中窗口延迟触发的机制</p>\n<p>在每个算子内部都自己有一个事件时间时钟，事件时间时钟是根据watermark来更新的，。流入算子的数据可能是单分区也可能是多分区的，每个流入算子的分区端都会有一个自己的partition watermark标记，当该分区内进入新的高于之前watermark的watermark数据时，partition watermark标记才会被更新，task内部也维护一个task的watermark数据。如果某个分区的partition watermark &lt; task watermark，那么task watermark会更新为该partition watermark数据，然后把task 把当前更新的task watermark数据发向下游task。</p>\n<h3 id=\"AssignerWithPeriodicWatermarks\"><a href=\"#AssignerWithPeriodicWatermarks\" class=\"headerlink\" title=\"AssignerWithPeriodicWatermarks\"></a>AssignerWithPeriodicWatermarks</h3><p>windowmax=watermark+windowsize<br>waterMark=数据携带的时间（窗口中最大的时间）-延迟执行的时间</p>\n<p>周期性的生成watermark，定期向分区数据流中插入时间水印。默认周期时间为200毫秒，可以使用setAutoWatermakrIntaval（）来设置<br>BoundedOutOfOrdernessTimestampExtractor继承自AssignerWithPeriodicWatermarks 属于周期性watermark</p>\n<blockquote>\n<p>周期性数据水印在特定条件下可能会造成数据错误<br>例如：env.fromCollection(List((1, “a1”, 158324361000l), (1, “a2”, 158324369000l), (1, “a3”, 158324364000l), (1, “a4”, 158324361000l), (1, “a5”,158324365000l), (1, “a6”, 158324362000l), (1, “a7”,158324367000l)))<br>.assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor<a href=\"Time.milliseconds(0)\">(Int, String, Long)</a> {<br>override def extractTimestamp(element: (Int, String, Long)): Long = {<br>element._3<br>}<br>})<br>.keyBy(0)<br>.window(TumblingEventTimeWindows.of(Time.seconds(4)))<br>.sum(2)<br>.print()<br>当使用周期性水印AssignerWithPeriodicWatermarks时就会造成数据的错误计算<br>是因为周期性水印是定期产生的（默认200毫秒）但是在这个周期里可能会出现有多个数据已经过去，这多个数据用于一个水印从而造成数据计算错误</p>\n</blockquote>\n<h3 id=\"AssignerWithPunctuatedWatermarks\"><a href=\"#AssignerWithPunctuatedWatermarks\" class=\"headerlink\" title=\"AssignerWithPunctuatedWatermarks\"></a>AssignerWithPunctuatedWatermarks</h3><p>根据事件生成watermark。可以用于根据具体数据来生成watermark，</p>\n<h2 id=\"Window\"><a href=\"#Window\" class=\"headerlink\" title=\"Window\"></a>Window</h2><h3 id=\"Keyed-Window\"><a href=\"#Keyed-Window\" class=\"headerlink\" title=\"Keyed Window\"></a>Keyed Window</h3><p>使用keyby后流的窗口</p>\n<h4 id=\"GlobalWindow\"><a href=\"#GlobalWindow\" class=\"headerlink\" title=\"GlobalWindow\"></a>GlobalWindow</h4><h4 id=\"CountWindow\"><a href=\"#CountWindow\" class=\"headerlink\" title=\"CountWindow\"></a>CountWindow</h4><h4 id=\"TimeWindow\"><a href=\"#TimeWindow\" class=\"headerlink\" title=\"TimeWindow\"></a>TimeWindow</h4><ul>\n<li>Tumbling</li>\n<li>Sliding</li>\n<li>Session</li>\n</ul>\n<h3 id=\"Non-Keyed-Windows\"><a href=\"#Non-Keyed-Windows\" class=\"headerlink\" title=\"Non-Keyed Windows\"></a>Non-Keyed Windows</h3><p>未使用keyby后流的窗口</p>\n<h4 id=\"windowAll\"><a href=\"#windowAll\" class=\"headerlink\" title=\"windowAll\"></a>windowAll</h4><h2 id=\"Window-之后的算子\"><a href=\"#Window-之后的算子\" class=\"headerlink\" title=\"Window 之后的算子\"></a>Window 之后的算子</h2><h3 id=\"Trigger\"><a href=\"#Trigger\" class=\"headerlink\" title=\"Trigger\"></a>Trigger</h3><p>window 数据触发器，keyed or non-keyed window 都可以使用</p>\n<ul>\n<li>EventTimeTrigger：事件时间触发器</li>\n<li>ProcessingTimeTrigger：程序时间触发器</li>\n<li>CountTrigger：数量出发器。只发送窗口触发信号</li>\n<li>PurgingTrigger：代理模式触发器，发送窗口触发和数据清理信号<h3 id=\"Evictor\"><a href=\"#Evictor\" class=\"headerlink\" title=\"Evictor\"></a>Evictor</h3>window 数据剔除器，可以在window执行前或者执行后剔除window内的元素</li>\n<li>CountEvictor：数量剔除器。在Window中保留指定数量的元素，并从窗口头部开始丢弃其余元素。</li>\n<li>DeltaEvictor： 阈值剔除器。计算Window中最后一个元素与其余每个元素之间的增量，丢弃增量大于或等于阈值的元素。</li>\n<li>TimeEvictor：时间剔除器。保留Window中最近一段时间内的元素，并丢弃其余元素。<h3 id=\"AllowedLateness\"><a href=\"#AllowedLateness\" class=\"headerlink\" title=\"AllowedLateness\"></a>AllowedLateness</h3></li>\n</ul>\n<p>决定一个窗口什么时候销毁，window 延迟数据是否保留计算，可能会造成窗口的二次触发，会导致结果数据的更新，造成数据不一致。这时窗口的最大长度为windowmax=waterma+windowsize+allowedleteness</p>\n<h2 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h2><h3 id=\"Managed-State\"><a href=\"#Managed-State\" class=\"headerlink\" title=\"Managed State\"></a>Managed State</h3><h4 id=\"Operator-State\"><a href=\"#Operator-State\" class=\"headerlink\" title=\"Operator State\"></a>Operator State</h4><p>operator state 绑定到每个算子的实例上，各个实例拥有自己的state，一个实例无法获取同并行的其他实例的state数据</p>\n<p>operator state ：记录的是每一个分区的偏移量</p>\n<h4 id=\"Keyed-State\"><a href=\"#Keyed-State\" class=\"headerlink\" title=\"Keyed State\"></a>Keyed State</h4><p>keyedstate：在一个subtask中可能有多个state，一个组对应一个key的状态</p>\n<h3 id=\"Raw-State\"><a href=\"#Raw-State\" class=\"headerlink\" title=\"Raw State\"></a>Raw State</h3><h2 id=\"CheckPoint\"><a href=\"#CheckPoint\" class=\"headerlink\" title=\"CheckPoint\"></a>CheckPoint</h2><p>全自动程序管理，轻量快捷算子级数据快照</p>\n<p>开启flink checkpoint 后设置精准一次消费，kafka的offset会保存在savepoint设置的路径里面，还会降offset保存在kafka 特殊topic里面，如果程序重启时没有指定savepiont保存数据的地址会默认根据kafka 特殊topic保存的偏移量消费数据，可以设置不降offset保存在kafka 特殊topic里面使用，setCommitOffsetOnCheckpoints(false)</p>\n<p>开启检查点机制</p>\n<pre><code>// start a checkpoint every 1000 ms\nenv.enableCheckpointing(1000);\n\n// advanced options:\n\n// set mode to exactly-once (this is the default)\nenv.getCheckpointConfig().setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);\n\n// make sure 500 ms of progress happen between checkpoints\nenv.getCheckpointConfig().setMinPauseBetweenCheckpoints(500);\n\n// checkpoints have to complete within one minute, or are discarded\nenv.getCheckpointConfig().setCheckpointTimeout(60000);\n\n// allow only one checkpoint to be in progress at the same time\nenv.getCheckpointConfig().setMaxConcurrentCheckpoints(1);\n\n// enable externalized checkpoints which are retained after job cancellation\nenv.getCheckpointConfig().enableExternalizedCheckpoints(ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);\n\n// allow job recovery fallback to checkpoint when there is a more recent savepoint\nenv.getCheckpointConfig().setPreferCheckpointForRecovery(true);</code></pre><h3 id=\"Barrier\"><a href=\"#Barrier\" class=\"headerlink\" title=\"Barrier\"></a>Barrier</h3><p>算子checkpoint的依据，是exactly-once 和at-least-once语义的根据</p>\n<h2 id=\"SavePoint\"><a href=\"#SavePoint\" class=\"headerlink\" title=\"SavePoint\"></a>SavePoint</h2><p>人工参与管理的application级别的数据快照</p>\n<h3 id=\"手动保存数据快照\"><a href=\"#手动保存数据快照\" class=\"headerlink\" title=\"手动保存数据快照\"></a>手动保存数据快照</h3><ul>\n<li><p>flink stop jobid<br>停止job并保存快照，如果在flink-conf.yaml上配置了state.savepoints.dir，停止任务后会自动将快照保存。</p>\n</li>\n<li><p>flink stop jobid -p dirpath<br>停止job并将快照保存在dirpath</p>\n</li>\n<li><p>flink savepoint jobid [dirpath]<br>在不结束job的情况下保存快照。如果带有dirpath则会将快照保存在此目录否则会保存在默认配置的保存目录</p>\n<h3 id=\"从数据快照恢复程序\"><a href=\"#从数据快照恢复程序\" class=\"headerlink\" title=\"从数据快照恢复程序\"></a>从数据快照恢复程序</h3></li>\n<li><p>直接从savepoint目录恢复<br>flink run -s dirpath<br>从dirpath目录恢复程序</p>\n</li>\n<li><p>跳过无法恢复的算子恢复<br>flink run -s dirpath -n</p>\n</li>\n</ul>\n<h3 id=\"手动清除数据快照\"><a href=\"#手动清除数据快照\" class=\"headerlink\" title=\"手动清除数据快照\"></a>手动清除数据快照</h3><ul>\n<li>flink savepoint -d itemdirpath<br>手动将数据某个具体快照删除（itemdirpath 快照具体根目录）</li>\n</ul>\n<h2 id=\"CEP（Complex-Event-Processing）\"><a href=\"#CEP（Complex-Event-Processing）\" class=\"headerlink\" title=\"CEP（Complex Event Processing）\"></a>CEP（Complex Event Processing）</h2><p>NFA（Nondeterministic Finite Automaton）</p>\n<h2 id=\"反压\"><a href=\"#反压\" class=\"headerlink\" title=\"反压\"></a>反压</h2><p>flink 三层buff缓存（resultsubpartition，nettybuff，netty中通过高水位来控制buff是否还可以接收数据，socketbuff）</p>\n<p>1.5 之前是基于tcp 窗口的反压机制，发送端根据接收端返回的ack和windox size 来发送数据，当window size 为0时，发送端则不会再附上数据，而是发送一个zerowindow 的探测性数据来确定是否可以再次发送数据，当接收端继续可以接收数据时，发送端才会继续发送数据</p>\n<p>基于tcp窗口的反压机制缺点<br>1.单个task造成的反压，会阻断整个TM-TM的socket，连chekcpoint barrier 也无法发送<br>2.反压路径较长，导致生效延迟较大</p>\n<p>1.5 引入credit 机制实现反压，credit 反压机制是类似于tcp 窗口反压实现的另一种反压机制，resultsubpartition在发送数据时会带有resultbuff里面还存有的数据大小 backlog size，inputchanel在接收到时会计算自己当前还能接收到的数据大小，当inputchanel无法再接收数据时会将credit置为0，告诉result不能再接收消息。result每次发送消息时会检测当前自己的credit数据，当credit为0时 则不会再向netty发送数据从而实现反压机制</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>两个流join 必须有等值字段必须都在同一个窗口里面</p>\n<p>duplicate key update  mysql数据库的更新插入 合为一条sql</p>\n<p>并行度： <strong>算子级别</strong> &gt; <strong>env级别</strong> &gt; <strong>Client级别</strong> &gt; <strong>系统默认级别</strong></p>\n<p>在所有Task共享资源槽点名字相同，默认情况下 （pipline）<br>同一个job的同一个Task中的多个subTask不能在同一个slot槽中</p>\n<blockquote>\n<p>具有并行度的subtask 不能在一个slot槽中<br>对于同一个job，不同Task【阶段】的subTask可以在同一个资源槽中</p>\n</blockquote>\n"},{"_content":"# Golang\n\n## 数据类型\n\n### 数值类型\n\n#### bool\n\n#### byte\nbyte = uint8\n\n#### int\n有符号类型：int8，int16，int32，int64\n无符号类型：uint8，uint16，uint32，uint64\nrune = int32\n\n#### float\nfloat16，float32\n\n#### string\n\n#### 数组\n\n数组类型声明赋值方式\n\n- 1\n\n  ```\n  var arr [3]int\n  \n  arr[0] = 1\n  arr[1] = 2\n  arr[2] = 3\n  \n  ```\n\n- 2\n  ```\n  var arr =[3]int{1,2,3}\n  ```\n\n- 3\n\n  ```\n  var arr =[...]int{1,2,3}\n  ```\n\n- 4 \n\n  ```\n   arr :=[3]int{1,2,3}\n  ```\n\n- 5 \n\n  ```\n   arr :=[...]int{1,2,3}\n  ```\n\n\n\n不管是使用...代替size还是有具体size 在声明赋值时必须有size\n\n### 引用类型\n\n#### slice\n\n#### map\n\n\n\n## 变量\ngo语言的变量声明了就必须使用，不用就别声明，否则编译不通过\n\n### 函数变量声明\n\n#### 单一变量声明\n关键字\t变量名称\t变量类型\n~~~go\nvar a\tint\t\n~~~\n声明的同时可以赋值变量，同时赋值可以省略变量类型\n~~~go\nvar a\t= 0\t\n~~~\n#### 多变量同时声明1\n关键字\t变量名称，变量名称\t变量类型\n多变量同时声明时，必须为多个类型一样的变量\n~~~go\nvar a,b,c int\n~~~\n声明的同时可以赋值变量，同时赋值时可以省略变量类型\n~~~go\nvar a,b,c = 0,0,0\n~~~\n#### 多变量同时声明2\n关键字\t（\n变量名称\t变量类型\t\n变量名称\t变量类型\n）\n带有括号的多变量赋值时，变量类型可以不同\n~~~go\nvar (\n  a int\n  b string\n)\n~~~\n其中并且可以进行赋值操作，变量类型可以直接省略\n~~~go\nvar (\n  a = 0\n  b = \"bb\"\n)\n~~~\n\n#### 简短声明赋值\n变量名称  :=  变量值\n~~~go\na := 0\n~~~\n\n### 全局变量声明\n\n全局变量声明，包含以上**单一变量声明**，**多变量同时声明1**，**多变量同时声明2**，声明方式，但是只有**多变量同时声明2**声明方式可以同时进行赋值操作，其他方式不支持赋值操作\n\n### 指针\n\n&：取地址\n\n\\*：取值\n\n#### 指针数组\n\\*[4]Type\n首先是一个指针，存储的是数组地址\n\n\n\nvar arr [3]int{1,2,3}\n\nvar p1 *[3]int\n\np1=&arr\n\n(*p1)[2]=100 简写成：p1[2]=100。p1操作的是arr数组\n\n#### 数组指针\n首先是一个数组，存储的是指针\n\n[4]\\*Type\n\n\n\n>注意：\n>\t\\*[4]int\t//指针，4个长度的int类型数组的指针\n>\t[4]\\*int\t//数组，4个长度的int指针地址的数组\n>\t\\*[4]\\*int\t//指针，4个长度int指针地址数组的指针\n>\t\\*\\*[4]\\*int\t//指针，4个长度int指针地址数组的指针的指针\n\n\n\n\n## 条件语句\n\n### if\n- 简单形式\n  ~~~go\n  if 1==2 {\n  \n  }\n  ~~~\n\n- 复合形式\n  - 1\n    ~~~go\n    if a := 0; a ==0 {\n    \n    }\n    ~~~\n  - 2\n    ~~~go\n    if  {\n    \n    }\n    ~~~\n    当不写条件时，当作true处理\n### switch\n\n- 简单形式\n  ~~~go\n  a := 1\n  switch a {\n  case 1:\n    println(1111)\n  default:\n  }\n  ~~~\n\n\n- 复合形式\n  - 1\n    ~~~go\n\n    switch a := 1; a {\n    case 1:\n      println(1111)\n    case 2,3,4:\n      println(222,333,444)\n    default:\n    }\n    ~~~\n\n  - 2\n\n    ~~~go\n    a := 4\n    switch  {\n    case a>=0:\n      println(\">=0\")\n    case a<=5:\n      println(\"<=4\")\n    }\n    ~~~\n    当不写条件时，当作true处理。此处只会输出一种情况`>=0`，switch处理时只要满足一种情况就不会再进行判断\n    \n#### switch穿透 fallthrough\n  ~~~go\n  a := 1\n  switch a {\n  case 1:\n    println(1111)\n    fallthrough\n case 2:\n    println(2222)\n  default:\n  }\n  \n  =======输出为=======\n  1111\n  2222\n  ~~~\nfallthrough 可以穿透case，链接上下两个case一起执行\n\n> 注意：\n> a := 1\n> switch a {\n>\n> default:\n>     println(\"default\")\n>\n>   case 1:\n>     println(1111)\n>\n> }\n> =================输出为===========\n> 1111\n\n\n## 循环语句\n\ngo语言里面没有while，do while 等其他循环结构，只有for\n\n\n\n- 简单形式\n\n  ~~~go\n  for i := 0; i < 10; i++ {\n\n  }\n  ~~~\n\n- 复合形式\n\n  - 1\n    \n    ~~~go\n    for {\n    \n    }\n    ~~~\n    不写条件，当作true处理\n    \n  - 2 \n  \n    ~~~go\n    for index,value := range []int{1,2,3,4} {\n      fmt.Printf(\"index:%d,value:%d \\n\",index,value)\n    }\n    ~~~\n    range关键字可以取出数组，切片，集合等容器里面的数据\n\n\n\n## defer关键字\n\ndefer 延迟，推迟执行。遵循栈的执行原则先进后出，参数变量是已经传递，是在return语句前执行\n\n\n## 函数\n\n\nfunc name(a int,b int) (int){\n\nreturn 0\n\n}\n\n### 函数返回值\n\n~~~go\nfunc name ()(int){\n\nreturn 1\n\n}\n\n\n\nfunc name ()int{\n\nreturn 1\n\n}\n\n\n\nfunc name ()(sum int){\n\nsum:=1\n\nreturn\n\n}\n\n~~~\n\n\n\n\n\n## 结构体\n深拷贝，值传递\n- 简单\n  ~~~go\n  type\tname\tstruct {\n    a int\n    b string\n  }\n  ~~~\n\n- 匿名结构体\n\n  ~~~go\n  struct {\n    a int\n    b string\n  }\n  ~~~\n\n- 匿名结构体字段\n\n  ~~~go\n  type\tname\tstruct {\n   int\n   string\n  }\n  ~~~\n\n  匿名结构体字段访问时，使用匿名字段类型`name.int`，`name.string`，匿名的字段类型不能重复\n\n  ~~~go\n  type\tname\tstruct {\n   int\n   string\n   int\t//不可以\n  }\n  ~~~\n\n\n### 提升字段\n结构体可以嵌套，当一个结构体内嵌套另一个匿名结构体时，可以直接使用字段名称访问被嵌套结构体的字段，这叫做字段提升。\n字段提升只有在被嵌套结构体为匿名的时候可用。\n如果结构体中的字段与被嵌套结构体的字段一样，则访问的为本结构体字段\n\n\n~~~go\ntype Person struct {\n\tname string\n\tage int\n}\n\ntype Student struct {\n\tPerson\n\taddre string\n\tname string\n}\n\np:=Person{\"nihao\",10}\nfmt.Println(p)\n\ns:=Student{Person{\"wohao\",20},\"beij\",\"djh\"}\nfmt.Println(s)\nfmt.Println(s.Person.name,s.Person.age,s.addre,s.name)\nfmt.Println(s.name,s.age,s.addre)\n\n\n======================输出为============================\n\n{nihao 10}\n{{wohao 20} beij djh}\nwohao 20 beij djh\ndjh 20 beij\n~~~\n\n\n\n## 方法\n方法是一个作用在struct结构体上的函数\n\n\n~~~go\nfunc (s Struct) name() {\n\n}\n~~~\n\n实例\n\n~~~go\ntype Person struct {\n\tname string\n\tage int\n}\n\ntype Student struct {\n\tPerson\n\taddre string\n\tname string\n}\nfunc (p Person) run(){\n\tfmt.Println(\"p run\")\n}\n\nfunc (s Student) run()  {\n\tfmt.Println(\"s run\")\n}\n\n\n\np:=Person{\"lisi\",10}\nfmt.Println(p)\np.run()\ns:=Student{Person{\"wangwu\",20},\"beij\",\"xiaowangwu\"}\nfmt.Println(s)\ns.Person.run()\ns.run()\n\n\n\n\n\n===============输出为================\n{lisi 10}\np run\n{{wangwu 20} beij xiaowangwu}\np run\ns run\n~~~\n\n## 接口（interface）\n\n接口可以看作是一些方法的集合。接口是为了解耦合，go语言的接口是非侵入式的。空接口可以看作是任意类型\n\n~~~go\ntype name interface{\n  start()\n  end()\n}\n~~~\n\n### 接口断言\n利用接口来判断类型\n\n- 1\n  instance := 接口对象.(实际类型)   //不安全，会panic（）\n  instance,err := 接口对象.(实际类型)\t//安全\n- 2\n  switch instance := 接口对象.(type) {\n    case 实际类型：\n      xxx\n    case 实际类型：\n      xxxx\n  }\n\n\n\n## type 关键字\n\n- 定义新类型\n  type myint int\n  定义一个int类型的myint类型，但是int和myint类型不一样不能通用\n- 给类型其别名\n  type myint = int \n  给一个int类型起一个别名，int和myint可以通用\n\n## 创建对象\n\n### new\n\n### make\n\n- slice\n  - make([]int,10)\t\n    长度（len）和容量（cap）都为10，默认值为int的零值\n  - make([]int,0,10)\t\n    长度（len）为0，和容量（cap）为10，因为0个长度所以没有值\n- map\n  - make(map[string]string)\n    \n  - make(map[string]string,10)\n  \n- chan\n  - make(chan bool)\n    没有缓存的chan\n  - make(chan bool,10)\n    长度为10的chan\n\n## 访问权限\n名称首字母大写时，可以在其他地方导入，小写其他地方访问不了\n\n\n## IO\n\n## 协程（Gorutine）\n\n## 管道（chan）\n\n## 反射（reflect）\n\n### 基本数据类型反射使用\n\n#### 修改值\n- step1:\n  获取反射对象Value。要修改对象，就要获取对象的地址，用对象的引用地址来更改里面的具体值\n  ~~~go\n  var a int = 0\n  value := reflect.ValueOf(&a)\n  ~~~\n- step2:\n  获取反射对象的指针对象\n  ~~~go\n  elem := value.Elem()\n  ~~~\n- step3:\n  修改值\n  ~~~go\n  elem.SetInt(9)\n  ~~~\n\n完整步骤：\n~~~go\nvar a int = 0\nvalue := reflect.ValueOf(&a)\nelem := value.Elem()\nif !elem.CanSet {  //判断反射对象是否可以修改，不可以直接返回不做修改\n  return\n}\n\nif elem.Kind() ==reflect.Int{ //判断对象是否是int类型\n  elem.SetInt(9)\n}\n\n~~~\n\n### 函数调用\n\n~~~go\nfunc star()  {\n  fmt.Println(\"call this func\")\n}\n\nvalueOf := reflect.ValueOf(star)  //这里star不能加（）\n\nif valueOf.Kind() == reflect.Func {\n  valueOf.Call(nil)\n}\n~~~\n\n### struct 的反射使用\n\n#### 获取字段名称和具体值\n\n- step1:\n  获取反射valueOf和typeOf实例\n  ~~~go\n  type Person struct {\n    Name string\n    Age  int\n  }\n  p:=Person{\"zhangshan\",30}\n\n  valueOf := reflect.ValueOf(p)\n  typeOf := reflect.TypeOf(p)\n  ~~~\n\n\n- step2:\n  通过实例获取字段名称和字段实际值\n  \n  ~~~go\n  for i := 0; i < typeOf.NumField(); i++ {\n    fmt.Println(\"fieldname:  \",typeOf.Field(i).Name)\n    fmt.Println(\"value:  \",valueOf.Field(i))\n  }\n  ~~~\n\n\n完整代码：\n~~~go\ntype Person struct {\n  Name string\n  Age  int\n}\n\np:=Person{\"zhangshan\",30}\n\nvalueOf := reflect.ValueOf(p)\ntypeOf := reflect.TypeOf(p)\n\n\nfor i := 0; i < typeOf.NumField(); i++ {\n  fmt.Println(\"fieldname:  \",typeOf.Field(i).Name)\n  fmt.Println(\"value:  \",valueOf.Field(i))\n}\n~~~\n#### 修改字段值\n\n- step1:\n  获取反射valueOf实例\n  ~~~go\n  type Person struct {\n    Name string\n    Age  int\n  }\n  p:=Person{\"zhangshan\",30}\n\n  valueOf := reflect.ValueOf(&p)  //这里要填写p的地址\n  ~~~\n  \n- step2:\n  修改相应的字段值\n  ~~~go\n  valueOf.Field(0).SetString(\"wangwu\")\n  ~~~\n  \n\n完整代码：\n~~~go\ntype Person struct {\n\tName string\n\tAge  int\n}\np:=Person{\"zhangshan\",30}\n\nvalueOf := reflect.ValueOf(&p)  //这里要填写p的地址\n\nif valueOf.Kind() == reflect.Ptr {\n  if valueOf.Elem().CanSet(){\n    elem := valueOf.Elem()\n  //  field := elem.Field(0)  //通过字段序号获取字段\n    field := elem.FieldByName(\"Name\")  //通过字段名称来获取字段\n    field.SetString(\"wangwu\")\n  }\n}\n~~~\n\n> 注意：\n> Person的字段为大写开头，为可访问字段，如果小写，则会发生程序panic\n> `reflect: reflect.flag.mustBeAssignable using value obtained using unexported field`\n\n#### 调用方法\n\n##### 调用无参数方法\n\n- step1:\n  获取反射valueOf实例\n  ~~~go\n  type Person struct {\n    Name string\n    Age  int\n  }\n  p:=Person{\"zhangshan\",30}\n  \n  func (p Person) Run() {\n    fmt.Println(\"p run\")\n  }\n  \n  valueOf := reflect.ValueOf(p)\n  ~~~\n  \n- step2:\n  通过反射实例获取方法实例\n  ~~~go\n  method := valueOf.MethodByName(\"Run\")\n  ~~~\n- step3:\n  调用方法\n  ~~~go\n  method.Call(nil)\n  ~~~\n\n完整代码：\n~~~go\ntype Person struct {\n  Name string\n  Age  int\n}\np:=Person{\"zhangshan\",30}\n  \nfunc (p Person) Run() {  //方法名称一定要大写\n  fmt.Println(\"p run\")\n}\n  \nvalueOf := reflect.ValueOf(p)\n\n// method := valueOf.Method(0)  //通过序号获取方法实例\nmethod := valueOf.MethodByName(\"Run\")\n\nif method.Kind() == reflect.Func {\n  // method.Call(make([]reflect.Value,0))  //传入一个空切片\n  method.Call(nil)  //直接传入nil空值\n}\n~~~\n\n##### 调用多参数方法\n\n调用多参数方法和无参数方法执行步骤一样，只是在调用时传入参数的切片即可`method.Call([]reflect.Value{reflect.ValueOf(\"lii\"),reflect.ValueOf(\"nihao\"),reflect.ValueOf(5)})`\n\n\n\n~~~go\nfunc (s Person) Write(name string,msg string, length int) {\n  fmt.Println(name,\"写了\",msg,\"一共\",length)\n}\n~~~\n\n\n\n## RPC\n\n### gRPC\n\n## Protobuf\n\n\n\n\n\n\n\n\n\n\n\nfallthrough   在switch 语句中进行穿透，链接两个case \n\n\n\n函数：\n\n\n\n当参数类型一致时，前一个参数可以省略类型\n\n函数参数中如果有可变参数，可变参数放到最后，参数列表中只能有一个可变参数\n\n函数返回值\n\n\n\n\n\n指针\n\n\n\n\n\n","source":"notes/Golang.md","raw":"# Golang\n\n## 数据类型\n\n### 数值类型\n\n#### bool\n\n#### byte\nbyte = uint8\n\n#### int\n有符号类型：int8，int16，int32，int64\n无符号类型：uint8，uint16，uint32，uint64\nrune = int32\n\n#### float\nfloat16，float32\n\n#### string\n\n#### 数组\n\n数组类型声明赋值方式\n\n- 1\n\n  ```\n  var arr [3]int\n  \n  arr[0] = 1\n  arr[1] = 2\n  arr[2] = 3\n  \n  ```\n\n- 2\n  ```\n  var arr =[3]int{1,2,3}\n  ```\n\n- 3\n\n  ```\n  var arr =[...]int{1,2,3}\n  ```\n\n- 4 \n\n  ```\n   arr :=[3]int{1,2,3}\n  ```\n\n- 5 \n\n  ```\n   arr :=[...]int{1,2,3}\n  ```\n\n\n\n不管是使用...代替size还是有具体size 在声明赋值时必须有size\n\n### 引用类型\n\n#### slice\n\n#### map\n\n\n\n## 变量\ngo语言的变量声明了就必须使用，不用就别声明，否则编译不通过\n\n### 函数变量声明\n\n#### 单一变量声明\n关键字\t变量名称\t变量类型\n~~~go\nvar a\tint\t\n~~~\n声明的同时可以赋值变量，同时赋值可以省略变量类型\n~~~go\nvar a\t= 0\t\n~~~\n#### 多变量同时声明1\n关键字\t变量名称，变量名称\t变量类型\n多变量同时声明时，必须为多个类型一样的变量\n~~~go\nvar a,b,c int\n~~~\n声明的同时可以赋值变量，同时赋值时可以省略变量类型\n~~~go\nvar a,b,c = 0,0,0\n~~~\n#### 多变量同时声明2\n关键字\t（\n变量名称\t变量类型\t\n变量名称\t变量类型\n）\n带有括号的多变量赋值时，变量类型可以不同\n~~~go\nvar (\n  a int\n  b string\n)\n~~~\n其中并且可以进行赋值操作，变量类型可以直接省略\n~~~go\nvar (\n  a = 0\n  b = \"bb\"\n)\n~~~\n\n#### 简短声明赋值\n变量名称  :=  变量值\n~~~go\na := 0\n~~~\n\n### 全局变量声明\n\n全局变量声明，包含以上**单一变量声明**，**多变量同时声明1**，**多变量同时声明2**，声明方式，但是只有**多变量同时声明2**声明方式可以同时进行赋值操作，其他方式不支持赋值操作\n\n### 指针\n\n&：取地址\n\n\\*：取值\n\n#### 指针数组\n\\*[4]Type\n首先是一个指针，存储的是数组地址\n\n\n\nvar arr [3]int{1,2,3}\n\nvar p1 *[3]int\n\np1=&arr\n\n(*p1)[2]=100 简写成：p1[2]=100。p1操作的是arr数组\n\n#### 数组指针\n首先是一个数组，存储的是指针\n\n[4]\\*Type\n\n\n\n>注意：\n>\t\\*[4]int\t//指针，4个长度的int类型数组的指针\n>\t[4]\\*int\t//数组，4个长度的int指针地址的数组\n>\t\\*[4]\\*int\t//指针，4个长度int指针地址数组的指针\n>\t\\*\\*[4]\\*int\t//指针，4个长度int指针地址数组的指针的指针\n\n\n\n\n## 条件语句\n\n### if\n- 简单形式\n  ~~~go\n  if 1==2 {\n  \n  }\n  ~~~\n\n- 复合形式\n  - 1\n    ~~~go\n    if a := 0; a ==0 {\n    \n    }\n    ~~~\n  - 2\n    ~~~go\n    if  {\n    \n    }\n    ~~~\n    当不写条件时，当作true处理\n### switch\n\n- 简单形式\n  ~~~go\n  a := 1\n  switch a {\n  case 1:\n    println(1111)\n  default:\n  }\n  ~~~\n\n\n- 复合形式\n  - 1\n    ~~~go\n\n    switch a := 1; a {\n    case 1:\n      println(1111)\n    case 2,3,4:\n      println(222,333,444)\n    default:\n    }\n    ~~~\n\n  - 2\n\n    ~~~go\n    a := 4\n    switch  {\n    case a>=0:\n      println(\">=0\")\n    case a<=5:\n      println(\"<=4\")\n    }\n    ~~~\n    当不写条件时，当作true处理。此处只会输出一种情况`>=0`，switch处理时只要满足一种情况就不会再进行判断\n    \n#### switch穿透 fallthrough\n  ~~~go\n  a := 1\n  switch a {\n  case 1:\n    println(1111)\n    fallthrough\n case 2:\n    println(2222)\n  default:\n  }\n  \n  =======输出为=======\n  1111\n  2222\n  ~~~\nfallthrough 可以穿透case，链接上下两个case一起执行\n\n> 注意：\n> a := 1\n> switch a {\n>\n> default:\n>     println(\"default\")\n>\n>   case 1:\n>     println(1111)\n>\n> }\n> =================输出为===========\n> 1111\n\n\n## 循环语句\n\ngo语言里面没有while，do while 等其他循环结构，只有for\n\n\n\n- 简单形式\n\n  ~~~go\n  for i := 0; i < 10; i++ {\n\n  }\n  ~~~\n\n- 复合形式\n\n  - 1\n    \n    ~~~go\n    for {\n    \n    }\n    ~~~\n    不写条件，当作true处理\n    \n  - 2 \n  \n    ~~~go\n    for index,value := range []int{1,2,3,4} {\n      fmt.Printf(\"index:%d,value:%d \\n\",index,value)\n    }\n    ~~~\n    range关键字可以取出数组，切片，集合等容器里面的数据\n\n\n\n## defer关键字\n\ndefer 延迟，推迟执行。遵循栈的执行原则先进后出，参数变量是已经传递，是在return语句前执行\n\n\n## 函数\n\n\nfunc name(a int,b int) (int){\n\nreturn 0\n\n}\n\n### 函数返回值\n\n~~~go\nfunc name ()(int){\n\nreturn 1\n\n}\n\n\n\nfunc name ()int{\n\nreturn 1\n\n}\n\n\n\nfunc name ()(sum int){\n\nsum:=1\n\nreturn\n\n}\n\n~~~\n\n\n\n\n\n## 结构体\n深拷贝，值传递\n- 简单\n  ~~~go\n  type\tname\tstruct {\n    a int\n    b string\n  }\n  ~~~\n\n- 匿名结构体\n\n  ~~~go\n  struct {\n    a int\n    b string\n  }\n  ~~~\n\n- 匿名结构体字段\n\n  ~~~go\n  type\tname\tstruct {\n   int\n   string\n  }\n  ~~~\n\n  匿名结构体字段访问时，使用匿名字段类型`name.int`，`name.string`，匿名的字段类型不能重复\n\n  ~~~go\n  type\tname\tstruct {\n   int\n   string\n   int\t//不可以\n  }\n  ~~~\n\n\n### 提升字段\n结构体可以嵌套，当一个结构体内嵌套另一个匿名结构体时，可以直接使用字段名称访问被嵌套结构体的字段，这叫做字段提升。\n字段提升只有在被嵌套结构体为匿名的时候可用。\n如果结构体中的字段与被嵌套结构体的字段一样，则访问的为本结构体字段\n\n\n~~~go\ntype Person struct {\n\tname string\n\tage int\n}\n\ntype Student struct {\n\tPerson\n\taddre string\n\tname string\n}\n\np:=Person{\"nihao\",10}\nfmt.Println(p)\n\ns:=Student{Person{\"wohao\",20},\"beij\",\"djh\"}\nfmt.Println(s)\nfmt.Println(s.Person.name,s.Person.age,s.addre,s.name)\nfmt.Println(s.name,s.age,s.addre)\n\n\n======================输出为============================\n\n{nihao 10}\n{{wohao 20} beij djh}\nwohao 20 beij djh\ndjh 20 beij\n~~~\n\n\n\n## 方法\n方法是一个作用在struct结构体上的函数\n\n\n~~~go\nfunc (s Struct) name() {\n\n}\n~~~\n\n实例\n\n~~~go\ntype Person struct {\n\tname string\n\tage int\n}\n\ntype Student struct {\n\tPerson\n\taddre string\n\tname string\n}\nfunc (p Person) run(){\n\tfmt.Println(\"p run\")\n}\n\nfunc (s Student) run()  {\n\tfmt.Println(\"s run\")\n}\n\n\n\np:=Person{\"lisi\",10}\nfmt.Println(p)\np.run()\ns:=Student{Person{\"wangwu\",20},\"beij\",\"xiaowangwu\"}\nfmt.Println(s)\ns.Person.run()\ns.run()\n\n\n\n\n\n===============输出为================\n{lisi 10}\np run\n{{wangwu 20} beij xiaowangwu}\np run\ns run\n~~~\n\n## 接口（interface）\n\n接口可以看作是一些方法的集合。接口是为了解耦合，go语言的接口是非侵入式的。空接口可以看作是任意类型\n\n~~~go\ntype name interface{\n  start()\n  end()\n}\n~~~\n\n### 接口断言\n利用接口来判断类型\n\n- 1\n  instance := 接口对象.(实际类型)   //不安全，会panic（）\n  instance,err := 接口对象.(实际类型)\t//安全\n- 2\n  switch instance := 接口对象.(type) {\n    case 实际类型：\n      xxx\n    case 实际类型：\n      xxxx\n  }\n\n\n\n## type 关键字\n\n- 定义新类型\n  type myint int\n  定义一个int类型的myint类型，但是int和myint类型不一样不能通用\n- 给类型其别名\n  type myint = int \n  给一个int类型起一个别名，int和myint可以通用\n\n## 创建对象\n\n### new\n\n### make\n\n- slice\n  - make([]int,10)\t\n    长度（len）和容量（cap）都为10，默认值为int的零值\n  - make([]int,0,10)\t\n    长度（len）为0，和容量（cap）为10，因为0个长度所以没有值\n- map\n  - make(map[string]string)\n    \n  - make(map[string]string,10)\n  \n- chan\n  - make(chan bool)\n    没有缓存的chan\n  - make(chan bool,10)\n    长度为10的chan\n\n## 访问权限\n名称首字母大写时，可以在其他地方导入，小写其他地方访问不了\n\n\n## IO\n\n## 协程（Gorutine）\n\n## 管道（chan）\n\n## 反射（reflect）\n\n### 基本数据类型反射使用\n\n#### 修改值\n- step1:\n  获取反射对象Value。要修改对象，就要获取对象的地址，用对象的引用地址来更改里面的具体值\n  ~~~go\n  var a int = 0\n  value := reflect.ValueOf(&a)\n  ~~~\n- step2:\n  获取反射对象的指针对象\n  ~~~go\n  elem := value.Elem()\n  ~~~\n- step3:\n  修改值\n  ~~~go\n  elem.SetInt(9)\n  ~~~\n\n完整步骤：\n~~~go\nvar a int = 0\nvalue := reflect.ValueOf(&a)\nelem := value.Elem()\nif !elem.CanSet {  //判断反射对象是否可以修改，不可以直接返回不做修改\n  return\n}\n\nif elem.Kind() ==reflect.Int{ //判断对象是否是int类型\n  elem.SetInt(9)\n}\n\n~~~\n\n### 函数调用\n\n~~~go\nfunc star()  {\n  fmt.Println(\"call this func\")\n}\n\nvalueOf := reflect.ValueOf(star)  //这里star不能加（）\n\nif valueOf.Kind() == reflect.Func {\n  valueOf.Call(nil)\n}\n~~~\n\n### struct 的反射使用\n\n#### 获取字段名称和具体值\n\n- step1:\n  获取反射valueOf和typeOf实例\n  ~~~go\n  type Person struct {\n    Name string\n    Age  int\n  }\n  p:=Person{\"zhangshan\",30}\n\n  valueOf := reflect.ValueOf(p)\n  typeOf := reflect.TypeOf(p)\n  ~~~\n\n\n- step2:\n  通过实例获取字段名称和字段实际值\n  \n  ~~~go\n  for i := 0; i < typeOf.NumField(); i++ {\n    fmt.Println(\"fieldname:  \",typeOf.Field(i).Name)\n    fmt.Println(\"value:  \",valueOf.Field(i))\n  }\n  ~~~\n\n\n完整代码：\n~~~go\ntype Person struct {\n  Name string\n  Age  int\n}\n\np:=Person{\"zhangshan\",30}\n\nvalueOf := reflect.ValueOf(p)\ntypeOf := reflect.TypeOf(p)\n\n\nfor i := 0; i < typeOf.NumField(); i++ {\n  fmt.Println(\"fieldname:  \",typeOf.Field(i).Name)\n  fmt.Println(\"value:  \",valueOf.Field(i))\n}\n~~~\n#### 修改字段值\n\n- step1:\n  获取反射valueOf实例\n  ~~~go\n  type Person struct {\n    Name string\n    Age  int\n  }\n  p:=Person{\"zhangshan\",30}\n\n  valueOf := reflect.ValueOf(&p)  //这里要填写p的地址\n  ~~~\n  \n- step2:\n  修改相应的字段值\n  ~~~go\n  valueOf.Field(0).SetString(\"wangwu\")\n  ~~~\n  \n\n完整代码：\n~~~go\ntype Person struct {\n\tName string\n\tAge  int\n}\np:=Person{\"zhangshan\",30}\n\nvalueOf := reflect.ValueOf(&p)  //这里要填写p的地址\n\nif valueOf.Kind() == reflect.Ptr {\n  if valueOf.Elem().CanSet(){\n    elem := valueOf.Elem()\n  //  field := elem.Field(0)  //通过字段序号获取字段\n    field := elem.FieldByName(\"Name\")  //通过字段名称来获取字段\n    field.SetString(\"wangwu\")\n  }\n}\n~~~\n\n> 注意：\n> Person的字段为大写开头，为可访问字段，如果小写，则会发生程序panic\n> `reflect: reflect.flag.mustBeAssignable using value obtained using unexported field`\n\n#### 调用方法\n\n##### 调用无参数方法\n\n- step1:\n  获取反射valueOf实例\n  ~~~go\n  type Person struct {\n    Name string\n    Age  int\n  }\n  p:=Person{\"zhangshan\",30}\n  \n  func (p Person) Run() {\n    fmt.Println(\"p run\")\n  }\n  \n  valueOf := reflect.ValueOf(p)\n  ~~~\n  \n- step2:\n  通过反射实例获取方法实例\n  ~~~go\n  method := valueOf.MethodByName(\"Run\")\n  ~~~\n- step3:\n  调用方法\n  ~~~go\n  method.Call(nil)\n  ~~~\n\n完整代码：\n~~~go\ntype Person struct {\n  Name string\n  Age  int\n}\np:=Person{\"zhangshan\",30}\n  \nfunc (p Person) Run() {  //方法名称一定要大写\n  fmt.Println(\"p run\")\n}\n  \nvalueOf := reflect.ValueOf(p)\n\n// method := valueOf.Method(0)  //通过序号获取方法实例\nmethod := valueOf.MethodByName(\"Run\")\n\nif method.Kind() == reflect.Func {\n  // method.Call(make([]reflect.Value,0))  //传入一个空切片\n  method.Call(nil)  //直接传入nil空值\n}\n~~~\n\n##### 调用多参数方法\n\n调用多参数方法和无参数方法执行步骤一样，只是在调用时传入参数的切片即可`method.Call([]reflect.Value{reflect.ValueOf(\"lii\"),reflect.ValueOf(\"nihao\"),reflect.ValueOf(5)})`\n\n\n\n~~~go\nfunc (s Person) Write(name string,msg string, length int) {\n  fmt.Println(name,\"写了\",msg,\"一共\",length)\n}\n~~~\n\n\n\n## RPC\n\n### gRPC\n\n## Protobuf\n\n\n\n\n\n\n\n\n\n\n\nfallthrough   在switch 语句中进行穿透，链接两个case \n\n\n\n函数：\n\n\n\n当参数类型一致时，前一个参数可以省略类型\n\n函数参数中如果有可变参数，可变参数放到最后，参数列表中只能有一个可变参数\n\n函数返回值\n\n\n\n\n\n指针\n\n\n\n\n\n","date":"2020-04-13T04:26:23.304Z","updated":"2020-04-13T04:26:23.252Z","path":"notes/Golang.html","_id":"ck8o1hab0000w13s6cghbbyog","title":"","comments":1,"layout":"page","content":"<h1 id=\"Golang\"><a href=\"#Golang\" class=\"headerlink\" title=\"Golang\"></a>Golang</h1><h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"数值类型\"><a href=\"#数值类型\" class=\"headerlink\" title=\"数值类型\"></a>数值类型</h3><h4 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool\"></a>bool</h4><h4 id=\"byte\"><a href=\"#byte\" class=\"headerlink\" title=\"byte\"></a>byte</h4><p>byte = uint8</p>\n<h4 id=\"int\"><a href=\"#int\" class=\"headerlink\" title=\"int\"></a>int</h4><p>有符号类型：int8，int16，int32，int64<br>无符号类型：uint8，uint16，uint32，uint64<br>rune = int32</p>\n<h4 id=\"float\"><a href=\"#float\" class=\"headerlink\" title=\"float\"></a>float</h4><p>float16，float32</p>\n<h4 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h4><h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><p>数组类型声明赋值方式</p>\n<ul>\n<li><p>1</p>\n<pre><code>var arr [3]int\n\narr[0] = 1\narr[1] = 2\narr[2] = 3\n</code></pre></li>\n<li><p>2</p>\n<pre><code>var arr =[3]int{1,2,3}</code></pre></li>\n<li><p>3</p>\n<pre><code>var arr =[...]int{1,2,3}</code></pre></li>\n<li><p>4 </p>\n<pre><code> arr :=[3]int{1,2,3}</code></pre></li>\n<li><p>5 </p>\n<pre><code> arr :=[...]int{1,2,3}</code></pre></li>\n</ul>\n<p>不管是使用…代替size还是有具体size 在声明赋值时必须有size</p>\n<h3 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h3><h4 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h4><h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>go语言的变量声明了就必须使用，不用就别声明，否则编译不通过</p>\n<h3 id=\"函数变量声明\"><a href=\"#函数变量声明\" class=\"headerlink\" title=\"函数变量声明\"></a>函数变量声明</h3><h4 id=\"单一变量声明\"><a href=\"#单一变量声明\" class=\"headerlink\" title=\"单一变量声明\"></a>单一变量声明</h4><p>关键字    变量名称    变量类型</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> a    <span class=\"token builtin\">int</span>    </code></pre>\n<p>声明的同时可以赋值变量，同时赋值可以省略变量类型</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> a    <span class=\"token operator\">=</span> <span class=\"token number\">0</span>    </code></pre>\n<h4 id=\"多变量同时声明1\"><a href=\"#多变量同时声明1\" class=\"headerlink\" title=\"多变量同时声明1\"></a>多变量同时声明1</h4><p>关键字    变量名称，变量名称    变量类型<br>多变量同时声明时，必须为多个类型一样的变量</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token builtin\">int</span></code></pre>\n<p>声明的同时可以赋值变量，同时赋值时可以省略变量类型</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> a<span class=\"token punctuation\">,</span>b<span class=\"token punctuation\">,</span>c <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">0</span></code></pre>\n<h4 id=\"多变量同时声明2\"><a href=\"#多变量同时声明2\" class=\"headerlink\" title=\"多变量同时声明2\"></a>多变量同时声明2</h4><p>关键字    （<br>变量名称    变量类型<br>变量名称    变量类型<br>）<br>带有括号的多变量赋值时，变量类型可以不同</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> <span class=\"token punctuation\">(</span>\n  a <span class=\"token builtin\">int</span>\n  b <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">)</span></code></pre>\n<p>其中并且可以进行赋值操作，变量类型可以直接省略</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> <span class=\"token punctuation\">(</span>\n  a <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  b <span class=\"token operator\">=</span> <span class=\"token string\">\"bb\"</span>\n<span class=\"token punctuation\">)</span></code></pre>\n<h4 id=\"简短声明赋值\"><a href=\"#简短声明赋值\" class=\"headerlink\" title=\"简短声明赋值\"></a>简短声明赋值</h4><p>变量名称  :=  变量值</p>\n<pre class=\" language-go\"><code class=\"language-go\">a <span class=\"token operator\">:=</span> <span class=\"token number\">0</span></code></pre>\n<h3 id=\"全局变量声明\"><a href=\"#全局变量声明\" class=\"headerlink\" title=\"全局变量声明\"></a>全局变量声明</h3><p>全局变量声明，包含以上<strong>单一变量声明</strong>，<strong>多变量同时声明1</strong>，<strong>多变量同时声明2</strong>，声明方式，但是只有<strong>多变量同时声明2</strong>声明方式可以同时进行赋值操作，其他方式不支持赋值操作</p>\n<h3 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h3><p>&amp;：取地址</p>\n<p>*：取值</p>\n<h4 id=\"指针数组\"><a href=\"#指针数组\" class=\"headerlink\" title=\"指针数组\"></a>指针数组</h4><p>*[4]Type<br>首先是一个指针，存储的是数组地址</p>\n<p>var arr [3]int{1,2,3}</p>\n<p>var p1 *[3]int</p>\n<p>p1=&amp;arr</p>\n<p>(*p1)[2]=100 简写成：p1[2]=100。p1操作的是arr数组</p>\n<h4 id=\"数组指针\"><a href=\"#数组指针\" class=\"headerlink\" title=\"数组指针\"></a>数组指针</h4><p>首先是一个数组，存储的是指针</p>\n<p>[4]*Type</p>\n<blockquote>\n<p>注意：<br>   *[4]int    //指针，4个长度的int类型数组的指针<br>   [4]*int    //数组，4个长度的int指针地址的数组<br>   *[4]*int    //指针，4个长度int指针地址数组的指针<br>   **[4]*int    //指针，4个长度int指针地址数组的指针的指针</p>\n</blockquote>\n<h2 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h2><h3 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h3><ul>\n<li><p>简单形式</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">if</span> <span class=\"token number\">1</span><span class=\"token operator\">==</span><span class=\"token number\">2</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p>复合形式</p>\n<ul>\n<li><p>1</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">if</span> a <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> a <span class=\"token operator\">==</span><span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p>2</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">if</span>  <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<p>当不写条件时，当作true处理</p>\n<h3 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h3></li>\n</ul>\n</li>\n<li><p>简单形式</p>\n<pre class=\" language-go\"><code class=\"language-go\">a <span class=\"token operator\">:=</span> <span class=\"token number\">1</span>\n<span class=\"token keyword\">switch</span> a <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">case</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token number\">1111</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n</ul>\n<ul>\n<li><p>复合形式</p>\n<ul>\n<li><p>1</p>\n<pre class=\" language-go\"><code class=\"language-go\">\n<span class=\"token keyword\">switch</span> a <span class=\"token operator\">:=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> a <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">case</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token number\">1111</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">case</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">:</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token number\">222</span><span class=\"token punctuation\">,</span><span class=\"token number\">333</span><span class=\"token punctuation\">,</span><span class=\"token number\">444</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p>2</p>\n<pre class=\" language-go\"><code class=\"language-go\">a <span class=\"token operator\">:=</span> <span class=\"token number\">4</span>\n<span class=\"token keyword\">switch</span>  <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">case</span> a<span class=\"token operator\">>=</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\">=0\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">case</span> a<span class=\"token operator\">&lt;=</span><span class=\"token number\">5</span><span class=\"token punctuation\">:</span>\n  <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"&lt;=4\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>当不写条件时，当作true处理。此处只会输出一种情况<code>&gt;=0</code>，switch处理时只要满足一种情况就不会再进行判断</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"switch穿透-fallthrough\"><a href=\"#switch穿透-fallthrough\" class=\"headerlink\" title=\"switch穿透 fallthrough\"></a>switch穿透 fallthrough</h4><pre class=\" language-go\"><code class=\"language-go\">  a <span class=\"token operator\">:=</span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">switch</span> a <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">case</span> <span class=\"token number\">1</span><span class=\"token punctuation\">:</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token number\">1111</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">fallthrough</span>\n <span class=\"token keyword\">case</span> <span class=\"token number\">2</span><span class=\"token punctuation\">:</span>\n    <span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token number\">2222</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">default</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>输出为<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>\n  <span class=\"token number\">1111</span>\n  <span class=\"token number\">2222</span></code></pre>\n<p>fallthrough 可以穿透case，链接上下两个case一起执行</p>\n<blockquote>\n<p>注意：<br>a := 1<br>switch a {</p>\n<p>default:<br>    println(“default”)</p>\n<p>  case 1:<br>    println(1111)</p>\n<p>}<br>=================输出为===========<br>1111</p>\n</blockquote>\n<h2 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h2><p>go语言里面没有while，do while 等其他循环结构，只有for</p>\n<ul>\n<li><p>简单形式</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p>复合形式</p>\n<ul>\n<li><p>1</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">for</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<p>不写条件，当作true处理</p>\n</li>\n<li><p>2 </p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">for</span> index<span class=\"token punctuation\">,</span>value <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">}</span> <span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Printf</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"index:%d,value:%d \\n\"</span><span class=\"token punctuation\">,</span>index<span class=\"token punctuation\">,</span>value<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>range关键字可以取出数组，切片，集合等容器里面的数据</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"defer关键字\"><a href=\"#defer关键字\" class=\"headerlink\" title=\"defer关键字\"></a>defer关键字</h2><p>defer 延迟，推迟执行。遵循栈的执行原则先进后出，参数变量是已经传递，是在return语句前执行</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>func name(a int,b int) (int){</p>\n<p>return 0</p>\n<p>}</p>\n<h3 id=\"函数返回值\"><a href=\"#函数返回值\" class=\"headerlink\" title=\"函数返回值\"></a>函数返回值</h3><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">name</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\n<span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n\n<span class=\"token punctuation\">}</span>\n\n\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">name</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">{</span>\n\n<span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n\n<span class=\"token punctuation\">}</span>\n\n\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">name</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>sum <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\nsum<span class=\"token operator\">:=</span><span class=\"token number\">1</span>\n\n<span class=\"token keyword\">return</span>\n\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h2 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h2><p>深拷贝，值传递</p>\n<ul>\n<li><p>简单</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span>    name    <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  a <span class=\"token builtin\">int</span>\n  b <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p>匿名结构体</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  a <span class=\"token builtin\">int</span>\n  b <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p>匿名结构体字段</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span>    name    <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n <span class=\"token builtin\">int</span>\n <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>匿名结构体字段访问时，使用匿名字段类型<code>name.int</code>，<code>name.string</code>，匿名的字段类型不能重复</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span>    name    <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n <span class=\"token builtin\">int</span>\n <span class=\"token builtin\">string</span>\n <span class=\"token builtin\">int</span>    <span class=\"token comment\" spellcheck=\"true\">//不可以</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n</ul>\n<h3 id=\"提升字段\"><a href=\"#提升字段\" class=\"headerlink\" title=\"提升字段\"></a>提升字段</h3><p>结构体可以嵌套，当一个结构体内嵌套另一个匿名结构体时，可以直接使用字段名称访问被嵌套结构体的字段，这叫做字段提升。<br>字段提升只有在被嵌套结构体为匿名的时候可用。<br>如果结构体中的字段与被嵌套结构体的字段一样，则访问的为本结构体字段</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    name <span class=\"token builtin\">string</span>\n    age <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> Student <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    Person\n    addre <span class=\"token builtin\">string</span>\n    name <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n\np<span class=\"token operator\">:=</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"nihao\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">}</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span>\n\ns<span class=\"token operator\">:=</span>Student<span class=\"token punctuation\">{</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"wohao\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"beij\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"djh\"</span><span class=\"token punctuation\">}</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>Person<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">.</span>Person<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">.</span>addre<span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">)</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">.</span>age<span class=\"token punctuation\">,</span>s<span class=\"token punctuation\">.</span>addre<span class=\"token punctuation\">)</span>\n\n\n<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span>输出为<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span>\n\n<span class=\"token punctuation\">{</span>nihao <span class=\"token number\">10</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>wohao <span class=\"token number\">20</span><span class=\"token punctuation\">}</span> beij djh<span class=\"token punctuation\">}</span>\nwohao <span class=\"token number\">20</span> beij djh\ndjh <span class=\"token number\">20</span> beij</code></pre>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>方法是一个作用在struct结构体上的函数</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s Struct<span class=\"token punctuation\">)</span> <span class=\"token function\">name</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span></code></pre>\n<p>实例</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    name <span class=\"token builtin\">string</span>\n    age <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> Student <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    Person\n    addre <span class=\"token builtin\">string</span>\n    name <span class=\"token builtin\">string</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>p Person<span class=\"token punctuation\">)</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"p run\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s Student<span class=\"token punctuation\">)</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">{</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"s run\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n\n\np<span class=\"token operator\">:=</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"lisi\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">10</span><span class=\"token punctuation\">}</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span>\np<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ns<span class=\"token operator\">:=</span>Student<span class=\"token punctuation\">{</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"wangwu\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">20</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"beij\"</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"xiaowangwu\"</span><span class=\"token punctuation\">}</span>\nfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\ns<span class=\"token punctuation\">.</span>Person<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\ns<span class=\"token punctuation\">.</span><span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n\n\n\n\n<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">=</span>输出为<span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span><span class=\"token operator\">==</span>\n<span class=\"token punctuation\">{</span>lisi <span class=\"token number\">10</span><span class=\"token punctuation\">}</span>\np run\n<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>wangwu <span class=\"token number\">20</span><span class=\"token punctuation\">}</span> beij xiaowangwu<span class=\"token punctuation\">}</span>\np run\ns run</code></pre>\n<h2 id=\"接口（interface）\"><a href=\"#接口（interface）\" class=\"headerlink\" title=\"接口（interface）\"></a>接口（interface）</h2><p>接口可以看作是一些方法的集合。接口是为了解耦合，go语言的接口是非侵入式的。空接口可以看作是任意类型</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> name <span class=\"token keyword\">interface</span><span class=\"token punctuation\">{</span>\n  <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token function\">end</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"接口断言\"><a href=\"#接口断言\" class=\"headerlink\" title=\"接口断言\"></a>接口断言</h3><p>利用接口来判断类型</p>\n<ul>\n<li>1<br>instance := 接口对象.(实际类型)   //不安全，会panic（）<br>instance,err := 接口对象.(实际类型)    //安全</li>\n<li>2<br>switch instance := 接口对象.(type) {<br>  case 实际类型：<pre><code>xxx</code></pre>  case 实际类型：<pre><code>xxxx</code></pre>}</li>\n</ul>\n<h2 id=\"type-关键字\"><a href=\"#type-关键字\" class=\"headerlink\" title=\"type 关键字\"></a>type 关键字</h2><ul>\n<li>定义新类型<br>type myint int<br>定义一个int类型的myint类型，但是int和myint类型不一样不能通用</li>\n<li>给类型其别名<br>type myint = int<br>给一个int类型起一个别名，int和myint可以通用</li>\n</ul>\n<h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h3><h3 id=\"make\"><a href=\"#make\" class=\"headerlink\" title=\"make\"></a>make</h3><ul>\n<li><p>slice</p>\n<ul>\n<li>make([]int,10)<br>长度（len）和容量（cap）都为10，默认值为int的零值</li>\n<li>make([]int,0,10)<br>长度（len）为0，和容量（cap）为10，因为0个长度所以没有值</li>\n</ul>\n</li>\n<li><p>map</p>\n<ul>\n<li><p>make(map[string]string)</p>\n</li>\n<li><p>make(map[string]string,10)</p>\n</li>\n</ul>\n</li>\n<li><p>chan</p>\n<ul>\n<li>make(chan bool)<br>没有缓存的chan</li>\n<li>make(chan bool,10)<br>长度为10的chan</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"访问权限\"><a href=\"#访问权限\" class=\"headerlink\" title=\"访问权限\"></a>访问权限</h2><p>名称首字母大写时，可以在其他地方导入，小写其他地方访问不了</p>\n<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><h2 id=\"协程（Gorutine）\"><a href=\"#协程（Gorutine）\" class=\"headerlink\" title=\"协程（Gorutine）\"></a>协程（Gorutine）</h2><h2 id=\"管道（chan）\"><a href=\"#管道（chan）\" class=\"headerlink\" title=\"管道（chan）\"></a>管道（chan）</h2><h2 id=\"反射（reflect）\"><a href=\"#反射（reflect）\" class=\"headerlink\" title=\"反射（reflect）\"></a>反射（reflect）</h2><h3 id=\"基本数据类型反射使用\"><a href=\"#基本数据类型反射使用\" class=\"headerlink\" title=\"基本数据类型反射使用\"></a>基本数据类型反射使用</h3><h4 id=\"修改值\"><a href=\"#修改值\" class=\"headerlink\" title=\"修改值\"></a>修改值</h4><ul>\n<li>step1:<br>获取反射对象Value。要修改对象，就要获取对象的地址，用对象的引用地址来更改里面的具体值<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> a <span class=\"token builtin\">int</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\nvalue <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">)</span></code></pre>\n</li>\n<li>step2:<br>获取反射对象的指针对象<pre class=\" language-go\"><code class=\"language-go\">elem <span class=\"token operator\">:=</span> value<span class=\"token punctuation\">.</span><span class=\"token function\">Elem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n</li>\n<li>step3:<br>修改值<pre class=\" language-go\"><code class=\"language-go\">elem<span class=\"token punctuation\">.</span><span class=\"token function\">SetInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">9</span><span class=\"token punctuation\">)</span></code></pre>\n</li>\n</ul>\n<p>完整步骤：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">var</span> a <span class=\"token builtin\">int</span> <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\nvalue <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>a<span class=\"token punctuation\">)</span>\nelem <span class=\"token operator\">:=</span> value<span class=\"token punctuation\">.</span><span class=\"token function\">Elem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">if</span> <span class=\"token operator\">!</span>elem<span class=\"token punctuation\">.</span>CanSet <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">//判断反射对象是否可以修改，不可以直接返回不做修改</span>\n  <span class=\"token keyword\">return</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">if</span> elem<span class=\"token punctuation\">.</span><span class=\"token function\">Kind</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span>reflect<span class=\"token punctuation\">.</span>Int<span class=\"token punctuation\">{</span> <span class=\"token comment\" spellcheck=\"true\">//判断对象是否是int类型</span>\n  elem<span class=\"token punctuation\">.</span><span class=\"token function\">SetInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">9</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<h3 id=\"函数调用\"><a href=\"#函数调用\" class=\"headerlink\" title=\"函数调用\"></a>函数调用</h3><pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">star</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>  <span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"call this func\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\nvalueOf <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span>star<span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">//这里star不能加（）</span>\n\n<span class=\"token keyword\">if</span> valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">Kind</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> reflect<span class=\"token punctuation\">.</span>Func <span class=\"token punctuation\">{</span>\n  valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">Call</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"struct-的反射使用\"><a href=\"#struct-的反射使用\" class=\"headerlink\" title=\"struct 的反射使用\"></a>struct 的反射使用</h3><h4 id=\"获取字段名称和具体值\"><a href=\"#获取字段名称和具体值\" class=\"headerlink\" title=\"获取字段名称和具体值\"></a>获取字段名称和具体值</h4><ul>\n<li><p>step1:<br>获取反射valueOf和typeOf实例</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  Name <span class=\"token builtin\">string</span>\n  Age  <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>\np<span class=\"token operator\">:=</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"zhangshan\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">30</span><span class=\"token punctuation\">}</span>\n\nvalueOf <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span>\ntypeOf <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">TypeOf</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span></code></pre>\n</li>\n</ul>\n<ul>\n<li><p>step2:<br>通过实例获取字段名称和字段实际值</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> typeOf<span class=\"token punctuation\">.</span><span class=\"token function\">NumField</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fieldname:  \"</span><span class=\"token punctuation\">,</span>typeOf<span class=\"token punctuation\">.</span><span class=\"token function\">Field</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">)</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"value:  \"</span><span class=\"token punctuation\">,</span>valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">Field</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n</ul>\n<p>完整代码：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  Name <span class=\"token builtin\">string</span>\n  Age  <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>\n\np<span class=\"token operator\">:=</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"zhangshan\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">30</span><span class=\"token punctuation\">}</span>\n\nvalueOf <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span>\ntypeOf <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">TypeOf</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span>\n\n\n<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> typeOf<span class=\"token punctuation\">.</span><span class=\"token function\">NumField</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span> <span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"fieldname:  \"</span><span class=\"token punctuation\">,</span>typeOf<span class=\"token punctuation\">.</span><span class=\"token function\">Field</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>Name<span class=\"token punctuation\">)</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"value:  \"</span><span class=\"token punctuation\">,</span>valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">Field</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"修改字段值\"><a href=\"#修改字段值\" class=\"headerlink\" title=\"修改字段值\"></a>修改字段值</h4><ul>\n<li><p>step1:<br>获取反射valueOf实例</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  Name <span class=\"token builtin\">string</span>\n  Age  <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>\np<span class=\"token operator\">:=</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"zhangshan\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">30</span><span class=\"token punctuation\">}</span>\n\nvalueOf <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">//这里要填写p的地址</span></code></pre>\n</li>\n<li><p>step2:<br>修改相应的字段值</p>\n<pre class=\" language-go\"><code class=\"language-go\">valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">Field</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">SetString</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"wangwu\"</span><span class=\"token punctuation\">)</span></code></pre>\n</li>\n</ul>\n<p>完整代码：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    Name <span class=\"token builtin\">string</span>\n    Age  <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>\np<span class=\"token operator\">:=</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"zhangshan\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">30</span><span class=\"token punctuation\">}</span>\n\nvalueOf <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>p<span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">//这里要填写p的地址</span>\n\n<span class=\"token keyword\">if</span> valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">Kind</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> reflect<span class=\"token punctuation\">.</span>Ptr <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">Elem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">CanSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    elem <span class=\"token operator\">:=</span> valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">Elem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token comment\" spellcheck=\"true\">//  field := elem.Field(0)  //通过字段序号获取字段</span>\n    field <span class=\"token operator\">:=</span> elem<span class=\"token punctuation\">.</span><span class=\"token function\">FieldByName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Name\"</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">//通过字段名称来获取字段</span>\n    field<span class=\"token punctuation\">.</span><span class=\"token function\">SetString</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"wangwu\"</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<blockquote>\n<p>注意：<br>Person的字段为大写开头，为可访问字段，如果小写，则会发生程序panic<br><code>reflect: reflect.flag.mustBeAssignable using value obtained using unexported field</code></p>\n</blockquote>\n<h4 id=\"调用方法\"><a href=\"#调用方法\" class=\"headerlink\" title=\"调用方法\"></a>调用方法</h4><h5 id=\"调用无参数方法\"><a href=\"#调用无参数方法\" class=\"headerlink\" title=\"调用无参数方法\"></a>调用无参数方法</h5><ul>\n<li><p>step1:<br>获取反射valueOf实例</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  Name <span class=\"token builtin\">string</span>\n  Age  <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>\np<span class=\"token operator\">:=</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"zhangshan\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">30</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>p Person<span class=\"token punctuation\">)</span> <span class=\"token function\">Run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"p run\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\nvalueOf <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span></code></pre>\n</li>\n<li><p>step2:<br>通过反射实例获取方法实例</p>\n<pre class=\" language-go\"><code class=\"language-go\">method <span class=\"token operator\">:=</span> valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">MethodByName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Run\"</span><span class=\"token punctuation\">)</span></code></pre>\n</li>\n<li><p>step3:<br>调用方法</p>\n<pre class=\" language-go\"><code class=\"language-go\">method<span class=\"token punctuation\">.</span><span class=\"token function\">Call</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span></code></pre>\n</li>\n</ul>\n<p>完整代码：</p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">type</span> Person <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n  Name <span class=\"token builtin\">string</span>\n  Age  <span class=\"token builtin\">int</span>\n<span class=\"token punctuation\">}</span>\np<span class=\"token operator\">:=</span>Person<span class=\"token punctuation\">{</span><span class=\"token string\">\"zhangshan\"</span><span class=\"token punctuation\">,</span><span class=\"token number\">30</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>p Person<span class=\"token punctuation\">)</span> <span class=\"token function\">Run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>  <span class=\"token comment\" spellcheck=\"true\">//方法名称一定要大写</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"p run\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\nvalueOf <span class=\"token operator\">:=</span> reflect<span class=\"token punctuation\">.</span><span class=\"token function\">ValueOf</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\" spellcheck=\"true\">// method := valueOf.Method(0)  //通过序号获取方法实例</span>\nmethod <span class=\"token operator\">:=</span> valueOf<span class=\"token punctuation\">.</span><span class=\"token function\">MethodByName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Run\"</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">if</span> method<span class=\"token punctuation\">.</span><span class=\"token function\">Kind</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> reflect<span class=\"token punctuation\">.</span>Func <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\" spellcheck=\"true\">// method.Call(make([]reflect.Value,0))  //传入一个空切片</span>\n  method<span class=\"token punctuation\">.</span><span class=\"token function\">Call</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">nil</span><span class=\"token punctuation\">)</span>  <span class=\"token comment\" spellcheck=\"true\">//直接传入nil空值</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h5 id=\"调用多参数方法\"><a href=\"#调用多参数方法\" class=\"headerlink\" title=\"调用多参数方法\"></a>调用多参数方法</h5><p>调用多参数方法和无参数方法执行步骤一样，只是在调用时传入参数的切片即可<code>method.Call([]reflect.Value{reflect.ValueOf(&quot;lii&quot;),reflect.ValueOf(&quot;nihao&quot;),reflect.ValueOf(5)})</code></p>\n<pre class=\" language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>s Person<span class=\"token punctuation\">)</span> <span class=\"token function\">Write</span><span class=\"token punctuation\">(</span>name <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span>msg <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> length <span class=\"token builtin\">int</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span><span class=\"token string\">\"写了\"</span><span class=\"token punctuation\">,</span>msg<span class=\"token punctuation\">,</span><span class=\"token string\">\"一共\"</span><span class=\"token punctuation\">,</span>length<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h2><h3 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h3><h2 id=\"Protobuf\"><a href=\"#Protobuf\" class=\"headerlink\" title=\"Protobuf\"></a>Protobuf</h2><p>fallthrough   在switch 语句中进行穿透，链接两个case </p>\n<p>函数：</p>\n<p>当参数类型一致时，前一个参数可以省略类型</p>\n<p>函数参数中如果有可变参数，可变参数放到最后，参数列表中只能有一个可变参数</p>\n<p>函数返回值</p>\n<p>指针</p>\n","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<h1 id=\"Golang\"><a href=\"#Golang\" class=\"headerlink\" title=\"Golang\"></a>Golang</h1><h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"数值类型\"><a href=\"#数值类型\" class=\"headerlink\" title=\"数值类型\"></a>数值类型</h3><h4 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool\"></a>bool</h4><h4 id=\"byte\"><a href=\"#byte\" class=\"headerlink\" title=\"byte\"></a>byte</h4><p>byte = uint8</p>\n<h4 id=\"int\"><a href=\"#int\" class=\"headerlink\" title=\"int\"></a>int</h4><p>有符号类型：int8，int16，int32，int64<br>无符号类型：uint8，uint16，uint32，uint64<br>rune = int32</p>\n<h4 id=\"float\"><a href=\"#float\" class=\"headerlink\" title=\"float\"></a>float</h4><p>float16，float32</p>\n<h4 id=\"string\"><a href=\"#string\" class=\"headerlink\" title=\"string\"></a>string</h4><h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><p>数组类型声明赋值方式</p>\n<ul>\n<li><p>1</p>\n<pre><code>var arr [3]int\n\narr[0] = 1\narr[1] = 2\narr[2] = 3\n</code></pre></li>\n<li><p>2</p>\n<pre><code>var arr =[3]int{1,2,3}</code></pre></li>\n<li><p>3</p>\n<pre><code>var arr =[...]int{1,2,3}</code></pre></li>\n<li><p>4 </p>\n<pre><code> arr :=[3]int{1,2,3}</code></pre></li>\n<li><p>5 </p>\n<pre><code> arr :=[...]int{1,2,3}</code></pre></li>\n</ul>\n<p>不管是使用…代替size还是有具体size 在声明赋值时必须有size</p>\n<h3 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h3><h4 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice\"></a>slice</h4><h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>go语言的变量声明了就必须使用，不用就别声明，否则编译不通过</p>\n<h3 id=\"函数变量声明\"><a href=\"#函数变量声明\" class=\"headerlink\" title=\"函数变量声明\"></a>函数变量声明</h3><h4 id=\"单一变量声明\"><a href=\"#单一变量声明\" class=\"headerlink\" title=\"单一变量声明\"></a>单一变量声明</h4><p>关键字    变量名称    变量类型</p>\n<pre><code class=\"go\">var a    int    </code></pre>\n<p>声明的同时可以赋值变量，同时赋值可以省略变量类型</p>\n<pre><code class=\"go\">var a    = 0    </code></pre>\n<h4 id=\"多变量同时声明1\"><a href=\"#多变量同时声明1\" class=\"headerlink\" title=\"多变量同时声明1\"></a>多变量同时声明1</h4><p>关键字    变量名称，变量名称    变量类型<br>多变量同时声明时，必须为多个类型一样的变量</p>\n<pre><code class=\"go\">var a,b,c int</code></pre>\n<p>声明的同时可以赋值变量，同时赋值时可以省略变量类型</p>\n<pre><code class=\"go\">var a,b,c = 0,0,0</code></pre>\n<h4 id=\"多变量同时声明2\"><a href=\"#多变量同时声明2\" class=\"headerlink\" title=\"多变量同时声明2\"></a>多变量同时声明2</h4><p>关键字    （<br>变量名称    变量类型<br>变量名称    变量类型<br>）<br>带有括号的多变量赋值时，变量类型可以不同</p>\n<pre><code class=\"go\">var (\n  a int\n  b string\n)</code></pre>\n<p>其中并且可以进行赋值操作，变量类型可以直接省略</p>\n<pre><code class=\"go\">var (\n  a = 0\n  b = &quot;bb&quot;\n)</code></pre>\n<h4 id=\"简短声明赋值\"><a href=\"#简短声明赋值\" class=\"headerlink\" title=\"简短声明赋值\"></a>简短声明赋值</h4><p>变量名称  :=  变量值</p>\n<pre><code class=\"go\">a := 0</code></pre>\n<h3 id=\"全局变量声明\"><a href=\"#全局变量声明\" class=\"headerlink\" title=\"全局变量声明\"></a>全局变量声明</h3><p>全局变量声明，包含以上<strong>单一变量声明</strong>，<strong>多变量同时声明1</strong>，<strong>多变量同时声明2</strong>，声明方式，但是只有<strong>多变量同时声明2</strong>声明方式可以同时进行赋值操作，其他方式不支持赋值操作</p>\n<h3 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h3><p>&amp;：取地址</p>\n<p>*：取值</p>\n<h4 id=\"指针数组\"><a href=\"#指针数组\" class=\"headerlink\" title=\"指针数组\"></a>指针数组</h4><p>*[4]Type<br>首先是一个指针，存储的是数组地址</p>\n<p>var arr [3]int{1,2,3}</p>\n<p>var p1 *[3]int</p>\n<p>p1=&amp;arr</p>\n<p>(*p1)[2]=100 简写成：p1[2]=100。p1操作的是arr数组</p>\n<h4 id=\"数组指针\"><a href=\"#数组指针\" class=\"headerlink\" title=\"数组指针\"></a>数组指针</h4><p>首先是一个数组，存储的是指针</p>\n<p>[4]*Type</p>\n<blockquote>\n<p>注意：<br>   *[4]int    //指针，4个长度的int类型数组的指针<br>   [4]*int    //数组，4个长度的int指针地址的数组<br>   *[4]*int    //指针，4个长度int指针地址数组的指针<br>   **[4]*int    //指针，4个长度int指针地址数组的指针的指针</p>\n</blockquote>\n<h2 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h2><h3 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h3><ul>\n<li><p>简单形式</p>\n<pre><code class=\"go\">if 1==2 {\n\n}</code></pre>\n</li>\n<li><p>复合形式</p>\n<ul>\n<li><p>1</p>\n<pre><code class=\"go\">if a := 0; a ==0 {\n\n}</code></pre>\n</li>\n<li><p>2</p>\n<pre><code class=\"go\">if  {\n\n}</code></pre>\n<p>当不写条件时，当作true处理</p>\n<h3 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h3></li>\n</ul>\n</li>\n<li><p>简单形式</p>\n<pre><code class=\"go\">a := 1\nswitch a {\ncase 1:\n  println(1111)\ndefault:\n}</code></pre>\n</li>\n</ul>\n<ul>\n<li><p>复合形式</p>\n<ul>\n<li><p>1</p>\n<pre><code class=\"go\">\nswitch a := 1; a {\ncase 1:\n  println(1111)\ncase 2,3,4:\n  println(222,333,444)\ndefault:\n}</code></pre>\n</li>\n<li><p>2</p>\n<pre><code class=\"go\">a := 4\nswitch  {\ncase a&gt;=0:\n  println(&quot;&gt;=0&quot;)\ncase a&lt;=5:\n  println(&quot;&lt;=4&quot;)\n}</code></pre>\n<p>当不写条件时，当作true处理。此处只会输出一种情况<code>&gt;=0</code>，switch处理时只要满足一种情况就不会再进行判断</p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"switch穿透-fallthrough\"><a href=\"#switch穿透-fallthrough\" class=\"headerlink\" title=\"switch穿透 fallthrough\"></a>switch穿透 fallthrough</h4><pre><code class=\"go\">  a := 1\n  switch a {\n  case 1:\n    println(1111)\n    fallthrough\n case 2:\n    println(2222)\n  default:\n  }\n\n  =======输出为=======\n  1111\n  2222</code></pre>\n<p>fallthrough 可以穿透case，链接上下两个case一起执行</p>\n<blockquote>\n<p>注意：<br>a := 1<br>switch a {</p>\n<p>default:<br>    println(“default”)</p>\n<p>  case 1:<br>    println(1111)</p>\n<p>}<br>=================输出为===========<br>1111</p>\n</blockquote>\n<h2 id=\"循环语句\"><a href=\"#循环语句\" class=\"headerlink\" title=\"循环语句\"></a>循环语句</h2><p>go语言里面没有while，do while 等其他循环结构，只有for</p>\n<ul>\n<li><p>简单形式</p>\n<pre><code class=\"go\">for i := 0; i &lt; 10; i++ {\n\n}</code></pre>\n</li>\n<li><p>复合形式</p>\n<ul>\n<li><p>1</p>\n<pre><code class=\"go\">for {\n\n}</code></pre>\n<p>不写条件，当作true处理</p>\n</li>\n<li><p>2 </p>\n<pre><code class=\"go\">for index,value := range []int{1,2,3,4} {\n  fmt.Printf(&quot;index:%d,value:%d \\n&quot;,index,value)\n}</code></pre>\n<p>range关键字可以取出数组，切片，集合等容器里面的数据</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"defer关键字\"><a href=\"#defer关键字\" class=\"headerlink\" title=\"defer关键字\"></a>defer关键字</h2><p>defer 延迟，推迟执行。遵循栈的执行原则先进后出，参数变量是已经传递，是在return语句前执行</p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>func name(a int,b int) (int){</p>\n<p>return 0</p>\n<p>}</p>\n<h3 id=\"函数返回值\"><a href=\"#函数返回值\" class=\"headerlink\" title=\"函数返回值\"></a>函数返回值</h3><pre><code class=\"go\">func name ()(int){\n\nreturn 1\n\n}\n\n\n\nfunc name ()int{\n\nreturn 1\n\n}\n\n\n\nfunc name ()(sum int){\n\nsum:=1\n\nreturn\n\n}\n</code></pre>\n<h2 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h2><p>深拷贝，值传递</p>\n<ul>\n<li><p>简单</p>\n<pre><code class=\"go\">type    name    struct {\n  a int\n  b string\n}</code></pre>\n</li>\n<li><p>匿名结构体</p>\n<pre><code class=\"go\">struct {\n  a int\n  b string\n}</code></pre>\n</li>\n<li><p>匿名结构体字段</p>\n<pre><code class=\"go\">type    name    struct {\n int\n string\n}</code></pre>\n<p>匿名结构体字段访问时，使用匿名字段类型<code>name.int</code>，<code>name.string</code>，匿名的字段类型不能重复</p>\n<pre><code class=\"go\">type    name    struct {\n int\n string\n int    //不可以\n}</code></pre>\n</li>\n</ul>\n<h3 id=\"提升字段\"><a href=\"#提升字段\" class=\"headerlink\" title=\"提升字段\"></a>提升字段</h3><p>结构体可以嵌套，当一个结构体内嵌套另一个匿名结构体时，可以直接使用字段名称访问被嵌套结构体的字段，这叫做字段提升。<br>字段提升只有在被嵌套结构体为匿名的时候可用。<br>如果结构体中的字段与被嵌套结构体的字段一样，则访问的为本结构体字段</p>\n<pre><code class=\"go\">type Person struct {\n    name string\n    age int\n}\n\ntype Student struct {\n    Person\n    addre string\n    name string\n}\n\np:=Person{&quot;nihao&quot;,10}\nfmt.Println(p)\n\ns:=Student{Person{&quot;wohao&quot;,20},&quot;beij&quot;,&quot;djh&quot;}\nfmt.Println(s)\nfmt.Println(s.Person.name,s.Person.age,s.addre,s.name)\nfmt.Println(s.name,s.age,s.addre)\n\n\n======================输出为============================\n\n{nihao 10}\n{{wohao 20} beij djh}\nwohao 20 beij djh\ndjh 20 beij</code></pre>\n<h2 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h2><p>方法是一个作用在struct结构体上的函数</p>\n<pre><code class=\"go\">func (s Struct) name() {\n\n}</code></pre>\n<p>实例</p>\n<pre><code class=\"go\">type Person struct {\n    name string\n    age int\n}\n\ntype Student struct {\n    Person\n    addre string\n    name string\n}\nfunc (p Person) run(){\n    fmt.Println(&quot;p run&quot;)\n}\n\nfunc (s Student) run()  {\n    fmt.Println(&quot;s run&quot;)\n}\n\n\n\np:=Person{&quot;lisi&quot;,10}\nfmt.Println(p)\np.run()\ns:=Student{Person{&quot;wangwu&quot;,20},&quot;beij&quot;,&quot;xiaowangwu&quot;}\nfmt.Println(s)\ns.Person.run()\ns.run()\n\n\n\n\n\n===============输出为================\n{lisi 10}\np run\n{{wangwu 20} beij xiaowangwu}\np run\ns run</code></pre>\n<h2 id=\"接口（interface）\"><a href=\"#接口（interface）\" class=\"headerlink\" title=\"接口（interface）\"></a>接口（interface）</h2><p>接口可以看作是一些方法的集合。接口是为了解耦合，go语言的接口是非侵入式的。空接口可以看作是任意类型</p>\n<pre><code class=\"go\">type name interface{\n  start()\n  end()\n}</code></pre>\n<h3 id=\"接口断言\"><a href=\"#接口断言\" class=\"headerlink\" title=\"接口断言\"></a>接口断言</h3><p>利用接口来判断类型</p>\n<ul>\n<li>1<br>instance := 接口对象.(实际类型)   //不安全，会panic（）<br>instance,err := 接口对象.(实际类型)    //安全</li>\n<li>2<br>switch instance := 接口对象.(type) {<br>  case 实际类型：<pre><code>xxx</code></pre>  case 实际类型：<pre><code>xxxx</code></pre>}</li>\n</ul>\n<h2 id=\"type-关键字\"><a href=\"#type-关键字\" class=\"headerlink\" title=\"type 关键字\"></a>type 关键字</h2><ul>\n<li>定义新类型<br>type myint int<br>定义一个int类型的myint类型，但是int和myint类型不一样不能通用</li>\n<li>给类型其别名<br>type myint = int<br>给一个int类型起一个别名，int和myint可以通用</li>\n</ul>\n<h2 id=\"创建对象\"><a href=\"#创建对象\" class=\"headerlink\" title=\"创建对象\"></a>创建对象</h2><h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h3><h3 id=\"make\"><a href=\"#make\" class=\"headerlink\" title=\"make\"></a>make</h3><ul>\n<li><p>slice</p>\n<ul>\n<li>make([]int,10)<br>长度（len）和容量（cap）都为10，默认值为int的零值</li>\n<li>make([]int,0,10)<br>长度（len）为0，和容量（cap）为10，因为0个长度所以没有值</li>\n</ul>\n</li>\n<li><p>map</p>\n<ul>\n<li><p>make(map[string]string)</p>\n</li>\n<li><p>make(map[string]string,10)</p>\n</li>\n</ul>\n</li>\n<li><p>chan</p>\n<ul>\n<li>make(chan bool)<br>没有缓存的chan</li>\n<li>make(chan bool,10)<br>长度为10的chan</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"访问权限\"><a href=\"#访问权限\" class=\"headerlink\" title=\"访问权限\"></a>访问权限</h2><p>名称首字母大写时，可以在其他地方导入，小写其他地方访问不了</p>\n<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><h2 id=\"协程（Gorutine）\"><a href=\"#协程（Gorutine）\" class=\"headerlink\" title=\"协程（Gorutine）\"></a>协程（Gorutine）</h2><h2 id=\"管道（chan）\"><a href=\"#管道（chan）\" class=\"headerlink\" title=\"管道（chan）\"></a>管道（chan）</h2><h2 id=\"反射（reflect）\"><a href=\"#反射（reflect）\" class=\"headerlink\" title=\"反射（reflect）\"></a>反射（reflect）</h2><h3 id=\"基本数据类型反射使用\"><a href=\"#基本数据类型反射使用\" class=\"headerlink\" title=\"基本数据类型反射使用\"></a>基本数据类型反射使用</h3><h4 id=\"修改值\"><a href=\"#修改值\" class=\"headerlink\" title=\"修改值\"></a>修改值</h4><ul>\n<li>step1:<br>获取反射对象Value。要修改对象，就要获取对象的地址，用对象的引用地址来更改里面的具体值<pre><code class=\"go\">var a int = 0\nvalue := reflect.ValueOf(&amp;a)</code></pre>\n</li>\n<li>step2:<br>获取反射对象的指针对象<pre><code class=\"go\">elem := value.Elem()</code></pre>\n</li>\n<li>step3:<br>修改值<pre><code class=\"go\">elem.SetInt(9)</code></pre>\n</li>\n</ul>\n<p>完整步骤：</p>\n<pre><code class=\"go\">var a int = 0\nvalue := reflect.ValueOf(&amp;a)\nelem := value.Elem()\nif !elem.CanSet {  //判断反射对象是否可以修改，不可以直接返回不做修改\n  return\n}\n\nif elem.Kind() ==reflect.Int{ //判断对象是否是int类型\n  elem.SetInt(9)\n}\n</code></pre>\n<h3 id=\"函数调用\"><a href=\"#函数调用\" class=\"headerlink\" title=\"函数调用\"></a>函数调用</h3><pre><code class=\"go\">func star()  {\n  fmt.Println(&quot;call this func&quot;)\n}\n\nvalueOf := reflect.ValueOf(star)  //这里star不能加（）\n\nif valueOf.Kind() == reflect.Func {\n  valueOf.Call(nil)\n}</code></pre>\n<h3 id=\"struct-的反射使用\"><a href=\"#struct-的反射使用\" class=\"headerlink\" title=\"struct 的反射使用\"></a>struct 的反射使用</h3><h4 id=\"获取字段名称和具体值\"><a href=\"#获取字段名称和具体值\" class=\"headerlink\" title=\"获取字段名称和具体值\"></a>获取字段名称和具体值</h4><ul>\n<li><p>step1:<br>获取反射valueOf和typeOf实例</p>\n<pre><code class=\"go\">type Person struct {\n  Name string\n  Age  int\n}\np:=Person{&quot;zhangshan&quot;,30}\n\nvalueOf := reflect.ValueOf(p)\ntypeOf := reflect.TypeOf(p)</code></pre>\n</li>\n</ul>\n<ul>\n<li><p>step2:<br>通过实例获取字段名称和字段实际值</p>\n<pre><code class=\"go\">for i := 0; i &lt; typeOf.NumField(); i++ {\n  fmt.Println(&quot;fieldname:  &quot;,typeOf.Field(i).Name)\n  fmt.Println(&quot;value:  &quot;,valueOf.Field(i))\n}</code></pre>\n</li>\n</ul>\n<p>完整代码：</p>\n<pre><code class=\"go\">type Person struct {\n  Name string\n  Age  int\n}\n\np:=Person{&quot;zhangshan&quot;,30}\n\nvalueOf := reflect.ValueOf(p)\ntypeOf := reflect.TypeOf(p)\n\n\nfor i := 0; i &lt; typeOf.NumField(); i++ {\n  fmt.Println(&quot;fieldname:  &quot;,typeOf.Field(i).Name)\n  fmt.Println(&quot;value:  &quot;,valueOf.Field(i))\n}</code></pre>\n<h4 id=\"修改字段值\"><a href=\"#修改字段值\" class=\"headerlink\" title=\"修改字段值\"></a>修改字段值</h4><ul>\n<li><p>step1:<br>获取反射valueOf实例</p>\n<pre><code class=\"go\">type Person struct {\n  Name string\n  Age  int\n}\np:=Person{&quot;zhangshan&quot;,30}\n\nvalueOf := reflect.ValueOf(&amp;p)  //这里要填写p的地址</code></pre>\n</li>\n<li><p>step2:<br>修改相应的字段值</p>\n<pre><code class=\"go\">valueOf.Field(0).SetString(&quot;wangwu&quot;)</code></pre>\n</li>\n</ul>\n<p>完整代码：</p>\n<pre><code class=\"go\">type Person struct {\n    Name string\n    Age  int\n}\np:=Person{&quot;zhangshan&quot;,30}\n\nvalueOf := reflect.ValueOf(&amp;p)  //这里要填写p的地址\n\nif valueOf.Kind() == reflect.Ptr {\n  if valueOf.Elem().CanSet(){\n    elem := valueOf.Elem()\n  //  field := elem.Field(0)  //通过字段序号获取字段\n    field := elem.FieldByName(&quot;Name&quot;)  //通过字段名称来获取字段\n    field.SetString(&quot;wangwu&quot;)\n  }\n}</code></pre>\n<blockquote>\n<p>注意：<br>Person的字段为大写开头，为可访问字段，如果小写，则会发生程序panic<br><code>reflect: reflect.flag.mustBeAssignable using value obtained using unexported field</code></p>\n</blockquote>\n<h4 id=\"调用方法\"><a href=\"#调用方法\" class=\"headerlink\" title=\"调用方法\"></a>调用方法</h4><h5 id=\"调用无参数方法\"><a href=\"#调用无参数方法\" class=\"headerlink\" title=\"调用无参数方法\"></a>调用无参数方法</h5><ul>\n<li><p>step1:<br>获取反射valueOf实例</p>\n<pre><code class=\"go\">type Person struct {\n  Name string\n  Age  int\n}\np:=Person{&quot;zhangshan&quot;,30}\n\nfunc (p Person) Run() {\n  fmt.Println(&quot;p run&quot;)\n}\n\nvalueOf := reflect.ValueOf(p)</code></pre>\n</li>\n<li><p>step2:<br>通过反射实例获取方法实例</p>\n<pre><code class=\"go\">method := valueOf.MethodByName(&quot;Run&quot;)</code></pre>\n</li>\n<li><p>step3:<br>调用方法</p>\n<pre><code class=\"go\">method.Call(nil)</code></pre>\n</li>\n</ul>\n<p>完整代码：</p>\n<pre><code class=\"go\">type Person struct {\n  Name string\n  Age  int\n}\np:=Person{&quot;zhangshan&quot;,30}\n\nfunc (p Person) Run() {  //方法名称一定要大写\n  fmt.Println(&quot;p run&quot;)\n}\n\nvalueOf := reflect.ValueOf(p)\n\n// method := valueOf.Method(0)  //通过序号获取方法实例\nmethod := valueOf.MethodByName(&quot;Run&quot;)\n\nif method.Kind() == reflect.Func {\n  // method.Call(make([]reflect.Value,0))  //传入一个空切片\n  method.Call(nil)  //直接传入nil空值\n}</code></pre>\n<h5 id=\"调用多参数方法\"><a href=\"#调用多参数方法\" class=\"headerlink\" title=\"调用多参数方法\"></a>调用多参数方法</h5><p>调用多参数方法和无参数方法执行步骤一样，只是在调用时传入参数的切片即可<code>method.Call([]reflect.Value{reflect.ValueOf(&quot;lii&quot;),reflect.ValueOf(&quot;nihao&quot;),reflect.ValueOf(5)})</code></p>\n<pre><code class=\"go\">func (s Person) Write(name string,msg string, length int) {\n  fmt.Println(name,&quot;写了&quot;,msg,&quot;一共&quot;,length)\n}</code></pre>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h2><h3 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h3><h2 id=\"Protobuf\"><a href=\"#Protobuf\" class=\"headerlink\" title=\"Protobuf\"></a>Protobuf</h2><p>fallthrough   在switch 语句中进行穿透，链接两个case </p>\n<p>函数：</p>\n<p>当参数类型一致时，前一个参数可以省略类型</p>\n<p>函数参数中如果有可变参数，可变参数放到最后，参数列表中只能有一个可变参数</p>\n<p>函数返回值</p>\n<p>指针</p>\n"},{"title":"Redis","date":"2019-12-26T15:50:21.000Z","_content":"\n# Redis（Remote Dictionary Server）\n\n\n\n## Redis 运行快速的原因\n\n1. 完全基于内存操作\n\n2. 数据结构简单，数据操作也简单\n\n3. 使用多路I/O复用模型\n\n## 数据类型\n### String\n#### 单条操作\n1. 增：set\tkey\tvalue\n2. 查：get\tkey\n3. 删：del\tkey\n\n#### 多条操作\n1. 增：mset\tkey\tvalue\t[key1\tvalue1]\n2. 查：mget\tkey\t[key1]\n\n#### 其他命令\n1. strlen\tkey\t//获取字符串长度\n2. append\tkey\tvalue\t//有则追加，无则新建\n3. setnx\tkey\tvalue\t//不存在就设置，存在就不设置\n4. incr\tkey\t//自增 1\n5. incrby\tkey\tnum  //给key的值增加num（int 类型），num 正数则为加，num 为负数 则为减\n6. incrbyfloat\tkey\tnum\t//给key的值增加num（float 类型）\n7. decr\tkey  //自减 1\n8. decrby\tkey\tnum\t//给key的值减num\n9. setex\tkey\tsecond\tvalue\t//设置key的值为value存活时间为second秒\n10. psetex\tkey\tmillisecond\tvalue\t//设置key的值为value存活时间为millisecond毫秒\n\n>注：\n>字符串值最大值为512m\n\n### Hash\n和字符串相似，可理解为字符串厘米套字符串\n\n#### 单条操作\n1. 增：hset\tkey\tfield\tvalue\t\n2. 查：hget\tkey\tfield\n3. 删：hdel\tkey\tfield\n\n#### 多条操作\n1. 增：hmset\tkey\tfield\tvalue\t[field1\tvalue2]\n2. 查：hmget\tkey\tfield\t[field1]\n\n#### 其他命令\n1. hgetall\tkey\t//获取key的全部的值\n2. hlen\tkey\t//获取key的值的数量\n3. hexists\tkey\tfield\t//是否存在field\n4. hkeys\tkey\t//所有key的字段（field）\n5. hvals\tkey\t//所有key的值 \n6. hincrby\tkey\tfield\tnum\t//给key的field的值增加num （num 为int值）\n7. hincrybyfloat\tkey\tfield\tnum\t//给key的field的值增加num （num 为float）\n8. hsetnx\tkey\tfield\tvalue\t//存在不设置，不存在设置\n\n>注：\n>1. Hash类型的value只能存字符串，不允许再嵌套其他类型，如果数据为空为Nil\n>2. 每个Hash可以存储$2^{32}-1$个键的值对\n>3. Hash类型十分贴近对象的数据存储，并且可以灵活添加、删除对象属性。但Hash类型设计并不是存在量而设计的，切记不可滥用，更不可将Hash作为对象列表使用\n>4. hgetall操作可以获取全部属性，如果内部field过多，遍历整体数据时效率会降低，很有可能成为数据访问的瓶颈\n\n### String存储对象（Json） VS Hash存储对象\n1. String存在对象讲究整体性，以读为主\n2. Hash存储对象讲究分散性，以写为主\n\n### List\n讲究顺序\n#### 添加\n1. lpush\tkey\tvalue\t[value1]\t//从左添加\n2. rpush\tkey\tvalue\t[value1]\t//从右添加\n\n#### 获取\n1. lrange\tkey\tstart\tstop\n2. lindex\tkey\tindex\n3. llen\tkey\n\n#### 获取并移除\n1. lpop\tkey\t//从左出\n2. rpop\tkey\t//从右出\n\n~~~tex\nlpush\tlist\ta\tb\tc\n结果：c b a\n===============================\nrpush list a\tb\tc\n结果：a b c\n===============================\nlist=[a\tb\tc]\nlpop list\n结果：b c\n===============================\nlist=[a b c]\nrpop list\n结果：a b\n===============================\n~~~\n\n>注：\n>1. list中保存的数据都是String，数据总量是有限的，最多$2^{32}-1$个元素\n>2. list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作（或以栈的形式进行入栈出栈操作）\n>3. 当stop的值为-1时，获取的是全部数据\n>4. list对数据进行分页操作，通常第一页的数据使的信息来自list，其他页面的数据通过数据形式进行加载\n\n### Set\n#### 命令\n1. 增：sadd\tkey\tmember\t[member1]\n2. 查：smembers\tkey\n3. 删：srem\tkey\tmember\t[member1]\n4. 获取总量：scard\tkey\n5. 判定是否存在：sismember\tkey\tmember\n6. 随机获取（原集合保留）：srandmember\tkey\t[count]\n7. 随机获取（原集合不保留）：spop\tkey\n8. 集合交集：sinter\tkey\tkey1\tkey2\n9. 集合并集：sunion\tkey\tkey1\tkey2\n10. 集合差集：sdiff\tkey\tkey1\tkey2\n11. 存储集合交集：sinterstore\tdestination\tkey\tkey1\tkey2\n12. 存储集合并集：sunionstore\tdestination\tkey\tkey1\tkey2\n13. 存储集合差集：sdiffstore\tdestination\tkey\tkey1\tkey2\n14. 集合元素移动：smove\tsource\tdestination\tmember\n\n### Sorted_Set\n#### 命令\n1. 增：zadd\tkey\tscore\tmember\t[score1\tmember1]\n2. 删：zrem\tkey\tmember\t[member1]\n3. 获取全部（正序）：zrange\tkey\tstart\tstop\t[withscores]\n4. 获取全部（倒序）：zrevrange\tkey\tstart\tstop\t[withscores]\n5. 按条件查（正序）：zrangebyscore\tkey\tmin\tmax\t[withscore\tlimit]\n6. 按条件查（倒序）：zrevrangebyscore\tkey\tmax\tmin\t[withscore\tlimit]\n7. 按条件删除（索引）：zremrangebyrank\tkey\tstart\tstop\n8. 按条件删除（积分）：zremrangebyscore\tkey\tmin\tmax\n9. 获取集合总量：zcard\tkey\t|\tzcount\tkey\tmin\tmax\n10. 存储集合交集：\tzinterstore\tdestination\tnumkeys\tkey\tkey1\n11. 存储集合并集：zunionstore\tdestination\tnumkeys\tkey\tkey1\n12. 获取索引（正序）：zrank\tkey\tmember\n13. 获取索引（倒序）：zrevrank\tkey\tmember\n14. score值获取：zscore\tkey\tmember\n15. score值修改：zincrby\tkey\tnum\tmember\n\n## Key的操作\n### 命令\n1. 删除：del\tkey\n2. 判断是否存在：exists\tkey\n3. 获取key类型：type\tkey\n4. 指定有效期：\n\t1.\texpire\tkey\tseconds\n\t2.\tpexpire\tkey\tmilliseconds\n\t3.\texpireat\tkey\ttimestamp\n\t4.\tpexpireat\tkey\tmilliseconds-timestamp\n5. 获取有效期：\n\t1.\tttl\tkey\n\t2.\tpttl\tkey\n6.\t设置永久：persist\tkey\n7.\t查询key：key\tpattern\t//*,?,[]\n8.\t重命名：rename\tkey\tnewkey\t|\trenamenx\tkey\tnewkey\n9.\t对key排序：sort\n\n## 数据库操作\n### 命令\n1. 选择数据库：select\tindex\n2. 数据移动：move\tkey\tdb\n3. 数据库大小：dbsize\n4. 数据清除：\n\t1. 单库删除：flushdb\n\t2. 多库删除：flushall\n\n## 持久化\n### RDB（Relational Database）\n#### 保存数据\n1. 指令（前台）：save\t//阻塞 立即保存\n2. 指令（后台）：bgsave\t//不立即执行\n3. 配置：save\tsecond\tchanges\t//用bgsave执行操作\n\n#### 常用配置项\n1. 数据文件名称：dbfilename\tdump.rdb\t//默认\n2. 数据保存路径：dir\n3. 是否开启压缩：rdbcompression\tyes\t//默认\n4. 是否开启格式检查：rdbchecksum\tyes|no //默认no\n\n#### RDB 持久化优点\n1. RDB是一个紧凑压缩的二进制文件，存储效率高\n2. RDB存储的是Redis在某个时间点的数据快照，非常适用于数据备份全量复制等场景\n3. RDB恢复数据速度比AOF快\n\n#### RDB应用\n服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复\n\n#### RDB持久化缺点\n1. RDB方式无论是执行命令还是进行配置，无法做到实时持久化，具有较大可能丢失数据\n2. bgsave每次运行要执行fork操作创建子进程，要牺牲一些性能\n3. Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各个版本服务器之间数据格式无法兼容\n4. 存储数量较大时，效率较低\n5. 大数据量下的I／O性能较低\n6. 基于fork创建子进程，内存产生额外消耗\n7. 宕机带来的数据丢失风险\n\n### AOF（Append Only File）\n#### 保存数据策略\n每次：always\n每秒：everysec\n系统控制：no\n\n#### 配置\n1. 是否开启：appendonly\tyes|no\t//默认no\n2. 保存策略：appendfsync\talways|everysec|no\n3. 重写：\n\t手动：bgrewriteaof\n\t自动：\n\t\tauto-aof-rewrite-min-size\tsize\n\t\tauto-aof-rewrite-percentage\tpercentage\n\n### RDB 与 AOF 如何选择\n对数据非常敏感，建议使用默认的AOF持久化方案\n\tAOF策略使用everysec，每秒fsync一次，该策略仍可保持很好性能，出现问题最多丢失一秒内的数据\n数据呈现阶段有效性，建议使用RDB持久化方案\n\t数据可以做到阶段内无丢失，且恢复较快，阶段点数据恢复通常使用RDB方案\n>注意：\n>AOF文件存储体积较大，恢复速度较慢\n>利用RDB使用线紧凑的数据持久化会使Redis性能降低\n\n综合：\n1. RDB与AOF选择实际上是在一种权衡，每种都有利有弊\n2. 如果不能承受分钟内的数据丢失，对业务数据非常敏感，选用AOF\n3. 如果能承受分钟内的数据丢失，且追求大数据集的恢复速度选用RDB\n4. 灾难恢复选用RDB\n5. 双保险策略，同时开启RDB和AOF，重启后Redis优先使用AOF来恢复数据，降低丢失数据量\n\n## 事务\nRedis事务不具有回滚机制\n\n### 命令\n1. 开启：multi\n2. 结束：exec\n3. 中断：discard\n\n### 事务中的错误\n#### 命令错误\n执行事务过程中输入的命令出现错误，Redis会结束事务不再执行，并报出错误的命令\n\n#### 操作错误\n执行事务过程中输入的命令正确，其他操作错误，事务中其他命令正常执行，错误操作报错\n\n## 锁\nRedis中锁和事务是相搭配使用的，可解决对key的监控\n\n### 命令\n加锁：watch\tkey\t[key1]\n解锁：unwatch  //取消掉所有key的监控\n\n## 数据删除策略\n当key过期后执行数据删除的策略\n### 定时删除（即可删除）\n创建一个具有时效性的key时，同时会创建一个定时器来监控该key是否过期，当key过期后立即进行key的删除\n\n优点：节约内存，到时就会进行删除，快速释放占用空间\n缺点：CPU压力大影响Redis响应时间和吞吐量\n总结：用处理器性能换取存储空间\n\n### 惰性删除\n当一个具有实效性的key过期后不会有删除操作，直到下一次调用时会先检查该key是否过期，如果过期则进行删除操作，并返回nil（该key不存在）\n\n优点：节约CPU性能，发现必须删除的时候才会删除\n缺点：内存压力大，出现长期占用内存的数据\n总结：用存储空间换取处理器性能\n\n### 定期删除\nRedis会根据设置的参数，定期对具有时效性的key进行清理工作，它是定时删除和惰性删除的结合者，既不像定时删除会立即进行删除给予CPU压力，也不会像惰性删除给予内存压力\n\n#### 步骤\n1. Redis启动服务器初始化时，读取配置server.hz的值（默认为10）\n2. 每秒钟执行server.hz次serverCron（）服务（serverCron【服务器级别】->databasesCron【数据库级别】->activeExpireCyle【活跃数据级别】）\n3. acitveExpireCyle（）对每个expires[*]（数据库）逐一进行检测，每次执行250ms／server.hz\n4. 对某个expires[*]检测时，随机挑选w个key进行检测\n\t1. 如果key超时，删除key\n\t2. 如果一轮中删除的kye的数量>w*25%，循环该过程\n\t3. 如果一轮中删除的可以的数量<=w*25%检查下一个expires[*],0-15（所有的数据库）循环\n>W=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP\n>参数current_db用于记录activeExpireCyle进入哪个expires[*]执行\n\n## 数据淘汰策略\n当内存到达最大内存限制时进行的数据淘汰策略\n\n数据驱逐淘汰策略配置依据，使用info命令输出相关监控信息，查新缓存hit 命中次数和miss的次数，根据业务调优\n### 配置\n1. 最大可用内存：maxmemory\t//默认为0，一般设置全部内存50%以上\n2. 每次选取带删除数据个数：maxmemory-samples\t//采用随机获取方式\n3. 删除策略：maxmemory-policy\t//达到最大内存后，对被选取带数据进行的删除策略\n\n### 检测易失数据集（可能会过期数据server.db[i].expires）\n1. volatile-lru：挑选最近最少使用的数据淘汰（最近数据中使用时间离当前最远的数据）。**常用**\n2. volatile-lfu：挑选最近使用次数最少的数据淘汰（最近数据中使用次数最少的数据）\n3. volatile-ttl：挑选将要过期数据淘汰\n4. volatile-random：任意挑选数据淘汰\n\n>ttl：time to live\n>lru：least recently\tused\n>lfu：least frequently\tused\n\n### 检测全库数据（所有数据集server.db[i].dict）\n1. allkeys-lru：挑选最近最少使用的数据淘汰\n2. allkeys-lfu：挑选最近使用次数最少的数据淘汰\n3. allkeys-random：任意挑选数据淘汰\n\n### 放弃数据驱逐\nno-enviction\t//禁止驱逐数据\n4.0中默认策略，会引发OOM\n\n## 服务器基本配置\n1. 设置服务器守护进程方式：daemonize\tyes|no\n2. 绑定地址：bing\t127.0.0.1\n3. 设置服务器端口：port\t6379\n4. 设置数据库数量：databases\t16\n5. 设置服务器日志级别：loglevel\tdebug|verbose|notice|warning\n6. 日志文件名称：logfile\t端口号.log\n7. 设置客户端最大连接数：maxclients\t0\n8. 客户端闲置最大等待时长：timeout\t0\n\n## 高级数据类型\n### Bitmaps\n标记统计\n\n#### 命令\n1. 获取：getbit\tkey\toffset\n2. 设置：setbit\tkey\toffset\tvalue\t// 0 或 1\n3. 交、并、或异\n\tbitop\top\tdestkey\tkey1\tkey2\n\top：\n\t\t交：and\n\t\t并：or\n\t\t非：not\n\t\t异或：xor\n4. 统计指定key中1的数量：bitcount\tkey\t[start\tend]\n\n### HyperLoglog\n基数统计\n#### 命令\n1. 添加：pfadd\tkey\telement\t[element1]\n2. 统计：pfcount\tkey\t[key1]\n3. 合并：pfmerge\tdestkey\tsourcekey\t[sourcekey1]\n\n### GEO\n距离计算（只计算水平距离）\n\n#### 命令\n1. 添加：geoadd\tkey\tlongitude\tlatitude\tmember\t[longitude1\tlatitude1\tmember1]\n2. 获取：geopos\tkey\tmember\t[member1]\n3. 计算距离：geodist\tkey\tmember1\tmember2\t[count]\n4. 根据坐标求范围内数据：georadius\tkey\tlongitude\tlatitude\tradius\tm|km|ft|mi\n5. 根据点求范围内的数据：georadusbymember\tkey\tmember\tradius\tm|km|ft|mi\n6. 获取指定点对应的hash值：geohash\tkey\tmember\t[member1]\t\n\n## 主从复制\n### 创建链接\n+ 方式一：客户端发指令：slaveof\tmasterip masterport\n+\t方式二：参数启动：redis-server\t--slaveof\tmasterip masterport\n+\t方式三：服务器配置：slaveof\tmasterip masterport\n\n### 数据同步 \n#### 全量复制\n从：发送指令（psync2）\n主：执行bgsave\n主：第一个slave链接时，创建命令缓冲区\n主：生成RDB文件，通过socket发送给slave\n从：接收RDB文件，清空自己数据，执行RDB文件恢复过程\n\n#### 部分复制\n从：发送命令告知RDB恢复完成\n主：发送复制缓冲区信息\n从：接收信息，执行bgsavewriteaof，恢复数据\n\n## 哨兵模式\n### 配置\nsentinel.conf\n\n启动：redis-sentinel\n\n## 集群（cluster）\n### 配置\n1. 开启：cluster-enabled\tyes|no\n2. 配置文件名称：cluster-config-file\tfilename\n3. 节点超时时间：cluster-node-timeout\tmilliseconds\n4. master链接slave最小数：cluster-migration-barrier\tcount\n\n### 命令\n1. 查看节点信息：cluster nodes\n2. 从一个节点Redis，切换其主节点：cluster\treplicate\tmasterip\n3. 新增主节点：cluster meet\tip:port\n4. 忽略一个节点：cluster\tfoeget\tid\n5. 手动故障转移：cluster\tfailover\n\n","source":"notes/Redis.md","raw":"---\ntitle: Redis\ndate: 2019-12-26 23:50:21\n---\n\n# Redis（Remote Dictionary Server）\n\n\n\n## Redis 运行快速的原因\n\n1. 完全基于内存操作\n\n2. 数据结构简单，数据操作也简单\n\n3. 使用多路I/O复用模型\n\n## 数据类型\n### String\n#### 单条操作\n1. 增：set\tkey\tvalue\n2. 查：get\tkey\n3. 删：del\tkey\n\n#### 多条操作\n1. 增：mset\tkey\tvalue\t[key1\tvalue1]\n2. 查：mget\tkey\t[key1]\n\n#### 其他命令\n1. strlen\tkey\t//获取字符串长度\n2. append\tkey\tvalue\t//有则追加，无则新建\n3. setnx\tkey\tvalue\t//不存在就设置，存在就不设置\n4. incr\tkey\t//自增 1\n5. incrby\tkey\tnum  //给key的值增加num（int 类型），num 正数则为加，num 为负数 则为减\n6. incrbyfloat\tkey\tnum\t//给key的值增加num（float 类型）\n7. decr\tkey  //自减 1\n8. decrby\tkey\tnum\t//给key的值减num\n9. setex\tkey\tsecond\tvalue\t//设置key的值为value存活时间为second秒\n10. psetex\tkey\tmillisecond\tvalue\t//设置key的值为value存活时间为millisecond毫秒\n\n>注：\n>字符串值最大值为512m\n\n### Hash\n和字符串相似，可理解为字符串厘米套字符串\n\n#### 单条操作\n1. 增：hset\tkey\tfield\tvalue\t\n2. 查：hget\tkey\tfield\n3. 删：hdel\tkey\tfield\n\n#### 多条操作\n1. 增：hmset\tkey\tfield\tvalue\t[field1\tvalue2]\n2. 查：hmget\tkey\tfield\t[field1]\n\n#### 其他命令\n1. hgetall\tkey\t//获取key的全部的值\n2. hlen\tkey\t//获取key的值的数量\n3. hexists\tkey\tfield\t//是否存在field\n4. hkeys\tkey\t//所有key的字段（field）\n5. hvals\tkey\t//所有key的值 \n6. hincrby\tkey\tfield\tnum\t//给key的field的值增加num （num 为int值）\n7. hincrybyfloat\tkey\tfield\tnum\t//给key的field的值增加num （num 为float）\n8. hsetnx\tkey\tfield\tvalue\t//存在不设置，不存在设置\n\n>注：\n>1. Hash类型的value只能存字符串，不允许再嵌套其他类型，如果数据为空为Nil\n>2. 每个Hash可以存储$2^{32}-1$个键的值对\n>3. Hash类型十分贴近对象的数据存储，并且可以灵活添加、删除对象属性。但Hash类型设计并不是存在量而设计的，切记不可滥用，更不可将Hash作为对象列表使用\n>4. hgetall操作可以获取全部属性，如果内部field过多，遍历整体数据时效率会降低，很有可能成为数据访问的瓶颈\n\n### String存储对象（Json） VS Hash存储对象\n1. String存在对象讲究整体性，以读为主\n2. Hash存储对象讲究分散性，以写为主\n\n### List\n讲究顺序\n#### 添加\n1. lpush\tkey\tvalue\t[value1]\t//从左添加\n2. rpush\tkey\tvalue\t[value1]\t//从右添加\n\n#### 获取\n1. lrange\tkey\tstart\tstop\n2. lindex\tkey\tindex\n3. llen\tkey\n\n#### 获取并移除\n1. lpop\tkey\t//从左出\n2. rpop\tkey\t//从右出\n\n~~~tex\nlpush\tlist\ta\tb\tc\n结果：c b a\n===============================\nrpush list a\tb\tc\n结果：a b c\n===============================\nlist=[a\tb\tc]\nlpop list\n结果：b c\n===============================\nlist=[a b c]\nrpop list\n结果：a b\n===============================\n~~~\n\n>注：\n>1. list中保存的数据都是String，数据总量是有限的，最多$2^{32}-1$个元素\n>2. list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作（或以栈的形式进行入栈出栈操作）\n>3. 当stop的值为-1时，获取的是全部数据\n>4. list对数据进行分页操作，通常第一页的数据使的信息来自list，其他页面的数据通过数据形式进行加载\n\n### Set\n#### 命令\n1. 增：sadd\tkey\tmember\t[member1]\n2. 查：smembers\tkey\n3. 删：srem\tkey\tmember\t[member1]\n4. 获取总量：scard\tkey\n5. 判定是否存在：sismember\tkey\tmember\n6. 随机获取（原集合保留）：srandmember\tkey\t[count]\n7. 随机获取（原集合不保留）：spop\tkey\n8. 集合交集：sinter\tkey\tkey1\tkey2\n9. 集合并集：sunion\tkey\tkey1\tkey2\n10. 集合差集：sdiff\tkey\tkey1\tkey2\n11. 存储集合交集：sinterstore\tdestination\tkey\tkey1\tkey2\n12. 存储集合并集：sunionstore\tdestination\tkey\tkey1\tkey2\n13. 存储集合差集：sdiffstore\tdestination\tkey\tkey1\tkey2\n14. 集合元素移动：smove\tsource\tdestination\tmember\n\n### Sorted_Set\n#### 命令\n1. 增：zadd\tkey\tscore\tmember\t[score1\tmember1]\n2. 删：zrem\tkey\tmember\t[member1]\n3. 获取全部（正序）：zrange\tkey\tstart\tstop\t[withscores]\n4. 获取全部（倒序）：zrevrange\tkey\tstart\tstop\t[withscores]\n5. 按条件查（正序）：zrangebyscore\tkey\tmin\tmax\t[withscore\tlimit]\n6. 按条件查（倒序）：zrevrangebyscore\tkey\tmax\tmin\t[withscore\tlimit]\n7. 按条件删除（索引）：zremrangebyrank\tkey\tstart\tstop\n8. 按条件删除（积分）：zremrangebyscore\tkey\tmin\tmax\n9. 获取集合总量：zcard\tkey\t|\tzcount\tkey\tmin\tmax\n10. 存储集合交集：\tzinterstore\tdestination\tnumkeys\tkey\tkey1\n11. 存储集合并集：zunionstore\tdestination\tnumkeys\tkey\tkey1\n12. 获取索引（正序）：zrank\tkey\tmember\n13. 获取索引（倒序）：zrevrank\tkey\tmember\n14. score值获取：zscore\tkey\tmember\n15. score值修改：zincrby\tkey\tnum\tmember\n\n## Key的操作\n### 命令\n1. 删除：del\tkey\n2. 判断是否存在：exists\tkey\n3. 获取key类型：type\tkey\n4. 指定有效期：\n\t1.\texpire\tkey\tseconds\n\t2.\tpexpire\tkey\tmilliseconds\n\t3.\texpireat\tkey\ttimestamp\n\t4.\tpexpireat\tkey\tmilliseconds-timestamp\n5. 获取有效期：\n\t1.\tttl\tkey\n\t2.\tpttl\tkey\n6.\t设置永久：persist\tkey\n7.\t查询key：key\tpattern\t//*,?,[]\n8.\t重命名：rename\tkey\tnewkey\t|\trenamenx\tkey\tnewkey\n9.\t对key排序：sort\n\n## 数据库操作\n### 命令\n1. 选择数据库：select\tindex\n2. 数据移动：move\tkey\tdb\n3. 数据库大小：dbsize\n4. 数据清除：\n\t1. 单库删除：flushdb\n\t2. 多库删除：flushall\n\n## 持久化\n### RDB（Relational Database）\n#### 保存数据\n1. 指令（前台）：save\t//阻塞 立即保存\n2. 指令（后台）：bgsave\t//不立即执行\n3. 配置：save\tsecond\tchanges\t//用bgsave执行操作\n\n#### 常用配置项\n1. 数据文件名称：dbfilename\tdump.rdb\t//默认\n2. 数据保存路径：dir\n3. 是否开启压缩：rdbcompression\tyes\t//默认\n4. 是否开启格式检查：rdbchecksum\tyes|no //默认no\n\n#### RDB 持久化优点\n1. RDB是一个紧凑压缩的二进制文件，存储效率高\n2. RDB存储的是Redis在某个时间点的数据快照，非常适用于数据备份全量复制等场景\n3. RDB恢复数据速度比AOF快\n\n#### RDB应用\n服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复\n\n#### RDB持久化缺点\n1. RDB方式无论是执行命令还是进行配置，无法做到实时持久化，具有较大可能丢失数据\n2. bgsave每次运行要执行fork操作创建子进程，要牺牲一些性能\n3. Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各个版本服务器之间数据格式无法兼容\n4. 存储数量较大时，效率较低\n5. 大数据量下的I／O性能较低\n6. 基于fork创建子进程，内存产生额外消耗\n7. 宕机带来的数据丢失风险\n\n### AOF（Append Only File）\n#### 保存数据策略\n每次：always\n每秒：everysec\n系统控制：no\n\n#### 配置\n1. 是否开启：appendonly\tyes|no\t//默认no\n2. 保存策略：appendfsync\talways|everysec|no\n3. 重写：\n\t手动：bgrewriteaof\n\t自动：\n\t\tauto-aof-rewrite-min-size\tsize\n\t\tauto-aof-rewrite-percentage\tpercentage\n\n### RDB 与 AOF 如何选择\n对数据非常敏感，建议使用默认的AOF持久化方案\n\tAOF策略使用everysec，每秒fsync一次，该策略仍可保持很好性能，出现问题最多丢失一秒内的数据\n数据呈现阶段有效性，建议使用RDB持久化方案\n\t数据可以做到阶段内无丢失，且恢复较快，阶段点数据恢复通常使用RDB方案\n>注意：\n>AOF文件存储体积较大，恢复速度较慢\n>利用RDB使用线紧凑的数据持久化会使Redis性能降低\n\n综合：\n1. RDB与AOF选择实际上是在一种权衡，每种都有利有弊\n2. 如果不能承受分钟内的数据丢失，对业务数据非常敏感，选用AOF\n3. 如果能承受分钟内的数据丢失，且追求大数据集的恢复速度选用RDB\n4. 灾难恢复选用RDB\n5. 双保险策略，同时开启RDB和AOF，重启后Redis优先使用AOF来恢复数据，降低丢失数据量\n\n## 事务\nRedis事务不具有回滚机制\n\n### 命令\n1. 开启：multi\n2. 结束：exec\n3. 中断：discard\n\n### 事务中的错误\n#### 命令错误\n执行事务过程中输入的命令出现错误，Redis会结束事务不再执行，并报出错误的命令\n\n#### 操作错误\n执行事务过程中输入的命令正确，其他操作错误，事务中其他命令正常执行，错误操作报错\n\n## 锁\nRedis中锁和事务是相搭配使用的，可解决对key的监控\n\n### 命令\n加锁：watch\tkey\t[key1]\n解锁：unwatch  //取消掉所有key的监控\n\n## 数据删除策略\n当key过期后执行数据删除的策略\n### 定时删除（即可删除）\n创建一个具有时效性的key时，同时会创建一个定时器来监控该key是否过期，当key过期后立即进行key的删除\n\n优点：节约内存，到时就会进行删除，快速释放占用空间\n缺点：CPU压力大影响Redis响应时间和吞吐量\n总结：用处理器性能换取存储空间\n\n### 惰性删除\n当一个具有实效性的key过期后不会有删除操作，直到下一次调用时会先检查该key是否过期，如果过期则进行删除操作，并返回nil（该key不存在）\n\n优点：节约CPU性能，发现必须删除的时候才会删除\n缺点：内存压力大，出现长期占用内存的数据\n总结：用存储空间换取处理器性能\n\n### 定期删除\nRedis会根据设置的参数，定期对具有时效性的key进行清理工作，它是定时删除和惰性删除的结合者，既不像定时删除会立即进行删除给予CPU压力，也不会像惰性删除给予内存压力\n\n#### 步骤\n1. Redis启动服务器初始化时，读取配置server.hz的值（默认为10）\n2. 每秒钟执行server.hz次serverCron（）服务（serverCron【服务器级别】->databasesCron【数据库级别】->activeExpireCyle【活跃数据级别】）\n3. acitveExpireCyle（）对每个expires[*]（数据库）逐一进行检测，每次执行250ms／server.hz\n4. 对某个expires[*]检测时，随机挑选w个key进行检测\n\t1. 如果key超时，删除key\n\t2. 如果一轮中删除的kye的数量>w*25%，循环该过程\n\t3. 如果一轮中删除的可以的数量<=w*25%检查下一个expires[*],0-15（所有的数据库）循环\n>W=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP\n>参数current_db用于记录activeExpireCyle进入哪个expires[*]执行\n\n## 数据淘汰策略\n当内存到达最大内存限制时进行的数据淘汰策略\n\n数据驱逐淘汰策略配置依据，使用info命令输出相关监控信息，查新缓存hit 命中次数和miss的次数，根据业务调优\n### 配置\n1. 最大可用内存：maxmemory\t//默认为0，一般设置全部内存50%以上\n2. 每次选取带删除数据个数：maxmemory-samples\t//采用随机获取方式\n3. 删除策略：maxmemory-policy\t//达到最大内存后，对被选取带数据进行的删除策略\n\n### 检测易失数据集（可能会过期数据server.db[i].expires）\n1. volatile-lru：挑选最近最少使用的数据淘汰（最近数据中使用时间离当前最远的数据）。**常用**\n2. volatile-lfu：挑选最近使用次数最少的数据淘汰（最近数据中使用次数最少的数据）\n3. volatile-ttl：挑选将要过期数据淘汰\n4. volatile-random：任意挑选数据淘汰\n\n>ttl：time to live\n>lru：least recently\tused\n>lfu：least frequently\tused\n\n### 检测全库数据（所有数据集server.db[i].dict）\n1. allkeys-lru：挑选最近最少使用的数据淘汰\n2. allkeys-lfu：挑选最近使用次数最少的数据淘汰\n3. allkeys-random：任意挑选数据淘汰\n\n### 放弃数据驱逐\nno-enviction\t//禁止驱逐数据\n4.0中默认策略，会引发OOM\n\n## 服务器基本配置\n1. 设置服务器守护进程方式：daemonize\tyes|no\n2. 绑定地址：bing\t127.0.0.1\n3. 设置服务器端口：port\t6379\n4. 设置数据库数量：databases\t16\n5. 设置服务器日志级别：loglevel\tdebug|verbose|notice|warning\n6. 日志文件名称：logfile\t端口号.log\n7. 设置客户端最大连接数：maxclients\t0\n8. 客户端闲置最大等待时长：timeout\t0\n\n## 高级数据类型\n### Bitmaps\n标记统计\n\n#### 命令\n1. 获取：getbit\tkey\toffset\n2. 设置：setbit\tkey\toffset\tvalue\t// 0 或 1\n3. 交、并、或异\n\tbitop\top\tdestkey\tkey1\tkey2\n\top：\n\t\t交：and\n\t\t并：or\n\t\t非：not\n\t\t异或：xor\n4. 统计指定key中1的数量：bitcount\tkey\t[start\tend]\n\n### HyperLoglog\n基数统计\n#### 命令\n1. 添加：pfadd\tkey\telement\t[element1]\n2. 统计：pfcount\tkey\t[key1]\n3. 合并：pfmerge\tdestkey\tsourcekey\t[sourcekey1]\n\n### GEO\n距离计算（只计算水平距离）\n\n#### 命令\n1. 添加：geoadd\tkey\tlongitude\tlatitude\tmember\t[longitude1\tlatitude1\tmember1]\n2. 获取：geopos\tkey\tmember\t[member1]\n3. 计算距离：geodist\tkey\tmember1\tmember2\t[count]\n4. 根据坐标求范围内数据：georadius\tkey\tlongitude\tlatitude\tradius\tm|km|ft|mi\n5. 根据点求范围内的数据：georadusbymember\tkey\tmember\tradius\tm|km|ft|mi\n6. 获取指定点对应的hash值：geohash\tkey\tmember\t[member1]\t\n\n## 主从复制\n### 创建链接\n+ 方式一：客户端发指令：slaveof\tmasterip masterport\n+\t方式二：参数启动：redis-server\t--slaveof\tmasterip masterport\n+\t方式三：服务器配置：slaveof\tmasterip masterport\n\n### 数据同步 \n#### 全量复制\n从：发送指令（psync2）\n主：执行bgsave\n主：第一个slave链接时，创建命令缓冲区\n主：生成RDB文件，通过socket发送给slave\n从：接收RDB文件，清空自己数据，执行RDB文件恢复过程\n\n#### 部分复制\n从：发送命令告知RDB恢复完成\n主：发送复制缓冲区信息\n从：接收信息，执行bgsavewriteaof，恢复数据\n\n## 哨兵模式\n### 配置\nsentinel.conf\n\n启动：redis-sentinel\n\n## 集群（cluster）\n### 配置\n1. 开启：cluster-enabled\tyes|no\n2. 配置文件名称：cluster-config-file\tfilename\n3. 节点超时时间：cluster-node-timeout\tmilliseconds\n4. master链接slave最小数：cluster-migration-barrier\tcount\n\n### 命令\n1. 查看节点信息：cluster nodes\n2. 从一个节点Redis，切换其主节点：cluster\treplicate\tmasterip\n3. 新增主节点：cluster meet\tip:port\n4. 忽略一个节点：cluster\tfoeget\tid\n5. 手动故障转移：cluster\tfailover\n\n","updated":"2020-04-01T08:42:49.000Z","path":"notes/Redis.html","comments":1,"layout":"page","_id":"ck8o1hab2000z13s6mgmwjw05","content":"<h1 id=\"Redis（Remote-Dictionary-Server）\"><a href=\"#Redis（Remote-Dictionary-Server）\" class=\"headerlink\" title=\"Redis（Remote Dictionary Server）\"></a>Redis（Remote Dictionary Server）</h1><h2 id=\"Redis-运行快速的原因\"><a href=\"#Redis-运行快速的原因\" class=\"headerlink\" title=\"Redis 运行快速的原因\"></a>Redis 运行快速的原因</h2><ol>\n<li><p>完全基于内存操作</p>\n</li>\n<li><p>数据结构简单，数据操作也简单</p>\n</li>\n<li><p>使用多路I/O复用模型</p>\n</li>\n</ol>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><h4 id=\"单条操作\"><a href=\"#单条操作\" class=\"headerlink\" title=\"单条操作\"></a>单条操作</h4><ol>\n<li>增：set    key    value</li>\n<li>查：get    key</li>\n<li>删：del    key</li>\n</ol>\n<h4 id=\"多条操作\"><a href=\"#多条操作\" class=\"headerlink\" title=\"多条操作\"></a>多条操作</h4><ol>\n<li>增：mset    key    value    [key1    value1]</li>\n<li>查：mget    key    [key1]</li>\n</ol>\n<h4 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h4><ol>\n<li>strlen    key    //获取字符串长度</li>\n<li>append    key    value    //有则追加，无则新建</li>\n<li>setnx    key    value    //不存在就设置，存在就不设置</li>\n<li>incr    key    //自增 1</li>\n<li>incrby    key    num  //给key的值增加num（int 类型），num 正数则为加，num 为负数 则为减</li>\n<li>incrbyfloat    key    num    //给key的值增加num（float 类型）</li>\n<li>decr    key  //自减 1</li>\n<li>decrby    key    num    //给key的值减num</li>\n<li>setex    key    second    value    //设置key的值为value存活时间为second秒</li>\n<li>psetex    key    millisecond    value    //设置key的值为value存活时间为millisecond毫秒</li>\n</ol>\n<blockquote>\n<p>注：<br>字符串值最大值为512m</p>\n</blockquote>\n<h3 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h3><p>和字符串相似，可理解为字符串厘米套字符串</p>\n<h4 id=\"单条操作-1\"><a href=\"#单条操作-1\" class=\"headerlink\" title=\"单条操作\"></a>单条操作</h4><ol>\n<li>增：hset    key    field    value    </li>\n<li>查：hget    key    field</li>\n<li>删：hdel    key    field</li>\n</ol>\n<h4 id=\"多条操作-1\"><a href=\"#多条操作-1\" class=\"headerlink\" title=\"多条操作\"></a>多条操作</h4><ol>\n<li>增：hmset    key    field    value    [field1    value2]</li>\n<li>查：hmget    key    field    [field1]</li>\n</ol>\n<h4 id=\"其他命令-1\"><a href=\"#其他命令-1\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h4><ol>\n<li>hgetall    key    //获取key的全部的值</li>\n<li>hlen    key    //获取key的值的数量</li>\n<li>hexists    key    field    //是否存在field</li>\n<li>hkeys    key    //所有key的字段（field）</li>\n<li>hvals    key    //所有key的值 </li>\n<li>hincrby    key    field    num    //给key的field的值增加num （num 为int值）</li>\n<li>hincrybyfloat    key    field    num    //给key的field的值增加num （num 为float）</li>\n<li>hsetnx    key    field    value    //存在不设置，不存在设置</li>\n</ol>\n<blockquote>\n<p>注：</p>\n<ol>\n<li>Hash类型的value只能存字符串，不允许再嵌套其他类型，如果数据为空为Nil</li>\n<li>每个Hash可以存储$2^{32}-1$个键的值对</li>\n<li>Hash类型十分贴近对象的数据存储，并且可以灵活添加、删除对象属性。但Hash类型设计并不是存在量而设计的，切记不可滥用，更不可将Hash作为对象列表使用</li>\n<li>hgetall操作可以获取全部属性，如果内部field过多，遍历整体数据时效率会降低，很有可能成为数据访问的瓶颈</li>\n</ol>\n</blockquote>\n<h3 id=\"String存储对象（Json）-VS-Hash存储对象\"><a href=\"#String存储对象（Json）-VS-Hash存储对象\" class=\"headerlink\" title=\"String存储对象（Json） VS Hash存储对象\"></a>String存储对象（Json） VS Hash存储对象</h3><ol>\n<li>String存在对象讲究整体性，以读为主</li>\n<li>Hash存储对象讲究分散性，以写为主</li>\n</ol>\n<h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><p>讲究顺序</p>\n<h4 id=\"添加\"><a href=\"#添加\" class=\"headerlink\" title=\"添加\"></a>添加</h4><ol>\n<li>lpush    key    value    [value1]    //从左添加</li>\n<li>rpush    key    value    [value1]    //从右添加</li>\n</ol>\n<h4 id=\"获取\"><a href=\"#获取\" class=\"headerlink\" title=\"获取\"></a>获取</h4><ol>\n<li>lrange    key    start    stop</li>\n<li>lindex    key    index</li>\n<li>llen    key</li>\n</ol>\n<h4 id=\"获取并移除\"><a href=\"#获取并移除\" class=\"headerlink\" title=\"获取并移除\"></a>获取并移除</h4><ol>\n<li>lpop    key    //从左出</li>\n<li>rpop    key    //从右出</li>\n</ol>\n<pre class=\" language-tex\"><code class=\"language-tex\">lpush    list    a    b    c\n结果：c b a\n===============================\nrpush list a    b    c\n结果：a b c\n===============================\nlist=[a    b    c]\nlpop list\n结果：b c\n===============================\nlist=[a b c]\nrpop list\n结果：a b\n===============================</code></pre>\n<blockquote>\n<p>注：</p>\n<ol>\n<li>list中保存的数据都是String，数据总量是有限的，最多$2^{32}-1$个元素</li>\n<li>list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作（或以栈的形式进行入栈出栈操作）</li>\n<li>当stop的值为-1时，获取的是全部数据</li>\n<li>list对数据进行分页操作，通常第一页的数据使的信息来自list，其他页面的数据通过数据形式进行加载</li>\n</ol>\n</blockquote>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><h4 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>增：sadd    key    member    [member1]</li>\n<li>查：smembers    key</li>\n<li>删：srem    key    member    [member1]</li>\n<li>获取总量：scard    key</li>\n<li>判定是否存在：sismember    key    member</li>\n<li>随机获取（原集合保留）：srandmember    key    [count]</li>\n<li>随机获取（原集合不保留）：spop    key</li>\n<li>集合交集：sinter    key    key1    key2</li>\n<li>集合并集：sunion    key    key1    key2</li>\n<li>集合差集：sdiff    key    key1    key2</li>\n<li>存储集合交集：sinterstore    destination    key    key1    key2</li>\n<li>存储集合并集：sunionstore    destination    key    key1    key2</li>\n<li>存储集合差集：sdiffstore    destination    key    key1    key2</li>\n<li>集合元素移动：smove    source    destination    member</li>\n</ol>\n<h3 id=\"Sorted-Set\"><a href=\"#Sorted-Set\" class=\"headerlink\" title=\"Sorted_Set\"></a>Sorted_Set</h3><h4 id=\"命令-1\"><a href=\"#命令-1\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>增：zadd    key    score    member    [score1    member1]</li>\n<li>删：zrem    key    member    [member1]</li>\n<li>获取全部（正序）：zrange    key    start    stop    [withscores]</li>\n<li>获取全部（倒序）：zrevrange    key    start    stop    [withscores]</li>\n<li>按条件查（正序）：zrangebyscore    key    min    max    [withscore    limit]</li>\n<li>按条件查（倒序）：zrevrangebyscore    key    max    min    [withscore    limit]</li>\n<li>按条件删除（索引）：zremrangebyrank    key    start    stop</li>\n<li>按条件删除（积分）：zremrangebyscore    key    min    max</li>\n<li>获取集合总量：zcard    key    |    zcount    key    min    max</li>\n<li>存储集合交集：    zinterstore    destination    numkeys    key    key1</li>\n<li>存储集合并集：zunionstore    destination    numkeys    key    key1</li>\n<li>获取索引（正序）：zrank    key    member</li>\n<li>获取索引（倒序）：zrevrank    key    member</li>\n<li>score值获取：zscore    key    member</li>\n<li>score值修改：zincrby    key    num    member</li>\n</ol>\n<h2 id=\"Key的操作\"><a href=\"#Key的操作\" class=\"headerlink\" title=\"Key的操作\"></a>Key的操作</h2><h3 id=\"命令-2\"><a href=\"#命令-2\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ol>\n<li>删除：del    key</li>\n<li>判断是否存在：exists    key</li>\n<li>获取key类型：type    key</li>\n<li>指定有效期：<ol>\n<li>expire    key    seconds</li>\n<li>pexpire    key    milliseconds</li>\n<li>expireat    key    timestamp</li>\n<li>pexpireat    key    milliseconds-timestamp</li>\n</ol>\n</li>\n<li>获取有效期：<ol>\n<li>ttl    key</li>\n<li>pttl    key</li>\n</ol>\n</li>\n<li>设置永久：persist    key</li>\n<li>查询key：key    pattern    //*,?,[]</li>\n<li>重命名：rename    key    newkey    |    renamenx    key    newkey</li>\n<li>对key排序：sort</li>\n</ol>\n<h2 id=\"数据库操作\"><a href=\"#数据库操作\" class=\"headerlink\" title=\"数据库操作\"></a>数据库操作</h2><h3 id=\"命令-3\"><a href=\"#命令-3\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ol>\n<li>选择数据库：select    index</li>\n<li>数据移动：move    key    db</li>\n<li>数据库大小：dbsize</li>\n<li>数据清除：<ol>\n<li>单库删除：flushdb</li>\n<li>多库删除：flushall</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><h3 id=\"RDB（Relational-Database）\"><a href=\"#RDB（Relational-Database）\" class=\"headerlink\" title=\"RDB（Relational Database）\"></a>RDB（Relational Database）</h3><h4 id=\"保存数据\"><a href=\"#保存数据\" class=\"headerlink\" title=\"保存数据\"></a>保存数据</h4><ol>\n<li>指令（前台）：save    //阻塞 立即保存</li>\n<li>指令（后台）：bgsave    //不立即执行</li>\n<li>配置：save    second    changes    //用bgsave执行操作</li>\n</ol>\n<h4 id=\"常用配置项\"><a href=\"#常用配置项\" class=\"headerlink\" title=\"常用配置项\"></a>常用配置项</h4><ol>\n<li>数据文件名称：dbfilename    dump.rdb    //默认</li>\n<li>数据保存路径：dir</li>\n<li>是否开启压缩：rdbcompression    yes    //默认</li>\n<li>是否开启格式检查：rdbchecksum    yes|no //默认no</li>\n</ol>\n<h4 id=\"RDB-持久化优点\"><a href=\"#RDB-持久化优点\" class=\"headerlink\" title=\"RDB 持久化优点\"></a>RDB 持久化优点</h4><ol>\n<li>RDB是一个紧凑压缩的二进制文件，存储效率高</li>\n<li>RDB存储的是Redis在某个时间点的数据快照，非常适用于数据备份全量复制等场景</li>\n<li>RDB恢复数据速度比AOF快</li>\n</ol>\n<h4 id=\"RDB应用\"><a href=\"#RDB应用\" class=\"headerlink\" title=\"RDB应用\"></a>RDB应用</h4><p>服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复</p>\n<h4 id=\"RDB持久化缺点\"><a href=\"#RDB持久化缺点\" class=\"headerlink\" title=\"RDB持久化缺点\"></a>RDB持久化缺点</h4><ol>\n<li>RDB方式无论是执行命令还是进行配置，无法做到实时持久化，具有较大可能丢失数据</li>\n<li>bgsave每次运行要执行fork操作创建子进程，要牺牲一些性能</li>\n<li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各个版本服务器之间数据格式无法兼容</li>\n<li>存储数量较大时，效率较低</li>\n<li>大数据量下的I／O性能较低</li>\n<li>基于fork创建子进程，内存产生额外消耗</li>\n<li>宕机带来的数据丢失风险</li>\n</ol>\n<h3 id=\"AOF（Append-Only-File）\"><a href=\"#AOF（Append-Only-File）\" class=\"headerlink\" title=\"AOF（Append Only File）\"></a>AOF（Append Only File）</h3><h4 id=\"保存数据策略\"><a href=\"#保存数据策略\" class=\"headerlink\" title=\"保存数据策略\"></a>保存数据策略</h4><p>每次：always<br>每秒：everysec<br>系统控制：no</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><ol>\n<li>是否开启：appendonly    yes|no    //默认no</li>\n<li>保存策略：appendfsync    always|everysec|no</li>\n<li>重写：<br> 手动：bgrewriteaof<br> 自动：<pre><code> auto-aof-rewrite-min-size    size\n auto-aof-rewrite-percentage    percentage</code></pre></li>\n</ol>\n<h3 id=\"RDB-与-AOF-如何选择\"><a href=\"#RDB-与-AOF-如何选择\" class=\"headerlink\" title=\"RDB 与 AOF 如何选择\"></a>RDB 与 AOF 如何选择</h3><p>对数据非常敏感，建议使用默认的AOF持久化方案<br>    AOF策略使用everysec，每秒fsync一次，该策略仍可保持很好性能，出现问题最多丢失一秒内的数据<br>数据呈现阶段有效性，建议使用RDB持久化方案<br>    数据可以做到阶段内无丢失，且恢复较快，阶段点数据恢复通常使用RDB方案</p>\n<blockquote>\n<p>注意：<br>AOF文件存储体积较大，恢复速度较慢<br>利用RDB使用线紧凑的数据持久化会使Redis性能降低</p>\n</blockquote>\n<p>综合：</p>\n<ol>\n<li>RDB与AOF选择实际上是在一种权衡，每种都有利有弊</li>\n<li>如果不能承受分钟内的数据丢失，对业务数据非常敏感，选用AOF</li>\n<li>如果能承受分钟内的数据丢失，且追求大数据集的恢复速度选用RDB</li>\n<li>灾难恢复选用RDB</li>\n<li>双保险策略，同时开启RDB和AOF，重启后Redis优先使用AOF来恢复数据，降低丢失数据量</li>\n</ol>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>Redis事务不具有回滚机制</p>\n<h3 id=\"命令-4\"><a href=\"#命令-4\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ol>\n<li>开启：multi</li>\n<li>结束：exec</li>\n<li>中断：discard</li>\n</ol>\n<h3 id=\"事务中的错误\"><a href=\"#事务中的错误\" class=\"headerlink\" title=\"事务中的错误\"></a>事务中的错误</h3><h4 id=\"命令错误\"><a href=\"#命令错误\" class=\"headerlink\" title=\"命令错误\"></a>命令错误</h4><p>执行事务过程中输入的命令出现错误，Redis会结束事务不再执行，并报出错误的命令</p>\n<h4 id=\"操作错误\"><a href=\"#操作错误\" class=\"headerlink\" title=\"操作错误\"></a>操作错误</h4><p>执行事务过程中输入的命令正确，其他操作错误，事务中其他命令正常执行，错误操作报错</p>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><p>Redis中锁和事务是相搭配使用的，可解决对key的监控</p>\n<h3 id=\"命令-5\"><a href=\"#命令-5\" class=\"headerlink\" title=\"命令\"></a>命令</h3><p>加锁：watch    key    [key1]<br>解锁：unwatch  //取消掉所有key的监控</p>\n<h2 id=\"数据删除策略\"><a href=\"#数据删除策略\" class=\"headerlink\" title=\"数据删除策略\"></a>数据删除策略</h2><p>当key过期后执行数据删除的策略</p>\n<h3 id=\"定时删除（即可删除）\"><a href=\"#定时删除（即可删除）\" class=\"headerlink\" title=\"定时删除（即可删除）\"></a>定时删除（即可删除）</h3><p>创建一个具有时效性的key时，同时会创建一个定时器来监控该key是否过期，当key过期后立即进行key的删除</p>\n<p>优点：节约内存，到时就会进行删除，快速释放占用空间<br>缺点：CPU压力大影响Redis响应时间和吞吐量<br>总结：用处理器性能换取存储空间</p>\n<h3 id=\"惰性删除\"><a href=\"#惰性删除\" class=\"headerlink\" title=\"惰性删除\"></a>惰性删除</h3><p>当一个具有实效性的key过期后不会有删除操作，直到下一次调用时会先检查该key是否过期，如果过期则进行删除操作，并返回nil（该key不存在）</p>\n<p>优点：节约CPU性能，发现必须删除的时候才会删除<br>缺点：内存压力大，出现长期占用内存的数据<br>总结：用存储空间换取处理器性能</p>\n<h3 id=\"定期删除\"><a href=\"#定期删除\" class=\"headerlink\" title=\"定期删除\"></a>定期删除</h3><p>Redis会根据设置的参数，定期对具有时效性的key进行清理工作，它是定时删除和惰性删除的结合者，既不像定时删除会立即进行删除给予CPU压力，也不会像惰性删除给予内存压力</p>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><ol>\n<li>Redis启动服务器初始化时，读取配置server.hz的值（默认为10）</li>\n<li>每秒钟执行server.hz次serverCron（）服务（serverCron【服务器级别】-&gt;databasesCron【数据库级别】-&gt;activeExpireCyle【活跃数据级别】）</li>\n<li>acitveExpireCyle（）对每个expires[*]（数据库）逐一进行检测，每次执行250ms／server.hz</li>\n<li>对某个expires[*]检测时，随机挑选w个key进行检测<ol>\n<li>如果key超时，删除key</li>\n<li>如果一轮中删除的kye的数量&gt;w*25%，循环该过程</li>\n<li>如果一轮中删除的可以的数量&lt;=w<em>25%检查下一个expires[</em>],0-15（所有的数据库）循环<blockquote>\n<p>W=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP<br>参数current_db用于记录activeExpireCyle进入哪个expires[*]执行</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"数据淘汰策略\"><a href=\"#数据淘汰策略\" class=\"headerlink\" title=\"数据淘汰策略\"></a>数据淘汰策略</h2><p>当内存到达最大内存限制时进行的数据淘汰策略</p>\n<p>数据驱逐淘汰策略配置依据，使用info命令输出相关监控信息，查新缓存hit 命中次数和miss的次数，根据业务调优</p>\n<h3 id=\"配置-1\"><a href=\"#配置-1\" class=\"headerlink\" title=\"配置\"></a>配置</h3><ol>\n<li>最大可用内存：maxmemory    //默认为0，一般设置全部内存50%以上</li>\n<li>每次选取带删除数据个数：maxmemory-samples    //采用随机获取方式</li>\n<li>删除策略：maxmemory-policy    //达到最大内存后，对被选取带数据进行的删除策略</li>\n</ol>\n<h3 id=\"检测易失数据集（可能会过期数据server-db-i-expires）\"><a href=\"#检测易失数据集（可能会过期数据server-db-i-expires）\" class=\"headerlink\" title=\"检测易失数据集（可能会过期数据server.db[i].expires）\"></a>检测易失数据集（可能会过期数据server.db[i].expires）</h3><ol>\n<li>volatile-lru：挑选最近最少使用的数据淘汰（最近数据中使用时间离当前最远的数据）。<strong>常用</strong></li>\n<li>volatile-lfu：挑选最近使用次数最少的数据淘汰（最近数据中使用次数最少的数据）</li>\n<li>volatile-ttl：挑选将要过期数据淘汰</li>\n<li>volatile-random：任意挑选数据淘汰</li>\n</ol>\n<blockquote>\n<p>ttl：time to live<br>lru：least recently    used<br>lfu：least frequently    used</p>\n</blockquote>\n<h3 id=\"检测全库数据（所有数据集server-db-i-dict）\"><a href=\"#检测全库数据（所有数据集server-db-i-dict）\" class=\"headerlink\" title=\"检测全库数据（所有数据集server.db[i].dict）\"></a>检测全库数据（所有数据集server.db[i].dict）</h3><ol>\n<li>allkeys-lru：挑选最近最少使用的数据淘汰</li>\n<li>allkeys-lfu：挑选最近使用次数最少的数据淘汰</li>\n<li>allkeys-random：任意挑选数据淘汰</li>\n</ol>\n<h3 id=\"放弃数据驱逐\"><a href=\"#放弃数据驱逐\" class=\"headerlink\" title=\"放弃数据驱逐\"></a>放弃数据驱逐</h3><p>no-enviction    //禁止驱逐数据<br>4.0中默认策略，会引发OOM</p>\n<h2 id=\"服务器基本配置\"><a href=\"#服务器基本配置\" class=\"headerlink\" title=\"服务器基本配置\"></a>服务器基本配置</h2><ol>\n<li>设置服务器守护进程方式：daemonize    yes|no</li>\n<li>绑定地址：bing    127.0.0.1</li>\n<li>设置服务器端口：port    6379</li>\n<li>设置数据库数量：databases    16</li>\n<li>设置服务器日志级别：loglevel    debug|verbose|notice|warning</li>\n<li>日志文件名称：logfile    端口号.log</li>\n<li>设置客户端最大连接数：maxclients    0</li>\n<li>客户端闲置最大等待时长：timeout    0</li>\n</ol>\n<h2 id=\"高级数据类型\"><a href=\"#高级数据类型\" class=\"headerlink\" title=\"高级数据类型\"></a>高级数据类型</h2><h3 id=\"Bitmaps\"><a href=\"#Bitmaps\" class=\"headerlink\" title=\"Bitmaps\"></a>Bitmaps</h3><p>标记统计</p>\n<h4 id=\"命令-6\"><a href=\"#命令-6\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>获取：getbit    key    offset</li>\n<li>设置：setbit    key    offset    value    // 0 或 1</li>\n<li>交、并、或异<br> bitop    op    destkey    key1    key2<br> op：<pre><code> 交：and\n 并：or\n 非：not\n 异或：xor</code></pre></li>\n<li>统计指定key中1的数量：bitcount    key    [start    end]</li>\n</ol>\n<h3 id=\"HyperLoglog\"><a href=\"#HyperLoglog\" class=\"headerlink\" title=\"HyperLoglog\"></a>HyperLoglog</h3><p>基数统计</p>\n<h4 id=\"命令-7\"><a href=\"#命令-7\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>添加：pfadd    key    element    [element1]</li>\n<li>统计：pfcount    key    [key1]</li>\n<li>合并：pfmerge    destkey    sourcekey    [sourcekey1]</li>\n</ol>\n<h3 id=\"GEO\"><a href=\"#GEO\" class=\"headerlink\" title=\"GEO\"></a>GEO</h3><p>距离计算（只计算水平距离）</p>\n<h4 id=\"命令-8\"><a href=\"#命令-8\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>添加：geoadd    key    longitude    latitude    member    [longitude1    latitude1    member1]</li>\n<li>获取：geopos    key    member    [member1]</li>\n<li>计算距离：geodist    key    member1    member2    [count]</li>\n<li>根据坐标求范围内数据：georadius    key    longitude    latitude    radius    m|km|ft|mi</li>\n<li>根据点求范围内的数据：georadusbymember    key    member    radius    m|km|ft|mi</li>\n<li>获取指定点对应的hash值：geohash    key    member    [member1]    </li>\n</ol>\n<h2 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h2><h3 id=\"创建链接\"><a href=\"#创建链接\" class=\"headerlink\" title=\"创建链接\"></a>创建链接</h3><ul>\n<li>方式一：客户端发指令：slaveof    masterip masterport</li>\n<li>方式二：参数启动：redis-server    –slaveof    masterip masterport</li>\n<li>方式三：服务器配置：slaveof    masterip masterport</li>\n</ul>\n<h3 id=\"数据同步\"><a href=\"#数据同步\" class=\"headerlink\" title=\"数据同步\"></a>数据同步</h3><h4 id=\"全量复制\"><a href=\"#全量复制\" class=\"headerlink\" title=\"全量复制\"></a>全量复制</h4><p>从：发送指令（psync2）<br>主：执行bgsave<br>主：第一个slave链接时，创建命令缓冲区<br>主：生成RDB文件，通过socket发送给slave<br>从：接收RDB文件，清空自己数据，执行RDB文件恢复过程</p>\n<h4 id=\"部分复制\"><a href=\"#部分复制\" class=\"headerlink\" title=\"部分复制\"></a>部分复制</h4><p>从：发送命令告知RDB恢复完成<br>主：发送复制缓冲区信息<br>从：接收信息，执行bgsavewriteaof，恢复数据</p>\n<h2 id=\"哨兵模式\"><a href=\"#哨兵模式\" class=\"headerlink\" title=\"哨兵模式\"></a>哨兵模式</h2><h3 id=\"配置-2\"><a href=\"#配置-2\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>sentinel.conf</p>\n<p>启动：redis-sentinel</p>\n<h2 id=\"集群（cluster）\"><a href=\"#集群（cluster）\" class=\"headerlink\" title=\"集群（cluster）\"></a>集群（cluster）</h2><h3 id=\"配置-3\"><a href=\"#配置-3\" class=\"headerlink\" title=\"配置\"></a>配置</h3><ol>\n<li>开启：cluster-enabled    yes|no</li>\n<li>配置文件名称：cluster-config-file    filename</li>\n<li>节点超时时间：cluster-node-timeout    milliseconds</li>\n<li>master链接slave最小数：cluster-migration-barrier    count</li>\n</ol>\n<h3 id=\"命令-9\"><a href=\"#命令-9\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ol>\n<li>查看节点信息：cluster nodes</li>\n<li>从一个节点Redis，切换其主节点：cluster    replicate    masterip</li>\n<li>新增主节点：cluster meet    ip:port</li>\n<li>忽略一个节点：cluster    foeget    id</li>\n<li>手动故障转移：cluster    failover</li>\n</ol>\n","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<h1 id=\"Redis（Remote-Dictionary-Server）\"><a href=\"#Redis（Remote-Dictionary-Server）\" class=\"headerlink\" title=\"Redis（Remote Dictionary Server）\"></a>Redis（Remote Dictionary Server）</h1><h2 id=\"Redis-运行快速的原因\"><a href=\"#Redis-运行快速的原因\" class=\"headerlink\" title=\"Redis 运行快速的原因\"></a>Redis 运行快速的原因</h2><ol>\n<li><p>完全基于内存操作</p>\n</li>\n<li><p>数据结构简单，数据操作也简单</p>\n</li>\n<li><p>使用多路I/O复用模型</p>\n</li>\n</ol>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><h4 id=\"单条操作\"><a href=\"#单条操作\" class=\"headerlink\" title=\"单条操作\"></a>单条操作</h4><ol>\n<li>增：set    key    value</li>\n<li>查：get    key</li>\n<li>删：del    key</li>\n</ol>\n<h4 id=\"多条操作\"><a href=\"#多条操作\" class=\"headerlink\" title=\"多条操作\"></a>多条操作</h4><ol>\n<li>增：mset    key    value    [key1    value1]</li>\n<li>查：mget    key    [key1]</li>\n</ol>\n<h4 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h4><ol>\n<li>strlen    key    //获取字符串长度</li>\n<li>append    key    value    //有则追加，无则新建</li>\n<li>setnx    key    value    //不存在就设置，存在就不设置</li>\n<li>incr    key    //自增 1</li>\n<li>incrby    key    num  //给key的值增加num（int 类型），num 正数则为加，num 为负数 则为减</li>\n<li>incrbyfloat    key    num    //给key的值增加num（float 类型）</li>\n<li>decr    key  //自减 1</li>\n<li>decrby    key    num    //给key的值减num</li>\n<li>setex    key    second    value    //设置key的值为value存活时间为second秒</li>\n<li>psetex    key    millisecond    value    //设置key的值为value存活时间为millisecond毫秒</li>\n</ol>\n<blockquote>\n<p>注：<br>字符串值最大值为512m</p>\n</blockquote>\n<h3 id=\"Hash\"><a href=\"#Hash\" class=\"headerlink\" title=\"Hash\"></a>Hash</h3><p>和字符串相似，可理解为字符串厘米套字符串</p>\n<h4 id=\"单条操作-1\"><a href=\"#单条操作-1\" class=\"headerlink\" title=\"单条操作\"></a>单条操作</h4><ol>\n<li>增：hset    key    field    value    </li>\n<li>查：hget    key    field</li>\n<li>删：hdel    key    field</li>\n</ol>\n<h4 id=\"多条操作-1\"><a href=\"#多条操作-1\" class=\"headerlink\" title=\"多条操作\"></a>多条操作</h4><ol>\n<li>增：hmset    key    field    value    [field1    value2]</li>\n<li>查：hmget    key    field    [field1]</li>\n</ol>\n<h4 id=\"其他命令-1\"><a href=\"#其他命令-1\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h4><ol>\n<li>hgetall    key    //获取key的全部的值</li>\n<li>hlen    key    //获取key的值的数量</li>\n<li>hexists    key    field    //是否存在field</li>\n<li>hkeys    key    //所有key的字段（field）</li>\n<li>hvals    key    //所有key的值 </li>\n<li>hincrby    key    field    num    //给key的field的值增加num （num 为int值）</li>\n<li>hincrybyfloat    key    field    num    //给key的field的值增加num （num 为float）</li>\n<li>hsetnx    key    field    value    //存在不设置，不存在设置</li>\n</ol>\n<blockquote>\n<p>注：</p>\n<ol>\n<li>Hash类型的value只能存字符串，不允许再嵌套其他类型，如果数据为空为Nil</li>\n<li>每个Hash可以存储$2^{32}-1$个键的值对</li>\n<li>Hash类型十分贴近对象的数据存储，并且可以灵活添加、删除对象属性。但Hash类型设计并不是存在量而设计的，切记不可滥用，更不可将Hash作为对象列表使用</li>\n<li>hgetall操作可以获取全部属性，如果内部field过多，遍历整体数据时效率会降低，很有可能成为数据访问的瓶颈</li>\n</ol>\n</blockquote>\n<h3 id=\"String存储对象（Json）-VS-Hash存储对象\"><a href=\"#String存储对象（Json）-VS-Hash存储对象\" class=\"headerlink\" title=\"String存储对象（Json） VS Hash存储对象\"></a>String存储对象（Json） VS Hash存储对象</h3><ol>\n<li>String存在对象讲究整体性，以读为主</li>\n<li>Hash存储对象讲究分散性，以写为主</li>\n</ol>\n<h3 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h3><p>讲究顺序</p>\n<h4 id=\"添加\"><a href=\"#添加\" class=\"headerlink\" title=\"添加\"></a>添加</h4><ol>\n<li>lpush    key    value    [value1]    //从左添加</li>\n<li>rpush    key    value    [value1]    //从右添加</li>\n</ol>\n<h4 id=\"获取\"><a href=\"#获取\" class=\"headerlink\" title=\"获取\"></a>获取</h4><ol>\n<li>lrange    key    start    stop</li>\n<li>lindex    key    index</li>\n<li>llen    key</li>\n</ol>\n<h4 id=\"获取并移除\"><a href=\"#获取并移除\" class=\"headerlink\" title=\"获取并移除\"></a>获取并移除</h4><ol>\n<li>lpop    key    //从左出</li>\n<li>rpop    key    //从右出</li>\n</ol>\n<pre><code class=\"tex\">lpush    list    a    b    c\n结果：c b a\n===============================\nrpush list a    b    c\n结果：a b c\n===============================\nlist=[a    b    c]\nlpop list\n结果：b c\n===============================\nlist=[a b c]\nrpop list\n结果：a b\n===============================</code></pre>\n<blockquote>\n<p>注：</p>\n<ol>\n<li>list中保存的数据都是String，数据总量是有限的，最多$2^{32}-1$个元素</li>\n<li>list具有索引的概念，但是操作数据时通常以队列的形式进行入队出队操作（或以栈的形式进行入栈出栈操作）</li>\n<li>当stop的值为-1时，获取的是全部数据</li>\n<li>list对数据进行分页操作，通常第一页的数据使的信息来自list，其他页面的数据通过数据形式进行加载</li>\n</ol>\n</blockquote>\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><h4 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>增：sadd    key    member    [member1]</li>\n<li>查：smembers    key</li>\n<li>删：srem    key    member    [member1]</li>\n<li>获取总量：scard    key</li>\n<li>判定是否存在：sismember    key    member</li>\n<li>随机获取（原集合保留）：srandmember    key    [count]</li>\n<li>随机获取（原集合不保留）：spop    key</li>\n<li>集合交集：sinter    key    key1    key2</li>\n<li>集合并集：sunion    key    key1    key2</li>\n<li>集合差集：sdiff    key    key1    key2</li>\n<li>存储集合交集：sinterstore    destination    key    key1    key2</li>\n<li>存储集合并集：sunionstore    destination    key    key1    key2</li>\n<li>存储集合差集：sdiffstore    destination    key    key1    key2</li>\n<li>集合元素移动：smove    source    destination    member</li>\n</ol>\n<h3 id=\"Sorted-Set\"><a href=\"#Sorted-Set\" class=\"headerlink\" title=\"Sorted_Set\"></a>Sorted_Set</h3><h4 id=\"命令-1\"><a href=\"#命令-1\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>增：zadd    key    score    member    [score1    member1]</li>\n<li>删：zrem    key    member    [member1]</li>\n<li>获取全部（正序）：zrange    key    start    stop    [withscores]</li>\n<li>获取全部（倒序）：zrevrange    key    start    stop    [withscores]</li>\n<li>按条件查（正序）：zrangebyscore    key    min    max    [withscore    limit]</li>\n<li>按条件查（倒序）：zrevrangebyscore    key    max    min    [withscore    limit]</li>\n<li>按条件删除（索引）：zremrangebyrank    key    start    stop</li>\n<li>按条件删除（积分）：zremrangebyscore    key    min    max</li>\n<li>获取集合总量：zcard    key    |    zcount    key    min    max</li>\n<li>存储集合交集：    zinterstore    destination    numkeys    key    key1</li>\n<li>存储集合并集：zunionstore    destination    numkeys    key    key1</li>\n<li>获取索引（正序）：zrank    key    member</li>\n<li>获取索引（倒序）：zrevrank    key    member</li>\n<li>score值获取：zscore    key    member</li>\n<li>score值修改：zincrby    key    num    member</li>\n</ol>\n<h2 id=\"Key的操作\"><a href=\"#Key的操作\" class=\"headerlink\" title=\"Key的操作\"></a>Key的操作</h2><h3 id=\"命令-2\"><a href=\"#命令-2\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ol>\n<li>删除：del    key</li>\n<li>判断是否存在：exists    key</li>\n<li>获取key类型：type    key</li>\n<li>指定有效期：<ol>\n<li>expire    key    seconds</li>\n<li>pexpire    key    milliseconds</li>\n<li>expireat    key    timestamp</li>\n<li>pexpireat    key    milliseconds-timestamp</li>\n</ol>\n</li>\n<li>获取有效期：<ol>\n<li>ttl    key</li>\n<li>pttl    key</li>\n</ol>\n</li>\n<li>设置永久：persist    key</li>\n<li>查询key：key    pattern    //*,?,[]</li>\n<li>重命名：rename    key    newkey    |    renamenx    key    newkey</li>\n<li>对key排序：sort</li>\n</ol>\n<h2 id=\"数据库操作\"><a href=\"#数据库操作\" class=\"headerlink\" title=\"数据库操作\"></a>数据库操作</h2><h3 id=\"命令-3\"><a href=\"#命令-3\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ol>\n<li>选择数据库：select    index</li>\n<li>数据移动：move    key    db</li>\n<li>数据库大小：dbsize</li>\n<li>数据清除：<ol>\n<li>单库删除：flushdb</li>\n<li>多库删除：flushall</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><h3 id=\"RDB（Relational-Database）\"><a href=\"#RDB（Relational-Database）\" class=\"headerlink\" title=\"RDB（Relational Database）\"></a>RDB（Relational Database）</h3><h4 id=\"保存数据\"><a href=\"#保存数据\" class=\"headerlink\" title=\"保存数据\"></a>保存数据</h4><ol>\n<li>指令（前台）：save    //阻塞 立即保存</li>\n<li>指令（后台）：bgsave    //不立即执行</li>\n<li>配置：save    second    changes    //用bgsave执行操作</li>\n</ol>\n<h4 id=\"常用配置项\"><a href=\"#常用配置项\" class=\"headerlink\" title=\"常用配置项\"></a>常用配置项</h4><ol>\n<li>数据文件名称：dbfilename    dump.rdb    //默认</li>\n<li>数据保存路径：dir</li>\n<li>是否开启压缩：rdbcompression    yes    //默认</li>\n<li>是否开启格式检查：rdbchecksum    yes|no //默认no</li>\n</ol>\n<h4 id=\"RDB-持久化优点\"><a href=\"#RDB-持久化优点\" class=\"headerlink\" title=\"RDB 持久化优点\"></a>RDB 持久化优点</h4><ol>\n<li>RDB是一个紧凑压缩的二进制文件，存储效率高</li>\n<li>RDB存储的是Redis在某个时间点的数据快照，非常适用于数据备份全量复制等场景</li>\n<li>RDB恢复数据速度比AOF快</li>\n</ol>\n<h4 id=\"RDB应用\"><a href=\"#RDB应用\" class=\"headerlink\" title=\"RDB应用\"></a>RDB应用</h4><p>服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复</p>\n<h4 id=\"RDB持久化缺点\"><a href=\"#RDB持久化缺点\" class=\"headerlink\" title=\"RDB持久化缺点\"></a>RDB持久化缺点</h4><ol>\n<li>RDB方式无论是执行命令还是进行配置，无法做到实时持久化，具有较大可能丢失数据</li>\n<li>bgsave每次运行要执行fork操作创建子进程，要牺牲一些性能</li>\n<li>Redis的众多版本中未进行RDB文件格式的版本统一，有可能出现各个版本服务器之间数据格式无法兼容</li>\n<li>存储数量较大时，效率较低</li>\n<li>大数据量下的I／O性能较低</li>\n<li>基于fork创建子进程，内存产生额外消耗</li>\n<li>宕机带来的数据丢失风险</li>\n</ol>\n<h3 id=\"AOF（Append-Only-File）\"><a href=\"#AOF（Append-Only-File）\" class=\"headerlink\" title=\"AOF（Append Only File）\"></a>AOF（Append Only File）</h3><h4 id=\"保存数据策略\"><a href=\"#保存数据策略\" class=\"headerlink\" title=\"保存数据策略\"></a>保存数据策略</h4><p>每次：always<br>每秒：everysec<br>系统控制：no</p>\n<h4 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h4><ol>\n<li>是否开启：appendonly    yes|no    //默认no</li>\n<li>保存策略：appendfsync    always|everysec|no</li>\n<li>重写：<br> 手动：bgrewriteaof<br> 自动：<pre><code> auto-aof-rewrite-min-size    size\n auto-aof-rewrite-percentage    percentage</code></pre></li>\n</ol>\n<h3 id=\"RDB-与-AOF-如何选择\"><a href=\"#RDB-与-AOF-如何选择\" class=\"headerlink\" title=\"RDB 与 AOF 如何选择\"></a>RDB 与 AOF 如何选择</h3><p>对数据非常敏感，建议使用默认的AOF持久化方案<br>    AOF策略使用everysec，每秒fsync一次，该策略仍可保持很好性能，出现问题最多丢失一秒内的数据<br>数据呈现阶段有效性，建议使用RDB持久化方案<br>    数据可以做到阶段内无丢失，且恢复较快，阶段点数据恢复通常使用RDB方案</p>\n<blockquote>\n<p>注意：<br>AOF文件存储体积较大，恢复速度较慢<br>利用RDB使用线紧凑的数据持久化会使Redis性能降低</p>\n</blockquote>\n<p>综合：</p>\n<ol>\n<li>RDB与AOF选择实际上是在一种权衡，每种都有利有弊</li>\n<li>如果不能承受分钟内的数据丢失，对业务数据非常敏感，选用AOF</li>\n<li>如果能承受分钟内的数据丢失，且追求大数据集的恢复速度选用RDB</li>\n<li>灾难恢复选用RDB</li>\n<li>双保险策略，同时开启RDB和AOF，重启后Redis优先使用AOF来恢复数据，降低丢失数据量</li>\n</ol>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>Redis事务不具有回滚机制</p>\n<h3 id=\"命令-4\"><a href=\"#命令-4\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ol>\n<li>开启：multi</li>\n<li>结束：exec</li>\n<li>中断：discard</li>\n</ol>\n<h3 id=\"事务中的错误\"><a href=\"#事务中的错误\" class=\"headerlink\" title=\"事务中的错误\"></a>事务中的错误</h3><h4 id=\"命令错误\"><a href=\"#命令错误\" class=\"headerlink\" title=\"命令错误\"></a>命令错误</h4><p>执行事务过程中输入的命令出现错误，Redis会结束事务不再执行，并报出错误的命令</p>\n<h4 id=\"操作错误\"><a href=\"#操作错误\" class=\"headerlink\" title=\"操作错误\"></a>操作错误</h4><p>执行事务过程中输入的命令正确，其他操作错误，事务中其他命令正常执行，错误操作报错</p>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><p>Redis中锁和事务是相搭配使用的，可解决对key的监控</p>\n<h3 id=\"命令-5\"><a href=\"#命令-5\" class=\"headerlink\" title=\"命令\"></a>命令</h3><p>加锁：watch    key    [key1]<br>解锁：unwatch  //取消掉所有key的监控</p>\n<h2 id=\"数据删除策略\"><a href=\"#数据删除策略\" class=\"headerlink\" title=\"数据删除策略\"></a>数据删除策略</h2><p>当key过期后执行数据删除的策略</p>\n<h3 id=\"定时删除（即可删除）\"><a href=\"#定时删除（即可删除）\" class=\"headerlink\" title=\"定时删除（即可删除）\"></a>定时删除（即可删除）</h3><p>创建一个具有时效性的key时，同时会创建一个定时器来监控该key是否过期，当key过期后立即进行key的删除</p>\n<p>优点：节约内存，到时就会进行删除，快速释放占用空间<br>缺点：CPU压力大影响Redis响应时间和吞吐量<br>总结：用处理器性能换取存储空间</p>\n<h3 id=\"惰性删除\"><a href=\"#惰性删除\" class=\"headerlink\" title=\"惰性删除\"></a>惰性删除</h3><p>当一个具有实效性的key过期后不会有删除操作，直到下一次调用时会先检查该key是否过期，如果过期则进行删除操作，并返回nil（该key不存在）</p>\n<p>优点：节约CPU性能，发现必须删除的时候才会删除<br>缺点：内存压力大，出现长期占用内存的数据<br>总结：用存储空间换取处理器性能</p>\n<h3 id=\"定期删除\"><a href=\"#定期删除\" class=\"headerlink\" title=\"定期删除\"></a>定期删除</h3><p>Redis会根据设置的参数，定期对具有时效性的key进行清理工作，它是定时删除和惰性删除的结合者，既不像定时删除会立即进行删除给予CPU压力，也不会像惰性删除给予内存压力</p>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><ol>\n<li>Redis启动服务器初始化时，读取配置server.hz的值（默认为10）</li>\n<li>每秒钟执行server.hz次serverCron（）服务（serverCron【服务器级别】-&gt;databasesCron【数据库级别】-&gt;activeExpireCyle【活跃数据级别】）</li>\n<li>acitveExpireCyle（）对每个expires[*]（数据库）逐一进行检测，每次执行250ms／server.hz</li>\n<li>对某个expires[*]检测时，随机挑选w个key进行检测<ol>\n<li>如果key超时，删除key</li>\n<li>如果一轮中删除的kye的数量&gt;w*25%，循环该过程</li>\n<li>如果一轮中删除的可以的数量&lt;=w<em>25%检查下一个expires[</em>],0-15（所有的数据库）循环<blockquote>\n<p>W=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP<br>参数current_db用于记录activeExpireCyle进入哪个expires[*]执行</p>\n</blockquote>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"数据淘汰策略\"><a href=\"#数据淘汰策略\" class=\"headerlink\" title=\"数据淘汰策略\"></a>数据淘汰策略</h2><p>当内存到达最大内存限制时进行的数据淘汰策略</p>\n<p>数据驱逐淘汰策略配置依据，使用info命令输出相关监控信息，查新缓存hit 命中次数和miss的次数，根据业务调优</p>\n<h3 id=\"配置-1\"><a href=\"#配置-1\" class=\"headerlink\" title=\"配置\"></a>配置</h3><ol>\n<li>最大可用内存：maxmemory    //默认为0，一般设置全部内存50%以上</li>\n<li>每次选取带删除数据个数：maxmemory-samples    //采用随机获取方式</li>\n<li>删除策略：maxmemory-policy    //达到最大内存后，对被选取带数据进行的删除策略</li>\n</ol>\n<h3 id=\"检测易失数据集（可能会过期数据server-db-i-expires）\"><a href=\"#检测易失数据集（可能会过期数据server-db-i-expires）\" class=\"headerlink\" title=\"检测易失数据集（可能会过期数据server.db[i].expires）\"></a>检测易失数据集（可能会过期数据server.db[i].expires）</h3><ol>\n<li>volatile-lru：挑选最近最少使用的数据淘汰（最近数据中使用时间离当前最远的数据）。<strong>常用</strong></li>\n<li>volatile-lfu：挑选最近使用次数最少的数据淘汰（最近数据中使用次数最少的数据）</li>\n<li>volatile-ttl：挑选将要过期数据淘汰</li>\n<li>volatile-random：任意挑选数据淘汰</li>\n</ol>\n<blockquote>\n<p>ttl：time to live<br>lru：least recently    used<br>lfu：least frequently    used</p>\n</blockquote>\n<h3 id=\"检测全库数据（所有数据集server-db-i-dict）\"><a href=\"#检测全库数据（所有数据集server-db-i-dict）\" class=\"headerlink\" title=\"检测全库数据（所有数据集server.db[i].dict）\"></a>检测全库数据（所有数据集server.db[i].dict）</h3><ol>\n<li>allkeys-lru：挑选最近最少使用的数据淘汰</li>\n<li>allkeys-lfu：挑选最近使用次数最少的数据淘汰</li>\n<li>allkeys-random：任意挑选数据淘汰</li>\n</ol>\n<h3 id=\"放弃数据驱逐\"><a href=\"#放弃数据驱逐\" class=\"headerlink\" title=\"放弃数据驱逐\"></a>放弃数据驱逐</h3><p>no-enviction    //禁止驱逐数据<br>4.0中默认策略，会引发OOM</p>\n<h2 id=\"服务器基本配置\"><a href=\"#服务器基本配置\" class=\"headerlink\" title=\"服务器基本配置\"></a>服务器基本配置</h2><ol>\n<li>设置服务器守护进程方式：daemonize    yes|no</li>\n<li>绑定地址：bing    127.0.0.1</li>\n<li>设置服务器端口：port    6379</li>\n<li>设置数据库数量：databases    16</li>\n<li>设置服务器日志级别：loglevel    debug|verbose|notice|warning</li>\n<li>日志文件名称：logfile    端口号.log</li>\n<li>设置客户端最大连接数：maxclients    0</li>\n<li>客户端闲置最大等待时长：timeout    0</li>\n</ol>\n<h2 id=\"高级数据类型\"><a href=\"#高级数据类型\" class=\"headerlink\" title=\"高级数据类型\"></a>高级数据类型</h2><h3 id=\"Bitmaps\"><a href=\"#Bitmaps\" class=\"headerlink\" title=\"Bitmaps\"></a>Bitmaps</h3><p>标记统计</p>\n<h4 id=\"命令-6\"><a href=\"#命令-6\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>获取：getbit    key    offset</li>\n<li>设置：setbit    key    offset    value    // 0 或 1</li>\n<li>交、并、或异<br> bitop    op    destkey    key1    key2<br> op：<pre><code> 交：and\n 并：or\n 非：not\n 异或：xor</code></pre></li>\n<li>统计指定key中1的数量：bitcount    key    [start    end]</li>\n</ol>\n<h3 id=\"HyperLoglog\"><a href=\"#HyperLoglog\" class=\"headerlink\" title=\"HyperLoglog\"></a>HyperLoglog</h3><p>基数统计</p>\n<h4 id=\"命令-7\"><a href=\"#命令-7\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>添加：pfadd    key    element    [element1]</li>\n<li>统计：pfcount    key    [key1]</li>\n<li>合并：pfmerge    destkey    sourcekey    [sourcekey1]</li>\n</ol>\n<h3 id=\"GEO\"><a href=\"#GEO\" class=\"headerlink\" title=\"GEO\"></a>GEO</h3><p>距离计算（只计算水平距离）</p>\n<h4 id=\"命令-8\"><a href=\"#命令-8\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>添加：geoadd    key    longitude    latitude    member    [longitude1    latitude1    member1]</li>\n<li>获取：geopos    key    member    [member1]</li>\n<li>计算距离：geodist    key    member1    member2    [count]</li>\n<li>根据坐标求范围内数据：georadius    key    longitude    latitude    radius    m|km|ft|mi</li>\n<li>根据点求范围内的数据：georadusbymember    key    member    radius    m|km|ft|mi</li>\n<li>获取指定点对应的hash值：geohash    key    member    [member1]    </li>\n</ol>\n<h2 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h2><h3 id=\"创建链接\"><a href=\"#创建链接\" class=\"headerlink\" title=\"创建链接\"></a>创建链接</h3><ul>\n<li>方式一：客户端发指令：slaveof    masterip masterport</li>\n<li>方式二：参数启动：redis-server    –slaveof    masterip masterport</li>\n<li>方式三：服务器配置：slaveof    masterip masterport</li>\n</ul>\n<h3 id=\"数据同步\"><a href=\"#数据同步\" class=\"headerlink\" title=\"数据同步\"></a>数据同步</h3><h4 id=\"全量复制\"><a href=\"#全量复制\" class=\"headerlink\" title=\"全量复制\"></a>全量复制</h4><p>从：发送指令（psync2）<br>主：执行bgsave<br>主：第一个slave链接时，创建命令缓冲区<br>主：生成RDB文件，通过socket发送给slave<br>从：接收RDB文件，清空自己数据，执行RDB文件恢复过程</p>\n<h4 id=\"部分复制\"><a href=\"#部分复制\" class=\"headerlink\" title=\"部分复制\"></a>部分复制</h4><p>从：发送命令告知RDB恢复完成<br>主：发送复制缓冲区信息<br>从：接收信息，执行bgsavewriteaof，恢复数据</p>\n<h2 id=\"哨兵模式\"><a href=\"#哨兵模式\" class=\"headerlink\" title=\"哨兵模式\"></a>哨兵模式</h2><h3 id=\"配置-2\"><a href=\"#配置-2\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>sentinel.conf</p>\n<p>启动：redis-sentinel</p>\n<h2 id=\"集群（cluster）\"><a href=\"#集群（cluster）\" class=\"headerlink\" title=\"集群（cluster）\"></a>集群（cluster）</h2><h3 id=\"配置-3\"><a href=\"#配置-3\" class=\"headerlink\" title=\"配置\"></a>配置</h3><ol>\n<li>开启：cluster-enabled    yes|no</li>\n<li>配置文件名称：cluster-config-file    filename</li>\n<li>节点超时时间：cluster-node-timeout    milliseconds</li>\n<li>master链接slave最小数：cluster-migration-barrier    count</li>\n</ol>\n<h3 id=\"命令-9\"><a href=\"#命令-9\" class=\"headerlink\" title=\"命令\"></a>命令</h3><ol>\n<li>查看节点信息：cluster nodes</li>\n<li>从一个节点Redis，切换其主节点：cluster    replicate    masterip</li>\n<li>新增主节点：cluster meet    ip:port</li>\n<li>忽略一个节点：cluster    foeget    id</li>\n<li>手动故障转移：cluster    failover</li>\n</ol>\n"},{"title":"tags","date":"2018-09-12T15:24:17.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-09-12 23:24:17\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2020-03-19T04:51:26.000Z","path":"tags/index.html","comments":1,"_id":"ck8o1hab3001113s6iyzkx2i3","content":"","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":""},{"_content":"# Java基础知识清单\n\n## JVM\n### JVM架构\n![image-20200309203737822](Java.assets/image-20200309203737822.png)\n\n![image-20200309214325839](Java.assets/image-20200309214325839.png)\n\n![QQ20200314-123059@2x](Java.assets/QQ20200314-123059@2x-4161454.png)\n\n\n#### Class file\n\n- 有特定的文件标示（cafe babe），由类加载器加载进JVM方法区\n- 在加载类时：静态块（只会加载一次）>构造块>构造方法\n\n#### 类加载器（ClassLoader）\n\n实现通过类的全限定名（java/lang/String）获取该类的二进制字节流的代码块叫做类加载器。\n\n#####分类\n###### 启动类加载器（Bootstrap）\n\n用来加载java核心类库，无法被java程序直接引用。主要加载jre/lib文件夹下的jar文件\n\n###### 扩展类加载器（Extension）\n\n它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。主要加载jre/lib/ext文件夹下的jar文件\n\n###### 应用程序加载器（Application）\n\n也叫应用类加载器,它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。\n\n###### 自定义\n通过继承 java.lang.ClassLoader类的方式实现。\n\n##### 全盘委托\n加载类时，除非显示使用其他类加载器，否则该加载类下的其他依赖都有该类加载器加载\n\n##### 双亲委派\n加载时会一层层向上委托，如果可以加载就进行加载，没有就向下层加载器找，找到加载找不到class not found\n\n##### 沙箱安全\n\n自己加载自己的，相当一个一个容器 各不影响\n\n#### 本地接口（Native Interface）\n本地接口的作用是融合不同的编程语言为Java所用，在本地方法栈（Native Method Stack） 中登记Native方法\n\n#### 程序计数器（Program Counter Register）,PC 寄存器\n线程私有的。内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。\n记录了方法之间的调用和执行情况，它是当前线程所执行的字节码的行号指示器。相当于一个指针，指示字节码的行号，指引程序执行顺序，native 的为空\n\n#### 本地方法栈（Native Method Stack）\n本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务，存放本地方法\n\n#### Java 栈（Java Stack ），虚拟机栈\n栈分为java虚拟机栈和本地方法栈\n栈管运行，堆管存储。栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命周期是跟随线程的生命周期，线程结束内存也释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是栈函数的栈内存中分配。\n栈存储：局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息\n\n虚拟机栈中包含有多个栈帧，每一个栈帧就是一个方法。\n\nStackOverFlowError：是错误，栈中递归调用等会发生，是由于栈内存溢出造成\n\n栈帧（Java中叫方法，栈中叫栈帧）数据\n每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。\n-  局部变量\n输入参数和输出参数以及方法内的变量\n  局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定\n  \n- 操作数栈\n记录出栈、入栈的操作\n  操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式\n  \n- 动态链接\n- 方法返回地址\n  \n#### 方法区（Method Area）还被叫为Non-Heap（非堆）\n\n被所有线程共享区域，在不同虚拟机里头实现是不一样的，最典型的就是永久代（PermGen Space）和元空间（Metaspace）。实例变量存储在对内存中和方法区无关。在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载。该区域是被线程共享的。\n存储：在方法区中，存储了每个类的信息（包括类的名称、修饰符、方法信息、字段信息）、类中静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息以及编译器编译后的代码等。运行时常量池用于存放静态编译产生的字面量和符号引用，该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。1.7以后字符串常量池被移植到堆内存中\n\n#### 堆（Heap）\n\n堆被所有线程共享区域，在虚拟机启动时创建，唯一目的存放对象实例。堆区是gc的主要区域，通常情况下分为两个区块年轻代和年老代。更细一点年轻代又分为Eden区，主要放新创建对象，From survivor 和 To survivor 保存gc后幸存下的对象，默认情况下各自占比 8:1:1。\n\n一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常量放到堆内存中，保存所有引用类型的真实信息，以便执行器执行。\n\n\n- 逻辑：Eden:S0:S1=8:1:1，新生：养老=1:2\n  - 新生（New）／年轻代（Young）\n    - 伊甸园（Eden Space）\n    新New对象都在此区域，98%是临时对象会被GC掉\n    - 幸存者0（Survivor 0 Space）| from\n    - 幸存者1（Survivor 1 Space）| to\n  - 养老（Tenure）／老年代（Old）\n  - 永久（java 7）／元数据（java 8）。永久代和元空间的最大区别在于，永久代使用的是JVM的堆内存，但是java 8以后元空间并不存在虚拟机中而是使用本地物理内存，默认只用物理内存的1/4\n- 物理\n  - 新生\n  - 老年\n\n\n\n### GC\nHotSpot采用的是分代收集算法\n\n是内存回收的方法论，垃圾回收器就是算法落地实现\n因为目前还没有完美的垃圾收集器出现，更加没有万能的收集器，只是有针对具体应用最合适的收集器，进行分代收集\n\n#### 判断一个对象是否可以被回收\n\n垃圾（内存中已经不再被使用到的空间）\n\n##### 引用计数\n\nJava中，引用和对象是有关联的。如果要操作对象则必须要用引用进行。因此，很显然一个简单的办法就是通过引用计数来判断一个对象是否可以回收。简单说，给对象中添加一个引用计数器。每当有一个地方引用它，计数器值加1；每当有一个地方引用失效时，计数器值减1。任何时刻计数器值为零的对象就是不可能再被使用的，那么这个对象就是可回收对象，\n那为什么主流的Java虚拟机里面都没有采用这种算法呢？其中最主要的原因是它很难解决对象直接相互循环引用的问题。\n\n##### 根节点作可达性分析（根搜索路径）\n\n为了解决引用计数循环引用问题，Java使用了可达性分析方法\n所谓GC Roots或者说tracking GC的根集合，就是一组必须活跃的引用\n基本思路就是通过一系列名为GC Roots的对象作为起始点，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何一个引用链相连时，则说明此对象不可用。即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达）对象就被判定为存活；没有遍历到的就自然被判定为死亡。\n\n\n#### Java中可以作为GC Roots的对象\n\n- 虚拟机栈（栈帧中的局部变量区，也叫局部变量表）中引用的对象\n- 方法区中的类静态属性、常量引用的对象\n- 本地方法栈中JNI（Native方法）引用的对象\n\n####  回收策略以及Minor GC和Major GC：\n对象优先在堆的Eden区分配，当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC，Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC，但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度。\n\n\n#### 新生代GC（Minor GC|GC）\n- 复制\neden、from 复制到 to，年龄+1\n首先，当Eden区满的时候会触发第一次GC，把还活着的对象拷贝到from区，当eden区再次触发GC的时候会扫描eden区和from区，对这两个区域进行垃圾回收，经过这次回收后还存活的对象，直接复制到to区域（如果有对象的年龄到了老年的标准，则复制到老年区），同时把这些对象的年龄+1\n- 清空\n清空eden、from\n然后清空eden和from中的对象\n\t\n- 互换\nto和from互换\n最后，也即复制之后有换，谁空谁是to。to和from互换，原来to成为下一次GC时的from区，部分对象会在from和to区中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认是15），最终如果还存活，就进入老年代。\n\n#### 老年代GC（Major GC|Full GC）\nGC日志分析\n- [GC (Allocation Failure) [PSYoungGen: 512K->425K(1024K)] 512K->425K(1536K), 0.0018589 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]\n- [Full GC (Ergonomics) [PSYoungGen: 469K->460K(1024K)] [ParOldGen: 448K->447K(512K)] 917K->908K(1536K), [Metaspace: 2697K->2697K(1056768K)], 0.0041891 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] \n  - DefNew(Default New Generation)\n  - Tenured(Old)\n  - ParNew(Parallel New Generation)\n  - PSYoungGen(Parallel Scavenge)\n  - ParOldGen(Parallel Old Generation)\n#### GC4大算法\n\n##### 引用计数\n应用于：微软的COM/ActionScrip3/Python等\n如果对象没有被引用，就会被回收\n缺点：需要维护一个引用计算器\n\n##### 复制（Copy）\n年轻代中使用的是Minor GC，这种GC算法采用的是复制算法(Copying)\n- 不会发生内存碎片，速度快\n- 消耗空间（需要进行复制）\n\n##### 标记清除（Mark Sweep）\n老年代一般是由标记清除或者是标记清除与标记整理的混合实现\n- 会产生内存碎片，两次扫描耗时严重\n- 节约内存空间\n\n##### 标记整理／压缩（Mark-Compat）\n老年代一般是由标记清除或者是标记清除与标记整理的混合实现\n- 没有碎片\n- 耗时严重\n\t\t\n#### 算法比较\n\n- 内存效率（时间纬度）\n  复制>标记清除>标记整理\n\n- 内存整齐度\n  复制=标记整理>标记清除\n\n- 内存利用率\n  标记整理=标记清除>复制\n### GC垃圾收集器\n#### 查看默认的垃圾收集器是哪个\njava -XX:+PrintCommandLineFlags -version\n\n#### 默认的垃圾收集器有哪些\n##### UseSerialGC\n它为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程，不适合服务器。\n一句话：一个单线程的收集器，在进行垃圾收集的时候，必须暂停其他所有的工作线程直到它收集结束。\n串行收集器是最古老，最稳定以及效率最高的收集器，只使用一个线程区回收但其在进行垃圾回收过程中可能会产生较长的停顿（Stop-The-World 状态）。虽然在收集垃圾过程中需要暂停其他的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是java虚拟机运行在Client模式下新生代的垃圾收集器。\n对应JVM参数：\n-XX:+UseSerialGC\n开启后会使用：Serial（Young区用）+Serial Old（Old区用）的收集器组合\n表示：新生代、老年代都会使用串行收集器，新生代使用复制算法，老年代使用标记-整理算法\n-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseSerialGC\n\n\n##### UseSerialOldGC\nSerial Old 是Serial 垃圾收集器老年代版本，它同样是单个线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的java虚拟机默认的老年代垃圾收集器。\n在Server模式下，主要有两个用途（了解，版本已经到8及以后）：\n\n- 在JDK1.5 之前版本中与新生代的Parallel Scavenge 收集器搭配使用。（Parallel Scavenge +Serial Old）\n- 作为老年代版本中使用CMS收集器的后备垃圾收集方案。\n\n##### UseParNewGC\n多个垃圾收集线程并行工作，此时用户线程是暂停的，适用于科学计算／大数据处理等弱交互场景\n一句话：使用多线程进行垃圾回收，在垃圾收集时，会Stop-The-World暂停其他所有的工作线程直到它收集结束。\nParNew收集器其实就是Serial收集器新生代的并行多线程版本，最常见的应用场景是配合老年代的CMS GC工作，其余的行为和Serial收集器完全一样，它是很多java虚拟机运行在Server模式下新生代的默认垃圾收集器\n常用JVM参数：-XX:+UseParNewGC 启用ParNew收集器，只影响新生代的收集，不影响老年代\n开启上述参数后，会使用：ParNew（Young区用）+Serial Old的收集器组合，新生代使用复制算法，老年代采用标记-整理算法。\n但是，ParNew+Tenured这样的搭配，java8已经不再被推荐\n备注：\n-XX:ParallelGCThreads 限制线程数量，默认开启和CPU数目相同的线程数\n -Xmx10m -Xmx10m -XX:+PrintGCDetails -XX:+UseParNewGC\n\n##### UseParallelGC\nParallel Scavenge收集器类似ParNew也是一个新生代垃圾收集器，使用复制算法，也是一个并行的多线程的垃圾收集器，俗称吞吐量优先收集器。\n一句话：串行收集器在新生代和老年代的并行化\n它重点关注的是：\n可控制的吞吐量（Thoughput=运行用户代码时间／（运行用户代码时间+垃圾收集时间），比如程序运行100分钟，垃圾收集1分钟，吞吐量就是99%）。高吞吐量意味着高效利用CPU时间，它多用于在后台运算而不需要太多交互的任务。\n自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。（自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间（-XX:MaxGCPauseMillis）或最大吞吐量。\n常用JVM参数：-XX:+UseParallelGC 或 -XX:+UseParallelOldGC(可互相激活）使用Parallel Scavenge收集器\n多说一句：-XX:ParallelGCThreads=数字N 表示启动多少个线程\nCPU>8 N=5/8\nCPU<8 N=实际个数\n-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseParallelGC\n-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseParllelOldGC\n\n##### UseParallelOldGC\nParallel Old收集器是Parallel Scavenge的老年代版本，使用多线程的标记-整理算法，Parallel Old收集器在JDK1.6才开始提供。\n在JDK1.6之前，新生代使用Parallel Scavenge收集器只能搭配老年代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。在JDK1.6之前（Parallel Scavenge+Serial Old）\nParallel Old正是为了在老年代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，JDK1.8之后可以优先考虑新生代Parallel Scavenge 和老年代Parallel Old收集器的搭配策略。在JDK1.8及之后（Parallel Scavenge+Parallel Old）\n常用JVM参数：-XX:+UseParallelOldGC 使用Parallel Old收集器，设置参数后，新生代Parallel+老年代Parallel Old\n##### UseConcMarkSweepGC\n用户线程和垃圾回收线程同时执行（并不一定是并行，可能交替执行），不需要暂停用户线程，互联网公司多用它，适用对相应时间有要求的场景\nCMS收集器（Concurrent Mark Sweep：并发标记清除）是一种以获取最短回收停顿时间为目标的收集器。适应应用在互联网站或者B／S系统的服务器上，这类应用尤其重视服务器响应速度，希望系统停顿时间最短。CMS非常适合堆内存大、CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。Concurrent Mark Sweep 并发标记清除，并发收集低停顿，并发指的是与用户线程一起执行\n开启该收集器的JVM参数： -XX:+UseConcMarkSweepGC 开启该参数后会自动将-XX:+UseParNewGC 打开开启该参数后，使用ParNew（Young区用）+CMS（Old区用）+Serial Old的收集器组合，Serial Old将作为CMS出错的后备收集器\n**执行步骤**\n\n- 初始标记（CMS initial mark）需要暂停所有的工作线程\n只是标记一下，GC Roots 能直接关联的对象，速度快，仍然需要暂停所有的工作线程\n- 并发标记（CMS concurrent mark）和用户线程一起\n进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。主要标记过程，标记全部对象。\n- 重新标记（CMS remark）需要暂停所有的工作线程\n为了修改在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。\n由于并发标记时，用户线程依然运行，因此在正式清理前，再作修正。\n- 并发清除（CMS concurrent sweep）和用户线程一起\n清除GC Roots 不可达对象，和用户一起工作，不需要暂停工作线程。基于标记结果，直接清除对象。\n由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发的执行。\n\n**优缺点**\n优：并发收集低停顿\n缺：\n\n- 并发执行，对CPU资源压力大\n由于并发进行，CMS垃圾收集和应用线程会同时增加对堆内存对占用，也就是说，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW的方式进行一次GC，从而造成较大停顿时间。\n- 采用对标记清除算法会导致大量碎片\n标记清除无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。CMS也提供了参数-XX:CMSFullGCsBeForeCompaction(默认0，即每次都进行内存整理）来指定多少次CMS收集之后，进行一次压缩的Full GC\n\n-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC\n\n##### UseG1GC\nG1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片\nG1的Stop The World（STW）更可控，G1在停顿时间上添加量预测机制，用户可以指定期望停顿时间\nCMS垃圾收集器虽然暂停了应用程序的运行时间，但还是存在着内存碎片的问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，java7 发布了一个新的垃圾收集器-G1垃圾收集器\nG1是在2012年才在jdk1.7u4中可用。oracle官方计划在jdk9中将G1变成默认的垃圾收集器以替代CMS。它是一款面向服务器端应用的收集器，主要应用在多CPU和大内存服务器环境下，极大的减少垃圾收集的停顿时间，全面提升服务器的性能，逐步替换java8以前的CMS收集器。\n主要改变是Eden，Surivor和Tenured等内存区域不再是连续的了，而是变成了一个个大小一样的region，每个region从1m到32m不等。一个region有可能属于Eden，Survivor或者Tenured内存区域\n\n###### 底层原理\nRegion区域化垃圾收集器\n化整为零，避免全内存扫描，只需要按照区域来进行扫描即可\n区域化内存划片Region，整体编辑为了一些不连续的内存区域，避免了全内存区的GC操作。\n核心思想是将整个堆内存区域分成大小相同的子区域（Region），在JVM启动的时候会自动设置这些子区域的大小，在堆的使用上，G1并不要求对象的存储一定是物理上连续的只要逻辑连续即可，每个分区也不会固定的为某个代服务，可以按需在新生代和老年代之间切换。启动时可以通过参数-XX:G1HeapRegionSize=n指定分区大小（1m-32m，且必须是2的幂），默认将整堆划分成2048个分区。\n大小范围在1m-32m，最多能设置2048个区域，能支持的最大内存为：32m*2048=65536m=64G\n\n###### 回收步骤\nG1收集器下的Young GC\n针对Eden区进行收集，Eden区耗尽后会被触发，主要是小区域收集+形成连续的内存块，避免内存碎片\nEden区的数据移动到Survivor区，假如出现Survivor区空间不够，Eden区数据会部分晋升到Old区\nSurivor区的数据移动到新的Survivor区，部分数据晋升到Old区\n最后Eden区收拾干净，GC结束，用户的应用程序继续执行\n\n###### 常用配置参数（了解）\n开发人员仅仅需要声明以下参数即可：\n三步归纳：开始G1+设置最大内存+设置最大停顿时间\n-XX:+UseG1GC  -Xmx32g  -XX:MaxGCPauseMillis=100\n-XX:MaxGCPauseMillis=n: 最大GC停顿时间单位毫米，这是个软目标，JVM将尽可能（但不保证）停顿小于这个时间。\n\n- -XX:+UseG1GC\n- -XX:G1HeapRegionSize=n\n设置G1区域的大小。值是2的幂，范围是1m-32m。目标是根据最小的java堆大小划分出约2048个区域\n- -XX:MaxGCPauseMillis=n\n最大GC时间，这是个软目标，JVM尽可能（但不保证）停顿小于这个时间\n- -XX:InitiatingHeapOccupancyPercent=n\n堆占用了多少堆时候就触发GC，默认为45%\n- -XX:ConcGCThreads=n\n并发GC使用的线程数\n- -XX:G1ReserverPercent=n\n设置作为空闲空间的预留内存占比，以降低目标空间溢出的风险，默认是10%\n\n###### 特点\n- G1能充分利用多CPU、多核环境硬件优势，尽量缩短STW。\n- G1整体上采用标记-整理算法，局部使用复制算法，不会产生内存碎片\n- 宏观上看G1不再区分新生代和老年代，把内存划分成多个独立的子区域（region），可以近似理解为一个围棋棋盘\n- G1收集器将整个内存区都混合为一起，但其本身依旧在小范围内进行新生代和老年代的区分，保留了新生代和老年代，但它们不是物理隔离，而是一部分region的集合，并且不需要region是连续，也就是说依然采用不同的GC方式来处理不同的区域。\n- G1虽然也是分代收集器，但整个内存分区不存在物理上的新生代和老年代的区别，也不需要完全独立的Survivor（to space）堆作复制准备。G1只有逻辑上的分代概念，或者说每个分区都有可能随着G1的运行在不同代之间前后切换\n\n###### G1和CMS相比的优势\n- G1不会产生内存碎片\n- 是可以精确控制停顿。该收集器是把整个堆（新生代、老年代）划分成多个固定大小的区域，每次根据允许停顿的时间区收集垃圾最多的区域\n\n### Server／Client模式分别是什么意思\n适用范围：只需要掌握Server模式即可，Client模式基本不会用操作系统\n- 32位Win操作系统，不论硬件如何都默认使用Client的JVM模式\n- 32位其他操作系统，2G内存同时有2个CPU以上用Server模式，低于该配置还是使用Client模64位only server模式\n\n### 如何选择垃圾收集器\n- 单CPU或者小内存，单机程序\n-XX:+UseSerialGC\n\n- 多CPU，需要最大吞吐量，如后台计算大型应用\n-XX:+UseParallelGC 或者\n-XX:+UseParallelOldGC\n\n- 多CPU，追求低停顿时间，需快速响应如互联网应用\n-XX:+UseConcMarkSweepGC\n-XX:+ParNewGC\n\n### 以前收集器特点\n- 新生代和老年代是各自独立且连续但内存块\n- 新生代收集使用单eden+s0+s1进行复制算法\n- 老年代收集必须扫描整个老年代区域\n- 都是以尽可能少而快速的执行GC为设计原则\n\n\n###  Java类加载过程\n#### 加载\n加载是类加载的第一个过程，在这个阶段，将完成一下三件事情：\n\n- 通过一个类的全限定名获取该类的二进制流。\n- 将该二进制流中的静态存储结构转化为方法去运行时数据结构。 \n- 在内存中生成该类的Class对象，作为该类的数据访问入口。\n#### 链接\n#####   验证\n 验证的目的是为了确保Class文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证: \n-  文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型. \n-  元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否继承了不被继承的类等。\n-  字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。\n-   符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。\n#####  准备\n准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。\n##### 解析\n该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。\n#### 初始化\n初始化是类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。\n\n\n\n#### 类加载\n类加载包含Main程序入口的类加载\n\n- 静态成员变量加载时执行到准备阶段将变量赋初始值（int 类型默认初始化为0，引用对象初始化为null）\n- 静态成员变量加载时执行到初始化阶段将变量赋值（private static int a=29，默认初始化为a=0，赋值初始化a=29；引用类型 初始化为对象实例)\n- 运行main方法\n\n>静态变量 （static int a）和静态引用变量（static  Object o）声明赋值是依据自上而下的顺序。\n\n###  JVM的参数类型\n####  标配参数\n- -version\n- -help\n-  java -showversion\n\n#### X参数(了解）\n- -Xint（解释执行）\n- -Xcomp（第一次使用就编译成本地代码）\n- -Xmixed（混合模式）\n\n#### XX参数\n##### Boolean类型\n- 公式\n  - -XX：+或者- 某个属性值\n  - +（开启）-（关闭）\n- Case\n  - 是否打印GC收集细节\n    -XX:-PrintGCDetails\n    -XX:+PrintGCDetails\n  - 是否使用串行垃圾回收器\n    -XX:-UseSerialGC\n    -XX:+UseSerialGC\n\n##### K-V设值类型\n-XX：属性key=属性value\n-XX:MetaspaceSize=128m\n-XX:MaxTenuringThreshold=15\n\n###  Jinfo\n任何查看当前运行程序的配置\njinfo -flag 配置项 进程编号\njinfo -flag IntialHeapSize 进程号\njinfo -flags 进程号\n\n### 查看JVM的默认值\n#### -XX:+PrintFlagsFinal\n主要查看修改更新\njava -XX:+PrintFlagsFinal -version\n:= 为人为修改过或初始加载修改过，= 为默认未改\nPrintFlagsFinal举例\n运行java命令的同时打印出参数\njava -XX:+PrintFlagsFinal -XX:MetaspaceSize=512m 类名\n\n#### -XX:+PrintCommandLineFlags\n主要看垃圾回收器，最后一个值\n\n#### -XX:+HeapDumpOnOutOfMemoryError \n设置内存溢出时dump内存快照\n\n### JVM常用参数\n#### -Xms（-XX:InitialHeapSize）\n初始大小内存，默认为物理内存1/64\n\n#### -Xmx（-XX:MaxHeapSize）\n最大分配内存，默认为物理内存1/4\n\n#### -Xss（-XX:ThreadStackSize）\n设置单个线程栈的大小，一般默认为512k～1024k\n\n#### -Xmn\n设置年轻代大小\n\n#### -XX:MetaspaceSize\n初始元空间大小\n\n元空间本质和永久代类似，都是对JVM规范方法中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。\n-Xms10m -Xmx10m  -XX:MetaspaceSize=1024m -XX：+PrintFlagsFinal\n\n#### -XX:MaxMetaspaceSize\n最大元空间大小，默认为-1，只受本地空间限制\n\n#### -XX:MaxDirectMemorySize\n最大直接内存大小，默认和 -Xmx 一致\n#### -XX:+PrintGCDetails\n1\t输出详细GC收集日志信息\n2\tGC：\n3\tFullGC：\n\n#### -XX:SurvivorRatio\n设置新生代中eden和s0/s1空间的比例\n默认-XX:ServivorRatio=8，Eden:S0:S1=8:1:1\n假如-XX:SurvivorRatio=4,\tEden::S0:S1=4:1:1\nSurvivorRatio值就是设置eden区的占比多少，s0/s1相同\n\n#### -XX:NewRatio\n配置年轻代与老年代在堆结构的占比，\n默认-XX:NewRatio=2 新生代占1，老年代占2，新生代占整个堆的1/3\n假如-XX:NewRatio=4 新生代占1，老年代占4，新生代占整个堆的1/5\nNewRatio值就是设置老年代的占比，剩下的1给新生代\n\n#### -XX:MaxTenuringThreshold\n设置进入老年代年龄\n典型设置案例\n-Xms128m -Xmx4096m -Xss1024k -XX:MetaspaceSize=512m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UseSerialGC\n\n### OOM\n#### java.lang.StackOverflowError\n\n虚拟机栈内存不足导致\n\n```java\npublic class StackOverflowErrorDemo {\n    public static void main(String[] args) {\n        stackError();\n    }\n\n    private static void stackError() {\n        stackError();\n    }\n}\n```\n\n#### java.lang.OutOfMemoryError:Java heap space\n\n- java虚拟机的对内存设置不够，可以通过-Xms和-Xmx来设置。生产中这两个参数会设置为一样，避免内存忽高忽低。\n- 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）\n\n```java\n/**\n * -Xms1m -Xmx1m\n */\npublic class OOM_heap_space {\n    public static void main(String[] args) {\n        byte[] bytes = new byte[20 * 1024 * 1024];\n    }\n}\n```\n#### java.lang.OutOfMemoryError:GC overhead limit exceeded\n\n```java\n/**\n * -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=10m\n */\npublic class GCOverheadDemo {\n    public static void main(String[] args) {\n        int i = 0;\n        ArrayList<String> list = new ArrayList<>();\n        try {\n            while (true) {\n                list.add(String.valueOf(++i).intern());\n            }\n        } catch (Exception e) {\n            System.out.println(\"+++++++i:\" + i);\n            e.printStackTrace();\n            throw e;\n        }\n    }\n}\n```\n#### java.lang.OutOfMemoryError:Direct buffer memory\n\n```java\n/**\n * -XX:MaxDirectMemorySize=3m -XX:+PrintGCDetails\n */\npublic class DirectBufferMemoryErrorDemo {\n    public static void main(String[] args) {\n        System.out.println(\"配置的MaxDirectMemorySize：\" + (sun.misc.VM.maxDirectMemory() / (double) 1024 / 1024 + \"MB\"));\n        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(6 * 1024 * 1024);\n    }\n}\n```\n#### java.lang.OutOfMemoryError:unbale to create new native thread\n\nroot 用户无限制 其他用户 linux 默认1024\n\n虚拟机栈内存不够用无法再创建新的线程。该异常是由于虚拟机栈内存被用尽导致无法再创建新线程，-Xss参数将直接导致所能创建线程的多少。\n\n```java\npublic class UnableCreateNewThreadDemo {\n    public static void main(String[] args) {\n        for (int i = 0; ; i++) {\n            final int tmp = i;\n            new Thread(() -> {\n                System.out.println(tmp);\n                try {\n                    TimeUnit.SECONDS.sleep(MAX_VALUE);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }, String.valueOf(i)).start();\n        }\n    }\n}\n```\n####\t java.lang.OutOfMemoryError:Metaspace\n\n```java\n/**\n * -XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m\n */\npublic class MetaspaceOOMDemo {\n    static class Temp {\n    }\n\n    public static void main(String[] args) {\n        int i = 0;\n        while (true) {\n            i++;\n            try {\n                Enhancer enhancer = new Enhancer();\n                enhancer.setSuperclass(Temp.class);\n                enhancer.setUseCache(false);\n                enhancer.setCallback(new MethodInterceptor() {\n                    @Override\n                    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n                        return methodProxy.invokeSuper(o, args);\n                    }\n                });\n                enhancer.create();\n            } catch (Throwable e) {\n                System.out.println(\"============\" + i);\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n### 生产环境服务器变慢，判断思路和性能评估\n- 整机：top\nuptime 是top精简版\n- CPU：vmstat\n- 查看所有CPU核信息：mpastat -P ALL 2\n- 每个进程使用CPU的用量分解信息：pidstat -u 1 -p 进程编号\n- 内存：free\n- pidstat -p 进程号 -r 采样间隔秒\n- 硬盘：df\n- 磁盘IO：iostat\n- 网络IO：ifstat\n\n### CPU占用过高，分析思路和定位\n- 先用top命令找出CPU占比最高的\n- ps -ef 或者jps 进一步定位，得知是一个怎样的后台程序\n- 定位到具体线程或者代码\n- ps -mp 进程 -o THRAD,tid,time\n- -m：显示所有的线程\n- -p pid 进程使用CPU的时间\n- -o 该参数后是用户自定义格式\n\n- 将需要的线程ID转换为16进制格式（英文小写）\n- printf \"%x\\n\" 有问题的线程ID\n- jstack 进程ID | grep tid（16进制线程ID）-A60\n\n## JUC\nJUC(java.util.concurrent)多线程及高并发\n\n### Volatile\n\n多线程访问成员变量时，会发生多个一个线程将变量数值该变，但是另一个线程可能无法感知变量的值的改变。使用volatile可以避免这种情况\n\nVolatile是Java虚拟机提供的轻量级的同步机制，低配版Synchronized\n\n#### 特性\n##### 保证可见性\n##### 禁止指令重排\n\n#### Volatile使用场景（DCL）\n- 单例模式DCL(Dobule Check Lock)代码\nDCL(双端检锁）机制不一定线程安全，是因为有指令重排序的存在，假如volatile可以禁止指令重排\n原因在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化。\n```java\ninstance=newSingletonDemo（）；可以分为以下3步：\nmemory =allocate();//1.分配内存空间\ninstance(memory); //2.初始化对象\ninstance =memory; //3.设置instance刚分配的内存地址，此时instance != null;\n步骤2和步骤3 不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化时允许的。\nmemory =allocate(); //1.分配内存对象\ninstance=memory; //3.设置instance刚分配的内存地址，此时instance != null， 但是对象还没有初始化完成！\ninstance(memory); //2.初始化对象\n```\n但是指令重排只会保证串行语义的执行的一致性（单线程），并不会关心多线程间语义的一致性。\n所以当一条线程访问instance不为null时，由于instance未必已经初始化完成，也就造成了线程安全问题。\n\n- 方案一(单线程）\n```java\npublic class SingletonDemo {\n    public static volatile SingletonDemo instance = null;\n\n    public class SingletonDemo {\n        public static SingletonDemo instance = null;\n\n        private SingletonDemo() {\n            System.out.println(\"aaa\");\n        }\n\n        //方案一\n        public static SingletonDemo getInstance() {\n            if (instance == null) {\n                instance = new SingletonDemo();\n            }\n            return instance;\n        }\n    }\n}\n```\n- 方案二（synchronized）\n```java\npublic class SingletonDemo {\n    public static SingletonDemo instance = null;\n\n    private SingletonDemo() {\n        System.out.println(\"aaa\");\n    }\n\n    //方案二\n    public static synchronized SingletonDemo getInstance() {\n        if (instance == null) {\n            instance = new SingletonDemo();\n        }\n        return instance;\n    }\n}\n```\n- 方案三(DCL+Volatile+Synchronized)\n```java\npublic class SingletonDemo {\n    public static volatile SingletonDemo instance = null;\n\n    private SingletonDemo() {\n        System.out.println(\"aaa\");\n    }\n\n    //方案三\n    public static SingletonDemo getInstance() {\n        if (instance == null) {\n            synchronized (SingletonDemo.class) {\n                if (instance == null) {\n                    instance = new SingletonDemo();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n### JMM\n![Java线程内存模型JMM2](Java.assets/Java线程内存模型JMM2.png)\n\nJMM(Java内存模型  Java Memory Model，简称 JMM） 本身是一种抽象的概念并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。\n由于JVM运行程序的实体是线程，而每个内存创建时JVM都会为其创建一个工作内存（有些地方称为栈内存），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再讲变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程捡的通信（传值）必须通过主内存来完成。\n**JMM关于同步的规定**\n\n- 线程解锁前，必须把共享变量的值刷新回主内存\n- 线程加锁前，必须读取主内存的最新值到自己的工作内存\n- 加锁解锁是同一把锁\n\n\n#### 可见性\n各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作然后再写回到主内存。\n这就可能存在一个线程A修改了共享变量X的值但还未写回主内存时，另外一个线程B又对内存中同一个变量X进行操作，此时A线程工作内存中共享变量X对线程B来说并不可见，这种工作内存与主内存同步延迟现象造成了可见性问题\n\n#### 原子性\nnumber++在多线程下是非线程安全的，如何不加Synchronized解决\nVolatileDemo代码演示可见性+原子性代码\n\n#### 有序性\n计算机在执行程序时，为了提高性能，编译器和处理器得常常对指令做重排，一般分为3种：\n单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致\n处理器在进行重排序时必须要考虑指令间的数据依赖性\n多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测\n\n- 重排1\n```java\npublic void mySort(){\nint x=1;  //语句1\nint y=2;  //语句2\nx=x+5;   //语句3\ny=x*x;   //语句4\n}\n1234\n2134\n...\n语句4由于存在数据依赖性不会先执行\n```\n- 重排2\n```java\npublic class ReSortSeqDemo {\nint a = 0;\nboolean flag = false;\npublic void method01() {\na = 1;\nflag = true;\n}\npublic void method02() {\nif (flag) {\na = a + 5;\nSystem.out.println(\"**********retValue:\" + a);\n}\n}\n}\n```\n-  禁止指令重排\nvolatile实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象\n先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：\n一是保证特定操作的执行顺序\n二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）\n由于编译器和处理器都能进行指令重排优化。如果在指令插入一条Memory Barrier则会告诉编译器和CPU，不管什么时候都不能和这条Memory Barrier指令重新排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。内存屏障的另一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。\n\n\n\n### CAS（comparAndSwap) \n比较并交换\n比较当前工作内存中的值和主内存中的值，如果相同则进行规定操作，否则继续比较直到主内存中的值和工作内存中的值一致为止\nCAS有三个操作数，内存值V，旧的预期值A，要修改的更新值B。\n当且仅当预期值A和内存值B相同时，将内存值V修改为B，否则什么也不做。\n\n#### 概念\nCAS的全称为compare-and-swap，它是一条cpu并发原语。\n它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。\nCAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统原语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条cpu的原子指令，不会造成所谓的数据不一致问题。\n\n\n##### 底层汇编\nUnsafe类中的compareAndSwapInt，是一个本地方法，该方法的实现位于unsafe.cpp中是CAS的核心类，由于Java无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为CAS操作的执行依赖于Unsafe类的方法。\n注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务。 unsafe 位于rt.jar包中\nunsafe.getAndAddInt\n\n```java\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n\t\t\t\t int var5;\n\t\t\t\tdo {\n\t\t\t\t   var5 = this.getIntVolatile(var1, var2);\n\t\t\t  } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n\t\t\t return var5;\n\t}\n```\nvar1 atomicInteger 对象本身。\nvar2 该对象值的引用地址\nvar4  需要变动的数值\nvar5 是用过var1 var2找出的内存中真实的值\n用该对象当前的值与var5比较\n如果相同，更新var5+var4并且返回true\n如果不同，继续取值然后再比较，直到更新完成\n假设线程A和线程B两个线程同时执行getAndAddInt操作（分别跑在不同cpu上）：\n\n- atomicInteger里面的value原始值为3，即内存中atomicInteger的value为3，根据JMM模型，线程A和线程B各自持有一份值为3的value副本分别到各自的工作内存。\n- 线程A通过getIntVolatile（var1，var2）拿到value值3，这时线程A被挂起。\n- 线程B也通过getIntVolatile（var1，var2）方法获取value值3，此时线程B刚好没有被挂起并执行compareAndSwapInt方法比较内存值也为3，成功修改内存值为4，线程B打完收工，一切ok\n- 这时线程A恢复，执行compareAndSwapInt方法比较，发现自己手里的值3和内存中的值4不一致，说明该值已经被其他线程抢先一步修改过了，那A线程本次修改失败，只能重新读取重新来一遍。\n- 线程A重新获取value值，因为变量value被volatile修饰，所以其他线程对它的修改，线程A总是能够看到，线程A继续执行compareAndSwapInt方法进行比较替换，直到成功\n  \n#### CAS的缺点\n##### 循环时间长开销很大\n```java\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n    int var5;\n    do {\n        var5 = this.getIntVolatile(var1, var2);\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n    return var5;\n}\n```\n我们可以看到getAndAddInt时，有个do while操作，如果CAS失败时，会一直进行尝试。如果CAS长时间一直不成功，可能会给cpu带来很大的开销。\n##### 只能保证一个共享变量的原子操作\n当对一个共享变量进行操作时，我们可以使用循环CAS来保证原子操作，但是，对于多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。\n##### 引出来ABA问题\n\n### ABA\n比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。\n原子类AtomicInteger的ABA问题(狸猫换太子) 原子类更新引用\n\n#### ABA问题产生\nCAS会导致ABA问题\nCAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻进行比较并替换，那么在这个时间差会导致数据的变化。\n比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且线程two进行来一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中国年依然是A，然后线程one操作成功。\n尽管线程one的CAS的操作成功，但是并不代表这个过程就是没有问题的。\n\n#### 原子引用(AtomicReference)\n\n```java\nclass User {\n    String userName;\n    int age;\n\n    public User(String userName, int age) {\n        this.userName = userName;\n        this.age = age;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"User(userName：\" + userName + \"，Age：\" + age + \")\";\n    }\n}\n\npublic class AtomicReferenceDemo {\n    public static void main(String[] args) {\n        User zhangsan = new User(\"zhangsan\", 23);\n        User lisi = new User(\"lisi\", 25);\n        AtomicReference<User> reference = new AtomicReference<>();\n        reference.set(zhangsan);\n        System.out.println(reference.compareAndSet(zhangsan, lisi) + \"\\t\" + reference.get().toString());\n        System.out.println(reference.compareAndSet(zhangsan, lisi) + \"\\t\" + reference.get().toString());\n    }\n}\n```\n#### 时间戳原子引用(AtomicStampedReference)\n\nABA问题的解决方案\n\n```java\n\tpublic class AtomicStmapedReferenceDemo {\n    static AtomicReference atomicReference = new AtomicReference<Integer>(100);\n    static AtomicStampedReference atomicStampedReference = new AtomicStampedReference<>(100, 1);\n\n    public static void main(String[] args) throws InterruptedException {\n        System.out.println(\"================以下是ABA问题的产生================\");\n        new Thread(() -> {\n            atomicReference.compareAndSet(100, 101);\n            atomicReference.compareAndSet(101, 100);\n        }, \"t1\").start();\n        new Thread(() -> {\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(atomicReference.compareAndSet(100, 2019) + \"\\t\" + atomicReference.get());\n        }, \"t2\").start();\n        TimeUnit.SECONDS.sleep(3);\n        System.out.println(\"=================以下是ABA问题的解决方案=====================\");\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName() + \"\\t第一次版本号：\" + atomicStampedReference.getStamp());\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            atomicStampedReference.compareAndSet(100, 101, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);\n            System.out.println(Thread.currentThread().getName() + \"\\t第二次版本号：\" + atomicStampedReference.getStamp());\n            atomicStampedReference.compareAndSet(101, 100, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);\n            System.out.println(Thread.currentThread().getName() + \"\\t第三次版本号：\" + atomicStampedReference.getStamp());\n        }, \"t3\").start();\n        new Thread(() -> {\n            int stamp = atomicStampedReference.getStamp();\n            System.out.println(Thread.currentThread().getName() + \"\\t第一次版本号：\" + stamp);\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            boolean flag = atomicStampedReference.compareAndSet(100, 2019, stamp, stamp + 1);\n            System.out.println(Thread.currentThread().getName() + \"\\t是否修改成功：\" + flag);\n            System.out.println(Thread.currentThread().getName() + \"\\t当前实际值：\" + atomicStampedReference.getReference() + \"\\t当前实际版本号：\" + atomicStampedReference.getStamp());\n        }, \"t4\").start();\n    }\n}\n```\n\n### AQS（AbstractQueuedSynchronizer）\nAQS 是 AbstractQueuedSynchronizer 的简称，它是一个 Java 提高的底层同步 工具类，用一个 int 类型的变量表示同步状态，并提供了一系列的 CAS 操作来管 理这个同步状态。\nAQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广 泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。\n\n#### **AQS 支持两种同步方式** \n- 独占式\n- 共享式\n这样方便使用者实现不同类型的同步组件，独占式如 ReentrantLock，共享式如 Semaphore，CountDownLatch，组合式的如 ReentrantReadWriteLock。总之， AQS 为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。\n\n### 线程\n\n#### 线程六种状态\n- NEW：新建状态 刚刚创建出来，还没有调用start方法之前的状态。\n- RUNNABLE:可运行状态，可能正在执行，也可能不是正在执行，只有在该种状态下的线程才有资格抢CPU。\n- BLOCKED:锁阻塞状态  线程要等待另一个线程释放锁对象。\n- WAITING：无限等待  线程调用了wait()方法进入的状态，需要其它线程调用notify方法唤醒。\n- TIMED_WAITING:计时等待状态  线程调用了sleep方法获wait（long time）方法进入的状态。\n- TERMINATED:死亡状态  线程任务执行完毕或调用了stop方法。\n\n#### ConcurrentModificationException\n线程不安全\n- ArrayList\n- HashMap\n- HashSet\n\n\n```java\npublic class ContainerNotSafeDemo {\n    public static void main(String[] args) {\n\n    }\n\n    private static void MapNotSafe() {\n        Map map = new HashMap();\n        for (int i = 0; i < 30; i++) {\n            new Thread(() -> {\n                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 8));\n                System.out.println(map);\n            }).start();\n        }\n    }\n\n    private static void SetNotSafe() {\n        Set set = new HashSet();\n        for (int i = 0; i < 30; i++) {\n            new Thread(() -> {\n                set.add(UUID.randomUUID().toString().substring(0, 8));\n                System.out.println(set);\n            }).start();\n        }\n    }\n\n    private static void ListNotSafe() {\n        List<String> list = new ArrayList<>();\n        for (int i = 0; i < 30; i++) {\n            new Thread(() -> {\n                list.add(UUID.randomUUID().toString().substring(0, 8));\n                System.out.println(list);\n            }).start();\n        }\n    }\n}\n```\n- 解决方案1\n```java\npublic class ContainerNotSafeDemo {\n    public static void main(String[] args) {\n    }\n\n    private static void MapNotSafe() {\n        Map map = new HashMap();/// Collections.synchronizedMap(new HashMap<>());new ConcurrentHashMap<>();\n        for (int i = 0; i < 30; i++) {\n            new Thread(() -> {\n                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 8));\n                System.out.println(map);\n            }).start();\n        }\n    }\n\n    private static void SetNotSafe() {\n        Set set = new HashSet();// Collections.synchronizedSet(new HashSet<>());new CopyOnWriteArraySet<>();\n        for (int i = 0; i < 30; i++) {\n            new Thread(() -> {\n                set.add(UUID.randomUUID().toString().substring(0, 8));\n                System.out.println(set);\n            }).start();\n        }\n    }\n\n    private static void ListNotSafe() {\n        List<String> list = new ArrayList<>();//new Vector<>(); Collections.synchronizedList(new ArrayList<>());new CopyOnWriteArrayList<>();\n        for (int i = 0; i < 30; i++) {\n            new Thread(() -> {\n                list.add(UUID.randomUUID().toString().substring(0, 8));\n                System.out.println(list);\n            }).start();\n        }\n    }\n}\n```\n- 解决方案2（限制不可以使用vector和collections工具类）\n  写时复制\n  CopyOnWrite容器即写时复制容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements,然后新的容器Object[] newElements里面添加元素，添加完元素之后，再将原容器的引用指向新容器setArray（newElements）；，这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。\n```java\n/**\n * Appends the specified element to the end of this list.\n *\n * @param e element to be appended to this list\n * @return {@code true} (as specified by {@link Collection#add})\n */\npublic boolean add(E e) {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        Object[] elements = getArray();\n        int len = elements.length;\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        newElements[len] = e;\n        setArray(newElements);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n```\n- Demo\n```java\npublic class ContainerNotSafeDemo {\n    public static void main(String[] args) {\n        List<String> list = new CopyOnWriteArrayList<>();\n        for (int i = 0; i <30 ; i++) {\n            new Thread(()->{\n                list.add(UUID.randomUUID().toString().substring(0,8));\n                System.out.println(list);\n            }).start();\n        }\n    }\n}\n```\n#### 线程接口\n- 分类\n  - Runnable\n  - Callable\n- 区别\n  - Callable有返回值，Runnable没有 返回值\n  - Callable抛异常，Runnable不抛异常\n  - 落地方法不一样，Callable是call，Runnable是run\n\n#### 多线程辅助类\nCountDownLatch/CyclicBarrier/Semaphore /ReadWriteLock\n\n##### ReadWriteLock\n读读共存，读写、写写不共存\n\n##### CountDownLatch（火箭倒计时）\n减一直到为0\n让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒。\nCountDownLatch主要有两个方法，当一个或多个线程调用await方法，调用线程会被阻塞。其它线程调用countDown方法会将计数器减1（调用countDown的方法不会阻塞），当计数器的值变为零时，因调用await方法被阻塞的线程会被唤醒，继续执行。\n\nmain线程会等待其他线程执行完后接着执行\n\n```java\npublic class CountDownLatchDemo  {\n\n    public static void main(String[] args) throws InterruptedException {\n        Random random=  new Random();\n        CountDownLatch latch = new CountDownLatch(10);\n\n        for (int i=0;i<10;i++){\n            new Thread(()->{\n                try {\n                    TimeUnit.SECONDS.sleep(random.nextInt(5));\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName());\n                latch.countDown();\n            },String.valueOf(i)).start();\n        }\n\n\n        latch.await();\n\n        System.out.println(\"game over\");\n\n    }\n}\n```\n\n\n\n##### CyclicBarrier（集齐七龙珠，召唤神龙）\n加一\nCyclicBarrier 的字面意思是可以循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，让一组线程达到一个屏障（同步点）时被阻塞，直到最后一个线程达到屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await方法。\n\n主线程会和其他线程一起并发执行\n\n```java\npublic class CyclicBarrierDemo {\n    public static void main(String[] args) {\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {\n            System.out.println(\"===========召唤神龙========\");\n        });\n        for (int i=1;i<=7;i++){\n            final  int tmp=i;\n            new Thread(()->{\n                System.out.println(Thread.currentThread().getName() + \"\\t 获得第 \" + tmp + \" 颗龙珠\");\n                try {\n                    cyclicBarrier.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n            },String.valueOf(i)).start();\n        }\n    }\n}\n```\n##### Semaphore（抢停车位）\n多线程抢占固定资源\n信号量主要有两个目的，一个是用于多个资源的互斥，另一个是用于并发线程数的控制。\n\n主线程会和其他线程并发执行\n\n```java\npublic class SemaphoreDemo {\n    public static void main(String[] args) {\n        Semaphore semaphore = new Semaphore(3);\n        for (int i=0;i<10;i++){\n            new Thread(()->{\n                try {\n                    semaphore.acquire();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + \"\\t 抢到停车位\");\n                try {\n                    TimeUnit.SECONDS.sleep(3);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }finally {\n                    semaphore.release();\n                }\n                System.out.println(Thread.currentThread().getName() + \"\\t 离开了\");\n            },String.valueOf(i)).start();\n        }\n    }\n}\n```\n\n### 线程池\n\n线程复用，控制最大并发数，管理线程 \n\n#### 架构说明\nJava中线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类。\n\n#### 了解\n- Executors.newScheduledThreadPool()\n- java8新出（Executors.newWorkStealingPool(int）\n\njava8 新增，使用目前机器上可用的处理器作为它的并行级别\n\n#### Executors.newFixedThreadPool(int)\n```java\n/**\n * Creates a thread pool that reuses a fixed number of threads\n * operating off a shared unbounded queue.  At any point, at most\n * {@code nThreads} threads will be active processing tasks.\n * If additional tasks are submitted when all threads are active,\n * they will wait in the queue until a thread is available.\n * If any thread terminates due to a failure during execution\n * prior to shutdown, a new one will take its place if needed to\n * execute subsequent tasks.  The threads in the pool will exist\n * until it is explicitly {@link ExecutorService#shutdown shutdown}.\n *\n * @param nThreads the number of threads in the pool\n * @return the newly created thread pool\n * @throws IllegalArgumentException if {@code nThreads <= 0}\n */\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n            0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>());\n}\n```\n主要特点：\n\n- 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待\n\n- newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlokingQueue\n\n  场景：\n  执行长期的任务，性能好很多\n\n#### Executors.newSingleThreadExecutor()\n```java\n/**\n * Creates an Executor that uses a single worker thread operating\n * off an unbounded queue. (Note however that if this single\n * thread terminates due to a failure during execution prior to\n * shutdown, a new one will take its place if needed to execute\n * subsequent tasks.)  Tasks are guaranteed to execute\n * sequentially, and no more than one task will be active at any\n * given time. Unlike the otherwise equivalent\n * {@code newFixedThreadPool(1)} the returned executor is\n * guaranteed not to be reconfigurable to use additional threads.\n *\n * @return the newly created single-threaded Executor\n */\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                    0L, TimeUnit.MILLISECONDS,\n                    new LinkedBlockingQueue<Runnable>()));\n}\n```\n主要特点：\n1\t创建一个单线化的线程池，它只会用唯一的工作线程来执行任务，保证任务按照指定顺序执行\n2\tnewSingleThreadExecutor将corePoolSize和maxmiumPoolSize都设置为1，它使用的是LinkedBlockingQueue\n场景：\n任务顺序执行\n#### Executors.newCachedPool()\n```java\n/**\n * Creates a thread pool that creates new threads as needed, but\n * will reuse previously constructed threads when they are\n * available.  These pools will typically improve the performance\n * of programs that execute many short-lived asynchronous tasks.\n * Calls to {@code execute} will reuse previously constructed\n * threads if available. If no existing thread is available, a new\n * thread will be created and added to the pool. Threads that have\n * not been used for sixty seconds are terminated and removed from\n * the cache. Thus, a pool that remains idle for long enough will\n * not consume any resources. Note that pools with similar\n * properties but different details (for example, timeout parameters)\n * may be created using {@link ThreadPoolExecutor} constructors.\n *\n * @return the newly created thread pool\n */\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n            60L, TimeUnit.SECONDS,\n            new SynchronousQueue<Runnable>());\n}\n```\n主要特点：\n1\t创建一个可缓存线程池，如果线程池长度超过处理要求，可灵活回收空线程，若无可回收，则新建线程。\n2\tnewCacheThreadPool将coreSize设置为0，将maxmiumSize设置为Integer.MAX_VALUE，使用的是SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程\n场景：\n执行很多短期异步的小程序或者负载较轻的服务\n\n\n#### 7大参数\n```java\n/**\n * Creates a new {@code ThreadPoolExecutor} with the given initial\n * parameters and default thread factory and rejected execution handler.\n * It may be more convenient to use one of the {@link Executors} factory\n * methods instead of this general purpose constructor.\n *\n * @param corePoolSize the number of threads to keep in the pool, even\n *        if they are idle, unless {@code allowCoreThreadTimeOut} is set\n * @param maximumPoolSize the maximum number of threads to allow in the\n *        pool\n * @param keepAliveTime when the number of threads is greater than\n *        the core, this is the maximum time that excess idle threads\n *        will wait for new tasks before terminating.\n * @param unit the time unit for the {@code keepAliveTime} argument\n * @param workQueue the queue to use for holding tasks before they are\n *        executed.  This queue will hold only the {@code Runnable}\n *        tasks submitted by the {@code execute} method.\n * @throws IllegalArgumentException if one of the following holds:<br>\n *         {@code corePoolSize < 0}<br>\n *         {@code keepAliveTime < 0}<br>\n *         {@code maximumPoolSize <= 0}<br>\n *         {@code maximumPoolSize < corePoolSize}\n * @throws NullPointerException if {@code workQueue} is null\n */\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue) {\n    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n            Executors.defaultThreadFactory(), defaultHandler);\n}\n```\n##### corePoolSize\n线程池中的常驻核心线程数\n\n##### maximumPoolSize\n线程池能够容纳同时执行的最大线程数，此值必须大于等于1\n\n##### keepAliveTime\n多余的空闲线程的存活时间。\n当前线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止\n默认情况下：\n只有当线程池中的线程数大于corePoolSize时，keepAlive才会起作用，直到线程池中的线程数不大于corePoolSize\n\n##### unit\nkeepAliveTime的单位\n##### workQueue\n任务队列，被提交但尚未被执行的任务\n##### threadFactory\n表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可\n##### handler\n拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runnable的策略\n等待队列也已经满了，再也塞不下新任务了\n同时，线程池中的max线程也达到了，无法继续为信任服务\n这时候我们就需要拒绝策略机制合理的处理这个问题\n\n- AbortPolicy（默认）\n中断抛异常\n- CallerRunsPolicy\n调用者运行。该策略既不会抛弃任务也不会抛异常，而是将任务回退给调用者，从而降低新任的流量\n- DiscardPolicy\n该策略会默默的抛弃无法处理的任务，不予任何处理也不会抛异常。如果任务允许丢失，这是最好的一种策略\n- DiscardOldestPolicy\n抛弃队列中等待最久的任务，把当前任务加入队列中尝试再次提交任务\n\n\n#### 说说线程池底层的工作原理\n- 在创建来线程池后，等待提交过来的任务请求\n- 当调用execute()方法添加一个任务时，线程池会作以下判断：\n  - 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务\n  -\t如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务加入队列\n  -\t如果这时队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程运行这个任务\n  - 如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行\n-\t当一个线程完成任务是，它会从队列中取下一个任务来执行\n-\t当一个线程无事可做超过一定的时间（keepAliveTime）时，线程池会判断：\n如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。\n所以线程池的所有任务完成后它最终会收缩到corePoolSize的大小。\n\n#### execute方法 和submit方法的区别\n- execute 没有返回值，submit带有返回值\n- execute可以传入Runnable接口，submit可以传入Runnable和Callable接口\n\n\n#### 合理配置线程池你是如何考虑的\n\n##### CPU密集型\n\nCPU密集型，即该任务需要大量CPU运算，没有阻塞，CPU一直处于全速运行状态\nCPU密集型任务只有在真正多核CPU上才可能得到加速（通过多线程）\n在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些\nCPU密集型任务配置尽可能少的线程数量：\n一般公式：线程池=CPU核数+1个线程\nRuntime.getRuntime().availableProcessors()+[1-2]\n\n##### IO密集型\n- 方案一\n由于IO密集型任务线程并不是一直在执行任务，则应该配置尽可能多的线程，如CPU核数*2\n\n- 方案二\nIO密集型，该任务需要大量的IO操作，即大量的阻塞\n在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力在等待上，所以在IO密集型任务中使用多线程可以大大的加速程序运行，在单核CPU上，这种加速主要就是利用了被浪费的阻塞时间\nIO密集型，大部分线程都在阻塞，故要多配置线程数：\n参考公式：CPU核数／1-阻塞系数\n阻塞系数=0.8～0.9\n阻塞系数一般取0.9\n比如8核CPU：8/（1-0.9）=80个线程数\n\n### 队列\n阻塞队列，顾名思义，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下：\n线程1往队列中添加元素，而线程2从阻塞队列中移除元素\n当阻塞队列是空时，从队列中获取元素的操作将会被阻塞。\n当阻塞队列满的时候，往队列中添加元素的操作将会被阻塞。\n试图从空的阻塞队列中国年获取元素的线程将会阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程从队列中移除一个或多个元素或者完全清空队列后使队列重新变得空闲起来并后续新增。\n#### 作用\n在多线程领域：所谓阻塞。在某些情况下会挂起线程（即阻塞），一旦条件被满足，被挂起的线程又会自动被唤醒\n#### BlockingQueue\n\n空的时候不能获取，满的时候不能生产 \n\n好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手操办了。\n在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，而这会使我们的程序带来不小的复杂度。\n\n##### ArrayBlockingQueue\n由数组结构组成的有界阻塞队列\n\n##### LinkedBlockingQueue\n由链表结构构成的有界队列（但大小默认值为Inter.MAX_VALUE）阻塞队列\n\n##### PriorityBlockingQueue\n支持优先级排序的无界阻塞队列\n\n##### DelayQueue\n使用优先级队列实现的延迟无界阻塞队列\n\n##### SynchronousQueue\n\n不存储元素的阻塞队列，也即单个元素的队列\nSynchronousQueue 没有容量\n与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue\n每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然\n\n- Demo\n```java\npublic class SynchronousQueueDemo {\n    public static void main(String[] args) {\n        SynchronousQueue<Object> synchronousQueue = new SynchronousQueue<>();\n        new Thread(() -> {\n            try {\n                System.out.println(Thread.currentThread().getName() + \"\\t put 1\");\n                synchronousQueue.put(\"1\");\n                System.out.println(Thread.currentThread().getName() + \"\\t put 2\");\n                synchronousQueue.put(\"2\");\n                System.out.println(Thread.currentThread().getName() + \"\\t put 3\");\n                synchronousQueue.put(\"3\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }, \"t1\").start();\n        new Thread(() -> {\n            try {\n                System.out.println(Thread.currentThread().getName() + \"\\t take 1\");\n                synchronousQueue.take();\n                TimeUnit.SECONDS.sleep(5);\n                System.out.println(Thread.currentThread().getName() + \"\\t take 2\");\n                synchronousQueue.take();\n                TimeUnit.SECONDS.sleep(5);\n                System.out.println(Thread.currentThread().getName() + \"\\t take 3\");\n                synchronousQueue.take();\n                TimeUnit.SECONDS.sleep(5);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, \"t2\").start();\n    }\n}\n```\n##### LinkedTransferQueue\n由链表结构组成的无界阻塞队列\n##### LinkedBlockingDeque\n由链表结构组成的双向阻塞队列\n\n#### 核心方法\n##### 抛异常\n- add\n当队列满时，再添加元素会抛出异常（Queue Full）\n- remove\n当队列空时，再移除元素会抛出异常（NoSuchElementException）\n- element\n检查队列第一个元素\n\n##### 有返回值\n- offer(e)\n当队列满时，再添加元素不会抛出异常会返回false\n- poll\n当队列空时，再移除元素不会抛出异常会返回null\n- peek\n检查队列第一个元素\n\n##### 阻塞\n- put\n当队列满时，再添加元素会一直阻塞，直到可以添加元素\n- take\n当队列空时，再移除元素会一直阻塞，直到有元素可以移除\n\n##### 超时\n- offer(e,time,unit)\n当队列满时，再添加元素会等待，直到超时时间到达，返回false\n- poll(time,unit)\n当队列空时，再移除元素会等待，直到超时时间到达，返回null\n\n#### 场景\n##### 生产者消费者模式\t\n- 传统版\n- Demo\n```java\nclass ShareData{\n    int number=0;\n    Lock lock=new ReentrantLock();\n    Condition condition=lock.newCondition();\n    public void increment()throws Exception{\n        lock.lock();\n        try{\n            while (number!=0){\n                condition.await();\n            }\n            number++;\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + number);\n            condition.signalAll();\n        }catch (Exception e){\n            e.printStackTrace();\n        }finally {\n            lock.unlock();\n        }\n    }\n    public void decrement()throws Exception{\n        lock.lock();\n        try{\n            while (number==0){\n                condition.await();\n            }\n            number--;\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + number);\n            condition.signalAll();\n        }catch (Exception e){\n            e.printStackTrace();\n        }finally {\n            lock.unlock();\n        }\n    }\n}\npublic class ProdConsumer_TraditionDemo {\n    public static void main(String[] args) {\n        ShareData shareData = new ShareData();\n        new Thread(() -> {\n            for (int i = 0; i < 5; i++) {\n                try {\n                    shareData.increment();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }, \"t1\").start();\n        new Thread(() -> {\n            for (int i = 0; i < 5; i++) {\n                try {\n                    shareData.decrement();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }, \"t2\").start();\n    }\n}\n```\n- 阻塞队列版\n\n## 锁\n公平锁／非公平锁／可重入锁／递归锁／自旋锁\n\n### 四种状态\n#### 无锁\n#### 偏向锁\n#### 轻量级锁\n#### 重量级锁\n\n### 锁的升级\n当只有一个线程访问是叫做偏向锁——>发生竞争时升级成轻量级锁（自选锁等）——>自选等待没结果时升级成重量级锁\n\n###  公平锁\n是指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先来后到。\n###  非公平锁\n是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发的情况下，有可能会造成优先级反转或者饥饿现象。\n### 公平锁／非公平锁 两者区别\n并发包中ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或非公平锁，默认是非公平锁。\nJava ReentrantLock 而言，通过构造函数指定该锁是否是公平锁（默认是非公平锁）。非公平锁的优点在于吞吐量比公平锁大。\n对于Synchronized而言，也是一种非公平锁。\n\n```java\n/**\n * Creates an instance of {@code ReentrantLock}.\n * This is equivalent to using {@code ReentrantLock(false)}.\n */\npublic ReentrantLock() {\n    sync = new NonfairSync();\n}\n\n/**\n * Creates an instance of {@code ReentrantLock} with the\n * given fairness policy.\n *\n * @param fair {@code true} if this lock should use a fair ordering policy\n */\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n```\n公平锁：Threads acquire a fair lock in the order in which they requested it\n公平锁，就是很公平，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己\n非公平锁：Threads acquire a fair lock in the order in which they requested it\n非公平锁比较粗鲁，上来就尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。\n\n### 可重入锁（递归锁）\n\n指的是统一线程外层函数获得锁之后，内层递归函数仍然能获取该所的代码。\n统一线程在外层方法获取锁之后，进入内层方法后会自动获取锁。也就是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。\n\n- ReentrantLock/Synchronized就是一个典型的可重入锁\n- 可重入锁的最大作用就是避免死锁\n- ReenterLockDemo\n```java\nclass Phone implements  Runnable{\n    public synchronized void  sedSMS(){\n        System.out.println(Thread.currentThread().getName()+\"\\t invoked sendSMS\");\n        sedMail();\n    }\n    public synchronized void  sedMail(){\n        System.out.println(Thread.currentThread().getName()+\"\\t invoked sedMail\");\n    }\n    @Override\n    public void run() {\n        get();\n    }\n    public void get(){\n        Lock lock = new ReentrantLock();\n        lock.lock();\n        try{\n            System.out.println(Thread.currentThread().getName()+\"\\t invoked get\");\n            set();\n        }finally {\n            lock.unlock();\n        }\n    }\n    public void set(){\n        Lock lock = new ReentrantLock();\n        lock.lock();\n        try{\n            System.out.println(Thread.currentThread().getName()+\"\\t invoked set\");\n        }finally {\n            lock.unlock();\n        }\n    }\n}\npublic class ReenterLockDemo {\n    public static void main(String[] args) throws InterruptedException {\n        Phone phone = new Phone();\n        new Thread(()->{phone.sedSMS();},\"t1\").start();\n        new Thread(()->{phone.sedSMS();},\"t2\").start();\n        TimeUnit.SECONDS.sleep(2);\n        System.out.println(\"=======================\");\n        System.out.println();\n        System.out.println();\n        System.out.println();\n        new Thread(phone,\"t3\").start();\n        new Thread(phone,\"t4\").start();\n    }\n}\n```\n### 独占锁\n指该锁一次只能被一个线程持有。对ReentrantLock和Synchronized而言都是独占锁\n\n### 共享锁\n指该锁可被多个线程所持有\n对ReentrantReadWriteLock其读锁是共享锁，其写锁是独占锁\n读锁对共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。\n\n```java\npublic class ReadWriteLockDemo {\n    volatile Map map= new HashMap<String,Object>();\n    ReadWriteLock rwLock=new ReentrantReadWriteLock();\n    public void get(String key) throws InterruptedException {\n        rwLock.readLock().lock();\n        try{\n            System.out.println(Thread.currentThread().getName()+\"\\t 正在读\");\n            TimeUnit.MILLISECONDS.sleep(300);\n            Object res=map.get(key);\n            System.out.println(Thread.currentThread().getName()+\"\\t 读完成：\"+res);\n        }catch (Exception e){\n            e.printStackTrace();\n        }finally{\n            rwLock.readLock().unlock();\n        }\n    }\n    public void put(String key,Object value) throws InterruptedException {\n        rwLock.writeLock().lock();\n        try{\n            System.out.println(Thread.currentThread().getName()+\"\\t 正在写：\"+key);\n            TimeUnit.MILLISECONDS.sleep(300);\n            map.put(key,value);\n            System.out.println(Thread.currentThread().getName() + \"\\t 写完成\");\n        }catch (Exception e){\n            e.printStackTrace();\n        }finally{\n            rwLock.writeLock().unlock();\n        }\n    }\n    public static void main(String[] args) {\n        ReadWriteLockDemo readWriteLockDemo = new ReadWriteLockDemo();\n        for (int i=0;i<10;i++){\n            final int tmp=i;\n            new Thread(()->{\n                try {\n                    readWriteLockDemo.put(tmp+\"\",tmp);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            },String.valueOf(i)).start();\n        }\n        for (int i=0;i<5;i++){\n            final int tmp=i;\n            new Thread(()->{\n                try {\n                    readWriteLockDemo.get(tmp+\"\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            },String.valueOf(i)).start();\n        }\n    }\n}\n```\n### 自旋锁（spinlock）\n是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式尝试去获取锁，这样的好出是减少线程上下文切换的消耗，缺点是循环会消耗CPU\n```java\n//unsafe.getAndAddInt\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n    int var5;\n    do {\n        var5 = this.getIntVolatile(var1, var2);\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n    return var5;\n}\n```\n- Demo\n```java\npublic class SpinLockDemo {\n    AtomicReference<Thread> atomicReference=new AtomicReference<>();\n    public void myLock(){\n        Thread thread=Thread.currentThread();\n        System.out.println(thread.getName()+\"\\t come in \");\n        while (!atomicReference.compareAndSet(null,thread)){}\n    }\n    public void myUnLock(){\n        atomicReference.compareAndSet(Thread.currentThread(),null);\n        System.out.println(Thread.currentThread().getName()+\"\\t out \");\n    }\n    public static void main(String[] args) throws InterruptedException {\n        SpinLockDemo spinLockDemo = new SpinLockDemo();\n        new Thread(()->{\n            spinLockDemo.myLock();\n            try {\n                TimeUnit.SECONDS.sleep(5);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            spinLockDemo.myUnLock();\n        },\"t1\").start();\n        TimeUnit.SECONDS.sleep(1);\n        new Thread(()->{\n            spinLockDemo.myLock();\n            spinLockDemo.myUnLock();\n        },\"t2\").start();\n    }\n}\n```\n### Synchornized\n实现同步方法的基础是Java中的每个对象都可以作为锁\nSynchronized （对象锁），static synchronized （类锁|全局锁），这两种锁互补影响，互相没有关系，可以同时访问\n\n#### 具体表现\n- 对于普通同步方法，锁的是当前实例对象，锁的是this\n- 对于同步方法块，锁的是synchroniezd括号里面的配置对象\n- 对于静态同步方法，锁的是当前类的Class对象\n\n#### Synchronized与Lock有什么区别\n##### 原始构成\n- Synchronized是关键字属于JVM层面，底层是通过monitor对象来完成，其wait／notify等方法也依赖与monitor对象，只有在同步块或方法中才能调用wait／notify等方法\n  monitorenter   进入，monitorexit\t退出（有两层退出，正常情况和非正常情况都能退出，不会造成死锁）\n- Lock 是API层面\n\n##### 使用方法\n- Synchronized 不需要用户手动去释放锁，当synchronized代码执行完成后系统会自动让线程释放对锁的占用\n- ReentrantLock则需要用户手动去释放锁，若没有主动释放锁，就有可能出现死锁现象\n  需要lock和unlock方法配合try finally 语句完成\n\n##### 等待是否可中断\n- Synchronized不可中断，除非抛出异常或者正常执行完成\n- ReentrantLock可中断\n  - 设置超时方法 tryLock（long timeout，TimeUtil unit）\n  - lockInterruptibly（）放代码块中，调用interrupt（）可中断\n\n##### 加锁是否公平\n- Synchronized 非公平锁\n- ReentrantLock 两者都可以，默认非公平锁，构造方法可传入boolean值，true为公平锁，false为非公平锁\t\n\n##### 锁绑定多个条件Condition\n- Synchronized 没有\n- ReentrantLock用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不像synchronized要么随机唤醒一个线程要么唤醒全部线程\n\n```java\nclass Data {\n    Lock lock = new ReentrantLock();\n    Condition c1 = lock.newCondition();\n    Condition c2 = lock.newCondition();\n    Condition c3 = lock.newCondition();\n    int number = 1;\n\n    public void print5() {\n        lock.lock();\n        try {\n            while (number != 1) {\n                c1.await();\n            }\n            for (int i = 0; i < 5; i++) {\n                System.out.println(Thread.currentThread().getName() + \"\\t\" + i);\n            }\n            number = 2;\n            c2.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void print10() {\n        lock.lock();\n        try {\n            while (number != 2) {\n                c2.await();\n            }\n            for (int i = 0; i < 10; i++) {\n                System.out.println(Thread.currentThread().getName() + \"\\t\" + i);\n            }\n            number = 3;\n            c3.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void print15() {\n        lock.lock();\n        try {\n            while (number != 3) {\n                c3.await();\n            }\n            for (int i = 0; i < 15; i++) {\n                System.out.println(Thread.currentThread().getName() + \"\\t\" + i);\n            }\n            number = 1;\n            c1.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic class Conditions {\n    public static void main(String[] args) {\n        Data data = new Data();\n        new Thread(() -> {\n            for (int i = 0; i < 10; i++) {\n                data.print5();\n            }\n        }, \"A\").start();\n        new Thread(() -> {\n            for (int i = 0; i < 10; i++) {\n                data.print10();\n            }\n        }, \"B\").start();\n        new Thread(() -> {\n            for (int i = 0; i < 10; i++) {\n                data.print15();\n            }\n        }, \"C\").start();\n    }\n}\n```\n\n### 死锁编码及定位分析\n死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那么它们都将无法推进下去，如果系统资源充足，线程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。\n\n#### 系统资源不足\n#### 线程进行推进的顺序不合适\n#### 资源分配不当\n\n```java\nclass HoldLockThread implements Runnable {\n    String lockA;\n    String lockB;\n\n    public HoldLockThread(String lockA, String lockB) {\n        this.lockA = lockA;\n        this.lockB = lockB;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lockA) {\n            System.out.println(Thread.currentThread().getName() + \"\\t 持有锁：\" + lockA + \"\\t 试图获取锁：\" + lockB);\n            try {\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            synchronized (lockB) {\n                System.out.println(Thread.currentThread().getName() + \"\\t 持有锁：\" + lockB + \"\\t 试图获取锁：\" + lockA);\n            }\n        }\n    }\n}\n\npublic class DeadLockDemo {\n    public static void main(String[] args) {\n        String lockA = \"lockA\";\n        String lockB = \"lockB\";\n        new Thread(new HoldLockThread(lockA, lockB), \"t1\").start();\n        new Thread(new HoldLockThread(lockB, lockA), \"t2\").start();\n    }\n}\n```\n#### 解决\n- jps命令定位进程号\n- jstack找到死锁查看\n\n### 什么是分布式锁\n当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。分布式锁可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存，如 Redis，通过set (key,value,nx,px,timeout)方法添加分布式锁。\n\n### 什么是分布式事务\n分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。\n\n## 集合（Collection）\n### List集合\n\nArrayList扩容为原来一半\n\n### Set集合\n#### HashSet\n```java\npublic HashSet() {\n    map = new HashMap<>();\n}\n\nHashSet底层是HashMap，put的值是key，value是一个Object类型的静态常量\nprivate static final Object PRESENT = new Object();\n\npublic boolean add(E e) {\n    return map.put(e, PRESENT) == null;\n}\n```\n### Map集合\n\n#### HashMap\n初始长度16 负载因子 3/4 扩容为2倍原长度，调用构造函数只是进行了默认长度和负载因子的设置并没有初始化数组，开辟存储空间。 1.7数组加单向链表，每个元素是entry，1.8 链表最大长度8 超过会转成红黑树，每个元素是Node。key可以为null，将key为null放在下标为0的位置\n##### put(key1,value1)\n七上八下（1.7 新加元素会在链表上面添加，1.8会在下面添加）\n- 首先调用key1的hashCode方法，然后再经过特定计算，计算出hash值，hash值&（length-1）计算出存放位置（Entry数组下标）\n- 如果此位置上的数据为空，此时添加成功          ---情况1   \n- 如果此位置上的数据不为空（意味着，此位置上存在一个或多个数据（以链表方式存在）），比较key1和已经存在的一个或多个数据的哈希值\n  - 如果key1的哈希值与已经存在的数据哈希值都不同，此时添加成功    ----情况2\n  - 如果key1的哈希值和已经存在的某一个数据（key2，value2）key2的哈希值相同，继续比较。调用key1所在类的equals（key2）\n    - 如果equals的返回值为false：此时添加成功       ---情况3\n    - 如果equals的返回值为true：使用value1替换掉value2\n\n补充：关于情况2和情况3:此时key1-value1的数据以链表的方式存储。\n##### 扩容\n在不断的添加过程中会涉及到扩容问题，默认的扩容方式：扩容为原来的2倍，并将原来的数据迁移过来。（不是rehash，而是链表上的数据通过用新数组长度进行计算得到的下标，会有两种情况，一种是和之前下标一样，一种是在原来下标基础上加上原来数组长度的下标。例如：原来下标为2，原来数组长度为8，新数组长度为16，链表上的数据有可能下标是2，有可能下标是2+8=10。）\n\n- 1.7：size >= threshold) && (null != table[bucketIndex]\n- 1.8：++size > threshold或tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY\n#### 为什么HashMap的长度是2的n次幂\n当长度2的n次幂时，2的n次幂 - 1=1111（2进制），任何值与此值按位（&）计算，这样才会快速拿到数组下标，并且数据分布相对均匀。\n#### 1.8 链表改为红黑树条件\n当数组的某一个索引位置上的元素以链表的形式存在的，数据个数>8且当前数组长度>64时，此时次位置伤的所有数据改为使用红黑树存储。\n#### 1.8 链表变成红黑树的阀值为8\n因为哈希桶中节点个数服从参数为0.5的泊松分布，超过8的概率很小\n#### HashMap和HashTable区别\n##### 线程安全性不同\nHashMap是线程不安全的，HashTable是线程安全的，其中的方法是Synchronize的，在多线程并发的情况下，可以直接使用HashTable，但是使用HashMap时必须自己增加同步处理。\n#####  是否提供contains方法\nHashMap只有containsValue和containsKey方法；HashTable有contains、containsKey和containsValue三个方法，其中contains和containsValue方法功能相同。\n#####  key和value是否允许null值\nHashTable中，key和value都不允许出现null值。HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。\n#####  数组初始化和扩容机制\n- HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。\n- HashTable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。\n#### ConcurrentHashMap\n- Segment：一个小型的HashMap，大小由并发级别确定\n- 线程安全，使用分段锁来控制同步访问问题\n\n#### TreeSet和HashSet区别\nHashSet是采用hash表来实现的。其中的元素没有按顺序排列，add()、remove()以及contains()等方法都是复杂度为O(1)的方法。\nTreeSet是采用树结构实现(红黑树算法)。元素是按顺序进行排列，但是add()、remove()以及contains()等方法都是复杂度为O(log (n))的方法。它还提供了一些方法来处理排序的set，如first(), last(), headSet(), tailSet()等等。\n## 字符串（String）\n### String buffer和String build区别\n- StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，\n- 只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。 \n- 在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全而StringBuffer则每次都需要判断锁，效率相对更低\n\n## 其他\n### 引用\n#### 强引用（默认支持模式）\n当内存不足，JVM开始垃圾回收，对于强引用当对象，就算是出现了OOM也不会对该对象进行回收，死都不回收。\n强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成java内存泄漏的主要原因之一。\n对于一个普通对象，如果没有其他的引用关系，只要超过了引用作用域或者显式的将相应（强）引用赋值为null，一般认为就是可以被垃圾收集的了（当然具体回收时机还要看垃圾收集策略）。\n\n#### 软引用\n软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。\n对于只有弱引用的对象来说，\n当系统内存充足时不会被回收\n当系统内存不足时会被回收\n软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用就保留，不够用就回收。\n\n#### 弱引用\n弱引用需要用java.lang.ref.WeakReference类来实现，它比软引用的生存周期更短，\n对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存。\n软引用、弱引用应用场景：\n假如有一个应用需要读取大量的本地图片：\n如果每次读取图片都要从硬盘读取图片则会严重影响性能\n如果一次性全部加载到内存中又能造成内存溢出\n设计思路：\n用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免来OOM的问题。\n`Map<String,SoftReference<Bitmap>> imageCache =new HashMap<String,SoftReference<Bitmap>>();`\n\n#### 虚引用\n\n### Final、Finally、Finalize\n#### final\n修饰符（关键字）有三种用法：修饰类、变量和方法。修饰类时，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。修饰变量时，该变量使用中不被改变，必须在声明时给定初值，在引用中只能读取不可修改，即为常量。修饰方法时，也同样只能使用，不能在子类中被重写。\n\n#### Finally\n通常放在try…catch的后面构造最终执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。\n\n#### Finalize\nObject类中定义的方法，Java中允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize() 方法可以整理系统资源或者执行其他清理工作。\n\n### ==和Equals区别\n\n####  == \n如果比较的是基本数据类型，那么比较的是变量的值\n如果比较的是引用数据类型，那么比较的是地址值（两个对象是否指向同一块内存）\n\n####  Equals\n如果没重写equals方法比较的是两个对象的地址值。\n如果重写了equals方法后我们往往比较的是对象中的属性的内容\nequals方法是从Object类中继承的，默认的实现就是使用==\n\n### B-tree和B+tree的区别\n- B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。\n- 在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。\n\n\n## 1.8 新特性\n\n###  四大函数接口\n\n- Consumer<T>\n重写accept，参数T，无返回\n\n- Supplier<T>\n 重写get，无参数，返回T\n\n- Function<T,R>\n重写apply，参数T，返回R\n\n- Predicate<T>\n重写test，参数T，返回boolean类型值\n\n### Stream\n\n### 分支合并框架\n- ForkJoinPool\n- ForJoinTask\n- RecursiveTask\n\n### 异步调用\n- CompletableFuture\n\n### lambada表达式\n- ()->{}\n- lambada表达式只可以使用在函数式接口上\n- java 8以前函数interface接口只能有方法定义，不能有实现。java 8以后可以由方法实现（default 关键字 修饰，可以由多个方法实现），有且仅有一个方法定义\n\n\n\n\n\n","source":"notes/Java.md","raw":"# Java基础知识清单\n\n## JVM\n### JVM架构\n![image-20200309203737822](Java.assets/image-20200309203737822.png)\n\n![image-20200309214325839](Java.assets/image-20200309214325839.png)\n\n![QQ20200314-123059@2x](Java.assets/QQ20200314-123059@2x-4161454.png)\n\n\n#### Class file\n\n- 有特定的文件标示（cafe babe），由类加载器加载进JVM方法区\n- 在加载类时：静态块（只会加载一次）>构造块>构造方法\n\n#### 类加载器（ClassLoader）\n\n实现通过类的全限定名（java/lang/String）获取该类的二进制字节流的代码块叫做类加载器。\n\n#####分类\n###### 启动类加载器（Bootstrap）\n\n用来加载java核心类库，无法被java程序直接引用。主要加载jre/lib文件夹下的jar文件\n\n###### 扩展类加载器（Extension）\n\n它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。主要加载jre/lib/ext文件夹下的jar文件\n\n###### 应用程序加载器（Application）\n\n也叫应用类加载器,它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。\n\n###### 自定义\n通过继承 java.lang.ClassLoader类的方式实现。\n\n##### 全盘委托\n加载类时，除非显示使用其他类加载器，否则该加载类下的其他依赖都有该类加载器加载\n\n##### 双亲委派\n加载时会一层层向上委托，如果可以加载就进行加载，没有就向下层加载器找，找到加载找不到class not found\n\n##### 沙箱安全\n\n自己加载自己的，相当一个一个容器 各不影响\n\n#### 本地接口（Native Interface）\n本地接口的作用是融合不同的编程语言为Java所用，在本地方法栈（Native Method Stack） 中登记Native方法\n\n#### 程序计数器（Program Counter Register）,PC 寄存器\n线程私有的。内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。\n记录了方法之间的调用和执行情况，它是当前线程所执行的字节码的行号指示器。相当于一个指针，指示字节码的行号，指引程序执行顺序，native 的为空\n\n#### 本地方法栈（Native Method Stack）\n本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务，存放本地方法\n\n#### Java 栈（Java Stack ），虚拟机栈\n栈分为java虚拟机栈和本地方法栈\n栈管运行，堆管存储。栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命周期是跟随线程的生命周期，线程结束内存也释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是栈函数的栈内存中分配。\n栈存储：局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息\n\n虚拟机栈中包含有多个栈帧，每一个栈帧就是一个方法。\n\nStackOverFlowError：是错误，栈中递归调用等会发生，是由于栈内存溢出造成\n\n栈帧（Java中叫方法，栈中叫栈帧）数据\n每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。\n-  局部变量\n输入参数和输出参数以及方法内的变量\n  局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定\n  \n- 操作数栈\n记录出栈、入栈的操作\n  操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式\n  \n- 动态链接\n- 方法返回地址\n  \n#### 方法区（Method Area）还被叫为Non-Heap（非堆）\n\n被所有线程共享区域，在不同虚拟机里头实现是不一样的，最典型的就是永久代（PermGen Space）和元空间（Metaspace）。实例变量存储在对内存中和方法区无关。在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载。该区域是被线程共享的。\n存储：在方法区中，存储了每个类的信息（包括类的名称、修饰符、方法信息、字段信息）、类中静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息以及编译器编译后的代码等。运行时常量池用于存放静态编译产生的字面量和符号引用，该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。1.7以后字符串常量池被移植到堆内存中\n\n#### 堆（Heap）\n\n堆被所有线程共享区域，在虚拟机启动时创建，唯一目的存放对象实例。堆区是gc的主要区域，通常情况下分为两个区块年轻代和年老代。更细一点年轻代又分为Eden区，主要放新创建对象，From survivor 和 To survivor 保存gc后幸存下的对象，默认情况下各自占比 8:1:1。\n\n一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常量放到堆内存中，保存所有引用类型的真实信息，以便执行器执行。\n\n\n- 逻辑：Eden:S0:S1=8:1:1，新生：养老=1:2\n  - 新生（New）／年轻代（Young）\n    - 伊甸园（Eden Space）\n    新New对象都在此区域，98%是临时对象会被GC掉\n    - 幸存者0（Survivor 0 Space）| from\n    - 幸存者1（Survivor 1 Space）| to\n  - 养老（Tenure）／老年代（Old）\n  - 永久（java 7）／元数据（java 8）。永久代和元空间的最大区别在于，永久代使用的是JVM的堆内存，但是java 8以后元空间并不存在虚拟机中而是使用本地物理内存，默认只用物理内存的1/4\n- 物理\n  - 新生\n  - 老年\n\n\n\n### GC\nHotSpot采用的是分代收集算法\n\n是内存回收的方法论，垃圾回收器就是算法落地实现\n因为目前还没有完美的垃圾收集器出现，更加没有万能的收集器，只是有针对具体应用最合适的收集器，进行分代收集\n\n#### 判断一个对象是否可以被回收\n\n垃圾（内存中已经不再被使用到的空间）\n\n##### 引用计数\n\nJava中，引用和对象是有关联的。如果要操作对象则必须要用引用进行。因此，很显然一个简单的办法就是通过引用计数来判断一个对象是否可以回收。简单说，给对象中添加一个引用计数器。每当有一个地方引用它，计数器值加1；每当有一个地方引用失效时，计数器值减1。任何时刻计数器值为零的对象就是不可能再被使用的，那么这个对象就是可回收对象，\n那为什么主流的Java虚拟机里面都没有采用这种算法呢？其中最主要的原因是它很难解决对象直接相互循环引用的问题。\n\n##### 根节点作可达性分析（根搜索路径）\n\n为了解决引用计数循环引用问题，Java使用了可达性分析方法\n所谓GC Roots或者说tracking GC的根集合，就是一组必须活跃的引用\n基本思路就是通过一系列名为GC Roots的对象作为起始点，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何一个引用链相连时，则说明此对象不可用。即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达）对象就被判定为存活；没有遍历到的就自然被判定为死亡。\n\n\n#### Java中可以作为GC Roots的对象\n\n- 虚拟机栈（栈帧中的局部变量区，也叫局部变量表）中引用的对象\n- 方法区中的类静态属性、常量引用的对象\n- 本地方法栈中JNI（Native方法）引用的对象\n\n####  回收策略以及Minor GC和Major GC：\n对象优先在堆的Eden区分配，当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC，Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC，但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度。\n\n\n#### 新生代GC（Minor GC|GC）\n- 复制\neden、from 复制到 to，年龄+1\n首先，当Eden区满的时候会触发第一次GC，把还活着的对象拷贝到from区，当eden区再次触发GC的时候会扫描eden区和from区，对这两个区域进行垃圾回收，经过这次回收后还存活的对象，直接复制到to区域（如果有对象的年龄到了老年的标准，则复制到老年区），同时把这些对象的年龄+1\n- 清空\n清空eden、from\n然后清空eden和from中的对象\n\t\n- 互换\nto和from互换\n最后，也即复制之后有换，谁空谁是to。to和from互换，原来to成为下一次GC时的from区，部分对象会在from和to区中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认是15），最终如果还存活，就进入老年代。\n\n#### 老年代GC（Major GC|Full GC）\nGC日志分析\n- [GC (Allocation Failure) [PSYoungGen: 512K->425K(1024K)] 512K->425K(1536K), 0.0018589 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]\n- [Full GC (Ergonomics) [PSYoungGen: 469K->460K(1024K)] [ParOldGen: 448K->447K(512K)] 917K->908K(1536K), [Metaspace: 2697K->2697K(1056768K)], 0.0041891 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] \n  - DefNew(Default New Generation)\n  - Tenured(Old)\n  - ParNew(Parallel New Generation)\n  - PSYoungGen(Parallel Scavenge)\n  - ParOldGen(Parallel Old Generation)\n#### GC4大算法\n\n##### 引用计数\n应用于：微软的COM/ActionScrip3/Python等\n如果对象没有被引用，就会被回收\n缺点：需要维护一个引用计算器\n\n##### 复制（Copy）\n年轻代中使用的是Minor GC，这种GC算法采用的是复制算法(Copying)\n- 不会发生内存碎片，速度快\n- 消耗空间（需要进行复制）\n\n##### 标记清除（Mark Sweep）\n老年代一般是由标记清除或者是标记清除与标记整理的混合实现\n- 会产生内存碎片，两次扫描耗时严重\n- 节约内存空间\n\n##### 标记整理／压缩（Mark-Compat）\n老年代一般是由标记清除或者是标记清除与标记整理的混合实现\n- 没有碎片\n- 耗时严重\n\t\t\n#### 算法比较\n\n- 内存效率（时间纬度）\n  复制>标记清除>标记整理\n\n- 内存整齐度\n  复制=标记整理>标记清除\n\n- 内存利用率\n  标记整理=标记清除>复制\n### GC垃圾收集器\n#### 查看默认的垃圾收集器是哪个\njava -XX:+PrintCommandLineFlags -version\n\n#### 默认的垃圾收集器有哪些\n##### UseSerialGC\n它为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程，不适合服务器。\n一句话：一个单线程的收集器，在进行垃圾收集的时候，必须暂停其他所有的工作线程直到它收集结束。\n串行收集器是最古老，最稳定以及效率最高的收集器，只使用一个线程区回收但其在进行垃圾回收过程中可能会产生较长的停顿（Stop-The-World 状态）。虽然在收集垃圾过程中需要暂停其他的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是java虚拟机运行在Client模式下新生代的垃圾收集器。\n对应JVM参数：\n-XX:+UseSerialGC\n开启后会使用：Serial（Young区用）+Serial Old（Old区用）的收集器组合\n表示：新生代、老年代都会使用串行收集器，新生代使用复制算法，老年代使用标记-整理算法\n-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseSerialGC\n\n\n##### UseSerialOldGC\nSerial Old 是Serial 垃圾收集器老年代版本，它同样是单个线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的java虚拟机默认的老年代垃圾收集器。\n在Server模式下，主要有两个用途（了解，版本已经到8及以后）：\n\n- 在JDK1.5 之前版本中与新生代的Parallel Scavenge 收集器搭配使用。（Parallel Scavenge +Serial Old）\n- 作为老年代版本中使用CMS收集器的后备垃圾收集方案。\n\n##### UseParNewGC\n多个垃圾收集线程并行工作，此时用户线程是暂停的，适用于科学计算／大数据处理等弱交互场景\n一句话：使用多线程进行垃圾回收，在垃圾收集时，会Stop-The-World暂停其他所有的工作线程直到它收集结束。\nParNew收集器其实就是Serial收集器新生代的并行多线程版本，最常见的应用场景是配合老年代的CMS GC工作，其余的行为和Serial收集器完全一样，它是很多java虚拟机运行在Server模式下新生代的默认垃圾收集器\n常用JVM参数：-XX:+UseParNewGC 启用ParNew收集器，只影响新生代的收集，不影响老年代\n开启上述参数后，会使用：ParNew（Young区用）+Serial Old的收集器组合，新生代使用复制算法，老年代采用标记-整理算法。\n但是，ParNew+Tenured这样的搭配，java8已经不再被推荐\n备注：\n-XX:ParallelGCThreads 限制线程数量，默认开启和CPU数目相同的线程数\n -Xmx10m -Xmx10m -XX:+PrintGCDetails -XX:+UseParNewGC\n\n##### UseParallelGC\nParallel Scavenge收集器类似ParNew也是一个新生代垃圾收集器，使用复制算法，也是一个并行的多线程的垃圾收集器，俗称吞吐量优先收集器。\n一句话：串行收集器在新生代和老年代的并行化\n它重点关注的是：\n可控制的吞吐量（Thoughput=运行用户代码时间／（运行用户代码时间+垃圾收集时间），比如程序运行100分钟，垃圾收集1分钟，吞吐量就是99%）。高吞吐量意味着高效利用CPU时间，它多用于在后台运算而不需要太多交互的任务。\n自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。（自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间（-XX:MaxGCPauseMillis）或最大吞吐量。\n常用JVM参数：-XX:+UseParallelGC 或 -XX:+UseParallelOldGC(可互相激活）使用Parallel Scavenge收集器\n多说一句：-XX:ParallelGCThreads=数字N 表示启动多少个线程\nCPU>8 N=5/8\nCPU<8 N=实际个数\n-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseParallelGC\n-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseParllelOldGC\n\n##### UseParallelOldGC\nParallel Old收集器是Parallel Scavenge的老年代版本，使用多线程的标记-整理算法，Parallel Old收集器在JDK1.6才开始提供。\n在JDK1.6之前，新生代使用Parallel Scavenge收集器只能搭配老年代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。在JDK1.6之前（Parallel Scavenge+Serial Old）\nParallel Old正是为了在老年代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，JDK1.8之后可以优先考虑新生代Parallel Scavenge 和老年代Parallel Old收集器的搭配策略。在JDK1.8及之后（Parallel Scavenge+Parallel Old）\n常用JVM参数：-XX:+UseParallelOldGC 使用Parallel Old收集器，设置参数后，新生代Parallel+老年代Parallel Old\n##### UseConcMarkSweepGC\n用户线程和垃圾回收线程同时执行（并不一定是并行，可能交替执行），不需要暂停用户线程，互联网公司多用它，适用对相应时间有要求的场景\nCMS收集器（Concurrent Mark Sweep：并发标记清除）是一种以获取最短回收停顿时间为目标的收集器。适应应用在互联网站或者B／S系统的服务器上，这类应用尤其重视服务器响应速度，希望系统停顿时间最短。CMS非常适合堆内存大、CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。Concurrent Mark Sweep 并发标记清除，并发收集低停顿，并发指的是与用户线程一起执行\n开启该收集器的JVM参数： -XX:+UseConcMarkSweepGC 开启该参数后会自动将-XX:+UseParNewGC 打开开启该参数后，使用ParNew（Young区用）+CMS（Old区用）+Serial Old的收集器组合，Serial Old将作为CMS出错的后备收集器\n**执行步骤**\n\n- 初始标记（CMS initial mark）需要暂停所有的工作线程\n只是标记一下，GC Roots 能直接关联的对象，速度快，仍然需要暂停所有的工作线程\n- 并发标记（CMS concurrent mark）和用户线程一起\n进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。主要标记过程，标记全部对象。\n- 重新标记（CMS remark）需要暂停所有的工作线程\n为了修改在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。\n由于并发标记时，用户线程依然运行，因此在正式清理前，再作修正。\n- 并发清除（CMS concurrent sweep）和用户线程一起\n清除GC Roots 不可达对象，和用户一起工作，不需要暂停工作线程。基于标记结果，直接清除对象。\n由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发的执行。\n\n**优缺点**\n优：并发收集低停顿\n缺：\n\n- 并发执行，对CPU资源压力大\n由于并发进行，CMS垃圾收集和应用线程会同时增加对堆内存对占用，也就是说，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW的方式进行一次GC，从而造成较大停顿时间。\n- 采用对标记清除算法会导致大量碎片\n标记清除无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。CMS也提供了参数-XX:CMSFullGCsBeForeCompaction(默认0，即每次都进行内存整理）来指定多少次CMS收集之后，进行一次压缩的Full GC\n\n-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC\n\n##### UseG1GC\nG1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片\nG1的Stop The World（STW）更可控，G1在停顿时间上添加量预测机制，用户可以指定期望停顿时间\nCMS垃圾收集器虽然暂停了应用程序的运行时间，但还是存在着内存碎片的问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，java7 发布了一个新的垃圾收集器-G1垃圾收集器\nG1是在2012年才在jdk1.7u4中可用。oracle官方计划在jdk9中将G1变成默认的垃圾收集器以替代CMS。它是一款面向服务器端应用的收集器，主要应用在多CPU和大内存服务器环境下，极大的减少垃圾收集的停顿时间，全面提升服务器的性能，逐步替换java8以前的CMS收集器。\n主要改变是Eden，Surivor和Tenured等内存区域不再是连续的了，而是变成了一个个大小一样的region，每个region从1m到32m不等。一个region有可能属于Eden，Survivor或者Tenured内存区域\n\n###### 底层原理\nRegion区域化垃圾收集器\n化整为零，避免全内存扫描，只需要按照区域来进行扫描即可\n区域化内存划片Region，整体编辑为了一些不连续的内存区域，避免了全内存区的GC操作。\n核心思想是将整个堆内存区域分成大小相同的子区域（Region），在JVM启动的时候会自动设置这些子区域的大小，在堆的使用上，G1并不要求对象的存储一定是物理上连续的只要逻辑连续即可，每个分区也不会固定的为某个代服务，可以按需在新生代和老年代之间切换。启动时可以通过参数-XX:G1HeapRegionSize=n指定分区大小（1m-32m，且必须是2的幂），默认将整堆划分成2048个分区。\n大小范围在1m-32m，最多能设置2048个区域，能支持的最大内存为：32m*2048=65536m=64G\n\n###### 回收步骤\nG1收集器下的Young GC\n针对Eden区进行收集，Eden区耗尽后会被触发，主要是小区域收集+形成连续的内存块，避免内存碎片\nEden区的数据移动到Survivor区，假如出现Survivor区空间不够，Eden区数据会部分晋升到Old区\nSurivor区的数据移动到新的Survivor区，部分数据晋升到Old区\n最后Eden区收拾干净，GC结束，用户的应用程序继续执行\n\n###### 常用配置参数（了解）\n开发人员仅仅需要声明以下参数即可：\n三步归纳：开始G1+设置最大内存+设置最大停顿时间\n-XX:+UseG1GC  -Xmx32g  -XX:MaxGCPauseMillis=100\n-XX:MaxGCPauseMillis=n: 最大GC停顿时间单位毫米，这是个软目标，JVM将尽可能（但不保证）停顿小于这个时间。\n\n- -XX:+UseG1GC\n- -XX:G1HeapRegionSize=n\n设置G1区域的大小。值是2的幂，范围是1m-32m。目标是根据最小的java堆大小划分出约2048个区域\n- -XX:MaxGCPauseMillis=n\n最大GC时间，这是个软目标，JVM尽可能（但不保证）停顿小于这个时间\n- -XX:InitiatingHeapOccupancyPercent=n\n堆占用了多少堆时候就触发GC，默认为45%\n- -XX:ConcGCThreads=n\n并发GC使用的线程数\n- -XX:G1ReserverPercent=n\n设置作为空闲空间的预留内存占比，以降低目标空间溢出的风险，默认是10%\n\n###### 特点\n- G1能充分利用多CPU、多核环境硬件优势，尽量缩短STW。\n- G1整体上采用标记-整理算法，局部使用复制算法，不会产生内存碎片\n- 宏观上看G1不再区分新生代和老年代，把内存划分成多个独立的子区域（region），可以近似理解为一个围棋棋盘\n- G1收集器将整个内存区都混合为一起，但其本身依旧在小范围内进行新生代和老年代的区分，保留了新生代和老年代，但它们不是物理隔离，而是一部分region的集合，并且不需要region是连续，也就是说依然采用不同的GC方式来处理不同的区域。\n- G1虽然也是分代收集器，但整个内存分区不存在物理上的新生代和老年代的区别，也不需要完全独立的Survivor（to space）堆作复制准备。G1只有逻辑上的分代概念，或者说每个分区都有可能随着G1的运行在不同代之间前后切换\n\n###### G1和CMS相比的优势\n- G1不会产生内存碎片\n- 是可以精确控制停顿。该收集器是把整个堆（新生代、老年代）划分成多个固定大小的区域，每次根据允许停顿的时间区收集垃圾最多的区域\n\n### Server／Client模式分别是什么意思\n适用范围：只需要掌握Server模式即可，Client模式基本不会用操作系统\n- 32位Win操作系统，不论硬件如何都默认使用Client的JVM模式\n- 32位其他操作系统，2G内存同时有2个CPU以上用Server模式，低于该配置还是使用Client模64位only server模式\n\n### 如何选择垃圾收集器\n- 单CPU或者小内存，单机程序\n-XX:+UseSerialGC\n\n- 多CPU，需要最大吞吐量，如后台计算大型应用\n-XX:+UseParallelGC 或者\n-XX:+UseParallelOldGC\n\n- 多CPU，追求低停顿时间，需快速响应如互联网应用\n-XX:+UseConcMarkSweepGC\n-XX:+ParNewGC\n\n### 以前收集器特点\n- 新生代和老年代是各自独立且连续但内存块\n- 新生代收集使用单eden+s0+s1进行复制算法\n- 老年代收集必须扫描整个老年代区域\n- 都是以尽可能少而快速的执行GC为设计原则\n\n\n###  Java类加载过程\n#### 加载\n加载是类加载的第一个过程，在这个阶段，将完成一下三件事情：\n\n- 通过一个类的全限定名获取该类的二进制流。\n- 将该二进制流中的静态存储结构转化为方法去运行时数据结构。 \n- 在内存中生成该类的Class对象，作为该类的数据访问入口。\n#### 链接\n#####   验证\n 验证的目的是为了确保Class文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证: \n-  文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型. \n-  元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否继承了不被继承的类等。\n-  字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。\n-   符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。\n#####  准备\n准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。\n##### 解析\n该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。\n#### 初始化\n初始化是类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。\n\n\n\n#### 类加载\n类加载包含Main程序入口的类加载\n\n- 静态成员变量加载时执行到准备阶段将变量赋初始值（int 类型默认初始化为0，引用对象初始化为null）\n- 静态成员变量加载时执行到初始化阶段将变量赋值（private static int a=29，默认初始化为a=0，赋值初始化a=29；引用类型 初始化为对象实例)\n- 运行main方法\n\n>静态变量 （static int a）和静态引用变量（static  Object o）声明赋值是依据自上而下的顺序。\n\n###  JVM的参数类型\n####  标配参数\n- -version\n- -help\n-  java -showversion\n\n#### X参数(了解）\n- -Xint（解释执行）\n- -Xcomp（第一次使用就编译成本地代码）\n- -Xmixed（混合模式）\n\n#### XX参数\n##### Boolean类型\n- 公式\n  - -XX：+或者- 某个属性值\n  - +（开启）-（关闭）\n- Case\n  - 是否打印GC收集细节\n    -XX:-PrintGCDetails\n    -XX:+PrintGCDetails\n  - 是否使用串行垃圾回收器\n    -XX:-UseSerialGC\n    -XX:+UseSerialGC\n\n##### K-V设值类型\n-XX：属性key=属性value\n-XX:MetaspaceSize=128m\n-XX:MaxTenuringThreshold=15\n\n###  Jinfo\n任何查看当前运行程序的配置\njinfo -flag 配置项 进程编号\njinfo -flag IntialHeapSize 进程号\njinfo -flags 进程号\n\n### 查看JVM的默认值\n#### -XX:+PrintFlagsFinal\n主要查看修改更新\njava -XX:+PrintFlagsFinal -version\n:= 为人为修改过或初始加载修改过，= 为默认未改\nPrintFlagsFinal举例\n运行java命令的同时打印出参数\njava -XX:+PrintFlagsFinal -XX:MetaspaceSize=512m 类名\n\n#### -XX:+PrintCommandLineFlags\n主要看垃圾回收器，最后一个值\n\n#### -XX:+HeapDumpOnOutOfMemoryError \n设置内存溢出时dump内存快照\n\n### JVM常用参数\n#### -Xms（-XX:InitialHeapSize）\n初始大小内存，默认为物理内存1/64\n\n#### -Xmx（-XX:MaxHeapSize）\n最大分配内存，默认为物理内存1/4\n\n#### -Xss（-XX:ThreadStackSize）\n设置单个线程栈的大小，一般默认为512k～1024k\n\n#### -Xmn\n设置年轻代大小\n\n#### -XX:MetaspaceSize\n初始元空间大小\n\n元空间本质和永久代类似，都是对JVM规范方法中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。\n-Xms10m -Xmx10m  -XX:MetaspaceSize=1024m -XX：+PrintFlagsFinal\n\n#### -XX:MaxMetaspaceSize\n最大元空间大小，默认为-1，只受本地空间限制\n\n#### -XX:MaxDirectMemorySize\n最大直接内存大小，默认和 -Xmx 一致\n#### -XX:+PrintGCDetails\n1\t输出详细GC收集日志信息\n2\tGC：\n3\tFullGC：\n\n#### -XX:SurvivorRatio\n设置新生代中eden和s0/s1空间的比例\n默认-XX:ServivorRatio=8，Eden:S0:S1=8:1:1\n假如-XX:SurvivorRatio=4,\tEden::S0:S1=4:1:1\nSurvivorRatio值就是设置eden区的占比多少，s0/s1相同\n\n#### -XX:NewRatio\n配置年轻代与老年代在堆结构的占比，\n默认-XX:NewRatio=2 新生代占1，老年代占2，新生代占整个堆的1/3\n假如-XX:NewRatio=4 新生代占1，老年代占4，新生代占整个堆的1/5\nNewRatio值就是设置老年代的占比，剩下的1给新生代\n\n#### -XX:MaxTenuringThreshold\n设置进入老年代年龄\n典型设置案例\n-Xms128m -Xmx4096m -Xss1024k -XX:MetaspaceSize=512m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UseSerialGC\n\n### OOM\n#### java.lang.StackOverflowError\n\n虚拟机栈内存不足导致\n\n```java\npublic class StackOverflowErrorDemo {\n    public static void main(String[] args) {\n        stackError();\n    }\n\n    private static void stackError() {\n        stackError();\n    }\n}\n```\n\n#### java.lang.OutOfMemoryError:Java heap space\n\n- java虚拟机的对内存设置不够，可以通过-Xms和-Xmx来设置。生产中这两个参数会设置为一样，避免内存忽高忽低。\n- 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）\n\n```java\n/**\n * -Xms1m -Xmx1m\n */\npublic class OOM_heap_space {\n    public static void main(String[] args) {\n        byte[] bytes = new byte[20 * 1024 * 1024];\n    }\n}\n```\n#### java.lang.OutOfMemoryError:GC overhead limit exceeded\n\n```java\n/**\n * -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=10m\n */\npublic class GCOverheadDemo {\n    public static void main(String[] args) {\n        int i = 0;\n        ArrayList<String> list = new ArrayList<>();\n        try {\n            while (true) {\n                list.add(String.valueOf(++i).intern());\n            }\n        } catch (Exception e) {\n            System.out.println(\"+++++++i:\" + i);\n            e.printStackTrace();\n            throw e;\n        }\n    }\n}\n```\n#### java.lang.OutOfMemoryError:Direct buffer memory\n\n```java\n/**\n * -XX:MaxDirectMemorySize=3m -XX:+PrintGCDetails\n */\npublic class DirectBufferMemoryErrorDemo {\n    public static void main(String[] args) {\n        System.out.println(\"配置的MaxDirectMemorySize：\" + (sun.misc.VM.maxDirectMemory() / (double) 1024 / 1024 + \"MB\"));\n        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(6 * 1024 * 1024);\n    }\n}\n```\n#### java.lang.OutOfMemoryError:unbale to create new native thread\n\nroot 用户无限制 其他用户 linux 默认1024\n\n虚拟机栈内存不够用无法再创建新的线程。该异常是由于虚拟机栈内存被用尽导致无法再创建新线程，-Xss参数将直接导致所能创建线程的多少。\n\n```java\npublic class UnableCreateNewThreadDemo {\n    public static void main(String[] args) {\n        for (int i = 0; ; i++) {\n            final int tmp = i;\n            new Thread(() -> {\n                System.out.println(tmp);\n                try {\n                    TimeUnit.SECONDS.sleep(MAX_VALUE);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }, String.valueOf(i)).start();\n        }\n    }\n}\n```\n####\t java.lang.OutOfMemoryError:Metaspace\n\n```java\n/**\n * -XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m\n */\npublic class MetaspaceOOMDemo {\n    static class Temp {\n    }\n\n    public static void main(String[] args) {\n        int i = 0;\n        while (true) {\n            i++;\n            try {\n                Enhancer enhancer = new Enhancer();\n                enhancer.setSuperclass(Temp.class);\n                enhancer.setUseCache(false);\n                enhancer.setCallback(new MethodInterceptor() {\n                    @Override\n                    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n                        return methodProxy.invokeSuper(o, args);\n                    }\n                });\n                enhancer.create();\n            } catch (Throwable e) {\n                System.out.println(\"============\" + i);\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n### 生产环境服务器变慢，判断思路和性能评估\n- 整机：top\nuptime 是top精简版\n- CPU：vmstat\n- 查看所有CPU核信息：mpastat -P ALL 2\n- 每个进程使用CPU的用量分解信息：pidstat -u 1 -p 进程编号\n- 内存：free\n- pidstat -p 进程号 -r 采样间隔秒\n- 硬盘：df\n- 磁盘IO：iostat\n- 网络IO：ifstat\n\n### CPU占用过高，分析思路和定位\n- 先用top命令找出CPU占比最高的\n- ps -ef 或者jps 进一步定位，得知是一个怎样的后台程序\n- 定位到具体线程或者代码\n- ps -mp 进程 -o THRAD,tid,time\n- -m：显示所有的线程\n- -p pid 进程使用CPU的时间\n- -o 该参数后是用户自定义格式\n\n- 将需要的线程ID转换为16进制格式（英文小写）\n- printf \"%x\\n\" 有问题的线程ID\n- jstack 进程ID | grep tid（16进制线程ID）-A60\n\n## JUC\nJUC(java.util.concurrent)多线程及高并发\n\n### Volatile\n\n多线程访问成员变量时，会发生多个一个线程将变量数值该变，但是另一个线程可能无法感知变量的值的改变。使用volatile可以避免这种情况\n\nVolatile是Java虚拟机提供的轻量级的同步机制，低配版Synchronized\n\n#### 特性\n##### 保证可见性\n##### 禁止指令重排\n\n#### Volatile使用场景（DCL）\n- 单例模式DCL(Dobule Check Lock)代码\nDCL(双端检锁）机制不一定线程安全，是因为有指令重排序的存在，假如volatile可以禁止指令重排\n原因在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化。\n```java\ninstance=newSingletonDemo（）；可以分为以下3步：\nmemory =allocate();//1.分配内存空间\ninstance(memory); //2.初始化对象\ninstance =memory; //3.设置instance刚分配的内存地址，此时instance != null;\n步骤2和步骤3 不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化时允许的。\nmemory =allocate(); //1.分配内存对象\ninstance=memory; //3.设置instance刚分配的内存地址，此时instance != null， 但是对象还没有初始化完成！\ninstance(memory); //2.初始化对象\n```\n但是指令重排只会保证串行语义的执行的一致性（单线程），并不会关心多线程间语义的一致性。\n所以当一条线程访问instance不为null时，由于instance未必已经初始化完成，也就造成了线程安全问题。\n\n- 方案一(单线程）\n```java\npublic class SingletonDemo {\n    public static volatile SingletonDemo instance = null;\n\n    public class SingletonDemo {\n        public static SingletonDemo instance = null;\n\n        private SingletonDemo() {\n            System.out.println(\"aaa\");\n        }\n\n        //方案一\n        public static SingletonDemo getInstance() {\n            if (instance == null) {\n                instance = new SingletonDemo();\n            }\n            return instance;\n        }\n    }\n}\n```\n- 方案二（synchronized）\n```java\npublic class SingletonDemo {\n    public static SingletonDemo instance = null;\n\n    private SingletonDemo() {\n        System.out.println(\"aaa\");\n    }\n\n    //方案二\n    public static synchronized SingletonDemo getInstance() {\n        if (instance == null) {\n            instance = new SingletonDemo();\n        }\n        return instance;\n    }\n}\n```\n- 方案三(DCL+Volatile+Synchronized)\n```java\npublic class SingletonDemo {\n    public static volatile SingletonDemo instance = null;\n\n    private SingletonDemo() {\n        System.out.println(\"aaa\");\n    }\n\n    //方案三\n    public static SingletonDemo getInstance() {\n        if (instance == null) {\n            synchronized (SingletonDemo.class) {\n                if (instance == null) {\n                    instance = new SingletonDemo();\n                }\n            }\n        }\n        return instance;\n    }\n}\n```\n\n### JMM\n![Java线程内存模型JMM2](Java.assets/Java线程内存模型JMM2.png)\n\nJMM(Java内存模型  Java Memory Model，简称 JMM） 本身是一种抽象的概念并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。\n由于JVM运行程序的实体是线程，而每个内存创建时JVM都会为其创建一个工作内存（有些地方称为栈内存），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再讲变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程捡的通信（传值）必须通过主内存来完成。\n**JMM关于同步的规定**\n\n- 线程解锁前，必须把共享变量的值刷新回主内存\n- 线程加锁前，必须读取主内存的最新值到自己的工作内存\n- 加锁解锁是同一把锁\n\n\n#### 可见性\n各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作然后再写回到主内存。\n这就可能存在一个线程A修改了共享变量X的值但还未写回主内存时，另外一个线程B又对内存中同一个变量X进行操作，此时A线程工作内存中共享变量X对线程B来说并不可见，这种工作内存与主内存同步延迟现象造成了可见性问题\n\n#### 原子性\nnumber++在多线程下是非线程安全的，如何不加Synchronized解决\nVolatileDemo代码演示可见性+原子性代码\n\n#### 有序性\n计算机在执行程序时，为了提高性能，编译器和处理器得常常对指令做重排，一般分为3种：\n单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致\n处理器在进行重排序时必须要考虑指令间的数据依赖性\n多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测\n\n- 重排1\n```java\npublic void mySort(){\nint x=1;  //语句1\nint y=2;  //语句2\nx=x+5;   //语句3\ny=x*x;   //语句4\n}\n1234\n2134\n...\n语句4由于存在数据依赖性不会先执行\n```\n- 重排2\n```java\npublic class ReSortSeqDemo {\nint a = 0;\nboolean flag = false;\npublic void method01() {\na = 1;\nflag = true;\n}\npublic void method02() {\nif (flag) {\na = a + 5;\nSystem.out.println(\"**********retValue:\" + a);\n}\n}\n}\n```\n-  禁止指令重排\nvolatile实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象\n先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：\n一是保证特定操作的执行顺序\n二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）\n由于编译器和处理器都能进行指令重排优化。如果在指令插入一条Memory Barrier则会告诉编译器和CPU，不管什么时候都不能和这条Memory Barrier指令重新排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。内存屏障的另一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。\n\n\n\n### CAS（comparAndSwap) \n比较并交换\n比较当前工作内存中的值和主内存中的值，如果相同则进行规定操作，否则继续比较直到主内存中的值和工作内存中的值一致为止\nCAS有三个操作数，内存值V，旧的预期值A，要修改的更新值B。\n当且仅当预期值A和内存值B相同时，将内存值V修改为B，否则什么也不做。\n\n#### 概念\nCAS的全称为compare-and-swap，它是一条cpu并发原语。\n它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。\nCAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统原语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条cpu的原子指令，不会造成所谓的数据不一致问题。\n\n\n##### 底层汇编\nUnsafe类中的compareAndSwapInt，是一个本地方法，该方法的实现位于unsafe.cpp中是CAS的核心类，由于Java无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为CAS操作的执行依赖于Unsafe类的方法。\n注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务。 unsafe 位于rt.jar包中\nunsafe.getAndAddInt\n\n```java\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n\t\t\t\t int var5;\n\t\t\t\tdo {\n\t\t\t\t   var5 = this.getIntVolatile(var1, var2);\n\t\t\t  } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n\t\t\t return var5;\n\t}\n```\nvar1 atomicInteger 对象本身。\nvar2 该对象值的引用地址\nvar4  需要变动的数值\nvar5 是用过var1 var2找出的内存中真实的值\n用该对象当前的值与var5比较\n如果相同，更新var5+var4并且返回true\n如果不同，继续取值然后再比较，直到更新完成\n假设线程A和线程B两个线程同时执行getAndAddInt操作（分别跑在不同cpu上）：\n\n- atomicInteger里面的value原始值为3，即内存中atomicInteger的value为3，根据JMM模型，线程A和线程B各自持有一份值为3的value副本分别到各自的工作内存。\n- 线程A通过getIntVolatile（var1，var2）拿到value值3，这时线程A被挂起。\n- 线程B也通过getIntVolatile（var1，var2）方法获取value值3，此时线程B刚好没有被挂起并执行compareAndSwapInt方法比较内存值也为3，成功修改内存值为4，线程B打完收工，一切ok\n- 这时线程A恢复，执行compareAndSwapInt方法比较，发现自己手里的值3和内存中的值4不一致，说明该值已经被其他线程抢先一步修改过了，那A线程本次修改失败，只能重新读取重新来一遍。\n- 线程A重新获取value值，因为变量value被volatile修饰，所以其他线程对它的修改，线程A总是能够看到，线程A继续执行compareAndSwapInt方法进行比较替换，直到成功\n  \n#### CAS的缺点\n##### 循环时间长开销很大\n```java\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n    int var5;\n    do {\n        var5 = this.getIntVolatile(var1, var2);\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n    return var5;\n}\n```\n我们可以看到getAndAddInt时，有个do while操作，如果CAS失败时，会一直进行尝试。如果CAS长时间一直不成功，可能会给cpu带来很大的开销。\n##### 只能保证一个共享变量的原子操作\n当对一个共享变量进行操作时，我们可以使用循环CAS来保证原子操作，但是，对于多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。\n##### 引出来ABA问题\n\n### ABA\n比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。\n原子类AtomicInteger的ABA问题(狸猫换太子) 原子类更新引用\n\n#### ABA问题产生\nCAS会导致ABA问题\nCAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻进行比较并替换，那么在这个时间差会导致数据的变化。\n比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且线程two进行来一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中国年依然是A，然后线程one操作成功。\n尽管线程one的CAS的操作成功，但是并不代表这个过程就是没有问题的。\n\n#### 原子引用(AtomicReference)\n\n```java\nclass User {\n    String userName;\n    int age;\n\n    public User(String userName, int age) {\n        this.userName = userName;\n        this.age = age;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"User(userName：\" + userName + \"，Age：\" + age + \")\";\n    }\n}\n\npublic class AtomicReferenceDemo {\n    public static void main(String[] args) {\n        User zhangsan = new User(\"zhangsan\", 23);\n        User lisi = new User(\"lisi\", 25);\n        AtomicReference<User> reference = new AtomicReference<>();\n        reference.set(zhangsan);\n        System.out.println(reference.compareAndSet(zhangsan, lisi) + \"\\t\" + reference.get().toString());\n        System.out.println(reference.compareAndSet(zhangsan, lisi) + \"\\t\" + reference.get().toString());\n    }\n}\n```\n#### 时间戳原子引用(AtomicStampedReference)\n\nABA问题的解决方案\n\n```java\n\tpublic class AtomicStmapedReferenceDemo {\n    static AtomicReference atomicReference = new AtomicReference<Integer>(100);\n    static AtomicStampedReference atomicStampedReference = new AtomicStampedReference<>(100, 1);\n\n    public static void main(String[] args) throws InterruptedException {\n        System.out.println(\"================以下是ABA问题的产生================\");\n        new Thread(() -> {\n            atomicReference.compareAndSet(100, 101);\n            atomicReference.compareAndSet(101, 100);\n        }, \"t1\").start();\n        new Thread(() -> {\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(atomicReference.compareAndSet(100, 2019) + \"\\t\" + atomicReference.get());\n        }, \"t2\").start();\n        TimeUnit.SECONDS.sleep(3);\n        System.out.println(\"=================以下是ABA问题的解决方案=====================\");\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName() + \"\\t第一次版本号：\" + atomicStampedReference.getStamp());\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            atomicStampedReference.compareAndSet(100, 101, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);\n            System.out.println(Thread.currentThread().getName() + \"\\t第二次版本号：\" + atomicStampedReference.getStamp());\n            atomicStampedReference.compareAndSet(101, 100, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);\n            System.out.println(Thread.currentThread().getName() + \"\\t第三次版本号：\" + atomicStampedReference.getStamp());\n        }, \"t3\").start();\n        new Thread(() -> {\n            int stamp = atomicStampedReference.getStamp();\n            System.out.println(Thread.currentThread().getName() + \"\\t第一次版本号：\" + stamp);\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            boolean flag = atomicStampedReference.compareAndSet(100, 2019, stamp, stamp + 1);\n            System.out.println(Thread.currentThread().getName() + \"\\t是否修改成功：\" + flag);\n            System.out.println(Thread.currentThread().getName() + \"\\t当前实际值：\" + atomicStampedReference.getReference() + \"\\t当前实际版本号：\" + atomicStampedReference.getStamp());\n        }, \"t4\").start();\n    }\n}\n```\n\n### AQS（AbstractQueuedSynchronizer）\nAQS 是 AbstractQueuedSynchronizer 的简称，它是一个 Java 提高的底层同步 工具类，用一个 int 类型的变量表示同步状态，并提供了一系列的 CAS 操作来管 理这个同步状态。\nAQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广 泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。\n\n#### **AQS 支持两种同步方式** \n- 独占式\n- 共享式\n这样方便使用者实现不同类型的同步组件，独占式如 ReentrantLock，共享式如 Semaphore，CountDownLatch，组合式的如 ReentrantReadWriteLock。总之， AQS 为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。\n\n### 线程\n\n#### 线程六种状态\n- NEW：新建状态 刚刚创建出来，还没有调用start方法之前的状态。\n- RUNNABLE:可运行状态，可能正在执行，也可能不是正在执行，只有在该种状态下的线程才有资格抢CPU。\n- BLOCKED:锁阻塞状态  线程要等待另一个线程释放锁对象。\n- WAITING：无限等待  线程调用了wait()方法进入的状态，需要其它线程调用notify方法唤醒。\n- TIMED_WAITING:计时等待状态  线程调用了sleep方法获wait（long time）方法进入的状态。\n- TERMINATED:死亡状态  线程任务执行完毕或调用了stop方法。\n\n#### ConcurrentModificationException\n线程不安全\n- ArrayList\n- HashMap\n- HashSet\n\n\n```java\npublic class ContainerNotSafeDemo {\n    public static void main(String[] args) {\n\n    }\n\n    private static void MapNotSafe() {\n        Map map = new HashMap();\n        for (int i = 0; i < 30; i++) {\n            new Thread(() -> {\n                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 8));\n                System.out.println(map);\n            }).start();\n        }\n    }\n\n    private static void SetNotSafe() {\n        Set set = new HashSet();\n        for (int i = 0; i < 30; i++) {\n            new Thread(() -> {\n                set.add(UUID.randomUUID().toString().substring(0, 8));\n                System.out.println(set);\n            }).start();\n        }\n    }\n\n    private static void ListNotSafe() {\n        List<String> list = new ArrayList<>();\n        for (int i = 0; i < 30; i++) {\n            new Thread(() -> {\n                list.add(UUID.randomUUID().toString().substring(0, 8));\n                System.out.println(list);\n            }).start();\n        }\n    }\n}\n```\n- 解决方案1\n```java\npublic class ContainerNotSafeDemo {\n    public static void main(String[] args) {\n    }\n\n    private static void MapNotSafe() {\n        Map map = new HashMap();/// Collections.synchronizedMap(new HashMap<>());new ConcurrentHashMap<>();\n        for (int i = 0; i < 30; i++) {\n            new Thread(() -> {\n                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 8));\n                System.out.println(map);\n            }).start();\n        }\n    }\n\n    private static void SetNotSafe() {\n        Set set = new HashSet();// Collections.synchronizedSet(new HashSet<>());new CopyOnWriteArraySet<>();\n        for (int i = 0; i < 30; i++) {\n            new Thread(() -> {\n                set.add(UUID.randomUUID().toString().substring(0, 8));\n                System.out.println(set);\n            }).start();\n        }\n    }\n\n    private static void ListNotSafe() {\n        List<String> list = new ArrayList<>();//new Vector<>(); Collections.synchronizedList(new ArrayList<>());new CopyOnWriteArrayList<>();\n        for (int i = 0; i < 30; i++) {\n            new Thread(() -> {\n                list.add(UUID.randomUUID().toString().substring(0, 8));\n                System.out.println(list);\n            }).start();\n        }\n    }\n}\n```\n- 解决方案2（限制不可以使用vector和collections工具类）\n  写时复制\n  CopyOnWrite容器即写时复制容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements,然后新的容器Object[] newElements里面添加元素，添加完元素之后，再将原容器的引用指向新容器setArray（newElements）；，这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。\n```java\n/**\n * Appends the specified element to the end of this list.\n *\n * @param e element to be appended to this list\n * @return {@code true} (as specified by {@link Collection#add})\n */\npublic boolean add(E e) {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n        Object[] elements = getArray();\n        int len = elements.length;\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        newElements[len] = e;\n        setArray(newElements);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n```\n- Demo\n```java\npublic class ContainerNotSafeDemo {\n    public static void main(String[] args) {\n        List<String> list = new CopyOnWriteArrayList<>();\n        for (int i = 0; i <30 ; i++) {\n            new Thread(()->{\n                list.add(UUID.randomUUID().toString().substring(0,8));\n                System.out.println(list);\n            }).start();\n        }\n    }\n}\n```\n#### 线程接口\n- 分类\n  - Runnable\n  - Callable\n- 区别\n  - Callable有返回值，Runnable没有 返回值\n  - Callable抛异常，Runnable不抛异常\n  - 落地方法不一样，Callable是call，Runnable是run\n\n#### 多线程辅助类\nCountDownLatch/CyclicBarrier/Semaphore /ReadWriteLock\n\n##### ReadWriteLock\n读读共存，读写、写写不共存\n\n##### CountDownLatch（火箭倒计时）\n减一直到为0\n让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒。\nCountDownLatch主要有两个方法，当一个或多个线程调用await方法，调用线程会被阻塞。其它线程调用countDown方法会将计数器减1（调用countDown的方法不会阻塞），当计数器的值变为零时，因调用await方法被阻塞的线程会被唤醒，继续执行。\n\nmain线程会等待其他线程执行完后接着执行\n\n```java\npublic class CountDownLatchDemo  {\n\n    public static void main(String[] args) throws InterruptedException {\n        Random random=  new Random();\n        CountDownLatch latch = new CountDownLatch(10);\n\n        for (int i=0;i<10;i++){\n            new Thread(()->{\n                try {\n                    TimeUnit.SECONDS.sleep(random.nextInt(5));\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName());\n                latch.countDown();\n            },String.valueOf(i)).start();\n        }\n\n\n        latch.await();\n\n        System.out.println(\"game over\");\n\n    }\n}\n```\n\n\n\n##### CyclicBarrier（集齐七龙珠，召唤神龙）\n加一\nCyclicBarrier 的字面意思是可以循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，让一组线程达到一个屏障（同步点）时被阻塞，直到最后一个线程达到屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await方法。\n\n主线程会和其他线程一起并发执行\n\n```java\npublic class CyclicBarrierDemo {\n    public static void main(String[] args) {\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {\n            System.out.println(\"===========召唤神龙========\");\n        });\n        for (int i=1;i<=7;i++){\n            final  int tmp=i;\n            new Thread(()->{\n                System.out.println(Thread.currentThread().getName() + \"\\t 获得第 \" + tmp + \" 颗龙珠\");\n                try {\n                    cyclicBarrier.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n            },String.valueOf(i)).start();\n        }\n    }\n}\n```\n##### Semaphore（抢停车位）\n多线程抢占固定资源\n信号量主要有两个目的，一个是用于多个资源的互斥，另一个是用于并发线程数的控制。\n\n主线程会和其他线程并发执行\n\n```java\npublic class SemaphoreDemo {\n    public static void main(String[] args) {\n        Semaphore semaphore = new Semaphore(3);\n        for (int i=0;i<10;i++){\n            new Thread(()->{\n                try {\n                    semaphore.acquire();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + \"\\t 抢到停车位\");\n                try {\n                    TimeUnit.SECONDS.sleep(3);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }finally {\n                    semaphore.release();\n                }\n                System.out.println(Thread.currentThread().getName() + \"\\t 离开了\");\n            },String.valueOf(i)).start();\n        }\n    }\n}\n```\n\n### 线程池\n\n线程复用，控制最大并发数，管理线程 \n\n#### 架构说明\nJava中线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类。\n\n#### 了解\n- Executors.newScheduledThreadPool()\n- java8新出（Executors.newWorkStealingPool(int）\n\njava8 新增，使用目前机器上可用的处理器作为它的并行级别\n\n#### Executors.newFixedThreadPool(int)\n```java\n/**\n * Creates a thread pool that reuses a fixed number of threads\n * operating off a shared unbounded queue.  At any point, at most\n * {@code nThreads} threads will be active processing tasks.\n * If additional tasks are submitted when all threads are active,\n * they will wait in the queue until a thread is available.\n * If any thread terminates due to a failure during execution\n * prior to shutdown, a new one will take its place if needed to\n * execute subsequent tasks.  The threads in the pool will exist\n * until it is explicitly {@link ExecutorService#shutdown shutdown}.\n *\n * @param nThreads the number of threads in the pool\n * @return the newly created thread pool\n * @throws IllegalArgumentException if {@code nThreads <= 0}\n */\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n            0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue<Runnable>());\n}\n```\n主要特点：\n\n- 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待\n\n- newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlokingQueue\n\n  场景：\n  执行长期的任务，性能好很多\n\n#### Executors.newSingleThreadExecutor()\n```java\n/**\n * Creates an Executor that uses a single worker thread operating\n * off an unbounded queue. (Note however that if this single\n * thread terminates due to a failure during execution prior to\n * shutdown, a new one will take its place if needed to execute\n * subsequent tasks.)  Tasks are guaranteed to execute\n * sequentially, and no more than one task will be active at any\n * given time. Unlike the otherwise equivalent\n * {@code newFixedThreadPool(1)} the returned executor is\n * guaranteed not to be reconfigurable to use additional threads.\n *\n * @return the newly created single-threaded Executor\n */\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                    0L, TimeUnit.MILLISECONDS,\n                    new LinkedBlockingQueue<Runnable>()));\n}\n```\n主要特点：\n1\t创建一个单线化的线程池，它只会用唯一的工作线程来执行任务，保证任务按照指定顺序执行\n2\tnewSingleThreadExecutor将corePoolSize和maxmiumPoolSize都设置为1，它使用的是LinkedBlockingQueue\n场景：\n任务顺序执行\n#### Executors.newCachedPool()\n```java\n/**\n * Creates a thread pool that creates new threads as needed, but\n * will reuse previously constructed threads when they are\n * available.  These pools will typically improve the performance\n * of programs that execute many short-lived asynchronous tasks.\n * Calls to {@code execute} will reuse previously constructed\n * threads if available. If no existing thread is available, a new\n * thread will be created and added to the pool. Threads that have\n * not been used for sixty seconds are terminated and removed from\n * the cache. Thus, a pool that remains idle for long enough will\n * not consume any resources. Note that pools with similar\n * properties but different details (for example, timeout parameters)\n * may be created using {@link ThreadPoolExecutor} constructors.\n *\n * @return the newly created thread pool\n */\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n            60L, TimeUnit.SECONDS,\n            new SynchronousQueue<Runnable>());\n}\n```\n主要特点：\n1\t创建一个可缓存线程池，如果线程池长度超过处理要求，可灵活回收空线程，若无可回收，则新建线程。\n2\tnewCacheThreadPool将coreSize设置为0，将maxmiumSize设置为Integer.MAX_VALUE，使用的是SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程\n场景：\n执行很多短期异步的小程序或者负载较轻的服务\n\n\n#### 7大参数\n```java\n/**\n * Creates a new {@code ThreadPoolExecutor} with the given initial\n * parameters and default thread factory and rejected execution handler.\n * It may be more convenient to use one of the {@link Executors} factory\n * methods instead of this general purpose constructor.\n *\n * @param corePoolSize the number of threads to keep in the pool, even\n *        if they are idle, unless {@code allowCoreThreadTimeOut} is set\n * @param maximumPoolSize the maximum number of threads to allow in the\n *        pool\n * @param keepAliveTime when the number of threads is greater than\n *        the core, this is the maximum time that excess idle threads\n *        will wait for new tasks before terminating.\n * @param unit the time unit for the {@code keepAliveTime} argument\n * @param workQueue the queue to use for holding tasks before they are\n *        executed.  This queue will hold only the {@code Runnable}\n *        tasks submitted by the {@code execute} method.\n * @throws IllegalArgumentException if one of the following holds:<br>\n *         {@code corePoolSize < 0}<br>\n *         {@code keepAliveTime < 0}<br>\n *         {@code maximumPoolSize <= 0}<br>\n *         {@code maximumPoolSize < corePoolSize}\n * @throws NullPointerException if {@code workQueue} is null\n */\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue) {\n    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n            Executors.defaultThreadFactory(), defaultHandler);\n}\n```\n##### corePoolSize\n线程池中的常驻核心线程数\n\n##### maximumPoolSize\n线程池能够容纳同时执行的最大线程数，此值必须大于等于1\n\n##### keepAliveTime\n多余的空闲线程的存活时间。\n当前线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止\n默认情况下：\n只有当线程池中的线程数大于corePoolSize时，keepAlive才会起作用，直到线程池中的线程数不大于corePoolSize\n\n##### unit\nkeepAliveTime的单位\n##### workQueue\n任务队列，被提交但尚未被执行的任务\n##### threadFactory\n表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可\n##### handler\n拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runnable的策略\n等待队列也已经满了，再也塞不下新任务了\n同时，线程池中的max线程也达到了，无法继续为信任服务\n这时候我们就需要拒绝策略机制合理的处理这个问题\n\n- AbortPolicy（默认）\n中断抛异常\n- CallerRunsPolicy\n调用者运行。该策略既不会抛弃任务也不会抛异常，而是将任务回退给调用者，从而降低新任的流量\n- DiscardPolicy\n该策略会默默的抛弃无法处理的任务，不予任何处理也不会抛异常。如果任务允许丢失，这是最好的一种策略\n- DiscardOldestPolicy\n抛弃队列中等待最久的任务，把当前任务加入队列中尝试再次提交任务\n\n\n#### 说说线程池底层的工作原理\n- 在创建来线程池后，等待提交过来的任务请求\n- 当调用execute()方法添加一个任务时，线程池会作以下判断：\n  - 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务\n  -\t如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务加入队列\n  -\t如果这时队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程运行这个任务\n  - 如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行\n-\t当一个线程完成任务是，它会从队列中取下一个任务来执行\n-\t当一个线程无事可做超过一定的时间（keepAliveTime）时，线程池会判断：\n如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。\n所以线程池的所有任务完成后它最终会收缩到corePoolSize的大小。\n\n#### execute方法 和submit方法的区别\n- execute 没有返回值，submit带有返回值\n- execute可以传入Runnable接口，submit可以传入Runnable和Callable接口\n\n\n#### 合理配置线程池你是如何考虑的\n\n##### CPU密集型\n\nCPU密集型，即该任务需要大量CPU运算，没有阻塞，CPU一直处于全速运行状态\nCPU密集型任务只有在真正多核CPU上才可能得到加速（通过多线程）\n在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些\nCPU密集型任务配置尽可能少的线程数量：\n一般公式：线程池=CPU核数+1个线程\nRuntime.getRuntime().availableProcessors()+[1-2]\n\n##### IO密集型\n- 方案一\n由于IO密集型任务线程并不是一直在执行任务，则应该配置尽可能多的线程，如CPU核数*2\n\n- 方案二\nIO密集型，该任务需要大量的IO操作，即大量的阻塞\n在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力在等待上，所以在IO密集型任务中使用多线程可以大大的加速程序运行，在单核CPU上，这种加速主要就是利用了被浪费的阻塞时间\nIO密集型，大部分线程都在阻塞，故要多配置线程数：\n参考公式：CPU核数／1-阻塞系数\n阻塞系数=0.8～0.9\n阻塞系数一般取0.9\n比如8核CPU：8/（1-0.9）=80个线程数\n\n### 队列\n阻塞队列，顾名思义，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下：\n线程1往队列中添加元素，而线程2从阻塞队列中移除元素\n当阻塞队列是空时，从队列中获取元素的操作将会被阻塞。\n当阻塞队列满的时候，往队列中添加元素的操作将会被阻塞。\n试图从空的阻塞队列中国年获取元素的线程将会阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程从队列中移除一个或多个元素或者完全清空队列后使队列重新变得空闲起来并后续新增。\n#### 作用\n在多线程领域：所谓阻塞。在某些情况下会挂起线程（即阻塞），一旦条件被满足，被挂起的线程又会自动被唤醒\n#### BlockingQueue\n\n空的时候不能获取，满的时候不能生产 \n\n好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手操办了。\n在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，而这会使我们的程序带来不小的复杂度。\n\n##### ArrayBlockingQueue\n由数组结构组成的有界阻塞队列\n\n##### LinkedBlockingQueue\n由链表结构构成的有界队列（但大小默认值为Inter.MAX_VALUE）阻塞队列\n\n##### PriorityBlockingQueue\n支持优先级排序的无界阻塞队列\n\n##### DelayQueue\n使用优先级队列实现的延迟无界阻塞队列\n\n##### SynchronousQueue\n\n不存储元素的阻塞队列，也即单个元素的队列\nSynchronousQueue 没有容量\n与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue\n每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然\n\n- Demo\n```java\npublic class SynchronousQueueDemo {\n    public static void main(String[] args) {\n        SynchronousQueue<Object> synchronousQueue = new SynchronousQueue<>();\n        new Thread(() -> {\n            try {\n                System.out.println(Thread.currentThread().getName() + \"\\t put 1\");\n                synchronousQueue.put(\"1\");\n                System.out.println(Thread.currentThread().getName() + \"\\t put 2\");\n                synchronousQueue.put(\"2\");\n                System.out.println(Thread.currentThread().getName() + \"\\t put 3\");\n                synchronousQueue.put(\"3\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }, \"t1\").start();\n        new Thread(() -> {\n            try {\n                System.out.println(Thread.currentThread().getName() + \"\\t take 1\");\n                synchronousQueue.take();\n                TimeUnit.SECONDS.sleep(5);\n                System.out.println(Thread.currentThread().getName() + \"\\t take 2\");\n                synchronousQueue.take();\n                TimeUnit.SECONDS.sleep(5);\n                System.out.println(Thread.currentThread().getName() + \"\\t take 3\");\n                synchronousQueue.take();\n                TimeUnit.SECONDS.sleep(5);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, \"t2\").start();\n    }\n}\n```\n##### LinkedTransferQueue\n由链表结构组成的无界阻塞队列\n##### LinkedBlockingDeque\n由链表结构组成的双向阻塞队列\n\n#### 核心方法\n##### 抛异常\n- add\n当队列满时，再添加元素会抛出异常（Queue Full）\n- remove\n当队列空时，再移除元素会抛出异常（NoSuchElementException）\n- element\n检查队列第一个元素\n\n##### 有返回值\n- offer(e)\n当队列满时，再添加元素不会抛出异常会返回false\n- poll\n当队列空时，再移除元素不会抛出异常会返回null\n- peek\n检查队列第一个元素\n\n##### 阻塞\n- put\n当队列满时，再添加元素会一直阻塞，直到可以添加元素\n- take\n当队列空时，再移除元素会一直阻塞，直到有元素可以移除\n\n##### 超时\n- offer(e,time,unit)\n当队列满时，再添加元素会等待，直到超时时间到达，返回false\n- poll(time,unit)\n当队列空时，再移除元素会等待，直到超时时间到达，返回null\n\n#### 场景\n##### 生产者消费者模式\t\n- 传统版\n- Demo\n```java\nclass ShareData{\n    int number=0;\n    Lock lock=new ReentrantLock();\n    Condition condition=lock.newCondition();\n    public void increment()throws Exception{\n        lock.lock();\n        try{\n            while (number!=0){\n                condition.await();\n            }\n            number++;\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + number);\n            condition.signalAll();\n        }catch (Exception e){\n            e.printStackTrace();\n        }finally {\n            lock.unlock();\n        }\n    }\n    public void decrement()throws Exception{\n        lock.lock();\n        try{\n            while (number==0){\n                condition.await();\n            }\n            number--;\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + number);\n            condition.signalAll();\n        }catch (Exception e){\n            e.printStackTrace();\n        }finally {\n            lock.unlock();\n        }\n    }\n}\npublic class ProdConsumer_TraditionDemo {\n    public static void main(String[] args) {\n        ShareData shareData = new ShareData();\n        new Thread(() -> {\n            for (int i = 0; i < 5; i++) {\n                try {\n                    shareData.increment();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }, \"t1\").start();\n        new Thread(() -> {\n            for (int i = 0; i < 5; i++) {\n                try {\n                    shareData.decrement();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n        }, \"t2\").start();\n    }\n}\n```\n- 阻塞队列版\n\n## 锁\n公平锁／非公平锁／可重入锁／递归锁／自旋锁\n\n### 四种状态\n#### 无锁\n#### 偏向锁\n#### 轻量级锁\n#### 重量级锁\n\n### 锁的升级\n当只有一个线程访问是叫做偏向锁——>发生竞争时升级成轻量级锁（自选锁等）——>自选等待没结果时升级成重量级锁\n\n###  公平锁\n是指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先来后到。\n###  非公平锁\n是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发的情况下，有可能会造成优先级反转或者饥饿现象。\n### 公平锁／非公平锁 两者区别\n并发包中ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或非公平锁，默认是非公平锁。\nJava ReentrantLock 而言，通过构造函数指定该锁是否是公平锁（默认是非公平锁）。非公平锁的优点在于吞吐量比公平锁大。\n对于Synchronized而言，也是一种非公平锁。\n\n```java\n/**\n * Creates an instance of {@code ReentrantLock}.\n * This is equivalent to using {@code ReentrantLock(false)}.\n */\npublic ReentrantLock() {\n    sync = new NonfairSync();\n}\n\n/**\n * Creates an instance of {@code ReentrantLock} with the\n * given fairness policy.\n *\n * @param fair {@code true} if this lock should use a fair ordering policy\n */\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n```\n公平锁：Threads acquire a fair lock in the order in which they requested it\n公平锁，就是很公平，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己\n非公平锁：Threads acquire a fair lock in the order in which they requested it\n非公平锁比较粗鲁，上来就尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。\n\n### 可重入锁（递归锁）\n\n指的是统一线程外层函数获得锁之后，内层递归函数仍然能获取该所的代码。\n统一线程在外层方法获取锁之后，进入内层方法后会自动获取锁。也就是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。\n\n- ReentrantLock/Synchronized就是一个典型的可重入锁\n- 可重入锁的最大作用就是避免死锁\n- ReenterLockDemo\n```java\nclass Phone implements  Runnable{\n    public synchronized void  sedSMS(){\n        System.out.println(Thread.currentThread().getName()+\"\\t invoked sendSMS\");\n        sedMail();\n    }\n    public synchronized void  sedMail(){\n        System.out.println(Thread.currentThread().getName()+\"\\t invoked sedMail\");\n    }\n    @Override\n    public void run() {\n        get();\n    }\n    public void get(){\n        Lock lock = new ReentrantLock();\n        lock.lock();\n        try{\n            System.out.println(Thread.currentThread().getName()+\"\\t invoked get\");\n            set();\n        }finally {\n            lock.unlock();\n        }\n    }\n    public void set(){\n        Lock lock = new ReentrantLock();\n        lock.lock();\n        try{\n            System.out.println(Thread.currentThread().getName()+\"\\t invoked set\");\n        }finally {\n            lock.unlock();\n        }\n    }\n}\npublic class ReenterLockDemo {\n    public static void main(String[] args) throws InterruptedException {\n        Phone phone = new Phone();\n        new Thread(()->{phone.sedSMS();},\"t1\").start();\n        new Thread(()->{phone.sedSMS();},\"t2\").start();\n        TimeUnit.SECONDS.sleep(2);\n        System.out.println(\"=======================\");\n        System.out.println();\n        System.out.println();\n        System.out.println();\n        new Thread(phone,\"t3\").start();\n        new Thread(phone,\"t4\").start();\n    }\n}\n```\n### 独占锁\n指该锁一次只能被一个线程持有。对ReentrantLock和Synchronized而言都是独占锁\n\n### 共享锁\n指该锁可被多个线程所持有\n对ReentrantReadWriteLock其读锁是共享锁，其写锁是独占锁\n读锁对共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。\n\n```java\npublic class ReadWriteLockDemo {\n    volatile Map map= new HashMap<String,Object>();\n    ReadWriteLock rwLock=new ReentrantReadWriteLock();\n    public void get(String key) throws InterruptedException {\n        rwLock.readLock().lock();\n        try{\n            System.out.println(Thread.currentThread().getName()+\"\\t 正在读\");\n            TimeUnit.MILLISECONDS.sleep(300);\n            Object res=map.get(key);\n            System.out.println(Thread.currentThread().getName()+\"\\t 读完成：\"+res);\n        }catch (Exception e){\n            e.printStackTrace();\n        }finally{\n            rwLock.readLock().unlock();\n        }\n    }\n    public void put(String key,Object value) throws InterruptedException {\n        rwLock.writeLock().lock();\n        try{\n            System.out.println(Thread.currentThread().getName()+\"\\t 正在写：\"+key);\n            TimeUnit.MILLISECONDS.sleep(300);\n            map.put(key,value);\n            System.out.println(Thread.currentThread().getName() + \"\\t 写完成\");\n        }catch (Exception e){\n            e.printStackTrace();\n        }finally{\n            rwLock.writeLock().unlock();\n        }\n    }\n    public static void main(String[] args) {\n        ReadWriteLockDemo readWriteLockDemo = new ReadWriteLockDemo();\n        for (int i=0;i<10;i++){\n            final int tmp=i;\n            new Thread(()->{\n                try {\n                    readWriteLockDemo.put(tmp+\"\",tmp);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            },String.valueOf(i)).start();\n        }\n        for (int i=0;i<5;i++){\n            final int tmp=i;\n            new Thread(()->{\n                try {\n                    readWriteLockDemo.get(tmp+\"\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            },String.valueOf(i)).start();\n        }\n    }\n}\n```\n### 自旋锁（spinlock）\n是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式尝试去获取锁，这样的好出是减少线程上下文切换的消耗，缺点是循环会消耗CPU\n```java\n//unsafe.getAndAddInt\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n    int var5;\n    do {\n        var5 = this.getIntVolatile(var1, var2);\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n    return var5;\n}\n```\n- Demo\n```java\npublic class SpinLockDemo {\n    AtomicReference<Thread> atomicReference=new AtomicReference<>();\n    public void myLock(){\n        Thread thread=Thread.currentThread();\n        System.out.println(thread.getName()+\"\\t come in \");\n        while (!atomicReference.compareAndSet(null,thread)){}\n    }\n    public void myUnLock(){\n        atomicReference.compareAndSet(Thread.currentThread(),null);\n        System.out.println(Thread.currentThread().getName()+\"\\t out \");\n    }\n    public static void main(String[] args) throws InterruptedException {\n        SpinLockDemo spinLockDemo = new SpinLockDemo();\n        new Thread(()->{\n            spinLockDemo.myLock();\n            try {\n                TimeUnit.SECONDS.sleep(5);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            spinLockDemo.myUnLock();\n        },\"t1\").start();\n        TimeUnit.SECONDS.sleep(1);\n        new Thread(()->{\n            spinLockDemo.myLock();\n            spinLockDemo.myUnLock();\n        },\"t2\").start();\n    }\n}\n```\n### Synchornized\n实现同步方法的基础是Java中的每个对象都可以作为锁\nSynchronized （对象锁），static synchronized （类锁|全局锁），这两种锁互补影响，互相没有关系，可以同时访问\n\n#### 具体表现\n- 对于普通同步方法，锁的是当前实例对象，锁的是this\n- 对于同步方法块，锁的是synchroniezd括号里面的配置对象\n- 对于静态同步方法，锁的是当前类的Class对象\n\n#### Synchronized与Lock有什么区别\n##### 原始构成\n- Synchronized是关键字属于JVM层面，底层是通过monitor对象来完成，其wait／notify等方法也依赖与monitor对象，只有在同步块或方法中才能调用wait／notify等方法\n  monitorenter   进入，monitorexit\t退出（有两层退出，正常情况和非正常情况都能退出，不会造成死锁）\n- Lock 是API层面\n\n##### 使用方法\n- Synchronized 不需要用户手动去释放锁，当synchronized代码执行完成后系统会自动让线程释放对锁的占用\n- ReentrantLock则需要用户手动去释放锁，若没有主动释放锁，就有可能出现死锁现象\n  需要lock和unlock方法配合try finally 语句完成\n\n##### 等待是否可中断\n- Synchronized不可中断，除非抛出异常或者正常执行完成\n- ReentrantLock可中断\n  - 设置超时方法 tryLock（long timeout，TimeUtil unit）\n  - lockInterruptibly（）放代码块中，调用interrupt（）可中断\n\n##### 加锁是否公平\n- Synchronized 非公平锁\n- ReentrantLock 两者都可以，默认非公平锁，构造方法可传入boolean值，true为公平锁，false为非公平锁\t\n\n##### 锁绑定多个条件Condition\n- Synchronized 没有\n- ReentrantLock用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不像synchronized要么随机唤醒一个线程要么唤醒全部线程\n\n```java\nclass Data {\n    Lock lock = new ReentrantLock();\n    Condition c1 = lock.newCondition();\n    Condition c2 = lock.newCondition();\n    Condition c3 = lock.newCondition();\n    int number = 1;\n\n    public void print5() {\n        lock.lock();\n        try {\n            while (number != 1) {\n                c1.await();\n            }\n            for (int i = 0; i < 5; i++) {\n                System.out.println(Thread.currentThread().getName() + \"\\t\" + i);\n            }\n            number = 2;\n            c2.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void print10() {\n        lock.lock();\n        try {\n            while (number != 2) {\n                c2.await();\n            }\n            for (int i = 0; i < 10; i++) {\n                System.out.println(Thread.currentThread().getName() + \"\\t\" + i);\n            }\n            number = 3;\n            c3.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void print15() {\n        lock.lock();\n        try {\n            while (number != 3) {\n                c3.await();\n            }\n            for (int i = 0; i < 15; i++) {\n                System.out.println(Thread.currentThread().getName() + \"\\t\" + i);\n            }\n            number = 1;\n            c1.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic class Conditions {\n    public static void main(String[] args) {\n        Data data = new Data();\n        new Thread(() -> {\n            for (int i = 0; i < 10; i++) {\n                data.print5();\n            }\n        }, \"A\").start();\n        new Thread(() -> {\n            for (int i = 0; i < 10; i++) {\n                data.print10();\n            }\n        }, \"B\").start();\n        new Thread(() -> {\n            for (int i = 0; i < 10; i++) {\n                data.print15();\n            }\n        }, \"C\").start();\n    }\n}\n```\n\n### 死锁编码及定位分析\n死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那么它们都将无法推进下去，如果系统资源充足，线程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。\n\n#### 系统资源不足\n#### 线程进行推进的顺序不合适\n#### 资源分配不当\n\n```java\nclass HoldLockThread implements Runnable {\n    String lockA;\n    String lockB;\n\n    public HoldLockThread(String lockA, String lockB) {\n        this.lockA = lockA;\n        this.lockB = lockB;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lockA) {\n            System.out.println(Thread.currentThread().getName() + \"\\t 持有锁：\" + lockA + \"\\t 试图获取锁：\" + lockB);\n            try {\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            synchronized (lockB) {\n                System.out.println(Thread.currentThread().getName() + \"\\t 持有锁：\" + lockB + \"\\t 试图获取锁：\" + lockA);\n            }\n        }\n    }\n}\n\npublic class DeadLockDemo {\n    public static void main(String[] args) {\n        String lockA = \"lockA\";\n        String lockB = \"lockB\";\n        new Thread(new HoldLockThread(lockA, lockB), \"t1\").start();\n        new Thread(new HoldLockThread(lockB, lockA), \"t2\").start();\n    }\n}\n```\n#### 解决\n- jps命令定位进程号\n- jstack找到死锁查看\n\n### 什么是分布式锁\n当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。分布式锁可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存，如 Redis，通过set (key,value,nx,px,timeout)方法添加分布式锁。\n\n### 什么是分布式事务\n分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。\n\n## 集合（Collection）\n### List集合\n\nArrayList扩容为原来一半\n\n### Set集合\n#### HashSet\n```java\npublic HashSet() {\n    map = new HashMap<>();\n}\n\nHashSet底层是HashMap，put的值是key，value是一个Object类型的静态常量\nprivate static final Object PRESENT = new Object();\n\npublic boolean add(E e) {\n    return map.put(e, PRESENT) == null;\n}\n```\n### Map集合\n\n#### HashMap\n初始长度16 负载因子 3/4 扩容为2倍原长度，调用构造函数只是进行了默认长度和负载因子的设置并没有初始化数组，开辟存储空间。 1.7数组加单向链表，每个元素是entry，1.8 链表最大长度8 超过会转成红黑树，每个元素是Node。key可以为null，将key为null放在下标为0的位置\n##### put(key1,value1)\n七上八下（1.7 新加元素会在链表上面添加，1.8会在下面添加）\n- 首先调用key1的hashCode方法，然后再经过特定计算，计算出hash值，hash值&（length-1）计算出存放位置（Entry数组下标）\n- 如果此位置上的数据为空，此时添加成功          ---情况1   \n- 如果此位置上的数据不为空（意味着，此位置上存在一个或多个数据（以链表方式存在）），比较key1和已经存在的一个或多个数据的哈希值\n  - 如果key1的哈希值与已经存在的数据哈希值都不同，此时添加成功    ----情况2\n  - 如果key1的哈希值和已经存在的某一个数据（key2，value2）key2的哈希值相同，继续比较。调用key1所在类的equals（key2）\n    - 如果equals的返回值为false：此时添加成功       ---情况3\n    - 如果equals的返回值为true：使用value1替换掉value2\n\n补充：关于情况2和情况3:此时key1-value1的数据以链表的方式存储。\n##### 扩容\n在不断的添加过程中会涉及到扩容问题，默认的扩容方式：扩容为原来的2倍，并将原来的数据迁移过来。（不是rehash，而是链表上的数据通过用新数组长度进行计算得到的下标，会有两种情况，一种是和之前下标一样，一种是在原来下标基础上加上原来数组长度的下标。例如：原来下标为2，原来数组长度为8，新数组长度为16，链表上的数据有可能下标是2，有可能下标是2+8=10。）\n\n- 1.7：size >= threshold) && (null != table[bucketIndex]\n- 1.8：++size > threshold或tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY\n#### 为什么HashMap的长度是2的n次幂\n当长度2的n次幂时，2的n次幂 - 1=1111（2进制），任何值与此值按位（&）计算，这样才会快速拿到数组下标，并且数据分布相对均匀。\n#### 1.8 链表改为红黑树条件\n当数组的某一个索引位置上的元素以链表的形式存在的，数据个数>8且当前数组长度>64时，此时次位置伤的所有数据改为使用红黑树存储。\n#### 1.8 链表变成红黑树的阀值为8\n因为哈希桶中节点个数服从参数为0.5的泊松分布，超过8的概率很小\n#### HashMap和HashTable区别\n##### 线程安全性不同\nHashMap是线程不安全的，HashTable是线程安全的，其中的方法是Synchronize的，在多线程并发的情况下，可以直接使用HashTable，但是使用HashMap时必须自己增加同步处理。\n#####  是否提供contains方法\nHashMap只有containsValue和containsKey方法；HashTable有contains、containsKey和containsValue三个方法，其中contains和containsValue方法功能相同。\n#####  key和value是否允许null值\nHashTable中，key和value都不允许出现null值。HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。\n#####  数组初始化和扩容机制\n- HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。\n- HashTable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。\n#### ConcurrentHashMap\n- Segment：一个小型的HashMap，大小由并发级别确定\n- 线程安全，使用分段锁来控制同步访问问题\n\n#### TreeSet和HashSet区别\nHashSet是采用hash表来实现的。其中的元素没有按顺序排列，add()、remove()以及contains()等方法都是复杂度为O(1)的方法。\nTreeSet是采用树结构实现(红黑树算法)。元素是按顺序进行排列，但是add()、remove()以及contains()等方法都是复杂度为O(log (n))的方法。它还提供了一些方法来处理排序的set，如first(), last(), headSet(), tailSet()等等。\n## 字符串（String）\n### String buffer和String build区别\n- StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，\n- 只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。 \n- 在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全而StringBuffer则每次都需要判断锁，效率相对更低\n\n## 其他\n### 引用\n#### 强引用（默认支持模式）\n当内存不足，JVM开始垃圾回收，对于强引用当对象，就算是出现了OOM也不会对该对象进行回收，死都不回收。\n强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成java内存泄漏的主要原因之一。\n对于一个普通对象，如果没有其他的引用关系，只要超过了引用作用域或者显式的将相应（强）引用赋值为null，一般认为就是可以被垃圾收集的了（当然具体回收时机还要看垃圾收集策略）。\n\n#### 软引用\n软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。\n对于只有弱引用的对象来说，\n当系统内存充足时不会被回收\n当系统内存不足时会被回收\n软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用就保留，不够用就回收。\n\n#### 弱引用\n弱引用需要用java.lang.ref.WeakReference类来实现，它比软引用的生存周期更短，\n对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存。\n软引用、弱引用应用场景：\n假如有一个应用需要读取大量的本地图片：\n如果每次读取图片都要从硬盘读取图片则会严重影响性能\n如果一次性全部加载到内存中又能造成内存溢出\n设计思路：\n用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免来OOM的问题。\n`Map<String,SoftReference<Bitmap>> imageCache =new HashMap<String,SoftReference<Bitmap>>();`\n\n#### 虚引用\n\n### Final、Finally、Finalize\n#### final\n修饰符（关键字）有三种用法：修饰类、变量和方法。修饰类时，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。修饰变量时，该变量使用中不被改变，必须在声明时给定初值，在引用中只能读取不可修改，即为常量。修饰方法时，也同样只能使用，不能在子类中被重写。\n\n#### Finally\n通常放在try…catch的后面构造最终执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。\n\n#### Finalize\nObject类中定义的方法，Java中允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize() 方法可以整理系统资源或者执行其他清理工作。\n\n### ==和Equals区别\n\n####  == \n如果比较的是基本数据类型，那么比较的是变量的值\n如果比较的是引用数据类型，那么比较的是地址值（两个对象是否指向同一块内存）\n\n####  Equals\n如果没重写equals方法比较的是两个对象的地址值。\n如果重写了equals方法后我们往往比较的是对象中的属性的内容\nequals方法是从Object类中继承的，默认的实现就是使用==\n\n### B-tree和B+tree的区别\n- B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。\n- 在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。\n\n\n## 1.8 新特性\n\n###  四大函数接口\n\n- Consumer<T>\n重写accept，参数T，无返回\n\n- Supplier<T>\n 重写get，无参数，返回T\n\n- Function<T,R>\n重写apply，参数T，返回R\n\n- Predicate<T>\n重写test，参数T，返回boolean类型值\n\n### Stream\n\n### 分支合并框架\n- ForkJoinPool\n- ForJoinTask\n- RecursiveTask\n\n### 异步调用\n- CompletableFuture\n\n### lambada表达式\n- ()->{}\n- lambada表达式只可以使用在函数式接口上\n- java 8以前函数interface接口只能有方法定义，不能有实现。java 8以后可以由方法实现（default 关键字 修饰，可以由多个方法实现），有且仅有一个方法定义\n\n\n\n\n\n","date":"2020-04-03T10:27:00.000Z","updated":"2020-04-03T10:27:00.000Z","path":"notes/Java.html","title":"","comments":1,"layout":"page","_id":"ck8o1hacs001a13s6bdkz5xv6","content":"<h1 id=\"Java基础知识清单\"><a href=\"#Java基础知识清单\" class=\"headerlink\" title=\"Java基础知识清单\"></a>Java基础知识清单</h1><h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><h3 id=\"JVM架构\"><a href=\"#JVM架构\" class=\"headerlink\" title=\"JVM架构\"></a>JVM架构</h3><p><img src=\"Java.assets/image-20200309203737822.png\" alt=\"image-20200309203737822\"></p>\n<p><img src=\"Java.assets/image-20200309214325839.png\" alt=\"image-20200309214325839\"></p>\n<p><img src=\"Java.assets/QQ20200314-123059@2x-4161454.png\" alt=\"QQ20200314-123059@2x\"></p>\n<h4 id=\"Class-file\"><a href=\"#Class-file\" class=\"headerlink\" title=\"Class file\"></a>Class file</h4><ul>\n<li>有特定的文件标示（cafe babe），由类加载器加载进JVM方法区</li>\n<li>在加载类时：静态块（只会加载一次）&gt;构造块&gt;构造方法</li>\n</ul>\n<h4 id=\"类加载器（ClassLoader）\"><a href=\"#类加载器（ClassLoader）\" class=\"headerlink\" title=\"类加载器（ClassLoader）\"></a>类加载器（ClassLoader）</h4><p>实现通过类的全限定名（java/lang/String）获取该类的二进制字节流的代码块叫做类加载器。</p>\n<p>#####分类</p>\n<h6 id=\"启动类加载器（Bootstrap）\"><a href=\"#启动类加载器（Bootstrap）\" class=\"headerlink\" title=\"启动类加载器（Bootstrap）\"></a>启动类加载器（Bootstrap）</h6><p>用来加载java核心类库，无法被java程序直接引用。主要加载jre/lib文件夹下的jar文件</p>\n<h6 id=\"扩展类加载器（Extension）\"><a href=\"#扩展类加载器（Extension）\" class=\"headerlink\" title=\"扩展类加载器（Extension）\"></a>扩展类加载器（Extension）</h6><p>它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。主要加载jre/lib/ext文件夹下的jar文件</p>\n<h6 id=\"应用程序加载器（Application）\"><a href=\"#应用程序加载器（Application）\" class=\"headerlink\" title=\"应用程序加载器（Application）\"></a>应用程序加载器（Application）</h6><p>也叫应用类加载器,它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</p>\n<h6 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h6><p>通过继承 java.lang.ClassLoader类的方式实现。</p>\n<h5 id=\"全盘委托\"><a href=\"#全盘委托\" class=\"headerlink\" title=\"全盘委托\"></a>全盘委托</h5><p>加载类时，除非显示使用其他类加载器，否则该加载类下的其他依赖都有该类加载器加载</p>\n<h5 id=\"双亲委派\"><a href=\"#双亲委派\" class=\"headerlink\" title=\"双亲委派\"></a>双亲委派</h5><p>加载时会一层层向上委托，如果可以加载就进行加载，没有就向下层加载器找，找到加载找不到class not found</p>\n<h5 id=\"沙箱安全\"><a href=\"#沙箱安全\" class=\"headerlink\" title=\"沙箱安全\"></a>沙箱安全</h5><p>自己加载自己的，相当一个一个容器 各不影响</p>\n<h4 id=\"本地接口（Native-Interface）\"><a href=\"#本地接口（Native-Interface）\" class=\"headerlink\" title=\"本地接口（Native Interface）\"></a>本地接口（Native Interface）</h4><p>本地接口的作用是融合不同的编程语言为Java所用，在本地方法栈（Native Method Stack） 中登记Native方法</p>\n<h4 id=\"程序计数器（Program-Counter-Register）-PC-寄存器\"><a href=\"#程序计数器（Program-Counter-Register）-PC-寄存器\" class=\"headerlink\" title=\"程序计数器（Program Counter Register）,PC 寄存器\"></a>程序计数器（Program Counter Register）,PC 寄存器</h4><p>线程私有的。内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。<br>记录了方法之间的调用和执行情况，它是当前线程所执行的字节码的行号指示器。相当于一个指针，指示字节码的行号，指引程序执行顺序，native 的为空</p>\n<h4 id=\"本地方法栈（Native-Method-Stack）\"><a href=\"#本地方法栈（Native-Method-Stack）\" class=\"headerlink\" title=\"本地方法栈（Native Method Stack）\"></a>本地方法栈（Native Method Stack）</h4><p>本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务，存放本地方法</p>\n<h4 id=\"Java-栈（Java-Stack-），虚拟机栈\"><a href=\"#Java-栈（Java-Stack-），虚拟机栈\" class=\"headerlink\" title=\"Java 栈（Java Stack ），虚拟机栈\"></a>Java 栈（Java Stack ），虚拟机栈</h4><p>栈分为java虚拟机栈和本地方法栈<br>栈管运行，堆管存储。栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命周期是跟随线程的生命周期，线程结束内存也释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是栈函数的栈内存中分配。<br>栈存储：局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息</p>\n<p>虚拟机栈中包含有多个栈帧，每一个栈帧就是一个方法。</p>\n<p>StackOverFlowError：是错误，栈中递归调用等会发生，是由于栈内存溢出造成</p>\n<p>栈帧（Java中叫方法，栈中叫栈帧）数据<br>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。</p>\n<ul>\n<li><p>局部变量<br>输入参数和输出参数以及方法内的变量<br>局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定</p>\n</li>\n<li><p>操作数栈<br>记录出栈、入栈的操作<br>操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式</p>\n</li>\n<li><p>动态链接</p>\n</li>\n<li><p>方法返回地址</p>\n</li>\n</ul>\n<h4 id=\"方法区（Method-Area）还被叫为Non-Heap（非堆）\"><a href=\"#方法区（Method-Area）还被叫为Non-Heap（非堆）\" class=\"headerlink\" title=\"方法区（Method Area）还被叫为Non-Heap（非堆）\"></a>方法区（Method Area）还被叫为Non-Heap（非堆）</h4><p>被所有线程共享区域，在不同虚拟机里头实现是不一样的，最典型的就是永久代（PermGen Space）和元空间（Metaspace）。实例变量存储在对内存中和方法区无关。在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载。该区域是被线程共享的。<br>存储：在方法区中，存储了每个类的信息（包括类的名称、修饰符、方法信息、字段信息）、类中静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息以及编译器编译后的代码等。运行时常量池用于存放静态编译产生的字面量和符号引用，该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。1.7以后字符串常量池被移植到堆内存中</p>\n<h4 id=\"堆（Heap）\"><a href=\"#堆（Heap）\" class=\"headerlink\" title=\"堆（Heap）\"></a>堆（Heap）</h4><p>堆被所有线程共享区域，在虚拟机启动时创建，唯一目的存放对象实例。堆区是gc的主要区域，通常情况下分为两个区块年轻代和年老代。更细一点年轻代又分为Eden区，主要放新创建对象，From survivor 和 To survivor 保存gc后幸存下的对象，默认情况下各自占比 8:1:1。</p>\n<p>一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常量放到堆内存中，保存所有引用类型的真实信息，以便执行器执行。</p>\n<ul>\n<li>逻辑：Eden:S0:S1=8:1:1，新生：养老=1:2<ul>\n<li>新生（New）／年轻代（Young）<ul>\n<li>伊甸园（Eden Space）<br>新New对象都在此区域，98%是临时对象会被GC掉</li>\n<li>幸存者0（Survivor 0 Space）| from</li>\n<li>幸存者1（Survivor 1 Space）| to</li>\n</ul>\n</li>\n<li>养老（Tenure）／老年代（Old）</li>\n<li>永久（java 7）／元数据（java 8）。永久代和元空间的最大区别在于，永久代使用的是JVM的堆内存，但是java 8以后元空间并不存在虚拟机中而是使用本地物理内存，默认只用物理内存的1/4</li>\n</ul>\n</li>\n<li>物理<ul>\n<li>新生</li>\n<li>老年</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h3><p>HotSpot采用的是分代收集算法</p>\n<p>是内存回收的方法论，垃圾回收器就是算法落地实现<br>因为目前还没有完美的垃圾收集器出现，更加没有万能的收集器，只是有针对具体应用最合适的收集器，进行分代收集</p>\n<h4 id=\"判断一个对象是否可以被回收\"><a href=\"#判断一个对象是否可以被回收\" class=\"headerlink\" title=\"判断一个对象是否可以被回收\"></a>判断一个对象是否可以被回收</h4><p>垃圾（内存中已经不再被使用到的空间）</p>\n<h5 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h5><p>Java中，引用和对象是有关联的。如果要操作对象则必须要用引用进行。因此，很显然一个简单的办法就是通过引用计数来判断一个对象是否可以回收。简单说，给对象中添加一个引用计数器。每当有一个地方引用它，计数器值加1；每当有一个地方引用失效时，计数器值减1。任何时刻计数器值为零的对象就是不可能再被使用的，那么这个对象就是可回收对象，<br>那为什么主流的Java虚拟机里面都没有采用这种算法呢？其中最主要的原因是它很难解决对象直接相互循环引用的问题。</p>\n<h5 id=\"根节点作可达性分析（根搜索路径）\"><a href=\"#根节点作可达性分析（根搜索路径）\" class=\"headerlink\" title=\"根节点作可达性分析（根搜索路径）\"></a>根节点作可达性分析（根搜索路径）</h5><p>为了解决引用计数循环引用问题，Java使用了可达性分析方法<br>所谓GC Roots或者说tracking GC的根集合，就是一组必须活跃的引用<br>基本思路就是通过一系列名为GC Roots的对象作为起始点，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何一个引用链相连时，则说明此对象不可用。即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达）对象就被判定为存活；没有遍历到的就自然被判定为死亡。</p>\n<h4 id=\"Java中可以作为GC-Roots的对象\"><a href=\"#Java中可以作为GC-Roots的对象\" class=\"headerlink\" title=\"Java中可以作为GC Roots的对象\"></a>Java中可以作为GC Roots的对象</h4><ul>\n<li>虚拟机栈（栈帧中的局部变量区，也叫局部变量表）中引用的对象</li>\n<li>方法区中的类静态属性、常量引用的对象</li>\n<li>本地方法栈中JNI（Native方法）引用的对象</li>\n</ul>\n<h4 id=\"回收策略以及Minor-GC和Major-GC：\"><a href=\"#回收策略以及Minor-GC和Major-GC：\" class=\"headerlink\" title=\"回收策略以及Minor GC和Major GC：\"></a>回收策略以及Minor GC和Major GC：</h4><p>对象优先在堆的Eden区分配，当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC，Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC，但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度。</p>\n<h4 id=\"新生代GC（Minor-GC-GC）\"><a href=\"#新生代GC（Minor-GC-GC）\" class=\"headerlink\" title=\"新生代GC（Minor GC|GC）\"></a>新生代GC（Minor GC|GC）</h4><ul>\n<li><p>复制<br>eden、from 复制到 to，年龄+1<br>首先，当Eden区满的时候会触发第一次GC，把还活着的对象拷贝到from区，当eden区再次触发GC的时候会扫描eden区和from区，对这两个区域进行垃圾回收，经过这次回收后还存活的对象，直接复制到to区域（如果有对象的年龄到了老年的标准，则复制到老年区），同时把这些对象的年龄+1</p>\n</li>\n<li><p>清空<br>清空eden、from<br>然后清空eden和from中的对象</p>\n</li>\n<li><p>互换<br>to和from互换<br>最后，也即复制之后有换，谁空谁是to。to和from互换，原来to成为下一次GC时的from区，部分对象会在from和to区中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认是15），最终如果还存活，就进入老年代。</p>\n</li>\n</ul>\n<h4 id=\"老年代GC（Major-GC-Full-GC）\"><a href=\"#老年代GC（Major-GC-Full-GC）\" class=\"headerlink\" title=\"老年代GC（Major GC|Full GC）\"></a>老年代GC（Major GC|Full GC）</h4><p>GC日志分析</p>\n<ul>\n<li>[GC (Allocation Failure) [PSYoungGen: 512K-&gt;425K(1024K)] 512K-&gt;425K(1536K), 0.0018589 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</li>\n<li>[Full GC (Ergonomics) [PSYoungGen: 469K-&gt;460K(1024K)] [ParOldGen: 448K-&gt;447K(512K)] 917K-&gt;908K(1536K), [Metaspace: 2697K-&gt;2697K(1056768K)], 0.0041891 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] <ul>\n<li>DefNew(Default New Generation)</li>\n<li>Tenured(Old)</li>\n<li>ParNew(Parallel New Generation)</li>\n<li>PSYoungGen(Parallel Scavenge)</li>\n<li>ParOldGen(Parallel Old Generation)<h4 id=\"GC4大算法\"><a href=\"#GC4大算法\" class=\"headerlink\" title=\"GC4大算法\"></a>GC4大算法</h4></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"引用计数-1\"><a href=\"#引用计数-1\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h5><p>应用于：微软的COM/ActionScrip3/Python等<br>如果对象没有被引用，就会被回收<br>缺点：需要维护一个引用计算器</p>\n<h5 id=\"复制（Copy）\"><a href=\"#复制（Copy）\" class=\"headerlink\" title=\"复制（Copy）\"></a>复制（Copy）</h5><p>年轻代中使用的是Minor GC，这种GC算法采用的是复制算法(Copying)</p>\n<ul>\n<li>不会发生内存碎片，速度快</li>\n<li>消耗空间（需要进行复制）</li>\n</ul>\n<h5 id=\"标记清除（Mark-Sweep）\"><a href=\"#标记清除（Mark-Sweep）\" class=\"headerlink\" title=\"标记清除（Mark Sweep）\"></a>标记清除（Mark Sweep）</h5><p>老年代一般是由标记清除或者是标记清除与标记整理的混合实现</p>\n<ul>\n<li>会产生内存碎片，两次扫描耗时严重</li>\n<li>节约内存空间</li>\n</ul>\n<h5 id=\"标记整理／压缩（Mark-Compat）\"><a href=\"#标记整理／压缩（Mark-Compat）\" class=\"headerlink\" title=\"标记整理／压缩（Mark-Compat）\"></a>标记整理／压缩（Mark-Compat）</h5><p>老年代一般是由标记清除或者是标记清除与标记整理的混合实现</p>\n<ul>\n<li>没有碎片</li>\n<li>耗时严重</li>\n</ul>\n<h4 id=\"算法比较\"><a href=\"#算法比较\" class=\"headerlink\" title=\"算法比较\"></a>算法比较</h4><ul>\n<li><p>内存效率（时间纬度）<br>复制&gt;标记清除&gt;标记整理</p>\n</li>\n<li><p>内存整齐度<br>复制=标记整理&gt;标记清除</p>\n</li>\n<li><p>内存利用率<br>标记整理=标记清除&gt;复制</p>\n<h3 id=\"GC垃圾收集器\"><a href=\"#GC垃圾收集器\" class=\"headerlink\" title=\"GC垃圾收集器\"></a>GC垃圾收集器</h3><h4 id=\"查看默认的垃圾收集器是哪个\"><a href=\"#查看默认的垃圾收集器是哪个\" class=\"headerlink\" title=\"查看默认的垃圾收集器是哪个\"></a>查看默认的垃圾收集器是哪个</h4><p>java -XX:+PrintCommandLineFlags -version</p>\n</li>\n</ul>\n<h4 id=\"默认的垃圾收集器有哪些\"><a href=\"#默认的垃圾收集器有哪些\" class=\"headerlink\" title=\"默认的垃圾收集器有哪些\"></a>默认的垃圾收集器有哪些</h4><h5 id=\"UseSerialGC\"><a href=\"#UseSerialGC\" class=\"headerlink\" title=\"UseSerialGC\"></a>UseSerialGC</h5><p>它为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程，不适合服务器。<br>一句话：一个单线程的收集器，在进行垃圾收集的时候，必须暂停其他所有的工作线程直到它收集结束。<br>串行收集器是最古老，最稳定以及效率最高的收集器，只使用一个线程区回收但其在进行垃圾回收过程中可能会产生较长的停顿（Stop-The-World 状态）。虽然在收集垃圾过程中需要暂停其他的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是java虚拟机运行在Client模式下新生代的垃圾收集器。<br>对应JVM参数：<br>-XX:+UseSerialGC<br>开启后会使用：Serial（Young区用）+Serial Old（Old区用）的收集器组合<br>表示：新生代、老年代都会使用串行收集器，新生代使用复制算法，老年代使用标记-整理算法<br>-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseSerialGC</p>\n<h5 id=\"UseSerialOldGC\"><a href=\"#UseSerialOldGC\" class=\"headerlink\" title=\"UseSerialOldGC\"></a>UseSerialOldGC</h5><p>Serial Old 是Serial 垃圾收集器老年代版本，它同样是单个线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的java虚拟机默认的老年代垃圾收集器。<br>在Server模式下，主要有两个用途（了解，版本已经到8及以后）：</p>\n<ul>\n<li>在JDK1.5 之前版本中与新生代的Parallel Scavenge 收集器搭配使用。（Parallel Scavenge +Serial Old）</li>\n<li>作为老年代版本中使用CMS收集器的后备垃圾收集方案。</li>\n</ul>\n<h5 id=\"UseParNewGC\"><a href=\"#UseParNewGC\" class=\"headerlink\" title=\"UseParNewGC\"></a>UseParNewGC</h5><p>多个垃圾收集线程并行工作，此时用户线程是暂停的，适用于科学计算／大数据处理等弱交互场景<br>一句话：使用多线程进行垃圾回收，在垃圾收集时，会Stop-The-World暂停其他所有的工作线程直到它收集结束。<br>ParNew收集器其实就是Serial收集器新生代的并行多线程版本，最常见的应用场景是配合老年代的CMS GC工作，其余的行为和Serial收集器完全一样，它是很多java虚拟机运行在Server模式下新生代的默认垃圾收集器<br>常用JVM参数：-XX:+UseParNewGC 启用ParNew收集器，只影响新生代的收集，不影响老年代<br>开启上述参数后，会使用：ParNew（Young区用）+Serial Old的收集器组合，新生代使用复制算法，老年代采用标记-整理算法。<br>但是，ParNew+Tenured这样的搭配，java8已经不再被推荐<br>备注：<br>-XX:ParallelGCThreads 限制线程数量，默认开启和CPU数目相同的线程数<br> -Xmx10m -Xmx10m -XX:+PrintGCDetails -XX:+UseParNewGC</p>\n<h5 id=\"UseParallelGC\"><a href=\"#UseParallelGC\" class=\"headerlink\" title=\"UseParallelGC\"></a>UseParallelGC</h5><p>Parallel Scavenge收集器类似ParNew也是一个新生代垃圾收集器，使用复制算法，也是一个并行的多线程的垃圾收集器，俗称吞吐量优先收集器。<br>一句话：串行收集器在新生代和老年代的并行化<br>它重点关注的是：<br>可控制的吞吐量（Thoughput=运行用户代码时间／（运行用户代码时间+垃圾收集时间），比如程序运行100分钟，垃圾收集1分钟，吞吐量就是99%）。高吞吐量意味着高效利用CPU时间，它多用于在后台运算而不需要太多交互的任务。<br>自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。（自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间（-XX:MaxGCPauseMillis）或最大吞吐量。<br>常用JVM参数：-XX:+UseParallelGC 或 -XX:+UseParallelOldGC(可互相激活）使用Parallel Scavenge收集器<br>多说一句：-XX:ParallelGCThreads=数字N 表示启动多少个线程<br>CPU&gt;8 N=5/8<br>CPU&lt;8 N=实际个数<br>-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseParallelGC<br>-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseParllelOldGC</p>\n<h5 id=\"UseParallelOldGC\"><a href=\"#UseParallelOldGC\" class=\"headerlink\" title=\"UseParallelOldGC\"></a>UseParallelOldGC</h5><p>Parallel Old收集器是Parallel Scavenge的老年代版本，使用多线程的标记-整理算法，Parallel Old收集器在JDK1.6才开始提供。<br>在JDK1.6之前，新生代使用Parallel Scavenge收集器只能搭配老年代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。在JDK1.6之前（Parallel Scavenge+Serial Old）<br>Parallel Old正是为了在老年代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，JDK1.8之后可以优先考虑新生代Parallel Scavenge 和老年代Parallel Old收集器的搭配策略。在JDK1.8及之后（Parallel Scavenge+Parallel Old）<br>常用JVM参数：-XX:+UseParallelOldGC 使用Parallel Old收集器，设置参数后，新生代Parallel+老年代Parallel Old</p>\n<h5 id=\"UseConcMarkSweepGC\"><a href=\"#UseConcMarkSweepGC\" class=\"headerlink\" title=\"UseConcMarkSweepGC\"></a>UseConcMarkSweepGC</h5><p>用户线程和垃圾回收线程同时执行（并不一定是并行，可能交替执行），不需要暂停用户线程，互联网公司多用它，适用对相应时间有要求的场景<br>CMS收集器（Concurrent Mark Sweep：并发标记清除）是一种以获取最短回收停顿时间为目标的收集器。适应应用在互联网站或者B／S系统的服务器上，这类应用尤其重视服务器响应速度，希望系统停顿时间最短。CMS非常适合堆内存大、CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。Concurrent Mark Sweep 并发标记清除，并发收集低停顿，并发指的是与用户线程一起执行<br>开启该收集器的JVM参数： -XX:+UseConcMarkSweepGC 开启该参数后会自动将-XX:+UseParNewGC 打开开启该参数后，使用ParNew（Young区用）+CMS（Old区用）+Serial Old的收集器组合，Serial Old将作为CMS出错的后备收集器<br><strong>执行步骤</strong></p>\n<ul>\n<li>初始标记（CMS initial mark）需要暂停所有的工作线程<br>只是标记一下，GC Roots 能直接关联的对象，速度快，仍然需要暂停所有的工作线程</li>\n<li>并发标记（CMS concurrent mark）和用户线程一起<br>进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。主要标记过程，标记全部对象。</li>\n<li>重新标记（CMS remark）需要暂停所有的工作线程<br>为了修改在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。<br>由于并发标记时，用户线程依然运行，因此在正式清理前，再作修正。</li>\n<li>并发清除（CMS concurrent sweep）和用户线程一起<br>清除GC Roots 不可达对象，和用户一起工作，不需要暂停工作线程。基于标记结果，直接清除对象。<br>由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发的执行。</li>\n</ul>\n<p><strong>优缺点</strong><br>优：并发收集低停顿<br>缺：</p>\n<ul>\n<li>并发执行，对CPU资源压力大<br>由于并发进行，CMS垃圾收集和应用线程会同时增加对堆内存对占用，也就是说，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW的方式进行一次GC，从而造成较大停顿时间。</li>\n<li>采用对标记清除算法会导致大量碎片<br>标记清除无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。CMS也提供了参数-XX:CMSFullGCsBeForeCompaction(默认0，即每次都进行内存整理）来指定多少次CMS收集之后，进行一次压缩的Full GC</li>\n</ul>\n<p>-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC</p>\n<h5 id=\"UseG1GC\"><a href=\"#UseG1GC\" class=\"headerlink\" title=\"UseG1GC\"></a>UseG1GC</h5><p>G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片<br>G1的Stop The World（STW）更可控，G1在停顿时间上添加量预测机制，用户可以指定期望停顿时间<br>CMS垃圾收集器虽然暂停了应用程序的运行时间，但还是存在着内存碎片的问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，java7 发布了一个新的垃圾收集器-G1垃圾收集器<br>G1是在2012年才在jdk1.7u4中可用。oracle官方计划在jdk9中将G1变成默认的垃圾收集器以替代CMS。它是一款面向服务器端应用的收集器，主要应用在多CPU和大内存服务器环境下，极大的减少垃圾收集的停顿时间，全面提升服务器的性能，逐步替换java8以前的CMS收集器。<br>主要改变是Eden，Surivor和Tenured等内存区域不再是连续的了，而是变成了一个个大小一样的region，每个region从1m到32m不等。一个region有可能属于Eden，Survivor或者Tenured内存区域</p>\n<h6 id=\"底层原理\"><a href=\"#底层原理\" class=\"headerlink\" title=\"底层原理\"></a>底层原理</h6><p>Region区域化垃圾收集器<br>化整为零，避免全内存扫描，只需要按照区域来进行扫描即可<br>区域化内存划片Region，整体编辑为了一些不连续的内存区域，避免了全内存区的GC操作。<br>核心思想是将整个堆内存区域分成大小相同的子区域（Region），在JVM启动的时候会自动设置这些子区域的大小，在堆的使用上，G1并不要求对象的存储一定是物理上连续的只要逻辑连续即可，每个分区也不会固定的为某个代服务，可以按需在新生代和老年代之间切换。启动时可以通过参数-XX:G1HeapRegionSize=n指定分区大小（1m-32m，且必须是2的幂），默认将整堆划分成2048个分区。<br>大小范围在1m-32m，最多能设置2048个区域，能支持的最大内存为：32m*2048=65536m=64G</p>\n<h6 id=\"回收步骤\"><a href=\"#回收步骤\" class=\"headerlink\" title=\"回收步骤\"></a>回收步骤</h6><p>G1收集器下的Young GC<br>针对Eden区进行收集，Eden区耗尽后会被触发，主要是小区域收集+形成连续的内存块，避免内存碎片<br>Eden区的数据移动到Survivor区，假如出现Survivor区空间不够，Eden区数据会部分晋升到Old区<br>Surivor区的数据移动到新的Survivor区，部分数据晋升到Old区<br>最后Eden区收拾干净，GC结束，用户的应用程序继续执行</p>\n<h6 id=\"常用配置参数（了解）\"><a href=\"#常用配置参数（了解）\" class=\"headerlink\" title=\"常用配置参数（了解）\"></a>常用配置参数（了解）</h6><p>开发人员仅仅需要声明以下参数即可：<br>三步归纳：开始G1+设置最大内存+设置最大停顿时间<br>-XX:+UseG1GC  -Xmx32g  -XX:MaxGCPauseMillis=100<br>-XX:MaxGCPauseMillis=n: 最大GC停顿时间单位毫米，这是个软目标，JVM将尽可能（但不保证）停顿小于这个时间。</p>\n<ul>\n<li>-XX:+UseG1GC</li>\n<li>-XX:G1HeapRegionSize=n<br>设置G1区域的大小。值是2的幂，范围是1m-32m。目标是根据最小的java堆大小划分出约2048个区域</li>\n<li>-XX:MaxGCPauseMillis=n<br>最大GC时间，这是个软目标，JVM尽可能（但不保证）停顿小于这个时间</li>\n<li>-XX:InitiatingHeapOccupancyPercent=n<br>堆占用了多少堆时候就触发GC，默认为45%</li>\n<li>-XX:ConcGCThreads=n<br>并发GC使用的线程数</li>\n<li>-XX:G1ReserverPercent=n<br>设置作为空闲空间的预留内存占比，以降低目标空间溢出的风险，默认是10%</li>\n</ul>\n<h6 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h6><ul>\n<li>G1能充分利用多CPU、多核环境硬件优势，尽量缩短STW。</li>\n<li>G1整体上采用标记-整理算法，局部使用复制算法，不会产生内存碎片</li>\n<li>宏观上看G1不再区分新生代和老年代，把内存划分成多个独立的子区域（region），可以近似理解为一个围棋棋盘</li>\n<li>G1收集器将整个内存区都混合为一起，但其本身依旧在小范围内进行新生代和老年代的区分，保留了新生代和老年代，但它们不是物理隔离，而是一部分region的集合，并且不需要region是连续，也就是说依然采用不同的GC方式来处理不同的区域。</li>\n<li>G1虽然也是分代收集器，但整个内存分区不存在物理上的新生代和老年代的区别，也不需要完全独立的Survivor（to space）堆作复制准备。G1只有逻辑上的分代概念，或者说每个分区都有可能随着G1的运行在不同代之间前后切换</li>\n</ul>\n<h6 id=\"G1和CMS相比的优势\"><a href=\"#G1和CMS相比的优势\" class=\"headerlink\" title=\"G1和CMS相比的优势\"></a>G1和CMS相比的优势</h6><ul>\n<li>G1不会产生内存碎片</li>\n<li>是可以精确控制停顿。该收集器是把整个堆（新生代、老年代）划分成多个固定大小的区域，每次根据允许停顿的时间区收集垃圾最多的区域</li>\n</ul>\n<h3 id=\"Server／Client模式分别是什么意思\"><a href=\"#Server／Client模式分别是什么意思\" class=\"headerlink\" title=\"Server／Client模式分别是什么意思\"></a>Server／Client模式分别是什么意思</h3><p>适用范围：只需要掌握Server模式即可，Client模式基本不会用操作系统</p>\n<ul>\n<li>32位Win操作系统，不论硬件如何都默认使用Client的JVM模式</li>\n<li>32位其他操作系统，2G内存同时有2个CPU以上用Server模式，低于该配置还是使用Client模64位only server模式</li>\n</ul>\n<h3 id=\"如何选择垃圾收集器\"><a href=\"#如何选择垃圾收集器\" class=\"headerlink\" title=\"如何选择垃圾收集器\"></a>如何选择垃圾收集器</h3><ul>\n<li><p>单CPU或者小内存，单机程序</p>\n</li>\n<li><p>XX:+UseSerialGC</p>\n</li>\n<li><p>多CPU，需要最大吞吐量，如后台计算大型应用</p>\n</li>\n<li><p>XX:+UseParallelGC 或者</p>\n</li>\n<li><p>XX:+UseParallelOldGC</p>\n</li>\n<li><p>多CPU，追求低停顿时间，需快速响应如互联网应用</p>\n</li>\n<li><p>XX:+UseConcMarkSweepGC</p>\n</li>\n<li><p>XX:+ParNewGC</p>\n</li>\n</ul>\n<h3 id=\"以前收集器特点\"><a href=\"#以前收集器特点\" class=\"headerlink\" title=\"以前收集器特点\"></a>以前收集器特点</h3><ul>\n<li>新生代和老年代是各自独立且连续但内存块</li>\n<li>新生代收集使用单eden+s0+s1进行复制算法</li>\n<li>老年代收集必须扫描整个老年代区域</li>\n<li>都是以尽可能少而快速的执行GC为设计原则</li>\n</ul>\n<h3 id=\"Java类加载过程\"><a href=\"#Java类加载过程\" class=\"headerlink\" title=\"Java类加载过程\"></a>Java类加载过程</h3><h4 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h4><p>加载是类加载的第一个过程，在这个阶段，将完成一下三件事情：</p>\n<ul>\n<li>通过一个类的全限定名获取该类的二进制流。</li>\n<li>将该二进制流中的静态存储结构转化为方法去运行时数据结构。 </li>\n<li>在内存中生成该类的Class对象，作为该类的数据访问入口。<h4 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h4><h5 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h5>验证的目的是为了确保Class文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证: </li>\n<li>文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型. </li>\n<li>元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否继承了不被继承的类等。</li>\n<li>字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。</li>\n<li>符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。<h5 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h5>准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。<h5 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h5>该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4>初始化是类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。</li>\n</ul>\n<h4 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h4><p>类加载包含Main程序入口的类加载</p>\n<ul>\n<li>静态成员变量加载时执行到准备阶段将变量赋初始值（int 类型默认初始化为0，引用对象初始化为null）</li>\n<li>静态成员变量加载时执行到初始化阶段将变量赋值（private static int a=29，默认初始化为a=0，赋值初始化a=29；引用类型 初始化为对象实例)</li>\n<li>运行main方法</li>\n</ul>\n<blockquote>\n<p>静态变量 （static int a）和静态引用变量（static  Object o）声明赋值是依据自上而下的顺序。</p>\n</blockquote>\n<h3 id=\"JVM的参数类型\"><a href=\"#JVM的参数类型\" class=\"headerlink\" title=\"JVM的参数类型\"></a>JVM的参数类型</h3><h4 id=\"标配参数\"><a href=\"#标配参数\" class=\"headerlink\" title=\"标配参数\"></a>标配参数</h4><ul>\n<li>-version</li>\n<li>-help</li>\n<li>java -showversion</li>\n</ul>\n<h4 id=\"X参数-了解）\"><a href=\"#X参数-了解）\" class=\"headerlink\" title=\"X参数(了解）\"></a>X参数(了解）</h4><ul>\n<li>-Xint（解释执行）</li>\n<li>-Xcomp（第一次使用就编译成本地代码）</li>\n<li>-Xmixed（混合模式）</li>\n</ul>\n<h4 id=\"XX参数\"><a href=\"#XX参数\" class=\"headerlink\" title=\"XX参数\"></a>XX参数</h4><h5 id=\"Boolean类型\"><a href=\"#Boolean类型\" class=\"headerlink\" title=\"Boolean类型\"></a>Boolean类型</h5><ul>\n<li>公式<ul>\n<li>-XX：+或者- 某个属性值</li>\n<li>+（开启）-（关闭）</li>\n</ul>\n</li>\n<li>Case<ul>\n<li>是否打印GC收集细节<br>-XX:-PrintGCDetails<br>-XX:+PrintGCDetails</li>\n<li>是否使用串行垃圾回收器<br>-XX:-UseSerialGC<br>-XX:+UseSerialGC</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"K-V设值类型\"><a href=\"#K-V设值类型\" class=\"headerlink\" title=\"K-V设值类型\"></a>K-V设值类型</h5><p>-XX：属性key=属性value<br>-XX:MetaspaceSize=128m<br>-XX:MaxTenuringThreshold=15</p>\n<h3 id=\"Jinfo\"><a href=\"#Jinfo\" class=\"headerlink\" title=\"Jinfo\"></a>Jinfo</h3><p>任何查看当前运行程序的配置<br>jinfo -flag 配置项 进程编号<br>jinfo -flag IntialHeapSize 进程号<br>jinfo -flags 进程号</p>\n<h3 id=\"查看JVM的默认值\"><a href=\"#查看JVM的默认值\" class=\"headerlink\" title=\"查看JVM的默认值\"></a>查看JVM的默认值</h3><h4 id=\"XX-PrintFlagsFinal\"><a href=\"#XX-PrintFlagsFinal\" class=\"headerlink\" title=\"-XX:+PrintFlagsFinal\"></a>-XX:+PrintFlagsFinal</h4><p>主要查看修改更新<br>java -XX:+PrintFlagsFinal -version<br>:= 为人为修改过或初始加载修改过，= 为默认未改<br>PrintFlagsFinal举例<br>运行java命令的同时打印出参数<br>java -XX:+PrintFlagsFinal -XX:MetaspaceSize=512m 类名</p>\n<h4 id=\"XX-PrintCommandLineFlags\"><a href=\"#XX-PrintCommandLineFlags\" class=\"headerlink\" title=\"-XX:+PrintCommandLineFlags\"></a>-XX:+PrintCommandLineFlags</h4><p>主要看垃圾回收器，最后一个值</p>\n<h4 id=\"XX-HeapDumpOnOutOfMemoryError\"><a href=\"#XX-HeapDumpOnOutOfMemoryError\" class=\"headerlink\" title=\"-XX:+HeapDumpOnOutOfMemoryError\"></a>-XX:+HeapDumpOnOutOfMemoryError</h4><p>设置内存溢出时dump内存快照</p>\n<h3 id=\"JVM常用参数\"><a href=\"#JVM常用参数\" class=\"headerlink\" title=\"JVM常用参数\"></a>JVM常用参数</h3><h4 id=\"Xms（-XX-InitialHeapSize）\"><a href=\"#Xms（-XX-InitialHeapSize）\" class=\"headerlink\" title=\"-Xms（-XX:InitialHeapSize）\"></a>-Xms（-XX:InitialHeapSize）</h4><p>初始大小内存，默认为物理内存1/64</p>\n<h4 id=\"Xmx（-XX-MaxHeapSize）\"><a href=\"#Xmx（-XX-MaxHeapSize）\" class=\"headerlink\" title=\"-Xmx（-XX:MaxHeapSize）\"></a>-Xmx（-XX:MaxHeapSize）</h4><p>最大分配内存，默认为物理内存1/4</p>\n<h4 id=\"Xss（-XX-ThreadStackSize）\"><a href=\"#Xss（-XX-ThreadStackSize）\" class=\"headerlink\" title=\"-Xss（-XX:ThreadStackSize）\"></a>-Xss（-XX:ThreadStackSize）</h4><p>设置单个线程栈的大小，一般默认为512k～1024k</p>\n<h4 id=\"Xmn\"><a href=\"#Xmn\" class=\"headerlink\" title=\"-Xmn\"></a>-Xmn</h4><p>设置年轻代大小</p>\n<h4 id=\"XX-MetaspaceSize\"><a href=\"#XX-MetaspaceSize\" class=\"headerlink\" title=\"-XX:MetaspaceSize\"></a>-XX:MetaspaceSize</h4><p>初始元空间大小</p>\n<p>元空间本质和永久代类似，都是对JVM规范方法中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。<br>-Xms10m -Xmx10m  -XX:MetaspaceSize=1024m -XX：+PrintFlagsFinal</p>\n<h4 id=\"XX-MaxMetaspaceSize\"><a href=\"#XX-MaxMetaspaceSize\" class=\"headerlink\" title=\"-XX:MaxMetaspaceSize\"></a>-XX:MaxMetaspaceSize</h4><p>最大元空间大小，默认为-1，只受本地空间限制</p>\n<h4 id=\"XX-MaxDirectMemorySize\"><a href=\"#XX-MaxDirectMemorySize\" class=\"headerlink\" title=\"-XX:MaxDirectMemorySize\"></a>-XX:MaxDirectMemorySize</h4><p>最大直接内存大小，默认和 -Xmx 一致</p>\n<h4 id=\"XX-PrintGCDetails\"><a href=\"#XX-PrintGCDetails\" class=\"headerlink\" title=\"-XX:+PrintGCDetails\"></a>-XX:+PrintGCDetails</h4><p>1    输出详细GC收集日志信息<br>2    GC：<br>3    FullGC：</p>\n<h4 id=\"XX-SurvivorRatio\"><a href=\"#XX-SurvivorRatio\" class=\"headerlink\" title=\"-XX:SurvivorRatio\"></a>-XX:SurvivorRatio</h4><p>设置新生代中eden和s0/s1空间的比例<br>默认-XX:ServivorRatio=8，Eden:S0:S1=8:1:1<br>假如-XX:SurvivorRatio=4,    Eden::S0:S1=4:1:1<br>SurvivorRatio值就是设置eden区的占比多少，s0/s1相同</p>\n<h4 id=\"XX-NewRatio\"><a href=\"#XX-NewRatio\" class=\"headerlink\" title=\"-XX:NewRatio\"></a>-XX:NewRatio</h4><p>配置年轻代与老年代在堆结构的占比，<br>默认-XX:NewRatio=2 新生代占1，老年代占2，新生代占整个堆的1/3<br>假如-XX:NewRatio=4 新生代占1，老年代占4，新生代占整个堆的1/5<br>NewRatio值就是设置老年代的占比，剩下的1给新生代</p>\n<h4 id=\"XX-MaxTenuringThreshold\"><a href=\"#XX-MaxTenuringThreshold\" class=\"headerlink\" title=\"-XX:MaxTenuringThreshold\"></a>-XX:MaxTenuringThreshold</h4><p>设置进入老年代年龄<br>典型设置案例<br>-Xms128m -Xmx4096m -Xss1024k -XX:MetaspaceSize=512m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UseSerialGC</p>\n<h3 id=\"OOM\"><a href=\"#OOM\" class=\"headerlink\" title=\"OOM\"></a>OOM</h3><h4 id=\"java-lang-StackOverflowError\"><a href=\"#java-lang-StackOverflowError\" class=\"headerlink\" title=\"java.lang.StackOverflowError\"></a>java.lang.StackOverflowError</h4><p>虚拟机栈内存不足导致</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StackOverflowErrorDemo</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">stackError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">stackError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">stackError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"java-lang-OutOfMemoryError-Java-heap-space\"><a href=\"#java-lang-OutOfMemoryError-Java-heap-space\" class=\"headerlink\" title=\"java.lang.OutOfMemoryError:Java heap space\"></a>java.lang.OutOfMemoryError:Java heap space</h4><ul>\n<li>java虚拟机的对内存设置不够，可以通过-Xms和-Xmx来设置。生产中这两个参数会设置为一样，避免内存忽高忽低。</li>\n<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n * -Xms1m -Xmx1m\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">OOM_heap_space</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">byte</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> bytes <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">byte</span><span class=\"token punctuation\">[</span><span class=\"token number\">20</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"java-lang-OutOfMemoryError-GC-overhead-limit-exceeded\"><a href=\"#java-lang-OutOfMemoryError-GC-overhead-limit-exceeded\" class=\"headerlink\" title=\"java.lang.OutOfMemoryError:GC overhead limit exceeded\"></a>java.lang.OutOfMemoryError:GC overhead limit exceeded</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n * -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=10m\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">GCOverheadDemo</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        ArrayList<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">intern</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"+++++++i:\"</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">throw</span> e<span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"java-lang-OutOfMemoryError-Direct-buffer-memory\"><a href=\"#java-lang-OutOfMemoryError-Direct-buffer-memory\" class=\"headerlink\" title=\"java.lang.OutOfMemoryError:Direct buffer memory\"></a>java.lang.OutOfMemoryError:Direct buffer memory</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n * -XX:MaxDirectMemorySize=3m -XX:+PrintGCDetails\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DirectBufferMemoryErrorDemo</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"配置的MaxDirectMemorySize：\"</span> <span class=\"token operator\">+</span> <span class=\"token punctuation\">(</span>sun<span class=\"token punctuation\">.</span>misc<span class=\"token punctuation\">.</span>VM<span class=\"token punctuation\">.</span><span class=\"token function\">maxDirectMemory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">/</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">double</span><span class=\"token punctuation\">)</span> <span class=\"token number\">1024</span> <span class=\"token operator\">/</span> <span class=\"token number\">1024</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"MB\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        ByteBuffer byteBuffer <span class=\"token operator\">=</span> ByteBuffer<span class=\"token punctuation\">.</span><span class=\"token function\">allocateDirect</span><span class=\"token punctuation\">(</span><span class=\"token number\">6</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span> <span class=\"token operator\">*</span> <span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"java-lang-OutOfMemoryError-unbale-to-create-new-native-thread\"><a href=\"#java-lang-OutOfMemoryError-unbale-to-create-new-native-thread\" class=\"headerlink\" title=\"java.lang.OutOfMemoryError:unbale to create new native thread\"></a>java.lang.OutOfMemoryError:unbale to create new native thread</h4><p>root 用户无限制 其他用户 linux 默认1024</p>\n<p>虚拟机栈内存不够用无法再创建新的线程。该异常是由于虚拟机栈内存被用尽导致无法再创建新线程，-Xss参数将直接导致所能创建线程的多少。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">UnableCreateNewThreadDemo</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> tmp <span class=\"token operator\">=</span> i<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>tmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>MAX_VALUE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"java-lang-OutOfMemoryError-Metaspace\"><a href=\"#java-lang-OutOfMemoryError-Metaspace\" class=\"headerlink\" title=\"java.lang.OutOfMemoryError:Metaspace\"></a>java.lang.OutOfMemoryError:Metaspace</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n * -XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">MetaspaceOOMDemo</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Temp</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                Enhancer enhancer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Enhancer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                enhancer<span class=\"token punctuation\">.</span><span class=\"token function\">setSuperclass</span><span class=\"token punctuation\">(</span>Temp<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                enhancer<span class=\"token punctuation\">.</span><span class=\"token function\">setUseCache</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                enhancer<span class=\"token punctuation\">.</span><span class=\"token function\">setCallback</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">MethodInterceptor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token annotation punctuation\">@Override</span>\n                    <span class=\"token keyword\">public</span> Object <span class=\"token function\">intercept</span><span class=\"token punctuation\">(</span>Object o<span class=\"token punctuation\">,</span> Method method<span class=\"token punctuation\">,</span> Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> objects<span class=\"token punctuation\">,</span> MethodProxy methodProxy<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> Throwable <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">return</span> methodProxy<span class=\"token punctuation\">.</span><span class=\"token function\">invokeSuper</span><span class=\"token punctuation\">(</span>o<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                enhancer<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"============\"</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"生产环境服务器变慢，判断思路和性能评估\"><a href=\"#生产环境服务器变慢，判断思路和性能评估\" class=\"headerlink\" title=\"生产环境服务器变慢，判断思路和性能评估\"></a>生产环境服务器变慢，判断思路和性能评估</h3><ul>\n<li>整机：top<br>uptime 是top精简版</li>\n<li>CPU：vmstat</li>\n<li>查看所有CPU核信息：mpastat -P ALL 2</li>\n<li>每个进程使用CPU的用量分解信息：pidstat -u 1 -p 进程编号</li>\n<li>内存：free</li>\n<li>pidstat -p 进程号 -r 采样间隔秒</li>\n<li>硬盘：df</li>\n<li>磁盘IO：iostat</li>\n<li>网络IO：ifstat</li>\n</ul>\n<h3 id=\"CPU占用过高，分析思路和定位\"><a href=\"#CPU占用过高，分析思路和定位\" class=\"headerlink\" title=\"CPU占用过高，分析思路和定位\"></a>CPU占用过高，分析思路和定位</h3><ul>\n<li><p>先用top命令找出CPU占比最高的</p>\n</li>\n<li><p>ps -ef 或者jps 进一步定位，得知是一个怎样的后台程序</p>\n</li>\n<li><p>定位到具体线程或者代码</p>\n</li>\n<li><p>ps -mp 进程 -o THRAD,tid,time</p>\n</li>\n<li><p>-m：显示所有的线程</p>\n</li>\n<li><p>-p pid 进程使用CPU的时间</p>\n</li>\n<li><p>-o 该参数后是用户自定义格式</p>\n</li>\n<li><p>将需要的线程ID转换为16进制格式（英文小写）</p>\n</li>\n<li><p>printf “%x\\n” 有问题的线程ID</p>\n</li>\n<li><p>jstack 进程ID | grep tid（16进制线程ID）-A60</p>\n</li>\n</ul>\n<h2 id=\"JUC\"><a href=\"#JUC\" class=\"headerlink\" title=\"JUC\"></a>JUC</h2><p>JUC(java.util.concurrent)多线程及高并发</p>\n<h3 id=\"Volatile\"><a href=\"#Volatile\" class=\"headerlink\" title=\"Volatile\"></a>Volatile</h3><p>多线程访问成员变量时，会发生多个一个线程将变量数值该变，但是另一个线程可能无法感知变量的值的改变。使用volatile可以避免这种情况</p>\n<p>Volatile是Java虚拟机提供的轻量级的同步机制，低配版Synchronized</p>\n<h4 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h4><h5 id=\"保证可见性\"><a href=\"#保证可见性\" class=\"headerlink\" title=\"保证可见性\"></a>保证可见性</h5><h5 id=\"禁止指令重排\"><a href=\"#禁止指令重排\" class=\"headerlink\" title=\"禁止指令重排\"></a>禁止指令重排</h5><h4 id=\"Volatile使用场景（DCL）\"><a href=\"#Volatile使用场景（DCL）\" class=\"headerlink\" title=\"Volatile使用场景（DCL）\"></a>Volatile使用场景（DCL）</h4><ul>\n<li><p>单例模式DCL(Dobule Check Lock)代码<br>DCL(双端检锁）机制不一定线程安全，是因为有指令重排序的存在，假如volatile可以禁止指令重排<br>原因在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化。</p>\n<pre class=\" language-java\"><code class=\"language-java\">instance<span class=\"token operator\">=</span>newSingletonDemo（）；可以分为以下<span class=\"token number\">3</span>步：\nmemory <span class=\"token operator\">=</span><span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//1.分配内存空间</span>\n<span class=\"token function\">instance</span><span class=\"token punctuation\">(</span>memory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//2.初始化对象</span>\ninstance <span class=\"token operator\">=</span>memory<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//3.设置instance刚分配的内存地址，此时instance != null;</span>\n步骤<span class=\"token number\">2</span>和步骤<span class=\"token number\">3</span> 不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化时允许的。\nmemory <span class=\"token operator\">=</span><span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//1.分配内存对象</span>\ninstance<span class=\"token operator\">=</span>memory<span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//3.设置instance刚分配的内存地址，此时instance != null， 但是对象还没有初始化完成！</span>\n<span class=\"token function\">instance</span><span class=\"token punctuation\">(</span>memory<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\" spellcheck=\"true\">//2.初始化对象</span></code></pre>\n<p>但是指令重排只会保证串行语义的执行的一致性（单线程），并不会关心多线程间语义的一致性。<br>所以当一条线程访问instance不为null时，由于instance未必已经初始化完成，也就造成了线程安全问题。</p>\n</li>\n<li><p>方案一(单线程）</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SingletonDemo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">volatile</span> SingletonDemo instance <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SingletonDemo</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> SingletonDemo instance <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n\n      <span class=\"token keyword\">private</span> <span class=\"token function\">SingletonDemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"aaa\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n\n      <span class=\"token comment\" spellcheck=\"true\">//方案一</span>\n      <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> SingletonDemo <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SingletonDemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n          <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p>方案二（synchronized）</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SingletonDemo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> SingletonDemo instance <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token function\">SingletonDemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"aaa\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">//方案二</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">synchronized</span> SingletonDemo <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SingletonDemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p>方案三(DCL+Volatile+Synchronized)</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SingletonDemo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">volatile</span> SingletonDemo instance <span class=\"token operator\">=</span> null<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token function\">SingletonDemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"aaa\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\" spellcheck=\"true\">//方案三</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> SingletonDemo <span class=\"token function\">getInstance</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>SingletonDemo<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>instance <span class=\"token operator\">==</span> null<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                  instance <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SingletonDemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">return</span> instance<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n</ul>\n<h3 id=\"JMM\"><a href=\"#JMM\" class=\"headerlink\" title=\"JMM\"></a>JMM</h3><p><img src=\"Java.assets/Java%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM2.png\" alt=\"Java线程内存模型JMM2\"></p>\n<p>JMM(Java内存模型  Java Memory Model，简称 JMM） 本身是一种抽象的概念并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。<br>由于JVM运行程序的实体是线程，而每个内存创建时JVM都会为其创建一个工作内存（有些地方称为栈内存），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再讲变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程捡的通信（传值）必须通过主内存来完成。<br><strong>JMM关于同步的规定</strong></p>\n<ul>\n<li>线程解锁前，必须把共享变量的值刷新回主内存</li>\n<li>线程加锁前，必须读取主内存的最新值到自己的工作内存</li>\n<li>加锁解锁是同一把锁</li>\n</ul>\n<h4 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h4><p>各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作然后再写回到主内存。<br>这就可能存在一个线程A修改了共享变量X的值但还未写回主内存时，另外一个线程B又对内存中同一个变量X进行操作，此时A线程工作内存中共享变量X对线程B来说并不可见，这种工作内存与主内存同步延迟现象造成了可见性问题</p>\n<h4 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h4><p>number++在多线程下是非线程安全的，如何不加Synchronized解决<br>VolatileDemo代码演示可见性+原子性代码</p>\n<h4 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h4><p>计算机在执行程序时，为了提高性能，编译器和处理器得常常对指令做重排，一般分为3种：<br>单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致<br>处理器在进行重排序时必须要考虑指令间的数据依赖性<br>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测</p>\n<ul>\n<li>重排1<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">mySort</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">int</span> x<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//语句1</span>\n<span class=\"token keyword\">int</span> y<span class=\"token operator\">=</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\" spellcheck=\"true\">//语句2</span>\nx<span class=\"token operator\">=</span>x<span class=\"token operator\">+</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//语句3</span>\ny<span class=\"token operator\">=</span>x<span class=\"token operator\">*</span>x<span class=\"token punctuation\">;</span>   <span class=\"token comment\" spellcheck=\"true\">//语句4</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token number\">1234</span>\n<span class=\"token number\">2134</span>\n<span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>\n语句<span class=\"token number\">4</span>由于存在数据依赖性不会先执行</code></pre>\n</li>\n<li>重排2<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ReSortSeqDemo</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">int</span> a <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">boolean</span> flag <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">method01</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\na <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\nflag <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">method02</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>flag<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\na <span class=\"token operator\">=</span> a <span class=\"token operator\">+</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span>\nSystem<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"**********retValue:\"</span> <span class=\"token operator\">+</span> a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li>禁止指令重排<br>volatile实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象<br>先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：<br>一是保证特定操作的执行顺序<br>二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）<br>由于编译器和处理器都能进行指令重排优化。如果在指令插入一条Memory Barrier则会告诉编译器和CPU，不管什么时候都不能和这条Memory Barrier指令重新排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。内存屏障的另一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。</li>\n</ul>\n<h3 id=\"CAS（comparAndSwap\"><a href=\"#CAS（comparAndSwap\" class=\"headerlink\" title=\"CAS（comparAndSwap)\"></a>CAS（comparAndSwap)</h3><p>比较并交换<br>比较当前工作内存中的值和主内存中的值，如果相同则进行规定操作，否则继续比较直到主内存中的值和工作内存中的值一致为止<br>CAS有三个操作数，内存值V，旧的预期值A，要修改的更新值B。<br>当且仅当预期值A和内存值B相同时，将内存值V修改为B，否则什么也不做。</p>\n<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>CAS的全称为compare-and-swap，它是一条cpu并发原语。<br>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。<br>CAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统原语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条cpu的原子指令，不会造成所谓的数据不一致问题。</p>\n<h5 id=\"底层汇编\"><a href=\"#底层汇编\" class=\"headerlink\" title=\"底层汇编\"></a>底层汇编</h5><p>Unsafe类中的compareAndSwapInt，是一个本地方法，该方法的实现位于unsafe.cpp中是CAS的核心类，由于Java无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为CAS操作的执行依赖于Unsafe类的方法。<br>注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务。 unsafe 位于rt.jar包中<br>unsafe.getAndAddInt</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAndAddInt</span><span class=\"token punctuation\">(</span>Object var1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> var2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> var4<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                 <span class=\"token keyword\">int</span> var5<span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n                   var5 <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getIntVolatile</span><span class=\"token punctuation\">(</span>var1<span class=\"token punctuation\">,</span> var2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSwapInt</span><span class=\"token punctuation\">(</span>var1<span class=\"token punctuation\">,</span> var2<span class=\"token punctuation\">,</span> var5<span class=\"token punctuation\">,</span> var5 <span class=\"token operator\">+</span> var4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n             <span class=\"token keyword\">return</span> var5<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span></code></pre>\n<p>var1 atomicInteger 对象本身。<br>var2 该对象值的引用地址<br>var4  需要变动的数值<br>var5 是用过var1 var2找出的内存中真实的值<br>用该对象当前的值与var5比较<br>如果相同，更新var5+var4并且返回true<br>如果不同，继续取值然后再比较，直到更新完成<br>假设线程A和线程B两个线程同时执行getAndAddInt操作（分别跑在不同cpu上）：</p>\n<ul>\n<li>atomicInteger里面的value原始值为3，即内存中atomicInteger的value为3，根据JMM模型，线程A和线程B各自持有一份值为3的value副本分别到各自的工作内存。</li>\n<li>线程A通过getIntVolatile（var1，var2）拿到value值3，这时线程A被挂起。</li>\n<li>线程B也通过getIntVolatile（var1，var2）方法获取value值3，此时线程B刚好没有被挂起并执行compareAndSwapInt方法比较内存值也为3，成功修改内存值为4，线程B打完收工，一切ok</li>\n<li>这时线程A恢复，执行compareAndSwapInt方法比较，发现自己手里的值3和内存中的值4不一致，说明该值已经被其他线程抢先一步修改过了，那A线程本次修改失败，只能重新读取重新来一遍。</li>\n<li>线程A重新获取value值，因为变量value被volatile修饰，所以其他线程对它的修改，线程A总是能够看到，线程A继续执行compareAndSwapInt方法进行比较替换，直到成功</li>\n</ul>\n<h4 id=\"CAS的缺点\"><a href=\"#CAS的缺点\" class=\"headerlink\" title=\"CAS的缺点\"></a>CAS的缺点</h4><h5 id=\"循环时间长开销很大\"><a href=\"#循环时间长开销很大\" class=\"headerlink\" title=\"循环时间长开销很大\"></a>循环时间长开销很大</h5><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAndAddInt</span><span class=\"token punctuation\">(</span>Object var1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> var2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> var4<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> var5<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n        var5 <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getIntVolatile</span><span class=\"token punctuation\">(</span>var1<span class=\"token punctuation\">,</span> var2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSwapInt</span><span class=\"token punctuation\">(</span>var1<span class=\"token punctuation\">,</span> var2<span class=\"token punctuation\">,</span> var5<span class=\"token punctuation\">,</span> var5 <span class=\"token operator\">+</span> var4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> var5<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>我们可以看到getAndAddInt时，有个do while操作，如果CAS失败时，会一直进行尝试。如果CAS长时间一直不成功，可能会给cpu带来很大的开销。</p>\n<h5 id=\"只能保证一个共享变量的原子操作\"><a href=\"#只能保证一个共享变量的原子操作\" class=\"headerlink\" title=\"只能保证一个共享变量的原子操作\"></a>只能保证一个共享变量的原子操作</h5><p>当对一个共享变量进行操作时，我们可以使用循环CAS来保证原子操作，但是，对于多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p>\n<h5 id=\"引出来ABA问题\"><a href=\"#引出来ABA问题\" class=\"headerlink\" title=\"引出来ABA问题\"></a>引出来ABA问题</h5><h3 id=\"ABA\"><a href=\"#ABA\" class=\"headerlink\" title=\"ABA\"></a>ABA</h3><p>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。<br>原子类AtomicInteger的ABA问题(狸猫换太子) 原子类更新引用</p>\n<h4 id=\"ABA问题产生\"><a href=\"#ABA问题产生\" class=\"headerlink\" title=\"ABA问题产生\"></a>ABA问题产生</h4><p>CAS会导致ABA问题<br>CAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻进行比较并替换，那么在这个时间差会导致数据的变化。<br>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且线程two进行来一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中国年依然是A，然后线程one操作成功。<br>尽管线程one的CAS的操作成功，但是并不代表这个过程就是没有问题的。</p>\n<h4 id=\"原子引用-AtomicReference\"><a href=\"#原子引用-AtomicReference\" class=\"headerlink\" title=\"原子引用(AtomicReference)\"></a>原子引用(AtomicReference)</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">User</span> <span class=\"token punctuation\">{</span>\n    String userName<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">User</span><span class=\"token punctuation\">(</span>String userName<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>userName <span class=\"token operator\">=</span> userName<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">getUserName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> userName<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setUserName</span><span class=\"token punctuation\">(</span>String userName<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>userName <span class=\"token operator\">=</span> userName<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAge</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setAge</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> age<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>age <span class=\"token operator\">=</span> age<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> String <span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token string\">\"User(userName：\"</span> <span class=\"token operator\">+</span> userName <span class=\"token operator\">+</span> <span class=\"token string\">\"，Age：\"</span> <span class=\"token operator\">+</span> age <span class=\"token operator\">+</span> <span class=\"token string\">\")\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AtomicReferenceDemo</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        User zhangsan <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"zhangsan\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">23</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        User lisi <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">User</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"lisi\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">25</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        AtomicReference<span class=\"token operator\">&lt;</span>User<span class=\"token operator\">></span> reference <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicReference</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        reference<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>zhangsan<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>reference<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span>zhangsan<span class=\"token punctuation\">,</span> lisi<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t\"</span> <span class=\"token operator\">+</span> reference<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>reference<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span>zhangsan<span class=\"token punctuation\">,</span> lisi<span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t\"</span> <span class=\"token operator\">+</span> reference<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"时间戳原子引用-AtomicStampedReference\"><a href=\"#时间戳原子引用-AtomicStampedReference\" class=\"headerlink\" title=\"时间戳原子引用(AtomicStampedReference)\"></a>时间戳原子引用(AtomicStampedReference)</h4><p>ABA问题的解决方案</p>\n<pre class=\" language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">AtomicStmapedReferenceDemo</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span> AtomicReference atomicReference <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicReference</span><span class=\"token operator\">&lt;</span>Integer<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">static</span> AtomicStampedReference atomicStampedReference <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicStampedReference</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"================以下是ABA问题的产生================\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            atomicReference<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">101</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            atomicReference<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token number\">101</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"t1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>atomicReference<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2019</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t\"</span> <span class=\"token operator\">+</span> atomicReference<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"t2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=================以下是ABA问题的解决方案=====================\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t第一次版本号：\"</span> <span class=\"token operator\">+</span> atomicStampedReference<span class=\"token punctuation\">.</span><span class=\"token function\">getStamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            atomicStampedReference<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">101</span><span class=\"token punctuation\">,</span> atomicStampedReference<span class=\"token punctuation\">.</span><span class=\"token function\">getStamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> atomicStampedReference<span class=\"token punctuation\">.</span><span class=\"token function\">getStamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t第二次版本号：\"</span> <span class=\"token operator\">+</span> atomicStampedReference<span class=\"token punctuation\">.</span><span class=\"token function\">getStamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            atomicStampedReference<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token number\">101</span><span class=\"token punctuation\">,</span> <span class=\"token number\">100</span><span class=\"token punctuation\">,</span> atomicStampedReference<span class=\"token punctuation\">.</span><span class=\"token function\">getStamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> atomicStampedReference<span class=\"token punctuation\">.</span><span class=\"token function\">getStamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t第三次版本号：\"</span> <span class=\"token operator\">+</span> atomicStampedReference<span class=\"token punctuation\">.</span><span class=\"token function\">getStamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"t3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> stamp <span class=\"token operator\">=</span> atomicStampedReference<span class=\"token punctuation\">.</span><span class=\"token function\">getStamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t第一次版本号：\"</span> <span class=\"token operator\">+</span> stamp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">boolean</span> flag <span class=\"token operator\">=</span> atomicStampedReference<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2019</span><span class=\"token punctuation\">,</span> stamp<span class=\"token punctuation\">,</span> stamp <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t是否修改成功：\"</span> <span class=\"token operator\">+</span> flag<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t当前实际值：\"</span> <span class=\"token operator\">+</span> atomicStampedReference<span class=\"token punctuation\">.</span><span class=\"token function\">getReference</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t当前实际版本号：\"</span> <span class=\"token operator\">+</span> atomicStampedReference<span class=\"token punctuation\">.</span><span class=\"token function\">getStamp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"t4\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"AQS（AbstractQueuedSynchronizer）\"><a href=\"#AQS（AbstractQueuedSynchronizer）\" class=\"headerlink\" title=\"AQS（AbstractQueuedSynchronizer）\"></a>AQS（AbstractQueuedSynchronizer）</h3><p>AQS 是 AbstractQueuedSynchronizer 的简称，它是一个 Java 提高的底层同步 工具类，用一个 int 类型的变量表示同步状态，并提供了一系列的 CAS 操作来管 理这个同步状态。<br>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广 泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。</p>\n<h4 id=\"AQS-支持两种同步方式\"><a href=\"#AQS-支持两种同步方式\" class=\"headerlink\" title=\"AQS 支持两种同步方式\"></a><strong>AQS 支持两种同步方式</strong></h4><ul>\n<li>独占式</li>\n<li>共享式<br>这样方便使用者实现不同类型的同步组件，独占式如 ReentrantLock，共享式如 Semaphore，CountDownLatch，组合式的如 ReentrantReadWriteLock。总之， AQS 为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。</li>\n</ul>\n<h3 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h3><h4 id=\"线程六种状态\"><a href=\"#线程六种状态\" class=\"headerlink\" title=\"线程六种状态\"></a>线程六种状态</h4><ul>\n<li>NEW：新建状态 刚刚创建出来，还没有调用start方法之前的状态。</li>\n<li>RUNNABLE:可运行状态，可能正在执行，也可能不是正在执行，只有在该种状态下的线程才有资格抢CPU。</li>\n<li>BLOCKED:锁阻塞状态  线程要等待另一个线程释放锁对象。</li>\n<li>WAITING：无限等待  线程调用了wait()方法进入的状态，需要其它线程调用notify方法唤醒。</li>\n<li>TIMED_WAITING:计时等待状态  线程调用了sleep方法获wait（long time）方法进入的状态。</li>\n<li>TERMINATED:死亡状态  线程任务执行完毕或调用了stop方法。</li>\n</ul>\n<h4 id=\"ConcurrentModificationException\"><a href=\"#ConcurrentModificationException\" class=\"headerlink\" title=\"ConcurrentModificationException\"></a>ConcurrentModificationException</h4><p>线程不安全</p>\n<ul>\n<li>ArrayList</li>\n<li>HashMap</li>\n<li>HashSet</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ContainerNotSafeDemo</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">MapNotSafe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Map map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> UUID<span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">SetNotSafe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Set set <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                set<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>UUID<span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>set<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">ListNotSafe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n                list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>UUID<span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li><p>解决方案1</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ContainerNotSafeDemo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">MapNotSafe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      Map map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">/// Collections.synchronizedMap(new HashMap&lt;>());new ConcurrentHashMap&lt;>();</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n              map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> UUID<span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>map<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">SetNotSafe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      Set set <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">// Collections.synchronizedSet(new HashSet&lt;>());new CopyOnWriteArraySet&lt;>();</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n              set<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>UUID<span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>set<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">ListNotSafe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token comment\" spellcheck=\"true\">//new Vector&lt;>(); Collections.synchronizedList(new ArrayList&lt;>());new CopyOnWriteArrayList&lt;>();</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n              list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>UUID<span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p>解决方案2（限制不可以使用vector和collections工具类）<br>写时复制<br>CopyOnWrite容器即写时复制容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements,然后新的容器Object[] newElements里面添加元素，添加完元素之后，再将原容器的引用指向新容器setArray（newElements）；，这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n* Appends the specified element to the end of this list.\n*\n* @param e element to be appended to this list\n* @return {@code true} (as specified by {@link Collection#add})\n*/</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>E e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">final</span> ReentrantLock lock <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lock<span class=\"token punctuation\">;</span>\n  lock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> elements <span class=\"token operator\">=</span> <span class=\"token function\">getArray</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">int</span> len <span class=\"token operator\">=</span> elements<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n      Object<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> newElements <span class=\"token operator\">=</span> Arrays<span class=\"token punctuation\">.</span><span class=\"token function\">copyOf</span><span class=\"token punctuation\">(</span>elements<span class=\"token punctuation\">,</span> len <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      newElements<span class=\"token punctuation\">[</span>len<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> e<span class=\"token punctuation\">;</span>\n      <span class=\"token function\">setArray</span><span class=\"token punctuation\">(</span>newElements<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n      lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li><p>Demo</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ContainerNotSafeDemo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      List<span class=\"token operator\">&lt;</span>String<span class=\"token operator\">></span> list <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CopyOnWriteArrayList</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span><span class=\"token number\">30</span> <span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>\n              list<span class=\"token punctuation\">.</span><span class=\"token function\">add</span><span class=\"token punctuation\">(</span>UUID<span class=\"token punctuation\">.</span><span class=\"token function\">randomUUID</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">substring</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span><span class=\"token number\">8</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>list<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"线程接口\"><a href=\"#线程接口\" class=\"headerlink\" title=\"线程接口\"></a>线程接口</h4></li>\n<li><p>分类</p>\n<ul>\n<li>Runnable</li>\n<li>Callable</li>\n</ul>\n</li>\n<li><p>区别</p>\n<ul>\n<li>Callable有返回值，Runnable没有 返回值</li>\n<li>Callable抛异常，Runnable不抛异常</li>\n<li>落地方法不一样，Callable是call，Runnable是run</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"多线程辅助类\"><a href=\"#多线程辅助类\" class=\"headerlink\" title=\"多线程辅助类\"></a>多线程辅助类</h4><p>CountDownLatch/CyclicBarrier/Semaphore /ReadWriteLock</p>\n<h5 id=\"ReadWriteLock\"><a href=\"#ReadWriteLock\" class=\"headerlink\" title=\"ReadWriteLock\"></a>ReadWriteLock</h5><p>读读共存，读写、写写不共存</p>\n<h5 id=\"CountDownLatch（火箭倒计时）\"><a href=\"#CountDownLatch（火箭倒计时）\" class=\"headerlink\" title=\"CountDownLatch（火箭倒计时）\"></a>CountDownLatch（火箭倒计时）</h5><p>减一直到为0<br>让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒。<br>CountDownLatch主要有两个方法，当一个或多个线程调用await方法，调用线程会被阻塞。其它线程调用countDown方法会将计数器减1（调用countDown的方法不会阻塞），当计数器的值变为零时，因调用await方法被阻塞的线程会被唤醒，继续执行。</p>\n<p>main线程会等待其他线程执行完后接着执行</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CountDownLatchDemo</span>  <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        Random random<span class=\"token operator\">=</span>  <span class=\"token keyword\">new</span> <span class=\"token class-name\">Random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        CountDownLatch latch <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CountDownLatch</span><span class=\"token punctuation\">(</span><span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span>random<span class=\"token punctuation\">.</span><span class=\"token function\">nextInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                latch<span class=\"token punctuation\">.</span><span class=\"token function\">countDown</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n\n        latch<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"game over\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h5 id=\"CyclicBarrier（集齐七龙珠，召唤神龙）\"><a href=\"#CyclicBarrier（集齐七龙珠，召唤神龙）\" class=\"headerlink\" title=\"CyclicBarrier（集齐七龙珠，召唤神龙）\"></a>CyclicBarrier（集齐七龙珠，召唤神龙）</h5><p>加一<br>CyclicBarrier 的字面意思是可以循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，让一组线程达到一个屏障（同步点）时被阻塞，直到最后一个线程达到屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await方法。</p>\n<p>主线程会和其他线程一起并发执行</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">CyclicBarrierDemo</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        CyclicBarrier cyclicBarrier <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CyclicBarrier</span><span class=\"token punctuation\">(</span><span class=\"token number\">7</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"===========召唤神龙========\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;=</span><span class=\"token number\">7</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">final</span>  <span class=\"token keyword\">int</span> tmp<span class=\"token operator\">=</span>i<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t 获得第 \"</span> <span class=\"token operator\">+</span> tmp <span class=\"token operator\">+</span> <span class=\"token string\">\" 颗龙珠\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    cyclicBarrier<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">BrokenBarrierException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h5 id=\"Semaphore（抢停车位）\"><a href=\"#Semaphore（抢停车位）\" class=\"headerlink\" title=\"Semaphore（抢停车位）\"></a>Semaphore（抢停车位）</h5><p>多线程抢占固定资源<br>信号量主要有两个目的，一个是用于多个资源的互斥，另一个是用于并发线程数的控制。</p>\n<p>主线程会和其他线程并发执行</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SemaphoreDemo</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Semaphore semaphore <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Semaphore</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    semaphore<span class=\"token punctuation\">.</span><span class=\"token function\">acquire</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t 抢到停车位\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span><span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n                    semaphore<span class=\"token punctuation\">.</span><span class=\"token function\">release</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t 离开了\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><p>线程复用，控制最大并发数，管理线程 </p>\n<h4 id=\"架构说明\"><a href=\"#架构说明\" class=\"headerlink\" title=\"架构说明\"></a>架构说明</h4><p>Java中线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类。</p>\n<h4 id=\"了解\"><a href=\"#了解\" class=\"headerlink\" title=\"了解\"></a>了解</h4><ul>\n<li>Executors.newScheduledThreadPool()</li>\n<li>java8新出（Executors.newWorkStealingPool(int）</li>\n</ul>\n<p>java8 新增，使用目前机器上可用的处理器作为它的并行级别</p>\n<h4 id=\"Executors-newFixedThreadPool-int\"><a href=\"#Executors-newFixedThreadPool-int\" class=\"headerlink\" title=\"Executors.newFixedThreadPool(int)\"></a>Executors.newFixedThreadPool(int)</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n * Creates a thread pool that reuses a fixed number of threads\n * operating off a shared unbounded queue.  At any point, at most\n * {@code nThreads} threads will be active processing tasks.\n * If additional tasks are submitted when all threads are active,\n * they will wait in the queue until a thread is available.\n * If any thread terminates due to a failure during execution\n * prior to shutdown, a new one will take its place if needed to\n * execute subsequent tasks.  The threads in the pool will exist\n * until it is explicitly {@link ExecutorService#shutdown shutdown}.\n *\n * @param nThreads the number of threads in the pool\n * @return the newly created thread pool\n * @throws IllegalArgumentException if {@code nThreads &lt;= 0}\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> ExecutorService <span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> nThreads<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span>nThreads<span class=\"token punctuation\">,</span> nThreads<span class=\"token punctuation\">,</span>\n            0L<span class=\"token punctuation\">,</span> TimeUnit<span class=\"token punctuation\">.</span>MILLISECONDS<span class=\"token punctuation\">,</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedBlockingQueue</span><span class=\"token operator\">&lt;</span>Runnable<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>主要特点：</p>\n<ul>\n<li><p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待</p>\n</li>\n<li><p>newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlokingQueue</p>\n<p>场景：<br>执行长期的任务，性能好很多</p>\n</li>\n</ul>\n<h4 id=\"Executors-newSingleThreadExecutor\"><a href=\"#Executors-newSingleThreadExecutor\" class=\"headerlink\" title=\"Executors.newSingleThreadExecutor()\"></a>Executors.newSingleThreadExecutor()</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n * Creates an Executor that uses a single worker thread operating\n * off an unbounded queue. (Note however that if this single\n * thread terminates due to a failure during execution prior to\n * shutdown, a new one will take its place if needed to execute\n * subsequent tasks.)  Tasks are guaranteed to execute\n * sequentially, and no more than one task will be active at any\n * given time. Unlike the otherwise equivalent\n * {@code newFixedThreadPool(1)} the returned executor is\n * guaranteed not to be reconfigurable to use additional threads.\n *\n * @return the newly created single-threaded Executor\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> ExecutorService <span class=\"token function\">newSingleThreadExecutor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FinalizableDelegatedExecutorService</span>\n            <span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n                    0L<span class=\"token punctuation\">,</span> TimeUnit<span class=\"token punctuation\">.</span>MILLISECONDS<span class=\"token punctuation\">,</span>\n                    <span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedBlockingQueue</span><span class=\"token operator\">&lt;</span>Runnable<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>主要特点：<br>1    创建一个单线化的线程池，它只会用唯一的工作线程来执行任务，保证任务按照指定顺序执行<br>2    newSingleThreadExecutor将corePoolSize和maxmiumPoolSize都设置为1，它使用的是LinkedBlockingQueue<br>场景：<br>任务顺序执行</p>\n<h4 id=\"Executors-newCachedPool\"><a href=\"#Executors-newCachedPool\" class=\"headerlink\" title=\"Executors.newCachedPool()\"></a>Executors.newCachedPool()</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n * Creates a thread pool that creates new threads as needed, but\n * will reuse previously constructed threads when they are\n * available.  These pools will typically improve the performance\n * of programs that execute many short-lived asynchronous tasks.\n * Calls to {@code execute} will reuse previously constructed\n * threads if available. If no existing thread is available, a new\n * thread will be created and added to the pool. Threads that have\n * not been used for sixty seconds are terminated and removed from\n * the cache. Thus, a pool that remains idle for long enough will\n * not consume any resources. Note that pools with similar\n * properties but different details (for example, timeout parameters)\n * may be created using {@link ThreadPoolExecutor} constructors.\n *\n * @return the newly created thread pool\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> ExecutorService <span class=\"token function\">newCachedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> Integer<span class=\"token punctuation\">.</span>MAX_VALUE<span class=\"token punctuation\">,</span>\n            60L<span class=\"token punctuation\">,</span> TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">,</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">SynchronousQueue</span><span class=\"token operator\">&lt;</span>Runnable<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>主要特点：<br>1    创建一个可缓存线程池，如果线程池长度超过处理要求，可灵活回收空线程，若无可回收，则新建线程。<br>2    newCacheThreadPool将coreSize设置为0，将maxmiumSize设置为Integer.MAX_VALUE，使用的是SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程<br>场景：<br>执行很多短期异步的小程序或者负载较轻的服务</p>\n<h4 id=\"7大参数\"><a href=\"#7大参数\" class=\"headerlink\" title=\"7大参数\"></a>7大参数</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n * Creates a new {@code ThreadPoolExecutor} with the given initial\n * parameters and default thread factory and rejected execution handler.\n * It may be more convenient to use one of the {@link Executors} factory\n * methods instead of this general purpose constructor.\n *\n * @param corePoolSize the number of threads to keep in the pool, even\n *        if they are idle, unless {@code allowCoreThreadTimeOut} is set\n * @param maximumPoolSize the maximum number of threads to allow in the\n *        pool\n * @param keepAliveTime when the number of threads is greater than\n *        the core, this is the maximum time that excess idle threads\n *        will wait for new tasks before terminating.\n * @param unit the time unit for the {@code keepAliveTime} argument\n * @param workQueue the queue to use for holding tasks before they are\n *        executed.  This queue will hold only the {@code Runnable}\n *        tasks submitted by the {@code execute} method.\n * @throws IllegalArgumentException if one of the following holds:&lt;br>\n *         {@code corePoolSize &lt; 0}&lt;br>\n *         {@code keepAliveTime &lt; 0}&lt;br>\n *         {@code maximumPoolSize &lt;= 0}&lt;br>\n *         {@code maximumPoolSize &lt; corePoolSize}\n * @throws NullPointerException if {@code workQueue} is null\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token function\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> corePoolSize<span class=\"token punctuation\">,</span>\n                          <span class=\"token keyword\">int</span> maximumPoolSize<span class=\"token punctuation\">,</span>\n                          <span class=\"token keyword\">long</span> keepAliveTime<span class=\"token punctuation\">,</span>\n                          TimeUnit unit<span class=\"token punctuation\">,</span>\n                          BlockingQueue<span class=\"token operator\">&lt;</span>Runnable<span class=\"token operator\">></span> workQueue<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">(</span>corePoolSize<span class=\"token punctuation\">,</span> maximumPoolSize<span class=\"token punctuation\">,</span> keepAliveTime<span class=\"token punctuation\">,</span> unit<span class=\"token punctuation\">,</span> workQueue<span class=\"token punctuation\">,</span>\n            Executors<span class=\"token punctuation\">.</span><span class=\"token function\">defaultThreadFactory</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> defaultHandler<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h5 id=\"corePoolSize\"><a href=\"#corePoolSize\" class=\"headerlink\" title=\"corePoolSize\"></a>corePoolSize</h5><p>线程池中的常驻核心线程数</p>\n<h5 id=\"maximumPoolSize\"><a href=\"#maximumPoolSize\" class=\"headerlink\" title=\"maximumPoolSize\"></a>maximumPoolSize</h5><p>线程池能够容纳同时执行的最大线程数，此值必须大于等于1</p>\n<h5 id=\"keepAliveTime\"><a href=\"#keepAliveTime\" class=\"headerlink\" title=\"keepAliveTime\"></a>keepAliveTime</h5><p>多余的空闲线程的存活时间。<br>当前线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止<br>默认情况下：<br>只有当线程池中的线程数大于corePoolSize时，keepAlive才会起作用，直到线程池中的线程数不大于corePoolSize</p>\n<h5 id=\"unit\"><a href=\"#unit\" class=\"headerlink\" title=\"unit\"></a>unit</h5><p>keepAliveTime的单位</p>\n<h5 id=\"workQueue\"><a href=\"#workQueue\" class=\"headerlink\" title=\"workQueue\"></a>workQueue</h5><p>任务队列，被提交但尚未被执行的任务</p>\n<h5 id=\"threadFactory\"><a href=\"#threadFactory\" class=\"headerlink\" title=\"threadFactory\"></a>threadFactory</h5><p>表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可</p>\n<h5 id=\"handler\"><a href=\"#handler\" class=\"headerlink\" title=\"handler\"></a>handler</h5><p>拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runnable的策略<br>等待队列也已经满了，再也塞不下新任务了<br>同时，线程池中的max线程也达到了，无法继续为信任服务<br>这时候我们就需要拒绝策略机制合理的处理这个问题</p>\n<ul>\n<li>AbortPolicy（默认）<br>中断抛异常</li>\n<li>CallerRunsPolicy<br>调用者运行。该策略既不会抛弃任务也不会抛异常，而是将任务回退给调用者，从而降低新任的流量</li>\n<li>DiscardPolicy<br>该策略会默默的抛弃无法处理的任务，不予任何处理也不会抛异常。如果任务允许丢失，这是最好的一种策略</li>\n<li>DiscardOldestPolicy<br>抛弃队列中等待最久的任务，把当前任务加入队列中尝试再次提交任务</li>\n</ul>\n<h4 id=\"说说线程池底层的工作原理\"><a href=\"#说说线程池底层的工作原理\" class=\"headerlink\" title=\"说说线程池底层的工作原理\"></a>说说线程池底层的工作原理</h4><ul>\n<li>在创建来线程池后，等待提交过来的任务请求</li>\n<li>当调用execute()方法添加一个任务时，线程池会作以下判断：<ul>\n<li>如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务</li>\n<li>如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务加入队列</li>\n<li>如果这时队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程运行这个任务</li>\n<li>如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行</li>\n</ul>\n</li>\n<li>当一个线程完成任务是，它会从队列中取下一个任务来执行</li>\n<li>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程池会判断：<br>如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。<br>所以线程池的所有任务完成后它最终会收缩到corePoolSize的大小。</li>\n</ul>\n<h4 id=\"execute方法-和submit方法的区别\"><a href=\"#execute方法-和submit方法的区别\" class=\"headerlink\" title=\"execute方法 和submit方法的区别\"></a>execute方法 和submit方法的区别</h4><ul>\n<li>execute 没有返回值，submit带有返回值</li>\n<li>execute可以传入Runnable接口，submit可以传入Runnable和Callable接口</li>\n</ul>\n<h4 id=\"合理配置线程池你是如何考虑的\"><a href=\"#合理配置线程池你是如何考虑的\" class=\"headerlink\" title=\"合理配置线程池你是如何考虑的\"></a>合理配置线程池你是如何考虑的</h4><h5 id=\"CPU密集型\"><a href=\"#CPU密集型\" class=\"headerlink\" title=\"CPU密集型\"></a>CPU密集型</h5><p>CPU密集型，即该任务需要大量CPU运算，没有阻塞，CPU一直处于全速运行状态<br>CPU密集型任务只有在真正多核CPU上才可能得到加速（通过多线程）<br>在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些<br>CPU密集型任务配置尽可能少的线程数量：<br>一般公式：线程池=CPU核数+1个线程<br>Runtime.getRuntime().availableProcessors()+[1-2]</p>\n<h5 id=\"IO密集型\"><a href=\"#IO密集型\" class=\"headerlink\" title=\"IO密集型\"></a>IO密集型</h5><ul>\n<li><p>方案一<br>由于IO密集型任务线程并不是一直在执行任务，则应该配置尽可能多的线程，如CPU核数*2</p>\n</li>\n<li><p>方案二<br>IO密集型，该任务需要大量的IO操作，即大量的阻塞<br>在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力在等待上，所以在IO密集型任务中使用多线程可以大大的加速程序运行，在单核CPU上，这种加速主要就是利用了被浪费的阻塞时间<br>IO密集型，大部分线程都在阻塞，故要多配置线程数：<br>参考公式：CPU核数／1-阻塞系数<br>阻塞系数=0.8～0.9<br>阻塞系数一般取0.9<br>比如8核CPU：8/（1-0.9）=80个线程数</p>\n</li>\n</ul>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><p>阻塞队列，顾名思义，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下：<br>线程1往队列中添加元素，而线程2从阻塞队列中移除元素<br>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞。<br>当阻塞队列满的时候，往队列中添加元素的操作将会被阻塞。<br>试图从空的阻塞队列中国年获取元素的线程将会阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程从队列中移除一个或多个元素或者完全清空队列后使队列重新变得空闲起来并后续新增。</p>\n<h4 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h4><p>在多线程领域：所谓阻塞。在某些情况下会挂起线程（即阻塞），一旦条件被满足，被挂起的线程又会自动被唤醒</p>\n<h4 id=\"BlockingQueue\"><a href=\"#BlockingQueue\" class=\"headerlink\" title=\"BlockingQueue\"></a>BlockingQueue</h4><p>空的时候不能获取，满的时候不能生产 </p>\n<p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手操办了。<br>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，而这会使我们的程序带来不小的复杂度。</p>\n<h5 id=\"ArrayBlockingQueue\"><a href=\"#ArrayBlockingQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue\"></a>ArrayBlockingQueue</h5><p>由数组结构组成的有界阻塞队列</p>\n<h5 id=\"LinkedBlockingQueue\"><a href=\"#LinkedBlockingQueue\" class=\"headerlink\" title=\"LinkedBlockingQueue\"></a>LinkedBlockingQueue</h5><p>由链表结构构成的有界队列（但大小默认值为Inter.MAX_VALUE）阻塞队列</p>\n<h5 id=\"PriorityBlockingQueue\"><a href=\"#PriorityBlockingQueue\" class=\"headerlink\" title=\"PriorityBlockingQueue\"></a>PriorityBlockingQueue</h5><p>支持优先级排序的无界阻塞队列</p>\n<h5 id=\"DelayQueue\"><a href=\"#DelayQueue\" class=\"headerlink\" title=\"DelayQueue\"></a>DelayQueue</h5><p>使用优先级队列实现的延迟无界阻塞队列</p>\n<h5 id=\"SynchronousQueue\"><a href=\"#SynchronousQueue\" class=\"headerlink\" title=\"SynchronousQueue\"></a>SynchronousQueue</h5><p>不存储元素的阻塞队列，也即单个元素的队列<br>SynchronousQueue 没有容量<br>与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue<br>每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然</p>\n<ul>\n<li>Demo<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SynchronousQueueDemo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      SynchronousQueue<span class=\"token operator\">&lt;</span>Object<span class=\"token operator\">></span> synchronousQueue <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SynchronousQueue</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n              System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t put 1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              synchronousQueue<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t put 2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              synchronousQueue<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t put 3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              synchronousQueue<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"t1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n              System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t take 1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              synchronousQueue<span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t take 2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              synchronousQueue<span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t take 3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              synchronousQueue<span class=\"token punctuation\">.</span><span class=\"token function\">take</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"t2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h5 id=\"LinkedTransferQueue\"><a href=\"#LinkedTransferQueue\" class=\"headerlink\" title=\"LinkedTransferQueue\"></a>LinkedTransferQueue</h5>由链表结构组成的无界阻塞队列<h5 id=\"LinkedBlockingDeque\"><a href=\"#LinkedBlockingDeque\" class=\"headerlink\" title=\"LinkedBlockingDeque\"></a>LinkedBlockingDeque</h5>由链表结构组成的双向阻塞队列</li>\n</ul>\n<h4 id=\"核心方法\"><a href=\"#核心方法\" class=\"headerlink\" title=\"核心方法\"></a>核心方法</h4><h5 id=\"抛异常\"><a href=\"#抛异常\" class=\"headerlink\" title=\"抛异常\"></a>抛异常</h5><ul>\n<li>add<br>当队列满时，再添加元素会抛出异常（Queue Full）</li>\n<li>remove<br>当队列空时，再移除元素会抛出异常（NoSuchElementException）</li>\n<li>element<br>检查队列第一个元素</li>\n</ul>\n<h5 id=\"有返回值\"><a href=\"#有返回值\" class=\"headerlink\" title=\"有返回值\"></a>有返回值</h5><ul>\n<li>offer(e)<br>当队列满时，再添加元素不会抛出异常会返回false</li>\n<li>poll<br>当队列空时，再移除元素不会抛出异常会返回null</li>\n<li>peek<br>检查队列第一个元素</li>\n</ul>\n<h5 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h5><ul>\n<li>put<br>当队列满时，再添加元素会一直阻塞，直到可以添加元素</li>\n<li>take<br>当队列空时，再移除元素会一直阻塞，直到有元素可以移除</li>\n</ul>\n<h5 id=\"超时\"><a href=\"#超时\" class=\"headerlink\" title=\"超时\"></a>超时</h5><ul>\n<li>offer(e,time,unit)<br>当队列满时，再添加元素会等待，直到超时时间到达，返回false</li>\n<li>poll(time,unit)<br>当队列空时，再移除元素会等待，直到超时时间到达，返回null</li>\n</ul>\n<h4 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h4><h5 id=\"生产者消费者模式\"><a href=\"#生产者消费者模式\" class=\"headerlink\" title=\"生产者消费者模式\"></a>生产者消费者模式</h5><ul>\n<li>传统版</li>\n<li>Demo<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ShareData</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">int</span> number<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  Lock lock<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  Condition condition<span class=\"token operator\">=</span>lock<span class=\"token punctuation\">.</span><span class=\"token function\">newCondition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">increment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">throws</span> Exception<span class=\"token punctuation\">{</span>\n      lock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>number<span class=\"token operator\">!=</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n              condition<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n          number<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n          System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t\"</span> <span class=\"token operator\">+</span> number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          condition<span class=\"token punctuation\">.</span><span class=\"token function\">signalAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n          e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n          lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">decrement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token keyword\">throws</span> Exception<span class=\"token punctuation\">{</span>\n      lock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>number<span class=\"token operator\">==</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n              condition<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n          number<span class=\"token operator\">--</span><span class=\"token punctuation\">;</span>\n          System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t\"</span> <span class=\"token operator\">+</span> number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          condition<span class=\"token punctuation\">.</span><span class=\"token function\">signalAll</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n          e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n          lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ProdConsumer_TraditionDemo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      ShareData shareData <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ShareData</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                  shareData<span class=\"token punctuation\">.</span><span class=\"token function\">increment</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                  e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"t1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                  shareData<span class=\"token punctuation\">.</span><span class=\"token function\">decrement</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                  e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n              <span class=\"token punctuation\">}</span>\n          <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"t2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n</li>\n<li>阻塞队列版</li>\n</ul>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><p>公平锁／非公平锁／可重入锁／递归锁／自旋锁</p>\n<h3 id=\"四种状态\"><a href=\"#四种状态\" class=\"headerlink\" title=\"四种状态\"></a>四种状态</h3><h4 id=\"无锁\"><a href=\"#无锁\" class=\"headerlink\" title=\"无锁\"></a>无锁</h4><h4 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h4><h4 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h4><h4 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h4><h3 id=\"锁的升级\"><a href=\"#锁的升级\" class=\"headerlink\" title=\"锁的升级\"></a>锁的升级</h3><p>当只有一个线程访问是叫做偏向锁——&gt;发生竞争时升级成轻量级锁（自选锁等）——&gt;自选等待没结果时升级成重量级锁</p>\n<h3 id=\"公平锁\"><a href=\"#公平锁\" class=\"headerlink\" title=\"公平锁\"></a>公平锁</h3><p>是指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先来后到。</p>\n<h3 id=\"非公平锁\"><a href=\"#非公平锁\" class=\"headerlink\" title=\"非公平锁\"></a>非公平锁</h3><p>是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发的情况下，有可能会造成优先级反转或者饥饿现象。</p>\n<h3 id=\"公平锁／非公平锁-两者区别\"><a href=\"#公平锁／非公平锁-两者区别\" class=\"headerlink\" title=\"公平锁／非公平锁 两者区别\"></a>公平锁／非公平锁 两者区别</h3><p>并发包中ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或非公平锁，默认是非公平锁。<br>Java ReentrantLock 而言，通过构造函数指定该锁是否是公平锁（默认是非公平锁）。非公平锁的优点在于吞吐量比公平锁大。<br>对于Synchronized而言，也是一种非公平锁。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">/**\n * Creates an instance of {@code ReentrantLock}.\n * This is equivalent to using {@code ReentrantLock(false)}.\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token function\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    sync <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NonfairSync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\" spellcheck=\"true\">/**\n * Creates an instance of {@code ReentrantLock} with the\n * given fairness policy.\n *\n * @param fair {@code true} if this lock should use a fair ordering policy\n */</span>\n<span class=\"token keyword\">public</span> <span class=\"token function\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">boolean</span> fair<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    sync <span class=\"token operator\">=</span> fair <span class=\"token operator\">?</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FairSync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NonfairSync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>公平锁：Threads acquire a fair lock in the order in which they requested it<br>公平锁，就是很公平，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己<br>非公平锁：Threads acquire a fair lock in the order in which they requested it<br>非公平锁比较粗鲁，上来就尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。</p>\n<h3 id=\"可重入锁（递归锁）\"><a href=\"#可重入锁（递归锁）\" class=\"headerlink\" title=\"可重入锁（递归锁）\"></a>可重入锁（递归锁）</h3><p>指的是统一线程外层函数获得锁之后，内层递归函数仍然能获取该所的代码。<br>统一线程在外层方法获取锁之后，进入内层方法后会自动获取锁。也就是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。</p>\n<ul>\n<li>ReentrantLock/Synchronized就是一个典型的可重入锁</li>\n<li>可重入锁的最大作用就是避免死锁</li>\n<li>ReenterLockDemo<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Phone</span> <span class=\"token keyword\">implements</span>  <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span>  <span class=\"token function\">sedSMS</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"\\t invoked sendSMS\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token function\">sedMail</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span>  <span class=\"token function\">sedMail</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"\\t invoked sedMail\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token annotation punctuation\">@Override</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      Lock lock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      lock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n          System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"\\t invoked get\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n          lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">set</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      Lock lock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      lock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n          System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"\\t invoked set\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n          lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ReenterLockDemo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n      Phone phone <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Phone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>phone<span class=\"token punctuation\">.</span><span class=\"token function\">sedSMS</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"t1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>phone<span class=\"token punctuation\">.</span><span class=\"token function\">sedSMS</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"t2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"=======================\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>phone<span class=\"token punctuation\">,</span><span class=\"token string\">\"t3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>phone<span class=\"token punctuation\">,</span><span class=\"token string\">\"t4\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"独占锁\"><a href=\"#独占锁\" class=\"headerlink\" title=\"独占锁\"></a>独占锁</h3>指该锁一次只能被一个线程持有。对ReentrantLock和Synchronized而言都是独占锁</li>\n</ul>\n<h3 id=\"共享锁\"><a href=\"#共享锁\" class=\"headerlink\" title=\"共享锁\"></a>共享锁</h3><p>指该锁可被多个线程所持有<br>对ReentrantReadWriteLock其读锁是共享锁，其写锁是独占锁<br>读锁对共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">ReadWriteLockDemo</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">volatile</span> Map map<span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span>String<span class=\"token punctuation\">,</span>Object<span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    ReadWriteLock rwLock<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantReadWriteLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">get</span><span class=\"token punctuation\">(</span>String key<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        rwLock<span class=\"token punctuation\">.</span><span class=\"token function\">readLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"\\t 正在读\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            TimeUnit<span class=\"token punctuation\">.</span>MILLISECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">300</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            Object res<span class=\"token operator\">=</span>map<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"\\t 读完成：\"</span><span class=\"token operator\">+</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">finally</span><span class=\"token punctuation\">{</span>\n            rwLock<span class=\"token punctuation\">.</span><span class=\"token function\">readLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span>String key<span class=\"token punctuation\">,</span>Object value<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n        rwLock<span class=\"token punctuation\">.</span><span class=\"token function\">writeLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"\\t 正在写：\"</span><span class=\"token operator\">+</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            TimeUnit<span class=\"token punctuation\">.</span>MILLISECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">300</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span>value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t 写完成\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token keyword\">finally</span><span class=\"token punctuation\">{</span>\n            rwLock<span class=\"token punctuation\">.</span><span class=\"token function\">writeLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        ReadWriteLockDemo readWriteLockDemo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReadWriteLockDemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">10</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> tmp<span class=\"token operator\">=</span>i<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    readWriteLockDemo<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>tmp<span class=\"token operator\">+</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">,</span>tmp<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">5</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> tmp<span class=\"token operator\">=</span>i<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                    readWriteLockDemo<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>tmp<span class=\"token operator\">+</span><span class=\"token string\">\"\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>String<span class=\"token punctuation\">.</span><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"自旋锁（spinlock）\"><a href=\"#自旋锁（spinlock）\" class=\"headerlink\" title=\"自旋锁（spinlock）\"></a>自旋锁（spinlock）</h3><p>是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式尝试去获取锁，这样的好出是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token comment\" spellcheck=\"true\">//unsafe.getAndAddInt</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">int</span> <span class=\"token function\">getAndAddInt</span><span class=\"token punctuation\">(</span>Object var1<span class=\"token punctuation\">,</span> <span class=\"token keyword\">long</span> var2<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> var4<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">int</span> var5<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n        var5 <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">getIntVolatile</span><span class=\"token punctuation\">(</span>var1<span class=\"token punctuation\">,</span> var2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSwapInt</span><span class=\"token punctuation\">(</span>var1<span class=\"token punctuation\">,</span> var2<span class=\"token punctuation\">,</span> var5<span class=\"token punctuation\">,</span> var5 <span class=\"token operator\">+</span> var4<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> var5<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<ul>\n<li>Demo<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SpinLockDemo</span> <span class=\"token punctuation\">{</span>\n  AtomicReference<span class=\"token operator\">&lt;</span>Thread<span class=\"token operator\">></span> atomicReference<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">AtomicReference</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">myLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      Thread thread<span class=\"token operator\">=</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>thread<span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"\\t come in \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>atomicReference<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span>null<span class=\"token punctuation\">,</span>thread<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">myUnLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n      atomicReference<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>null<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token string\">\"\\t out \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> InterruptedException <span class=\"token punctuation\">{</span>\n      SpinLockDemo spinLockDemo <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SpinLockDemo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>\n          spinLockDemo<span class=\"token punctuation\">.</span><span class=\"token function\">myLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n              TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n          spinLockDemo<span class=\"token punctuation\">.</span><span class=\"token function\">myUnLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"t1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>\n          spinLockDemo<span class=\"token punctuation\">.</span><span class=\"token function\">myLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          spinLockDemo<span class=\"token punctuation\">.</span><span class=\"token function\">myUnLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token string\">\"t2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"Synchornized\"><a href=\"#Synchornized\" class=\"headerlink\" title=\"Synchornized\"></a>Synchornized</h3>实现同步方法的基础是Java中的每个对象都可以作为锁<br>Synchronized （对象锁），static synchronized （类锁|全局锁），这两种锁互补影响，互相没有关系，可以同时访问</li>\n</ul>\n<h4 id=\"具体表现\"><a href=\"#具体表现\" class=\"headerlink\" title=\"具体表现\"></a>具体表现</h4><ul>\n<li>对于普通同步方法，锁的是当前实例对象，锁的是this</li>\n<li>对于同步方法块，锁的是synchroniezd括号里面的配置对象</li>\n<li>对于静态同步方法，锁的是当前类的Class对象</li>\n</ul>\n<h4 id=\"Synchronized与Lock有什么区别\"><a href=\"#Synchronized与Lock有什么区别\" class=\"headerlink\" title=\"Synchronized与Lock有什么区别\"></a>Synchronized与Lock有什么区别</h4><h5 id=\"原始构成\"><a href=\"#原始构成\" class=\"headerlink\" title=\"原始构成\"></a>原始构成</h5><ul>\n<li>Synchronized是关键字属于JVM层面，底层是通过monitor对象来完成，其wait／notify等方法也依赖与monitor对象，只有在同步块或方法中才能调用wait／notify等方法<br>monitorenter   进入，monitorexit    退出（有两层退出，正常情况和非正常情况都能退出，不会造成死锁）</li>\n<li>Lock 是API层面</li>\n</ul>\n<h5 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h5><ul>\n<li>Synchronized 不需要用户手动去释放锁，当synchronized代码执行完成后系统会自动让线程释放对锁的占用</li>\n<li>ReentrantLock则需要用户手动去释放锁，若没有主动释放锁，就有可能出现死锁现象<br>需要lock和unlock方法配合try finally 语句完成</li>\n</ul>\n<h5 id=\"等待是否可中断\"><a href=\"#等待是否可中断\" class=\"headerlink\" title=\"等待是否可中断\"></a>等待是否可中断</h5><ul>\n<li>Synchronized不可中断，除非抛出异常或者正常执行完成</li>\n<li>ReentrantLock可中断<ul>\n<li>设置超时方法 tryLock（long timeout，TimeUtil unit）</li>\n<li>lockInterruptibly（）放代码块中，调用interrupt（）可中断</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"加锁是否公平\"><a href=\"#加锁是否公平\" class=\"headerlink\" title=\"加锁是否公平\"></a>加锁是否公平</h5><ul>\n<li>Synchronized 非公平锁</li>\n<li>ReentrantLock 两者都可以，默认非公平锁，构造方法可传入boolean值，true为公平锁，false为非公平锁    </li>\n</ul>\n<h5 id=\"锁绑定多个条件Condition\"><a href=\"#锁绑定多个条件Condition\" class=\"headerlink\" title=\"锁绑定多个条件Condition\"></a>锁绑定多个条件Condition</h5><ul>\n<li>Synchronized 没有</li>\n<li>ReentrantLock用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不像synchronized要么随机唤醒一个线程要么唤醒全部线程</li>\n</ul>\n<pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Data</span> <span class=\"token punctuation\">{</span>\n    Lock lock <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Condition c1 <span class=\"token operator\">=</span> lock<span class=\"token punctuation\">.</span><span class=\"token function\">newCondition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Condition c2 <span class=\"token operator\">=</span> lock<span class=\"token punctuation\">.</span><span class=\"token function\">newCondition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    Condition c3 <span class=\"token operator\">=</span> lock<span class=\"token punctuation\">.</span><span class=\"token function\">newCondition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">int</span> number <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">print5</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        lock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>number <span class=\"token operator\">!=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                c1<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t\"</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            number <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n            c2<span class=\"token punctuation\">.</span><span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">print10</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        lock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>number <span class=\"token operator\">!=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                c2<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t\"</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            number <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span>\n            c3<span class=\"token punctuation\">.</span><span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">print15</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        lock<span class=\"token punctuation\">.</span><span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>number <span class=\"token operator\">!=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                c3<span class=\"token punctuation\">.</span><span class=\"token function\">await</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">15</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t\"</span> <span class=\"token operator\">+</span> i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            number <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n            c1<span class=\"token punctuation\">.</span><span class=\"token function\">signal</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Exception</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n            lock<span class=\"token punctuation\">.</span><span class=\"token function\">unlock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Conditions</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        Data data <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Data</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                data<span class=\"token punctuation\">.</span><span class=\"token function\">print5</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"A\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                data<span class=\"token punctuation\">.</span><span class=\"token function\">print10</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"B\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token number\">10</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                data<span class=\"token punctuation\">.</span><span class=\"token function\">print15</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"C\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"死锁编码及定位分析\"><a href=\"#死锁编码及定位分析\" class=\"headerlink\" title=\"死锁编码及定位分析\"></a>死锁编码及定位分析</h3><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那么它们都将无法推进下去，如果系统资源充足，线程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p>\n<h4 id=\"系统资源不足\"><a href=\"#系统资源不足\" class=\"headerlink\" title=\"系统资源不足\"></a>系统资源不足</h4><h4 id=\"线程进行推进的顺序不合适\"><a href=\"#线程进行推进的顺序不合适\" class=\"headerlink\" title=\"线程进行推进的顺序不合适\"></a>线程进行推进的顺序不合适</h4><h4 id=\"资源分配不当\"><a href=\"#资源分配不当\" class=\"headerlink\" title=\"资源分配不当\"></a>资源分配不当</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">HoldLockThread</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">Runnable</span> <span class=\"token punctuation\">{</span>\n    String lockA<span class=\"token punctuation\">;</span>\n    String lockB<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token function\">HoldLockThread</span><span class=\"token punctuation\">(</span>String lockA<span class=\"token punctuation\">,</span> String lockB<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lockA <span class=\"token operator\">=</span> lockA<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>lockB <span class=\"token operator\">=</span> lockB<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token annotation punctuation\">@Override</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>lockA<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t 持有锁：\"</span> <span class=\"token operator\">+</span> lockA <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t 试图获取锁：\"</span> <span class=\"token operator\">+</span> lockB<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n                TimeUnit<span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                e<span class=\"token punctuation\">.</span><span class=\"token function\">printStackTrace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n            <span class=\"token keyword\">synchronized</span> <span class=\"token punctuation\">(</span>lockB<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                System<span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span>Thread<span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t 持有锁：\"</span> <span class=\"token operator\">+</span> lockB <span class=\"token operator\">+</span> <span class=\"token string\">\"\\t 试图获取锁：\"</span> <span class=\"token operator\">+</span> lockA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DeadLockDemo</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span>String<span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        String lockA <span class=\"token operator\">=</span> <span class=\"token string\">\"lockA\"</span><span class=\"token punctuation\">;</span>\n        String lockB <span class=\"token operator\">=</span> <span class=\"token string\">\"lockB\"</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">HoldLockThread</span><span class=\"token punctuation\">(</span>lockA<span class=\"token punctuation\">,</span> lockB<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"t1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">HoldLockThread</span><span class=\"token punctuation\">(</span>lockB<span class=\"token punctuation\">,</span> lockA<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"t2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h4 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h4><ul>\n<li>jps命令定位进程号</li>\n<li>jstack找到死锁查看</li>\n</ul>\n<h3 id=\"什么是分布式锁\"><a href=\"#什么是分布式锁\" class=\"headerlink\" title=\"什么是分布式锁\"></a>什么是分布式锁</h3><p>当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。分布式锁可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存，如 Redis，通过set (key,value,nx,px,timeout)方法添加分布式锁。</p>\n<h3 id=\"什么是分布式事务\"><a href=\"#什么是分布式事务\" class=\"headerlink\" title=\"什么是分布式事务\"></a>什么是分布式事务</h3><p>分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。</p>\n<h2 id=\"集合（Collection）\"><a href=\"#集合（Collection）\" class=\"headerlink\" title=\"集合（Collection）\"></a>集合（Collection）</h2><h3 id=\"List集合\"><a href=\"#List集合\" class=\"headerlink\" title=\"List集合\"></a>List集合</h3><p>ArrayList扩容为原来一半</p>\n<h3 id=\"Set集合\"><a href=\"#Set集合\" class=\"headerlink\" title=\"Set集合\"></a>Set集合</h3><h4 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h4><pre class=\" language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token function\">HashSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    map <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">HashMap</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nHashSet底层是HashMap，put的值是key，value是一个Object类型的静态常量\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> Object PRESENT <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span>E e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> map<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">,</span> PRESENT<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> null<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"Map集合\"><a href=\"#Map集合\" class=\"headerlink\" title=\"Map集合\"></a>Map集合</h3><h4 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h4><p>初始长度16 负载因子 3/4 扩容为2倍原长度，调用构造函数只是进行了默认长度和负载因子的设置并没有初始化数组，开辟存储空间。 1.7数组加单向链表，每个元素是entry，1.8 链表最大长度8 超过会转成红黑树，每个元素是Node。key可以为null，将key为null放在下标为0的位置</p>\n<h5 id=\"put-key1-value1\"><a href=\"#put-key1-value1\" class=\"headerlink\" title=\"put(key1,value1)\"></a>put(key1,value1)</h5><p>七上八下（1.7 新加元素会在链表上面添加，1.8会在下面添加）</p>\n<ul>\n<li>首先调用key1的hashCode方法，然后再经过特定计算，计算出hash值，hash值&amp;（length-1）计算出存放位置（Entry数组下标）</li>\n<li>如果此位置上的数据为空，此时添加成功          —情况1   </li>\n<li>如果此位置上的数据不为空（意味着，此位置上存在一个或多个数据（以链表方式存在）），比较key1和已经存在的一个或多个数据的哈希值<ul>\n<li>如果key1的哈希值与已经存在的数据哈希值都不同，此时添加成功    —-情况2</li>\n<li>如果key1的哈希值和已经存在的某一个数据（key2，value2）key2的哈希值相同，继续比较。调用key1所在类的equals（key2）<ul>\n<li>如果equals的返回值为false：此时添加成功       —情况3</li>\n<li>如果equals的返回值为true：使用value1替换掉value2</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>补充：关于情况2和情况3:此时key1-value1的数据以链表的方式存储。</p>\n<h5 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h5><p>在不断的添加过程中会涉及到扩容问题，默认的扩容方式：扩容为原来的2倍，并将原来的数据迁移过来。（不是rehash，而是链表上的数据通过用新数组长度进行计算得到的下标，会有两种情况，一种是和之前下标一样，一种是在原来下标基础上加上原来数组长度的下标。例如：原来下标为2，原来数组长度为8，新数组长度为16，链表上的数据有可能下标是2，有可能下标是2+8=10。）</p>\n<ul>\n<li>1.7：size &gt;= threshold) &amp;&amp; (null != table[bucketIndex]</li>\n<li>1.8：++size &gt; threshold或tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY<h4 id=\"为什么HashMap的长度是2的n次幂\"><a href=\"#为什么HashMap的长度是2的n次幂\" class=\"headerlink\" title=\"为什么HashMap的长度是2的n次幂\"></a>为什么HashMap的长度是2的n次幂</h4>当长度2的n次幂时，2的n次幂 - 1=1111（2进制），任何值与此值按位（&amp;）计算，这样才会快速拿到数组下标，并且数据分布相对均匀。<h4 id=\"1-8-链表改为红黑树条件\"><a href=\"#1-8-链表改为红黑树条件\" class=\"headerlink\" title=\"1.8 链表改为红黑树条件\"></a>1.8 链表改为红黑树条件</h4>当数组的某一个索引位置上的元素以链表的形式存在的，数据个数&gt;8且当前数组长度&gt;64时，此时次位置伤的所有数据改为使用红黑树存储。<h4 id=\"1-8-链表变成红黑树的阀值为8\"><a href=\"#1-8-链表变成红黑树的阀值为8\" class=\"headerlink\" title=\"1.8 链表变成红黑树的阀值为8\"></a>1.8 链表变成红黑树的阀值为8</h4>因为哈希桶中节点个数服从参数为0.5的泊松分布，超过8的概率很小<h4 id=\"HashMap和HashTable区别\"><a href=\"#HashMap和HashTable区别\" class=\"headerlink\" title=\"HashMap和HashTable区别\"></a>HashMap和HashTable区别</h4><h5 id=\"线程安全性不同\"><a href=\"#线程安全性不同\" class=\"headerlink\" title=\"线程安全性不同\"></a>线程安全性不同</h5>HashMap是线程不安全的，HashTable是线程安全的，其中的方法是Synchronize的，在多线程并发的情况下，可以直接使用HashTable，但是使用HashMap时必须自己增加同步处理。<h5 id=\"是否提供contains方法\"><a href=\"#是否提供contains方法\" class=\"headerlink\" title=\"是否提供contains方法\"></a>是否提供contains方法</h5>HashMap只有containsValue和containsKey方法；HashTable有contains、containsKey和containsValue三个方法，其中contains和containsValue方法功能相同。<h5 id=\"key和value是否允许null值\"><a href=\"#key和value是否允许null值\" class=\"headerlink\" title=\"key和value是否允许null值\"></a>key和value是否允许null值</h5>HashTable中，key和value都不允许出现null值。HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。<h5 id=\"数组初始化和扩容机制\"><a href=\"#数组初始化和扩容机制\" class=\"headerlink\" title=\"数组初始化和扩容机制\"></a>数组初始化和扩容机制</h5></li>\n<li>HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。</li>\n<li>HashTable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。<h4 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h4></li>\n<li>Segment：一个小型的HashMap，大小由并发级别确定</li>\n<li>线程安全，使用分段锁来控制同步访问问题</li>\n</ul>\n<h4 id=\"TreeSet和HashSet区别\"><a href=\"#TreeSet和HashSet区别\" class=\"headerlink\" title=\"TreeSet和HashSet区别\"></a>TreeSet和HashSet区别</h4><p>HashSet是采用hash表来实现的。其中的元素没有按顺序排列，add()、remove()以及contains()等方法都是复杂度为O(1)的方法。<br>TreeSet是采用树结构实现(红黑树算法)。元素是按顺序进行排列，但是add()、remove()以及contains()等方法都是复杂度为O(log (n))的方法。它还提供了一些方法来处理排序的set，如first(), last(), headSet(), tailSet()等等。</p>\n<h2 id=\"字符串（String）\"><a href=\"#字符串（String）\" class=\"headerlink\" title=\"字符串（String）\"></a>字符串（String）</h2><h3 id=\"String-buffer和String-build区别\"><a href=\"#String-buffer和String-build区别\" class=\"headerlink\" title=\"String buffer和String build区别\"></a>String buffer和String build区别</h3><ul>\n<li>StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，</li>\n<li>只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。 </li>\n<li>在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全而StringBuffer则每次都需要判断锁，效率相对更低</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><h4 id=\"强引用（默认支持模式）\"><a href=\"#强引用（默认支持模式）\" class=\"headerlink\" title=\"强引用（默认支持模式）\"></a>强引用（默认支持模式）</h4><p>当内存不足，JVM开始垃圾回收，对于强引用当对象，就算是出现了OOM也不会对该对象进行回收，死都不回收。<br>强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成java内存泄漏的主要原因之一。<br>对于一个普通对象，如果没有其他的引用关系，只要超过了引用作用域或者显式的将相应（强）引用赋值为null，一般认为就是可以被垃圾收集的了（当然具体回收时机还要看垃圾收集策略）。</p>\n<h4 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h4><p>软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。<br>对于只有弱引用的对象来说，<br>当系统内存充足时不会被回收<br>当系统内存不足时会被回收<br>软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用就保留，不够用就回收。</p>\n<h4 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h4><p>弱引用需要用java.lang.ref.WeakReference类来实现，它比软引用的生存周期更短，<br>对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存。<br>软引用、弱引用应用场景：<br>假如有一个应用需要读取大量的本地图片：<br>如果每次读取图片都要从硬盘读取图片则会严重影响性能<br>如果一次性全部加载到内存中又能造成内存溢出<br>设计思路：<br>用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免来OOM的问题。<br><code>Map&lt;String,SoftReference&lt;Bitmap&gt;&gt; imageCache =new HashMap&lt;String,SoftReference&lt;Bitmap&gt;&gt;();</code></p>\n<h4 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h4><h3 id=\"Final、Finally、Finalize\"><a href=\"#Final、Finally、Finalize\" class=\"headerlink\" title=\"Final、Finally、Finalize\"></a>Final、Finally、Finalize</h3><h4 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h4><p>修饰符（关键字）有三种用法：修饰类、变量和方法。修饰类时，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。修饰变量时，该变量使用中不被改变，必须在声明时给定初值，在引用中只能读取不可修改，即为常量。修饰方法时，也同样只能使用，不能在子类中被重写。</p>\n<h4 id=\"Finally\"><a href=\"#Finally\" class=\"headerlink\" title=\"Finally\"></a>Finally</h4><p>通常放在try…catch的后面构造最终执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。</p>\n<h4 id=\"Finalize\"><a href=\"#Finalize\" class=\"headerlink\" title=\"Finalize\"></a>Finalize</h4><p>Object类中定义的方法，Java中允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize() 方法可以整理系统资源或者执行其他清理工作。</p>\n<h3 id=\"和Equals区别\"><a href=\"#和Equals区别\" class=\"headerlink\" title=\"==和Equals区别\"></a>==和Equals区别</h3><h4 id><a href=\"#\" class=\"headerlink\" title=\"==\"></a>==</h4><p>如果比较的是基本数据类型，那么比较的是变量的值<br>如果比较的是引用数据类型，那么比较的是地址值（两个对象是否指向同一块内存）</p>\n<h4 id=\"Equals\"><a href=\"#Equals\" class=\"headerlink\" title=\"Equals\"></a>Equals</h4><p>如果没重写equals方法比较的是两个对象的地址值。<br>如果重写了equals方法后我们往往比较的是对象中的属性的内容<br>equals方法是从Object类中继承的，默认的实现就是使用==</p>\n<h3 id=\"B-tree和B-tree的区别\"><a href=\"#B-tree和B-tree的区别\" class=\"headerlink\" title=\"B-tree和B+tree的区别\"></a>B-tree和B+tree的区别</h3><ul>\n<li>B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。</li>\n<li>在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。</li>\n</ul>\n<h2 id=\"1-8-新特性\"><a href=\"#1-8-新特性\" class=\"headerlink\" title=\"1.8 新特性\"></a>1.8 新特性</h2><h3 id=\"四大函数接口\"><a href=\"#四大函数接口\" class=\"headerlink\" title=\"四大函数接口\"></a>四大函数接口</h3><ul>\n<li><p>Consumer<t><br>重写accept，参数T，无返回</t></p>\n</li>\n<li><p>Supplier<t><br>重写get，无参数，返回T</t></p>\n</li>\n<li><p>Function&lt;T,R&gt;<br>重写apply，参数T，返回R</p>\n</li>\n<li><p>Predicate<t><br>重写test，参数T，返回boolean类型值</t></p>\n</li>\n</ul>\n<h3 id=\"Stream\"><a href=\"#Stream\" class=\"headerlink\" title=\"Stream\"></a>Stream</h3><h3 id=\"分支合并框架\"><a href=\"#分支合并框架\" class=\"headerlink\" title=\"分支合并框架\"></a>分支合并框架</h3><ul>\n<li>ForkJoinPool</li>\n<li>ForJoinTask</li>\n<li>RecursiveTask</li>\n</ul>\n<h3 id=\"异步调用\"><a href=\"#异步调用\" class=\"headerlink\" title=\"异步调用\"></a>异步调用</h3><ul>\n<li>CompletableFuture</li>\n</ul>\n<h3 id=\"lambada表达式\"><a href=\"#lambada表达式\" class=\"headerlink\" title=\"lambada表达式\"></a>lambada表达式</h3><ul>\n<li>()-&gt;{}</li>\n<li>lambada表达式只可以使用在函数式接口上</li>\n<li>java 8以前函数interface接口只能有方法定义，不能有实现。java 8以后可以由方法实现（default 关键字 修饰，可以由多个方法实现），有且仅有一个方法定义</li>\n</ul>\n","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<h1 id=\"Java基础知识清单\"><a href=\"#Java基础知识清单\" class=\"headerlink\" title=\"Java基础知识清单\"></a>Java基础知识清单</h1><h2 id=\"JVM\"><a href=\"#JVM\" class=\"headerlink\" title=\"JVM\"></a>JVM</h2><h3 id=\"JVM架构\"><a href=\"#JVM架构\" class=\"headerlink\" title=\"JVM架构\"></a>JVM架构</h3><p><img src=\"Java.assets/image-20200309203737822.png\" alt=\"image-20200309203737822\"></p>\n<p><img src=\"Java.assets/image-20200309214325839.png\" alt=\"image-20200309214325839\"></p>\n<p><img src=\"Java.assets/QQ20200314-123059@2x-4161454.png\" alt=\"QQ20200314-123059@2x\"></p>\n<h4 id=\"Class-file\"><a href=\"#Class-file\" class=\"headerlink\" title=\"Class file\"></a>Class file</h4><ul>\n<li>有特定的文件标示（cafe babe），由类加载器加载进JVM方法区</li>\n<li>在加载类时：静态块（只会加载一次）&gt;构造块&gt;构造方法</li>\n</ul>\n<h4 id=\"类加载器（ClassLoader）\"><a href=\"#类加载器（ClassLoader）\" class=\"headerlink\" title=\"类加载器（ClassLoader）\"></a>类加载器（ClassLoader）</h4><p>实现通过类的全限定名（java/lang/String）获取该类的二进制字节流的代码块叫做类加载器。</p>\n<p>#####分类</p>\n<h6 id=\"启动类加载器（Bootstrap）\"><a href=\"#启动类加载器（Bootstrap）\" class=\"headerlink\" title=\"启动类加载器（Bootstrap）\"></a>启动类加载器（Bootstrap）</h6><p>用来加载java核心类库，无法被java程序直接引用。主要加载jre/lib文件夹下的jar文件</p>\n<h6 id=\"扩展类加载器（Extension）\"><a href=\"#扩展类加载器（Extension）\" class=\"headerlink\" title=\"扩展类加载器（Extension）\"></a>扩展类加载器（Extension）</h6><p>它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。主要加载jre/lib/ext文件夹下的jar文件</p>\n<h6 id=\"应用程序加载器（Application）\"><a href=\"#应用程序加载器（Application）\" class=\"headerlink\" title=\"应用程序加载器（Application）\"></a>应用程序加载器（Application）</h6><p>也叫应用类加载器,它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。</p>\n<h6 id=\"自定义\"><a href=\"#自定义\" class=\"headerlink\" title=\"自定义\"></a>自定义</h6><p>通过继承 java.lang.ClassLoader类的方式实现。</p>\n<h5 id=\"全盘委托\"><a href=\"#全盘委托\" class=\"headerlink\" title=\"全盘委托\"></a>全盘委托</h5><p>加载类时，除非显示使用其他类加载器，否则该加载类下的其他依赖都有该类加载器加载</p>\n<h5 id=\"双亲委派\"><a href=\"#双亲委派\" class=\"headerlink\" title=\"双亲委派\"></a>双亲委派</h5><p>加载时会一层层向上委托，如果可以加载就进行加载，没有就向下层加载器找，找到加载找不到class not found</p>\n<h5 id=\"沙箱安全\"><a href=\"#沙箱安全\" class=\"headerlink\" title=\"沙箱安全\"></a>沙箱安全</h5><p>自己加载自己的，相当一个一个容器 各不影响</p>\n<h4 id=\"本地接口（Native-Interface）\"><a href=\"#本地接口（Native-Interface）\" class=\"headerlink\" title=\"本地接口（Native Interface）\"></a>本地接口（Native Interface）</h4><p>本地接口的作用是融合不同的编程语言为Java所用，在本地方法栈（Native Method Stack） 中登记Native方法</p>\n<h4 id=\"程序计数器（Program-Counter-Register）-PC-寄存器\"><a href=\"#程序计数器（Program-Counter-Register）-PC-寄存器\" class=\"headerlink\" title=\"程序计数器（Program Counter Register）,PC 寄存器\"></a>程序计数器（Program Counter Register）,PC 寄存器</h4><p>线程私有的。内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个java虚拟机规范没有规定任何OOM情况的区域。<br>记录了方法之间的调用和执行情况，它是当前线程所执行的字节码的行号指示器。相当于一个指针，指示字节码的行号，指引程序执行顺序，native 的为空</p>\n<h4 id=\"本地方法栈（Native-Method-Stack）\"><a href=\"#本地方法栈（Native-Method-Stack）\" class=\"headerlink\" title=\"本地方法栈（Native Method Stack）\"></a>本地方法栈（Native Method Stack）</h4><p>本地方法栈和虚拟机栈类似，只不过本地方法栈为Native方法服务，存放本地方法</p>\n<h4 id=\"Java-栈（Java-Stack-），虚拟机栈\"><a href=\"#Java-栈（Java-Stack-），虚拟机栈\" class=\"headerlink\" title=\"Java 栈（Java Stack ），虚拟机栈\"></a>Java 栈（Java Stack ），虚拟机栈</h4><p>栈分为java虚拟机栈和本地方法栈<br>栈管运行，堆管存储。栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命周期是跟随线程的生命周期，线程结束内存也释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，生命周期一致，是线程私有的。8种基本类型的变量+对象的引用变量+实例方法都是栈函数的栈内存中分配。<br>栈存储：局部变量表(Local Variables)、操作数栈(Operand Stack)、指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)、方法返回地址(Return Address)和一些额外的附加信息</p>\n<p>虚拟机栈中包含有多个栈帧，每一个栈帧就是一个方法。</p>\n<p>StackOverFlowError：是错误，栈中递归调用等会发生，是由于栈内存溢出造成</p>\n<p>栈帧（Java中叫方法，栈中叫栈帧）数据<br>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。</p>\n<ul>\n<li><p>局部变量<br>输入参数和输出参数以及方法内的变量<br>局部变量表里存储的是基本数据类型、returnAddress类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定</p>\n</li>\n<li><p>操作数栈<br>记录出栈、入栈的操作<br>操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式</p>\n</li>\n<li><p>动态链接</p>\n</li>\n<li><p>方法返回地址</p>\n</li>\n</ul>\n<h4 id=\"方法区（Method-Area）还被叫为Non-Heap（非堆）\"><a href=\"#方法区（Method-Area）还被叫为Non-Heap（非堆）\" class=\"headerlink\" title=\"方法区（Method Area）还被叫为Non-Heap（非堆）\"></a>方法区（Method Area）还被叫为Non-Heap（非堆）</h4><p>被所有线程共享区域，在不同虚拟机里头实现是不一样的，最典型的就是永久代（PermGen Space）和元空间（Metaspace）。实例变量存储在对内存中和方法区无关。在该区内很少发生垃圾回收，但是并不代表不发生GC，在这里进行的GC主要是对方法区里的常量池和对类型的卸载。该区域是被线程共享的。<br>存储：在方法区中，存储了每个类的信息（包括类的名称、修饰符、方法信息、字段信息）、类中静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息以及编译器编译后的代码等。运行时常量池用于存放静态编译产生的字面量和符号引用，该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。1.7以后字符串常量池被移植到堆内存中</p>\n<h4 id=\"堆（Heap）\"><a href=\"#堆（Heap）\" class=\"headerlink\" title=\"堆（Heap）\"></a>堆（Heap）</h4><p>堆被所有线程共享区域，在虚拟机启动时创建，唯一目的存放对象实例。堆区是gc的主要区域，通常情况下分为两个区块年轻代和年老代。更细一点年轻代又分为Eden区，主要放新创建对象，From survivor 和 To survivor 保存gc后幸存下的对象，默认情况下各自占比 8:1:1。</p>\n<p>一个JVM实例只存在一个堆内存，堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常量放到堆内存中，保存所有引用类型的真实信息，以便执行器执行。</p>\n<ul>\n<li>逻辑：Eden:S0:S1=8:1:1，新生：养老=1:2<ul>\n<li>新生（New）／年轻代（Young）<ul>\n<li>伊甸园（Eden Space）<br>新New对象都在此区域，98%是临时对象会被GC掉</li>\n<li>幸存者0（Survivor 0 Space）| from</li>\n<li>幸存者1（Survivor 1 Space）| to</li>\n</ul>\n</li>\n<li>养老（Tenure）／老年代（Old）</li>\n<li>永久（java 7）／元数据（java 8）。永久代和元空间的最大区别在于，永久代使用的是JVM的堆内存，但是java 8以后元空间并不存在虚拟机中而是使用本地物理内存，默认只用物理内存的1/4</li>\n</ul>\n</li>\n<li>物理<ul>\n<li>新生</li>\n<li>老年</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"GC\"><a href=\"#GC\" class=\"headerlink\" title=\"GC\"></a>GC</h3><p>HotSpot采用的是分代收集算法</p>\n<p>是内存回收的方法论，垃圾回收器就是算法落地实现<br>因为目前还没有完美的垃圾收集器出现，更加没有万能的收集器，只是有针对具体应用最合适的收集器，进行分代收集</p>\n<h4 id=\"判断一个对象是否可以被回收\"><a href=\"#判断一个对象是否可以被回收\" class=\"headerlink\" title=\"判断一个对象是否可以被回收\"></a>判断一个对象是否可以被回收</h4><p>垃圾（内存中已经不再被使用到的空间）</p>\n<h5 id=\"引用计数\"><a href=\"#引用计数\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h5><p>Java中，引用和对象是有关联的。如果要操作对象则必须要用引用进行。因此，很显然一个简单的办法就是通过引用计数来判断一个对象是否可以回收。简单说，给对象中添加一个引用计数器。每当有一个地方引用它，计数器值加1；每当有一个地方引用失效时，计数器值减1。任何时刻计数器值为零的对象就是不可能再被使用的，那么这个对象就是可回收对象，<br>那为什么主流的Java虚拟机里面都没有采用这种算法呢？其中最主要的原因是它很难解决对象直接相互循环引用的问题。</p>\n<h5 id=\"根节点作可达性分析（根搜索路径）\"><a href=\"#根节点作可达性分析（根搜索路径）\" class=\"headerlink\" title=\"根节点作可达性分析（根搜索路径）\"></a>根节点作可达性分析（根搜索路径）</h5><p>为了解决引用计数循环引用问题，Java使用了可达性分析方法<br>所谓GC Roots或者说tracking GC的根集合，就是一组必须活跃的引用<br>基本思路就是通过一系列名为GC Roots的对象作为起始点，从这个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何一个引用链相连时，则说明此对象不可用。即给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达）对象就被判定为存活；没有遍历到的就自然被判定为死亡。</p>\n<h4 id=\"Java中可以作为GC-Roots的对象\"><a href=\"#Java中可以作为GC-Roots的对象\" class=\"headerlink\" title=\"Java中可以作为GC Roots的对象\"></a>Java中可以作为GC Roots的对象</h4><ul>\n<li>虚拟机栈（栈帧中的局部变量区，也叫局部变量表）中引用的对象</li>\n<li>方法区中的类静态属性、常量引用的对象</li>\n<li>本地方法栈中JNI（Native方法）引用的对象</li>\n</ul>\n<h4 id=\"回收策略以及Minor-GC和Major-GC：\"><a href=\"#回收策略以及Minor-GC和Major-GC：\" class=\"headerlink\" title=\"回收策略以及Minor GC和Major GC：\"></a>回收策略以及Minor GC和Major GC：</h4><p>对象优先在堆的Eden区分配，当Eden区没有足够的空间进行分配时，虚拟机会执行一次Minor GC，Minor GC通常发生在新生代的Eden区，在这个区的对象生存期短，往往发生GC的频率较高，回收速度比较快;Full Gc/Major GC 发生在老年代，一般情况下，触发老年代GC的时候不会触发Minor GC，但是通过配置，可以在Full GC之前进行一次Minor GC这样可以加快老年代的回收速度。</p>\n<h4 id=\"新生代GC（Minor-GC-GC）\"><a href=\"#新生代GC（Minor-GC-GC）\" class=\"headerlink\" title=\"新生代GC（Minor GC|GC）\"></a>新生代GC（Minor GC|GC）</h4><ul>\n<li><p>复制<br>eden、from 复制到 to，年龄+1<br>首先，当Eden区满的时候会触发第一次GC，把还活着的对象拷贝到from区，当eden区再次触发GC的时候会扫描eden区和from区，对这两个区域进行垃圾回收，经过这次回收后还存活的对象，直接复制到to区域（如果有对象的年龄到了老年的标准，则复制到老年区），同时把这些对象的年龄+1</p>\n</li>\n<li><p>清空<br>清空eden、from<br>然后清空eden和from中的对象</p>\n</li>\n<li><p>互换<br>to和from互换<br>最后，也即复制之后有换，谁空谁是to。to和from互换，原来to成为下一次GC时的from区，部分对象会在from和to区中复制来复制去，如此交换15次（由JVM参数MaxTenuringThreshold决定，这个参数默认是15），最终如果还存活，就进入老年代。</p>\n</li>\n</ul>\n<h4 id=\"老年代GC（Major-GC-Full-GC）\"><a href=\"#老年代GC（Major-GC-Full-GC）\" class=\"headerlink\" title=\"老年代GC（Major GC|Full GC）\"></a>老年代GC（Major GC|Full GC）</h4><p>GC日志分析</p>\n<ul>\n<li>[GC (Allocation Failure) [PSYoungGen: 512K-&gt;425K(1024K)] 512K-&gt;425K(1536K), 0.0018589 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</li>\n<li>[Full GC (Ergonomics) [PSYoungGen: 469K-&gt;460K(1024K)] [ParOldGen: 448K-&gt;447K(512K)] 917K-&gt;908K(1536K), [Metaspace: 2697K-&gt;2697K(1056768K)], 0.0041891 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] <ul>\n<li>DefNew(Default New Generation)</li>\n<li>Tenured(Old)</li>\n<li>ParNew(Parallel New Generation)</li>\n<li>PSYoungGen(Parallel Scavenge)</li>\n<li>ParOldGen(Parallel Old Generation)<h4 id=\"GC4大算法\"><a href=\"#GC4大算法\" class=\"headerlink\" title=\"GC4大算法\"></a>GC4大算法</h4></li>\n</ul>\n</li>\n</ul>\n<h5 id=\"引用计数-1\"><a href=\"#引用计数-1\" class=\"headerlink\" title=\"引用计数\"></a>引用计数</h5><p>应用于：微软的COM/ActionScrip3/Python等<br>如果对象没有被引用，就会被回收<br>缺点：需要维护一个引用计算器</p>\n<h5 id=\"复制（Copy）\"><a href=\"#复制（Copy）\" class=\"headerlink\" title=\"复制（Copy）\"></a>复制（Copy）</h5><p>年轻代中使用的是Minor GC，这种GC算法采用的是复制算法(Copying)</p>\n<ul>\n<li>不会发生内存碎片，速度快</li>\n<li>消耗空间（需要进行复制）</li>\n</ul>\n<h5 id=\"标记清除（Mark-Sweep）\"><a href=\"#标记清除（Mark-Sweep）\" class=\"headerlink\" title=\"标记清除（Mark Sweep）\"></a>标记清除（Mark Sweep）</h5><p>老年代一般是由标记清除或者是标记清除与标记整理的混合实现</p>\n<ul>\n<li>会产生内存碎片，两次扫描耗时严重</li>\n<li>节约内存空间</li>\n</ul>\n<h5 id=\"标记整理／压缩（Mark-Compat）\"><a href=\"#标记整理／压缩（Mark-Compat）\" class=\"headerlink\" title=\"标记整理／压缩（Mark-Compat）\"></a>标记整理／压缩（Mark-Compat）</h5><p>老年代一般是由标记清除或者是标记清除与标记整理的混合实现</p>\n<ul>\n<li>没有碎片</li>\n<li>耗时严重</li>\n</ul>\n<h4 id=\"算法比较\"><a href=\"#算法比较\" class=\"headerlink\" title=\"算法比较\"></a>算法比较</h4><ul>\n<li><p>内存效率（时间纬度）<br>复制&gt;标记清除&gt;标记整理</p>\n</li>\n<li><p>内存整齐度<br>复制=标记整理&gt;标记清除</p>\n</li>\n<li><p>内存利用率<br>标记整理=标记清除&gt;复制</p>\n<h3 id=\"GC垃圾收集器\"><a href=\"#GC垃圾收集器\" class=\"headerlink\" title=\"GC垃圾收集器\"></a>GC垃圾收集器</h3><h4 id=\"查看默认的垃圾收集器是哪个\"><a href=\"#查看默认的垃圾收集器是哪个\" class=\"headerlink\" title=\"查看默认的垃圾收集器是哪个\"></a>查看默认的垃圾收集器是哪个</h4><p>java -XX:+PrintCommandLineFlags -version</p>\n</li>\n</ul>\n<h4 id=\"默认的垃圾收集器有哪些\"><a href=\"#默认的垃圾收集器有哪些\" class=\"headerlink\" title=\"默认的垃圾收集器有哪些\"></a>默认的垃圾收集器有哪些</h4><h5 id=\"UseSerialGC\"><a href=\"#UseSerialGC\" class=\"headerlink\" title=\"UseSerialGC\"></a>UseSerialGC</h5><p>它为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程，不适合服务器。<br>一句话：一个单线程的收集器，在进行垃圾收集的时候，必须暂停其他所有的工作线程直到它收集结束。<br>串行收集器是最古老，最稳定以及效率最高的收集器，只使用一个线程区回收但其在进行垃圾回收过程中可能会产生较长的停顿（Stop-The-World 状态）。虽然在收集垃圾过程中需要暂停其他的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销可以获得最高的单线程垃圾收集效率，因此Serial垃圾收集器依然是java虚拟机运行在Client模式下新生代的垃圾收集器。<br>对应JVM参数：<br>-XX:+UseSerialGC<br>开启后会使用：Serial（Young区用）+Serial Old（Old区用）的收集器组合<br>表示：新生代、老年代都会使用串行收集器，新生代使用复制算法，老年代使用标记-整理算法<br>-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseSerialGC</p>\n<h5 id=\"UseSerialOldGC\"><a href=\"#UseSerialOldGC\" class=\"headerlink\" title=\"UseSerialOldGC\"></a>UseSerialOldGC</h5><p>Serial Old 是Serial 垃圾收集器老年代版本，它同样是单个线程的收集器，使用标记-整理算法，这个收集器也主要是运行在Client默认的java虚拟机默认的老年代垃圾收集器。<br>在Server模式下，主要有两个用途（了解，版本已经到8及以后）：</p>\n<ul>\n<li>在JDK1.5 之前版本中与新生代的Parallel Scavenge 收集器搭配使用。（Parallel Scavenge +Serial Old）</li>\n<li>作为老年代版本中使用CMS收集器的后备垃圾收集方案。</li>\n</ul>\n<h5 id=\"UseParNewGC\"><a href=\"#UseParNewGC\" class=\"headerlink\" title=\"UseParNewGC\"></a>UseParNewGC</h5><p>多个垃圾收集线程并行工作，此时用户线程是暂停的，适用于科学计算／大数据处理等弱交互场景<br>一句话：使用多线程进行垃圾回收，在垃圾收集时，会Stop-The-World暂停其他所有的工作线程直到它收集结束。<br>ParNew收集器其实就是Serial收集器新生代的并行多线程版本，最常见的应用场景是配合老年代的CMS GC工作，其余的行为和Serial收集器完全一样，它是很多java虚拟机运行在Server模式下新生代的默认垃圾收集器<br>常用JVM参数：-XX:+UseParNewGC 启用ParNew收集器，只影响新生代的收集，不影响老年代<br>开启上述参数后，会使用：ParNew（Young区用）+Serial Old的收集器组合，新生代使用复制算法，老年代采用标记-整理算法。<br>但是，ParNew+Tenured这样的搭配，java8已经不再被推荐<br>备注：<br>-XX:ParallelGCThreads 限制线程数量，默认开启和CPU数目相同的线程数<br> -Xmx10m -Xmx10m -XX:+PrintGCDetails -XX:+UseParNewGC</p>\n<h5 id=\"UseParallelGC\"><a href=\"#UseParallelGC\" class=\"headerlink\" title=\"UseParallelGC\"></a>UseParallelGC</h5><p>Parallel Scavenge收集器类似ParNew也是一个新生代垃圾收集器，使用复制算法，也是一个并行的多线程的垃圾收集器，俗称吞吐量优先收集器。<br>一句话：串行收集器在新生代和老年代的并行化<br>它重点关注的是：<br>可控制的吞吐量（Thoughput=运行用户代码时间／（运行用户代码时间+垃圾收集时间），比如程序运行100分钟，垃圾收集1分钟，吞吐量就是99%）。高吞吐量意味着高效利用CPU时间，它多用于在后台运算而不需要太多交互的任务。<br>自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。（自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间（-XX:MaxGCPauseMillis）或最大吞吐量。<br>常用JVM参数：-XX:+UseParallelGC 或 -XX:+UseParallelOldGC(可互相激活）使用Parallel Scavenge收集器<br>多说一句：-XX:ParallelGCThreads=数字N 表示启动多少个线程<br>CPU&gt;8 N=5/8<br>CPU&lt;8 N=实际个数<br>-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseParallelGC<br>-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseParllelOldGC</p>\n<h5 id=\"UseParallelOldGC\"><a href=\"#UseParallelOldGC\" class=\"headerlink\" title=\"UseParallelOldGC\"></a>UseParallelOldGC</h5><p>Parallel Old收集器是Parallel Scavenge的老年代版本，使用多线程的标记-整理算法，Parallel Old收集器在JDK1.6才开始提供。<br>在JDK1.6之前，新生代使用Parallel Scavenge收集器只能搭配老年代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。在JDK1.6之前（Parallel Scavenge+Serial Old）<br>Parallel Old正是为了在老年代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，JDK1.8之后可以优先考虑新生代Parallel Scavenge 和老年代Parallel Old收集器的搭配策略。在JDK1.8及之后（Parallel Scavenge+Parallel Old）<br>常用JVM参数：-XX:+UseParallelOldGC 使用Parallel Old收集器，设置参数后，新生代Parallel+老年代Parallel Old</p>\n<h5 id=\"UseConcMarkSweepGC\"><a href=\"#UseConcMarkSweepGC\" class=\"headerlink\" title=\"UseConcMarkSweepGC\"></a>UseConcMarkSweepGC</h5><p>用户线程和垃圾回收线程同时执行（并不一定是并行，可能交替执行），不需要暂停用户线程，互联网公司多用它，适用对相应时间有要求的场景<br>CMS收集器（Concurrent Mark Sweep：并发标记清除）是一种以获取最短回收停顿时间为目标的收集器。适应应用在互联网站或者B／S系统的服务器上，这类应用尤其重视服务器响应速度，希望系统停顿时间最短。CMS非常适合堆内存大、CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。Concurrent Mark Sweep 并发标记清除，并发收集低停顿，并发指的是与用户线程一起执行<br>开启该收集器的JVM参数： -XX:+UseConcMarkSweepGC 开启该参数后会自动将-XX:+UseParNewGC 打开开启该参数后，使用ParNew（Young区用）+CMS（Old区用）+Serial Old的收集器组合，Serial Old将作为CMS出错的后备收集器<br><strong>执行步骤</strong></p>\n<ul>\n<li>初始标记（CMS initial mark）需要暂停所有的工作线程<br>只是标记一下，GC Roots 能直接关联的对象，速度快，仍然需要暂停所有的工作线程</li>\n<li>并发标记（CMS concurrent mark）和用户线程一起<br>进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。主要标记过程，标记全部对象。</li>\n<li>重新标记（CMS remark）需要暂停所有的工作线程<br>为了修改在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。<br>由于并发标记时，用户线程依然运行，因此在正式清理前，再作修正。</li>\n<li>并发清除（CMS concurrent sweep）和用户线程一起<br>清除GC Roots 不可达对象，和用户一起工作，不需要暂停工作线程。基于标记结果，直接清除对象。<br>由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发的执行。</li>\n</ul>\n<p><strong>优缺点</strong><br>优：并发收集低停顿<br>缺：</p>\n<ul>\n<li>并发执行，对CPU资源压力大<br>由于并发进行，CMS垃圾收集和应用线程会同时增加对堆内存对占用，也就是说，CMS必须要在老年代堆内存用尽之前完成垃圾回收，否则CMS回收失败时，将触发担保机制，串行老年代收集器将会以STW的方式进行一次GC，从而造成较大停顿时间。</li>\n<li>采用对标记清除算法会导致大量碎片<br>标记清除无法整理空间碎片，老年代空间会随着应用时长被逐步耗尽，最后将不得不通过担保机制对堆内存进行压缩。CMS也提供了参数-XX:CMSFullGCsBeForeCompaction(默认0，即每次都进行内存整理）来指定多少次CMS收集之后，进行一次压缩的Full GC</li>\n</ul>\n<p>-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC</p>\n<h5 id=\"UseG1GC\"><a href=\"#UseG1GC\" class=\"headerlink\" title=\"UseG1GC\"></a>UseG1GC</h5><p>G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片<br>G1的Stop The World（STW）更可控，G1在停顿时间上添加量预测机制，用户可以指定期望停顿时间<br>CMS垃圾收集器虽然暂停了应用程序的运行时间，但还是存在着内存碎片的问题。于是，为了去除内存碎片问题，同时又保留CMS垃圾收集器低暂停时间的优点，java7 发布了一个新的垃圾收集器-G1垃圾收集器<br>G1是在2012年才在jdk1.7u4中可用。oracle官方计划在jdk9中将G1变成默认的垃圾收集器以替代CMS。它是一款面向服务器端应用的收集器，主要应用在多CPU和大内存服务器环境下，极大的减少垃圾收集的停顿时间，全面提升服务器的性能，逐步替换java8以前的CMS收集器。<br>主要改变是Eden，Surivor和Tenured等内存区域不再是连续的了，而是变成了一个个大小一样的region，每个region从1m到32m不等。一个region有可能属于Eden，Survivor或者Tenured内存区域</p>\n<h6 id=\"底层原理\"><a href=\"#底层原理\" class=\"headerlink\" title=\"底层原理\"></a>底层原理</h6><p>Region区域化垃圾收集器<br>化整为零，避免全内存扫描，只需要按照区域来进行扫描即可<br>区域化内存划片Region，整体编辑为了一些不连续的内存区域，避免了全内存区的GC操作。<br>核心思想是将整个堆内存区域分成大小相同的子区域（Region），在JVM启动的时候会自动设置这些子区域的大小，在堆的使用上，G1并不要求对象的存储一定是物理上连续的只要逻辑连续即可，每个分区也不会固定的为某个代服务，可以按需在新生代和老年代之间切换。启动时可以通过参数-XX:G1HeapRegionSize=n指定分区大小（1m-32m，且必须是2的幂），默认将整堆划分成2048个分区。<br>大小范围在1m-32m，最多能设置2048个区域，能支持的最大内存为：32m*2048=65536m=64G</p>\n<h6 id=\"回收步骤\"><a href=\"#回收步骤\" class=\"headerlink\" title=\"回收步骤\"></a>回收步骤</h6><p>G1收集器下的Young GC<br>针对Eden区进行收集，Eden区耗尽后会被触发，主要是小区域收集+形成连续的内存块，避免内存碎片<br>Eden区的数据移动到Survivor区，假如出现Survivor区空间不够，Eden区数据会部分晋升到Old区<br>Surivor区的数据移动到新的Survivor区，部分数据晋升到Old区<br>最后Eden区收拾干净，GC结束，用户的应用程序继续执行</p>\n<h6 id=\"常用配置参数（了解）\"><a href=\"#常用配置参数（了解）\" class=\"headerlink\" title=\"常用配置参数（了解）\"></a>常用配置参数（了解）</h6><p>开发人员仅仅需要声明以下参数即可：<br>三步归纳：开始G1+设置最大内存+设置最大停顿时间<br>-XX:+UseG1GC  -Xmx32g  -XX:MaxGCPauseMillis=100<br>-XX:MaxGCPauseMillis=n: 最大GC停顿时间单位毫米，这是个软目标，JVM将尽可能（但不保证）停顿小于这个时间。</p>\n<ul>\n<li>-XX:+UseG1GC</li>\n<li>-XX:G1HeapRegionSize=n<br>设置G1区域的大小。值是2的幂，范围是1m-32m。目标是根据最小的java堆大小划分出约2048个区域</li>\n<li>-XX:MaxGCPauseMillis=n<br>最大GC时间，这是个软目标，JVM尽可能（但不保证）停顿小于这个时间</li>\n<li>-XX:InitiatingHeapOccupancyPercent=n<br>堆占用了多少堆时候就触发GC，默认为45%</li>\n<li>-XX:ConcGCThreads=n<br>并发GC使用的线程数</li>\n<li>-XX:G1ReserverPercent=n<br>设置作为空闲空间的预留内存占比，以降低目标空间溢出的风险，默认是10%</li>\n</ul>\n<h6 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h6><ul>\n<li>G1能充分利用多CPU、多核环境硬件优势，尽量缩短STW。</li>\n<li>G1整体上采用标记-整理算法，局部使用复制算法，不会产生内存碎片</li>\n<li>宏观上看G1不再区分新生代和老年代，把内存划分成多个独立的子区域（region），可以近似理解为一个围棋棋盘</li>\n<li>G1收集器将整个内存区都混合为一起，但其本身依旧在小范围内进行新生代和老年代的区分，保留了新生代和老年代，但它们不是物理隔离，而是一部分region的集合，并且不需要region是连续，也就是说依然采用不同的GC方式来处理不同的区域。</li>\n<li>G1虽然也是分代收集器，但整个内存分区不存在物理上的新生代和老年代的区别，也不需要完全独立的Survivor（to space）堆作复制准备。G1只有逻辑上的分代概念，或者说每个分区都有可能随着G1的运行在不同代之间前后切换</li>\n</ul>\n<h6 id=\"G1和CMS相比的优势\"><a href=\"#G1和CMS相比的优势\" class=\"headerlink\" title=\"G1和CMS相比的优势\"></a>G1和CMS相比的优势</h6><ul>\n<li>G1不会产生内存碎片</li>\n<li>是可以精确控制停顿。该收集器是把整个堆（新生代、老年代）划分成多个固定大小的区域，每次根据允许停顿的时间区收集垃圾最多的区域</li>\n</ul>\n<h3 id=\"Server／Client模式分别是什么意思\"><a href=\"#Server／Client模式分别是什么意思\" class=\"headerlink\" title=\"Server／Client模式分别是什么意思\"></a>Server／Client模式分别是什么意思</h3><p>适用范围：只需要掌握Server模式即可，Client模式基本不会用操作系统</p>\n<ul>\n<li>32位Win操作系统，不论硬件如何都默认使用Client的JVM模式</li>\n<li>32位其他操作系统，2G内存同时有2个CPU以上用Server模式，低于该配置还是使用Client模64位only server模式</li>\n</ul>\n<h3 id=\"如何选择垃圾收集器\"><a href=\"#如何选择垃圾收集器\" class=\"headerlink\" title=\"如何选择垃圾收集器\"></a>如何选择垃圾收集器</h3><ul>\n<li><p>单CPU或者小内存，单机程序</p>\n</li>\n<li><p>XX:+UseSerialGC</p>\n</li>\n<li><p>多CPU，需要最大吞吐量，如后台计算大型应用</p>\n</li>\n<li><p>XX:+UseParallelGC 或者</p>\n</li>\n<li><p>XX:+UseParallelOldGC</p>\n</li>\n<li><p>多CPU，追求低停顿时间，需快速响应如互联网应用</p>\n</li>\n<li><p>XX:+UseConcMarkSweepGC</p>\n</li>\n<li><p>XX:+ParNewGC</p>\n</li>\n</ul>\n<h3 id=\"以前收集器特点\"><a href=\"#以前收集器特点\" class=\"headerlink\" title=\"以前收集器特点\"></a>以前收集器特点</h3><ul>\n<li>新生代和老年代是各自独立且连续但内存块</li>\n<li>新生代收集使用单eden+s0+s1进行复制算法</li>\n<li>老年代收集必须扫描整个老年代区域</li>\n<li>都是以尽可能少而快速的执行GC为设计原则</li>\n</ul>\n<h3 id=\"Java类加载过程\"><a href=\"#Java类加载过程\" class=\"headerlink\" title=\"Java类加载过程\"></a>Java类加载过程</h3><h4 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h4><p>加载是类加载的第一个过程，在这个阶段，将完成一下三件事情：</p>\n<ul>\n<li>通过一个类的全限定名获取该类的二进制流。</li>\n<li>将该二进制流中的静态存储结构转化为方法去运行时数据结构。 </li>\n<li>在内存中生成该类的Class对象，作为该类的数据访问入口。<h4 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h4><h5 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h5>验证的目的是为了确保Class文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证: </li>\n<li>文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型. </li>\n<li>元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否继承了不被继承的类等。</li>\n<li>字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。</li>\n<li>符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。<h5 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h5>准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。<h5 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h5>该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。<h4 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h4>初始化是类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。</li>\n</ul>\n<h4 id=\"类加载\"><a href=\"#类加载\" class=\"headerlink\" title=\"类加载\"></a>类加载</h4><p>类加载包含Main程序入口的类加载</p>\n<ul>\n<li>静态成员变量加载时执行到准备阶段将变量赋初始值（int 类型默认初始化为0，引用对象初始化为null）</li>\n<li>静态成员变量加载时执行到初始化阶段将变量赋值（private static int a=29，默认初始化为a=0，赋值初始化a=29；引用类型 初始化为对象实例)</li>\n<li>运行main方法</li>\n</ul>\n<blockquote>\n<p>静态变量 （static int a）和静态引用变量（static  Object o）声明赋值是依据自上而下的顺序。</p>\n</blockquote>\n<h3 id=\"JVM的参数类型\"><a href=\"#JVM的参数类型\" class=\"headerlink\" title=\"JVM的参数类型\"></a>JVM的参数类型</h3><h4 id=\"标配参数\"><a href=\"#标配参数\" class=\"headerlink\" title=\"标配参数\"></a>标配参数</h4><ul>\n<li>-version</li>\n<li>-help</li>\n<li>java -showversion</li>\n</ul>\n<h4 id=\"X参数-了解）\"><a href=\"#X参数-了解）\" class=\"headerlink\" title=\"X参数(了解）\"></a>X参数(了解）</h4><ul>\n<li>-Xint（解释执行）</li>\n<li>-Xcomp（第一次使用就编译成本地代码）</li>\n<li>-Xmixed（混合模式）</li>\n</ul>\n<h4 id=\"XX参数\"><a href=\"#XX参数\" class=\"headerlink\" title=\"XX参数\"></a>XX参数</h4><h5 id=\"Boolean类型\"><a href=\"#Boolean类型\" class=\"headerlink\" title=\"Boolean类型\"></a>Boolean类型</h5><ul>\n<li>公式<ul>\n<li>-XX：+或者- 某个属性值</li>\n<li>+（开启）-（关闭）</li>\n</ul>\n</li>\n<li>Case<ul>\n<li>是否打印GC收集细节<br>-XX:-PrintGCDetails<br>-XX:+PrintGCDetails</li>\n<li>是否使用串行垃圾回收器<br>-XX:-UseSerialGC<br>-XX:+UseSerialGC</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"K-V设值类型\"><a href=\"#K-V设值类型\" class=\"headerlink\" title=\"K-V设值类型\"></a>K-V设值类型</h5><p>-XX：属性key=属性value<br>-XX:MetaspaceSize=128m<br>-XX:MaxTenuringThreshold=15</p>\n<h3 id=\"Jinfo\"><a href=\"#Jinfo\" class=\"headerlink\" title=\"Jinfo\"></a>Jinfo</h3><p>任何查看当前运行程序的配置<br>jinfo -flag 配置项 进程编号<br>jinfo -flag IntialHeapSize 进程号<br>jinfo -flags 进程号</p>\n<h3 id=\"查看JVM的默认值\"><a href=\"#查看JVM的默认值\" class=\"headerlink\" title=\"查看JVM的默认值\"></a>查看JVM的默认值</h3><h4 id=\"XX-PrintFlagsFinal\"><a href=\"#XX-PrintFlagsFinal\" class=\"headerlink\" title=\"-XX:+PrintFlagsFinal\"></a>-XX:+PrintFlagsFinal</h4><p>主要查看修改更新<br>java -XX:+PrintFlagsFinal -version<br>:= 为人为修改过或初始加载修改过，= 为默认未改<br>PrintFlagsFinal举例<br>运行java命令的同时打印出参数<br>java -XX:+PrintFlagsFinal -XX:MetaspaceSize=512m 类名</p>\n<h4 id=\"XX-PrintCommandLineFlags\"><a href=\"#XX-PrintCommandLineFlags\" class=\"headerlink\" title=\"-XX:+PrintCommandLineFlags\"></a>-XX:+PrintCommandLineFlags</h4><p>主要看垃圾回收器，最后一个值</p>\n<h4 id=\"XX-HeapDumpOnOutOfMemoryError\"><a href=\"#XX-HeapDumpOnOutOfMemoryError\" class=\"headerlink\" title=\"-XX:+HeapDumpOnOutOfMemoryError\"></a>-XX:+HeapDumpOnOutOfMemoryError</h4><p>设置内存溢出时dump内存快照</p>\n<h3 id=\"JVM常用参数\"><a href=\"#JVM常用参数\" class=\"headerlink\" title=\"JVM常用参数\"></a>JVM常用参数</h3><h4 id=\"Xms（-XX-InitialHeapSize）\"><a href=\"#Xms（-XX-InitialHeapSize）\" class=\"headerlink\" title=\"-Xms（-XX:InitialHeapSize）\"></a>-Xms（-XX:InitialHeapSize）</h4><p>初始大小内存，默认为物理内存1/64</p>\n<h4 id=\"Xmx（-XX-MaxHeapSize）\"><a href=\"#Xmx（-XX-MaxHeapSize）\" class=\"headerlink\" title=\"-Xmx（-XX:MaxHeapSize）\"></a>-Xmx（-XX:MaxHeapSize）</h4><p>最大分配内存，默认为物理内存1/4</p>\n<h4 id=\"Xss（-XX-ThreadStackSize）\"><a href=\"#Xss（-XX-ThreadStackSize）\" class=\"headerlink\" title=\"-Xss（-XX:ThreadStackSize）\"></a>-Xss（-XX:ThreadStackSize）</h4><p>设置单个线程栈的大小，一般默认为512k～1024k</p>\n<h4 id=\"Xmn\"><a href=\"#Xmn\" class=\"headerlink\" title=\"-Xmn\"></a>-Xmn</h4><p>设置年轻代大小</p>\n<h4 id=\"XX-MetaspaceSize\"><a href=\"#XX-MetaspaceSize\" class=\"headerlink\" title=\"-XX:MetaspaceSize\"></a>-XX:MetaspaceSize</h4><p>初始元空间大小</p>\n<p>元空间本质和永久代类似，都是对JVM规范方法中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。<br>-Xms10m -Xmx10m  -XX:MetaspaceSize=1024m -XX：+PrintFlagsFinal</p>\n<h4 id=\"XX-MaxMetaspaceSize\"><a href=\"#XX-MaxMetaspaceSize\" class=\"headerlink\" title=\"-XX:MaxMetaspaceSize\"></a>-XX:MaxMetaspaceSize</h4><p>最大元空间大小，默认为-1，只受本地空间限制</p>\n<h4 id=\"XX-MaxDirectMemorySize\"><a href=\"#XX-MaxDirectMemorySize\" class=\"headerlink\" title=\"-XX:MaxDirectMemorySize\"></a>-XX:MaxDirectMemorySize</h4><p>最大直接内存大小，默认和 -Xmx 一致</p>\n<h4 id=\"XX-PrintGCDetails\"><a href=\"#XX-PrintGCDetails\" class=\"headerlink\" title=\"-XX:+PrintGCDetails\"></a>-XX:+PrintGCDetails</h4><p>1    输出详细GC收集日志信息<br>2    GC：<br>3    FullGC：</p>\n<h4 id=\"XX-SurvivorRatio\"><a href=\"#XX-SurvivorRatio\" class=\"headerlink\" title=\"-XX:SurvivorRatio\"></a>-XX:SurvivorRatio</h4><p>设置新生代中eden和s0/s1空间的比例<br>默认-XX:ServivorRatio=8，Eden:S0:S1=8:1:1<br>假如-XX:SurvivorRatio=4,    Eden::S0:S1=4:1:1<br>SurvivorRatio值就是设置eden区的占比多少，s0/s1相同</p>\n<h4 id=\"XX-NewRatio\"><a href=\"#XX-NewRatio\" class=\"headerlink\" title=\"-XX:NewRatio\"></a>-XX:NewRatio</h4><p>配置年轻代与老年代在堆结构的占比，<br>默认-XX:NewRatio=2 新生代占1，老年代占2，新生代占整个堆的1/3<br>假如-XX:NewRatio=4 新生代占1，老年代占4，新生代占整个堆的1/5<br>NewRatio值就是设置老年代的占比，剩下的1给新生代</p>\n<h4 id=\"XX-MaxTenuringThreshold\"><a href=\"#XX-MaxTenuringThreshold\" class=\"headerlink\" title=\"-XX:MaxTenuringThreshold\"></a>-XX:MaxTenuringThreshold</h4><p>设置进入老年代年龄<br>典型设置案例<br>-Xms128m -Xmx4096m -Xss1024k -XX:MetaspaceSize=512m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UseSerialGC</p>\n<h3 id=\"OOM\"><a href=\"#OOM\" class=\"headerlink\" title=\"OOM\"></a>OOM</h3><h4 id=\"java-lang-StackOverflowError\"><a href=\"#java-lang-StackOverflowError\" class=\"headerlink\" title=\"java.lang.StackOverflowError\"></a>java.lang.StackOverflowError</h4><p>虚拟机栈内存不足导致</p>\n<pre><code class=\"java\">public class StackOverflowErrorDemo {\n    public static void main(String[] args) {\n        stackError();\n    }\n\n    private static void stackError() {\n        stackError();\n    }\n}</code></pre>\n<h4 id=\"java-lang-OutOfMemoryError-Java-heap-space\"><a href=\"#java-lang-OutOfMemoryError-Java-heap-space\" class=\"headerlink\" title=\"java.lang.OutOfMemoryError:Java heap space\"></a>java.lang.OutOfMemoryError:Java heap space</h4><ul>\n<li>java虚拟机的对内存设置不够，可以通过-Xms和-Xmx来设置。生产中这两个参数会设置为一样，避免内存忽高忽低。</li>\n<li>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</li>\n</ul>\n<pre><code class=\"java\">/**\n * -Xms1m -Xmx1m\n */\npublic class OOM_heap_space {\n    public static void main(String[] args) {\n        byte[] bytes = new byte[20 * 1024 * 1024];\n    }\n}</code></pre>\n<h4 id=\"java-lang-OutOfMemoryError-GC-overhead-limit-exceeded\"><a href=\"#java-lang-OutOfMemoryError-GC-overhead-limit-exceeded\" class=\"headerlink\" title=\"java.lang.OutOfMemoryError:GC overhead limit exceeded\"></a>java.lang.OutOfMemoryError:GC overhead limit exceeded</h4><pre><code class=\"java\">/**\n * -Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=10m\n */\npublic class GCOverheadDemo {\n    public static void main(String[] args) {\n        int i = 0;\n        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();\n        try {\n            while (true) {\n                list.add(String.valueOf(++i).intern());\n            }\n        } catch (Exception e) {\n            System.out.println(&quot;+++++++i:&quot; + i);\n            e.printStackTrace();\n            throw e;\n        }\n    }\n}</code></pre>\n<h4 id=\"java-lang-OutOfMemoryError-Direct-buffer-memory\"><a href=\"#java-lang-OutOfMemoryError-Direct-buffer-memory\" class=\"headerlink\" title=\"java.lang.OutOfMemoryError:Direct buffer memory\"></a>java.lang.OutOfMemoryError:Direct buffer memory</h4><pre><code class=\"java\">/**\n * -XX:MaxDirectMemorySize=3m -XX:+PrintGCDetails\n */\npublic class DirectBufferMemoryErrorDemo {\n    public static void main(String[] args) {\n        System.out.println(&quot;配置的MaxDirectMemorySize：&quot; + (sun.misc.VM.maxDirectMemory() / (double) 1024 / 1024 + &quot;MB&quot;));\n        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(6 * 1024 * 1024);\n    }\n}</code></pre>\n<h4 id=\"java-lang-OutOfMemoryError-unbale-to-create-new-native-thread\"><a href=\"#java-lang-OutOfMemoryError-unbale-to-create-new-native-thread\" class=\"headerlink\" title=\"java.lang.OutOfMemoryError:unbale to create new native thread\"></a>java.lang.OutOfMemoryError:unbale to create new native thread</h4><p>root 用户无限制 其他用户 linux 默认1024</p>\n<p>虚拟机栈内存不够用无法再创建新的线程。该异常是由于虚拟机栈内存被用尽导致无法再创建新线程，-Xss参数将直接导致所能创建线程的多少。</p>\n<pre><code class=\"java\">public class UnableCreateNewThreadDemo {\n    public static void main(String[] args) {\n        for (int i = 0; ; i++) {\n            final int tmp = i;\n            new Thread(() -&gt; {\n                System.out.println(tmp);\n                try {\n                    TimeUnit.SECONDS.sleep(MAX_VALUE);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }, String.valueOf(i)).start();\n        }\n    }\n}</code></pre>\n<h4 id=\"java-lang-OutOfMemoryError-Metaspace\"><a href=\"#java-lang-OutOfMemoryError-Metaspace\" class=\"headerlink\" title=\"java.lang.OutOfMemoryError:Metaspace\"></a>java.lang.OutOfMemoryError:Metaspace</h4><pre><code class=\"java\">/**\n * -XX:MetaspaceSize=8m -XX:MaxMetaspaceSize=8m\n */\npublic class MetaspaceOOMDemo {\n    static class Temp {\n    }\n\n    public static void main(String[] args) {\n        int i = 0;\n        while (true) {\n            i++;\n            try {\n                Enhancer enhancer = new Enhancer();\n                enhancer.setSuperclass(Temp.class);\n                enhancer.setUseCache(false);\n                enhancer.setCallback(new MethodInterceptor() {\n                    @Override\n                    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n                        return methodProxy.invokeSuper(o, args);\n                    }\n                });\n                enhancer.create();\n            } catch (Throwable e) {\n                System.out.println(&quot;============&quot; + i);\n                e.printStackTrace();\n            }\n        }\n    }\n}</code></pre>\n<h3 id=\"生产环境服务器变慢，判断思路和性能评估\"><a href=\"#生产环境服务器变慢，判断思路和性能评估\" class=\"headerlink\" title=\"生产环境服务器变慢，判断思路和性能评估\"></a>生产环境服务器变慢，判断思路和性能评估</h3><ul>\n<li>整机：top<br>uptime 是top精简版</li>\n<li>CPU：vmstat</li>\n<li>查看所有CPU核信息：mpastat -P ALL 2</li>\n<li>每个进程使用CPU的用量分解信息：pidstat -u 1 -p 进程编号</li>\n<li>内存：free</li>\n<li>pidstat -p 进程号 -r 采样间隔秒</li>\n<li>硬盘：df</li>\n<li>磁盘IO：iostat</li>\n<li>网络IO：ifstat</li>\n</ul>\n<h3 id=\"CPU占用过高，分析思路和定位\"><a href=\"#CPU占用过高，分析思路和定位\" class=\"headerlink\" title=\"CPU占用过高，分析思路和定位\"></a>CPU占用过高，分析思路和定位</h3><ul>\n<li><p>先用top命令找出CPU占比最高的</p>\n</li>\n<li><p>ps -ef 或者jps 进一步定位，得知是一个怎样的后台程序</p>\n</li>\n<li><p>定位到具体线程或者代码</p>\n</li>\n<li><p>ps -mp 进程 -o THRAD,tid,time</p>\n</li>\n<li><p>-m：显示所有的线程</p>\n</li>\n<li><p>-p pid 进程使用CPU的时间</p>\n</li>\n<li><p>-o 该参数后是用户自定义格式</p>\n</li>\n<li><p>将需要的线程ID转换为16进制格式（英文小写）</p>\n</li>\n<li><p>printf “%x\\n” 有问题的线程ID</p>\n</li>\n<li><p>jstack 进程ID | grep tid（16进制线程ID）-A60</p>\n</li>\n</ul>\n<h2 id=\"JUC\"><a href=\"#JUC\" class=\"headerlink\" title=\"JUC\"></a>JUC</h2><p>JUC(java.util.concurrent)多线程及高并发</p>\n<h3 id=\"Volatile\"><a href=\"#Volatile\" class=\"headerlink\" title=\"Volatile\"></a>Volatile</h3><p>多线程访问成员变量时，会发生多个一个线程将变量数值该变，但是另一个线程可能无法感知变量的值的改变。使用volatile可以避免这种情况</p>\n<p>Volatile是Java虚拟机提供的轻量级的同步机制，低配版Synchronized</p>\n<h4 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h4><h5 id=\"保证可见性\"><a href=\"#保证可见性\" class=\"headerlink\" title=\"保证可见性\"></a>保证可见性</h5><h5 id=\"禁止指令重排\"><a href=\"#禁止指令重排\" class=\"headerlink\" title=\"禁止指令重排\"></a>禁止指令重排</h5><h4 id=\"Volatile使用场景（DCL）\"><a href=\"#Volatile使用场景（DCL）\" class=\"headerlink\" title=\"Volatile使用场景（DCL）\"></a>Volatile使用场景（DCL）</h4><ul>\n<li><p>单例模式DCL(Dobule Check Lock)代码<br>DCL(双端检锁）机制不一定线程安全，是因为有指令重排序的存在，假如volatile可以禁止指令重排<br>原因在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化。</p>\n<pre><code class=\"java\">instance=newSingletonDemo（）；可以分为以下3步：\nmemory =allocate();//1.分配内存空间\ninstance(memory); //2.初始化对象\ninstance =memory; //3.设置instance刚分配的内存地址，此时instance != null;\n步骤2和步骤3 不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种重排优化时允许的。\nmemory =allocate(); //1.分配内存对象\ninstance=memory; //3.设置instance刚分配的内存地址，此时instance != null， 但是对象还没有初始化完成！\ninstance(memory); //2.初始化对象</code></pre>\n<p>但是指令重排只会保证串行语义的执行的一致性（单线程），并不会关心多线程间语义的一致性。<br>所以当一条线程访问instance不为null时，由于instance未必已经初始化完成，也就造成了线程安全问题。</p>\n</li>\n<li><p>方案一(单线程）</p>\n<pre><code class=\"java\">public class SingletonDemo {\n  public static volatile SingletonDemo instance = null;\n\n  public class SingletonDemo {\n      public static SingletonDemo instance = null;\n\n      private SingletonDemo() {\n          System.out.println(&quot;aaa&quot;);\n      }\n\n      //方案一\n      public static SingletonDemo getInstance() {\n          if (instance == null) {\n              instance = new SingletonDemo();\n          }\n          return instance;\n      }\n  }\n}</code></pre>\n</li>\n<li><p>方案二（synchronized）</p>\n<pre><code class=\"java\">public class SingletonDemo {\n  public static SingletonDemo instance = null;\n\n  private SingletonDemo() {\n      System.out.println(&quot;aaa&quot;);\n  }\n\n  //方案二\n  public static synchronized SingletonDemo getInstance() {\n      if (instance == null) {\n          instance = new SingletonDemo();\n      }\n      return instance;\n  }\n}</code></pre>\n</li>\n<li><p>方案三(DCL+Volatile+Synchronized)</p>\n<pre><code class=\"java\">public class SingletonDemo {\n  public static volatile SingletonDemo instance = null;\n\n  private SingletonDemo() {\n      System.out.println(&quot;aaa&quot;);\n  }\n\n  //方案三\n  public static SingletonDemo getInstance() {\n      if (instance == null) {\n          synchronized (SingletonDemo.class) {\n              if (instance == null) {\n                  instance = new SingletonDemo();\n              }\n          }\n      }\n      return instance;\n  }\n}</code></pre>\n</li>\n</ul>\n<h3 id=\"JMM\"><a href=\"#JMM\" class=\"headerlink\" title=\"JMM\"></a>JMM</h3><p><img src=\"Java.assets/Java%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8BJMM2.png\" alt=\"Java线程内存模型JMM2\"></p>\n<p>JMM(Java内存模型  Java Memory Model，简称 JMM） 本身是一种抽象的概念并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。<br>由于JVM运行程序的实体是线程，而每个内存创建时JVM都会为其创建一个工作内存（有些地方称为栈内存），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再讲变量写回主内存，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程捡的通信（传值）必须通过主内存来完成。<br><strong>JMM关于同步的规定</strong></p>\n<ul>\n<li>线程解锁前，必须把共享变量的值刷新回主内存</li>\n<li>线程加锁前，必须读取主内存的最新值到自己的工作内存</li>\n<li>加锁解锁是同一把锁</li>\n</ul>\n<h4 id=\"可见性\"><a href=\"#可见性\" class=\"headerlink\" title=\"可见性\"></a>可见性</h4><p>各个线程对主内存中共享变量的操作都是各个线程各自拷贝到自己的工作内存进行操作然后再写回到主内存。<br>这就可能存在一个线程A修改了共享变量X的值但还未写回主内存时，另外一个线程B又对内存中同一个变量X进行操作，此时A线程工作内存中共享变量X对线程B来说并不可见，这种工作内存与主内存同步延迟现象造成了可见性问题</p>\n<h4 id=\"原子性\"><a href=\"#原子性\" class=\"headerlink\" title=\"原子性\"></a>原子性</h4><p>number++在多线程下是非线程安全的，如何不加Synchronized解决<br>VolatileDemo代码演示可见性+原子性代码</p>\n<h4 id=\"有序性\"><a href=\"#有序性\" class=\"headerlink\" title=\"有序性\"></a>有序性</h4><p>计算机在执行程序时，为了提高性能，编译器和处理器得常常对指令做重排，一般分为3种：<br>单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致<br>处理器在进行重排序时必须要考虑指令间的数据依赖性<br>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测</p>\n<ul>\n<li>重排1<pre><code class=\"java\">public void mySort(){\nint x=1;  //语句1\nint y=2;  //语句2\nx=x+5;   //语句3\ny=x*x;   //语句4\n}\n1234\n2134\n...\n语句4由于存在数据依赖性不会先执行</code></pre>\n</li>\n<li>重排2<pre><code class=\"java\">public class ReSortSeqDemo {\nint a = 0;\nboolean flag = false;\npublic void method01() {\na = 1;\nflag = true;\n}\npublic void method02() {\nif (flag) {\na = a + 5;\nSystem.out.println(&quot;**********retValue:&quot; + a);\n}\n}\n}</code></pre>\n</li>\n<li>禁止指令重排<br>volatile实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象<br>先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：<br>一是保证特定操作的执行顺序<br>二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）<br>由于编译器和处理器都能进行指令重排优化。如果在指令插入一条Memory Barrier则会告诉编译器和CPU，不管什么时候都不能和这条Memory Barrier指令重新排序，也就是说通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化。内存屏障的另一个作用是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。</li>\n</ul>\n<h3 id=\"CAS（comparAndSwap\"><a href=\"#CAS（comparAndSwap\" class=\"headerlink\" title=\"CAS（comparAndSwap)\"></a>CAS（comparAndSwap)</h3><p>比较并交换<br>比较当前工作内存中的值和主内存中的值，如果相同则进行规定操作，否则继续比较直到主内存中的值和工作内存中的值一致为止<br>CAS有三个操作数，内存值V，旧的预期值A，要修改的更新值B。<br>当且仅当预期值A和内存值B相同时，将内存值V修改为B，否则什么也不做。</p>\n<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>CAS的全称为compare-and-swap，它是一条cpu并发原语。<br>它的功能是判断内存某个位置的值是否为预期值，如果是则更改为新的值，这个过程是原子的。<br>CAS并发原语体现在JAVA语言中就是sun.misc.Unsafe类中的各个方法。调用Unsafe类中的CAS方法，JVM会帮我们实现出CAS汇编指令。这是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统原语范畴，是由若干条指令组成的，用于完成某个功能的一个过程，并且原语的执行必须是连续的，在执行过程中不允许被中断，也就是说CAS是一条cpu的原子指令，不会造成所谓的数据不一致问题。</p>\n<h5 id=\"底层汇编\"><a href=\"#底层汇编\" class=\"headerlink\" title=\"底层汇编\"></a>底层汇编</h5><p>Unsafe类中的compareAndSwapInt，是一个本地方法，该方法的实现位于unsafe.cpp中是CAS的核心类，由于Java无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以像C的指针一样直接操作内存，因为CAS操作的执行依赖于Unsafe类的方法。<br>注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务。 unsafe 位于rt.jar包中<br>unsafe.getAndAddInt</p>\n<pre><code class=\"java\">public final int getAndAddInt(Object var1, long var2, int var4) {\n                 int var5;\n                do {\n                   var5 = this.getIntVolatile(var1, var2);\n              } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n             return var5;\n    }</code></pre>\n<p>var1 atomicInteger 对象本身。<br>var2 该对象值的引用地址<br>var4  需要变动的数值<br>var5 是用过var1 var2找出的内存中真实的值<br>用该对象当前的值与var5比较<br>如果相同，更新var5+var4并且返回true<br>如果不同，继续取值然后再比较，直到更新完成<br>假设线程A和线程B两个线程同时执行getAndAddInt操作（分别跑在不同cpu上）：</p>\n<ul>\n<li>atomicInteger里面的value原始值为3，即内存中atomicInteger的value为3，根据JMM模型，线程A和线程B各自持有一份值为3的value副本分别到各自的工作内存。</li>\n<li>线程A通过getIntVolatile（var1，var2）拿到value值3，这时线程A被挂起。</li>\n<li>线程B也通过getIntVolatile（var1，var2）方法获取value值3，此时线程B刚好没有被挂起并执行compareAndSwapInt方法比较内存值也为3，成功修改内存值为4，线程B打完收工，一切ok</li>\n<li>这时线程A恢复，执行compareAndSwapInt方法比较，发现自己手里的值3和内存中的值4不一致，说明该值已经被其他线程抢先一步修改过了，那A线程本次修改失败，只能重新读取重新来一遍。</li>\n<li>线程A重新获取value值，因为变量value被volatile修饰，所以其他线程对它的修改，线程A总是能够看到，线程A继续执行compareAndSwapInt方法进行比较替换，直到成功</li>\n</ul>\n<h4 id=\"CAS的缺点\"><a href=\"#CAS的缺点\" class=\"headerlink\" title=\"CAS的缺点\"></a>CAS的缺点</h4><h5 id=\"循环时间长开销很大\"><a href=\"#循环时间长开销很大\" class=\"headerlink\" title=\"循环时间长开销很大\"></a>循环时间长开销很大</h5><pre><code class=\"java\">public final int getAndAddInt(Object var1, long var2, int var4) {\n    int var5;\n    do {\n        var5 = this.getIntVolatile(var1, var2);\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n    return var5;\n}</code></pre>\n<p>我们可以看到getAndAddInt时，有个do while操作，如果CAS失败时，会一直进行尝试。如果CAS长时间一直不成功，可能会给cpu带来很大的开销。</p>\n<h5 id=\"只能保证一个共享变量的原子操作\"><a href=\"#只能保证一个共享变量的原子操作\" class=\"headerlink\" title=\"只能保证一个共享变量的原子操作\"></a>只能保证一个共享变量的原子操作</h5><p>当对一个共享变量进行操作时，我们可以使用循环CAS来保证原子操作，但是，对于多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。</p>\n<h5 id=\"引出来ABA问题\"><a href=\"#引出来ABA问题\" class=\"headerlink\" title=\"引出来ABA问题\"></a>引出来ABA问题</h5><h3 id=\"ABA\"><a href=\"#ABA\" class=\"headerlink\" title=\"ABA\"></a>ABA</h3><p>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。<br>原子类AtomicInteger的ABA问题(狸猫换太子) 原子类更新引用</p>\n<h4 id=\"ABA问题产生\"><a href=\"#ABA问题产生\" class=\"headerlink\" title=\"ABA问题产生\"></a>ABA问题产生</h4><p>CAS会导致ABA问题<br>CAS算法实现一个重要前提需要取出内存中某时刻的数据并在当下时刻进行比较并替换，那么在这个时间差会导致数据的变化。<br>比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且线程two进行来一些操作将值变成了B，然后线程two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中国年依然是A，然后线程one操作成功。<br>尽管线程one的CAS的操作成功，但是并不代表这个过程就是没有问题的。</p>\n<h4 id=\"原子引用-AtomicReference\"><a href=\"#原子引用-AtomicReference\" class=\"headerlink\" title=\"原子引用(AtomicReference)\"></a>原子引用(AtomicReference)</h4><pre><code class=\"java\">class User {\n    String userName;\n    int age;\n\n    public User(String userName, int age) {\n        this.userName = userName;\n        this.age = age;\n    }\n\n    public String getUserName() {\n        return userName;\n    }\n\n    public void setUserName(String userName) {\n        this.userName = userName;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return &quot;User(userName：&quot; + userName + &quot;，Age：&quot; + age + &quot;)&quot;;\n    }\n}\n\npublic class AtomicReferenceDemo {\n    public static void main(String[] args) {\n        User zhangsan = new User(&quot;zhangsan&quot;, 23);\n        User lisi = new User(&quot;lisi&quot;, 25);\n        AtomicReference&lt;User&gt; reference = new AtomicReference&lt;&gt;();\n        reference.set(zhangsan);\n        System.out.println(reference.compareAndSet(zhangsan, lisi) + &quot;\\t&quot; + reference.get().toString());\n        System.out.println(reference.compareAndSet(zhangsan, lisi) + &quot;\\t&quot; + reference.get().toString());\n    }\n}</code></pre>\n<h4 id=\"时间戳原子引用-AtomicStampedReference\"><a href=\"#时间戳原子引用-AtomicStampedReference\" class=\"headerlink\" title=\"时间戳原子引用(AtomicStampedReference)\"></a>时间戳原子引用(AtomicStampedReference)</h4><p>ABA问题的解决方案</p>\n<pre><code class=\"java\">    public class AtomicStmapedReferenceDemo {\n    static AtomicReference atomicReference = new AtomicReference&lt;Integer&gt;(100);\n    static AtomicStampedReference atomicStampedReference = new AtomicStampedReference&lt;&gt;(100, 1);\n\n    public static void main(String[] args) throws InterruptedException {\n        System.out.println(&quot;================以下是ABA问题的产生================&quot;);\n        new Thread(() -&gt; {\n            atomicReference.compareAndSet(100, 101);\n            atomicReference.compareAndSet(101, 100);\n        }, &quot;t1&quot;).start();\n        new Thread(() -&gt; {\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(atomicReference.compareAndSet(100, 2019) + &quot;\\t&quot; + atomicReference.get());\n        }, &quot;t2&quot;).start();\n        TimeUnit.SECONDS.sleep(3);\n        System.out.println(&quot;=================以下是ABA问题的解决方案=====================&quot;);\n        new Thread(() -&gt; {\n            System.out.println(Thread.currentThread().getName() + &quot;\\t第一次版本号：&quot; + atomicStampedReference.getStamp());\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            atomicStampedReference.compareAndSet(100, 101, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);\n            System.out.println(Thread.currentThread().getName() + &quot;\\t第二次版本号：&quot; + atomicStampedReference.getStamp());\n            atomicStampedReference.compareAndSet(101, 100, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);\n            System.out.println(Thread.currentThread().getName() + &quot;\\t第三次版本号：&quot; + atomicStampedReference.getStamp());\n        }, &quot;t3&quot;).start();\n        new Thread(() -&gt; {\n            int stamp = atomicStampedReference.getStamp();\n            System.out.println(Thread.currentThread().getName() + &quot;\\t第一次版本号：&quot; + stamp);\n            try {\n                TimeUnit.SECONDS.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            boolean flag = atomicStampedReference.compareAndSet(100, 2019, stamp, stamp + 1);\n            System.out.println(Thread.currentThread().getName() + &quot;\\t是否修改成功：&quot; + flag);\n            System.out.println(Thread.currentThread().getName() + &quot;\\t当前实际值：&quot; + atomicStampedReference.getReference() + &quot;\\t当前实际版本号：&quot; + atomicStampedReference.getStamp());\n        }, &quot;t4&quot;).start();\n    }\n}</code></pre>\n<h3 id=\"AQS（AbstractQueuedSynchronizer）\"><a href=\"#AQS（AbstractQueuedSynchronizer）\" class=\"headerlink\" title=\"AQS（AbstractQueuedSynchronizer）\"></a>AQS（AbstractQueuedSynchronizer）</h3><p>AQS 是 AbstractQueuedSynchronizer 的简称，它是一个 Java 提高的底层同步 工具类，用一个 int 类型的变量表示同步状态，并提供了一系列的 CAS 操作来管 理这个同步状态。<br>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广 泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。</p>\n<h4 id=\"AQS-支持两种同步方式\"><a href=\"#AQS-支持两种同步方式\" class=\"headerlink\" title=\"AQS 支持两种同步方式\"></a><strong>AQS 支持两种同步方式</strong></h4><ul>\n<li>独占式</li>\n<li>共享式<br>这样方便使用者实现不同类型的同步组件，独占式如 ReentrantLock，共享式如 Semaphore，CountDownLatch，组合式的如 ReentrantReadWriteLock。总之， AQS 为使用提供了底层支撑，如何组装实现，使用者可以自由发挥。</li>\n</ul>\n<h3 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h3><h4 id=\"线程六种状态\"><a href=\"#线程六种状态\" class=\"headerlink\" title=\"线程六种状态\"></a>线程六种状态</h4><ul>\n<li>NEW：新建状态 刚刚创建出来，还没有调用start方法之前的状态。</li>\n<li>RUNNABLE:可运行状态，可能正在执行，也可能不是正在执行，只有在该种状态下的线程才有资格抢CPU。</li>\n<li>BLOCKED:锁阻塞状态  线程要等待另一个线程释放锁对象。</li>\n<li>WAITING：无限等待  线程调用了wait()方法进入的状态，需要其它线程调用notify方法唤醒。</li>\n<li>TIMED_WAITING:计时等待状态  线程调用了sleep方法获wait（long time）方法进入的状态。</li>\n<li>TERMINATED:死亡状态  线程任务执行完毕或调用了stop方法。</li>\n</ul>\n<h4 id=\"ConcurrentModificationException\"><a href=\"#ConcurrentModificationException\" class=\"headerlink\" title=\"ConcurrentModificationException\"></a>ConcurrentModificationException</h4><p>线程不安全</p>\n<ul>\n<li>ArrayList</li>\n<li>HashMap</li>\n<li>HashSet</li>\n</ul>\n<pre><code class=\"java\">public class ContainerNotSafeDemo {\n    public static void main(String[] args) {\n\n    }\n\n    private static void MapNotSafe() {\n        Map map = new HashMap();\n        for (int i = 0; i &lt; 30; i++) {\n            new Thread(() -&gt; {\n                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 8));\n                System.out.println(map);\n            }).start();\n        }\n    }\n\n    private static void SetNotSafe() {\n        Set set = new HashSet();\n        for (int i = 0; i &lt; 30; i++) {\n            new Thread(() -&gt; {\n                set.add(UUID.randomUUID().toString().substring(0, 8));\n                System.out.println(set);\n            }).start();\n        }\n    }\n\n    private static void ListNotSafe() {\n        List&lt;String&gt; list = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 30; i++) {\n            new Thread(() -&gt; {\n                list.add(UUID.randomUUID().toString().substring(0, 8));\n                System.out.println(list);\n            }).start();\n        }\n    }\n}</code></pre>\n<ul>\n<li><p>解决方案1</p>\n<pre><code class=\"java\">public class ContainerNotSafeDemo {\n  public static void main(String[] args) {\n  }\n\n  private static void MapNotSafe() {\n      Map map = new HashMap();/// Collections.synchronizedMap(new HashMap&lt;&gt;());new ConcurrentHashMap&lt;&gt;();\n      for (int i = 0; i &lt; 30; i++) {\n          new Thread(() -&gt; {\n              map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 8));\n              System.out.println(map);\n          }).start();\n      }\n  }\n\n  private static void SetNotSafe() {\n      Set set = new HashSet();// Collections.synchronizedSet(new HashSet&lt;&gt;());new CopyOnWriteArraySet&lt;&gt;();\n      for (int i = 0; i &lt; 30; i++) {\n          new Thread(() -&gt; {\n              set.add(UUID.randomUUID().toString().substring(0, 8));\n              System.out.println(set);\n          }).start();\n      }\n  }\n\n  private static void ListNotSafe() {\n      List&lt;String&gt; list = new ArrayList&lt;&gt;();//new Vector&lt;&gt;(); Collections.synchronizedList(new ArrayList&lt;&gt;());new CopyOnWriteArrayList&lt;&gt;();\n      for (int i = 0; i &lt; 30; i++) {\n          new Thread(() -&gt; {\n              list.add(UUID.randomUUID().toString().substring(0, 8));\n              System.out.println(list);\n          }).start();\n      }\n  }\n}</code></pre>\n</li>\n<li><p>解决方案2（限制不可以使用vector和collections工具类）<br>写时复制<br>CopyOnWrite容器即写时复制容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是先将当前容器Object[]进行Copy，复制出一个新的容器Object[] newElements,然后新的容器Object[] newElements里面添加元素，添加完元素之后，再将原容器的引用指向新容器setArray（newElements）；，这样做的好处是可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>\n<pre><code class=\"java\">/**\n* Appends the specified element to the end of this list.\n*\n* @param e element to be appended to this list\n* @return {@code true} (as specified by {@link Collection#add})\n*/\npublic boolean add(E e) {\n  final ReentrantLock lock = this.lock;\n  lock.lock();\n  try {\n      Object[] elements = getArray();\n      int len = elements.length;\n      Object[] newElements = Arrays.copyOf(elements, len + 1);\n      newElements[len] = e;\n      setArray(newElements);\n      return true;\n  } finally {\n      lock.unlock();\n  }\n}</code></pre>\n</li>\n<li><p>Demo</p>\n<pre><code class=\"java\">public class ContainerNotSafeDemo {\n  public static void main(String[] args) {\n      List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();\n      for (int i = 0; i &lt;30 ; i++) {\n          new Thread(()-&gt;{\n              list.add(UUID.randomUUID().toString().substring(0,8));\n              System.out.println(list);\n          }).start();\n      }\n  }\n}</code></pre>\n<h4 id=\"线程接口\"><a href=\"#线程接口\" class=\"headerlink\" title=\"线程接口\"></a>线程接口</h4></li>\n<li><p>分类</p>\n<ul>\n<li>Runnable</li>\n<li>Callable</li>\n</ul>\n</li>\n<li><p>区别</p>\n<ul>\n<li>Callable有返回值，Runnable没有 返回值</li>\n<li>Callable抛异常，Runnable不抛异常</li>\n<li>落地方法不一样，Callable是call，Runnable是run</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"多线程辅助类\"><a href=\"#多线程辅助类\" class=\"headerlink\" title=\"多线程辅助类\"></a>多线程辅助类</h4><p>CountDownLatch/CyclicBarrier/Semaphore /ReadWriteLock</p>\n<h5 id=\"ReadWriteLock\"><a href=\"#ReadWriteLock\" class=\"headerlink\" title=\"ReadWriteLock\"></a>ReadWriteLock</h5><p>读读共存，读写、写写不共存</p>\n<h5 id=\"CountDownLatch（火箭倒计时）\"><a href=\"#CountDownLatch（火箭倒计时）\" class=\"headerlink\" title=\"CountDownLatch（火箭倒计时）\"></a>CountDownLatch（火箭倒计时）</h5><p>减一直到为0<br>让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒。<br>CountDownLatch主要有两个方法，当一个或多个线程调用await方法，调用线程会被阻塞。其它线程调用countDown方法会将计数器减1（调用countDown的方法不会阻塞），当计数器的值变为零时，因调用await方法被阻塞的线程会被唤醒，继续执行。</p>\n<p>main线程会等待其他线程执行完后接着执行</p>\n<pre><code class=\"java\">public class CountDownLatchDemo  {\n\n    public static void main(String[] args) throws InterruptedException {\n        Random random=  new Random();\n        CountDownLatch latch = new CountDownLatch(10);\n\n        for (int i=0;i&lt;10;i++){\n            new Thread(()-&gt;{\n                try {\n                    TimeUnit.SECONDS.sleep(random.nextInt(5));\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName());\n                latch.countDown();\n            },String.valueOf(i)).start();\n        }\n\n\n        latch.await();\n\n        System.out.println(&quot;game over&quot;);\n\n    }\n}</code></pre>\n<h5 id=\"CyclicBarrier（集齐七龙珠，召唤神龙）\"><a href=\"#CyclicBarrier（集齐七龙珠，召唤神龙）\" class=\"headerlink\" title=\"CyclicBarrier（集齐七龙珠，召唤神龙）\"></a>CyclicBarrier（集齐七龙珠，召唤神龙）</h5><p>加一<br>CyclicBarrier 的字面意思是可以循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，让一组线程达到一个屏障（同步点）时被阻塞，直到最后一个线程达到屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await方法。</p>\n<p>主线程会和其他线程一起并发执行</p>\n<pre><code class=\"java\">public class CyclicBarrierDemo {\n    public static void main(String[] args) {\n        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -&gt; {\n            System.out.println(&quot;===========召唤神龙========&quot;);\n        });\n        for (int i=1;i&lt;=7;i++){\n            final  int tmp=i;\n            new Thread(()-&gt;{\n                System.out.println(Thread.currentThread().getName() + &quot;\\t 获得第 &quot; + tmp + &quot; 颗龙珠&quot;);\n                try {\n                    cyclicBarrier.await();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n            },String.valueOf(i)).start();\n        }\n    }\n}</code></pre>\n<h5 id=\"Semaphore（抢停车位）\"><a href=\"#Semaphore（抢停车位）\" class=\"headerlink\" title=\"Semaphore（抢停车位）\"></a>Semaphore（抢停车位）</h5><p>多线程抢占固定资源<br>信号量主要有两个目的，一个是用于多个资源的互斥，另一个是用于并发线程数的控制。</p>\n<p>主线程会和其他线程并发执行</p>\n<pre><code class=\"java\">public class SemaphoreDemo {\n    public static void main(String[] args) {\n        Semaphore semaphore = new Semaphore(3);\n        for (int i=0;i&lt;10;i++){\n            new Thread(()-&gt;{\n                try {\n                    semaphore.acquire();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + &quot;\\t 抢到停车位&quot;);\n                try {\n                    TimeUnit.SECONDS.sleep(3);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }finally {\n                    semaphore.release();\n                }\n                System.out.println(Thread.currentThread().getName() + &quot;\\t 离开了&quot;);\n            },String.valueOf(i)).start();\n        }\n    }\n}</code></pre>\n<h3 id=\"线程池\"><a href=\"#线程池\" class=\"headerlink\" title=\"线程池\"></a>线程池</h3><p>线程复用，控制最大并发数，管理线程 </p>\n<h4 id=\"架构说明\"><a href=\"#架构说明\" class=\"headerlink\" title=\"架构说明\"></a>架构说明</h4><p>Java中线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类。</p>\n<h4 id=\"了解\"><a href=\"#了解\" class=\"headerlink\" title=\"了解\"></a>了解</h4><ul>\n<li>Executors.newScheduledThreadPool()</li>\n<li>java8新出（Executors.newWorkStealingPool(int）</li>\n</ul>\n<p>java8 新增，使用目前机器上可用的处理器作为它的并行级别</p>\n<h4 id=\"Executors-newFixedThreadPool-int\"><a href=\"#Executors-newFixedThreadPool-int\" class=\"headerlink\" title=\"Executors.newFixedThreadPool(int)\"></a>Executors.newFixedThreadPool(int)</h4><pre><code class=\"java\">/**\n * Creates a thread pool that reuses a fixed number of threads\n * operating off a shared unbounded queue.  At any point, at most\n * {@code nThreads} threads will be active processing tasks.\n * If additional tasks are submitted when all threads are active,\n * they will wait in the queue until a thread is available.\n * If any thread terminates due to a failure during execution\n * prior to shutdown, a new one will take its place if needed to\n * execute subsequent tasks.  The threads in the pool will exist\n * until it is explicitly {@link ExecutorService#shutdown shutdown}.\n *\n * @param nThreads the number of threads in the pool\n * @return the newly created thread pool\n * @throws IllegalArgumentException if {@code nThreads &lt;= 0}\n */\npublic static ExecutorService newFixedThreadPool(int nThreads) {\n    return new ThreadPoolExecutor(nThreads, nThreads,\n            0L, TimeUnit.MILLISECONDS,\n            new LinkedBlockingQueue&lt;Runnable&gt;());\n}</code></pre>\n<p>主要特点：</p>\n<ul>\n<li><p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待</p>\n</li>\n<li><p>newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlokingQueue</p>\n<p>场景：<br>执行长期的任务，性能好很多</p>\n</li>\n</ul>\n<h4 id=\"Executors-newSingleThreadExecutor\"><a href=\"#Executors-newSingleThreadExecutor\" class=\"headerlink\" title=\"Executors.newSingleThreadExecutor()\"></a>Executors.newSingleThreadExecutor()</h4><pre><code class=\"java\">/**\n * Creates an Executor that uses a single worker thread operating\n * off an unbounded queue. (Note however that if this single\n * thread terminates due to a failure during execution prior to\n * shutdown, a new one will take its place if needed to execute\n * subsequent tasks.)  Tasks are guaranteed to execute\n * sequentially, and no more than one task will be active at any\n * given time. Unlike the otherwise equivalent\n * {@code newFixedThreadPool(1)} the returned executor is\n * guaranteed not to be reconfigurable to use additional threads.\n *\n * @return the newly created single-threaded Executor\n */\npublic static ExecutorService newSingleThreadExecutor() {\n    return new FinalizableDelegatedExecutorService\n            (new ThreadPoolExecutor(1, 1,\n                    0L, TimeUnit.MILLISECONDS,\n                    new LinkedBlockingQueue&lt;Runnable&gt;()));\n}</code></pre>\n<p>主要特点：<br>1    创建一个单线化的线程池，它只会用唯一的工作线程来执行任务，保证任务按照指定顺序执行<br>2    newSingleThreadExecutor将corePoolSize和maxmiumPoolSize都设置为1，它使用的是LinkedBlockingQueue<br>场景：<br>任务顺序执行</p>\n<h4 id=\"Executors-newCachedPool\"><a href=\"#Executors-newCachedPool\" class=\"headerlink\" title=\"Executors.newCachedPool()\"></a>Executors.newCachedPool()</h4><pre><code class=\"java\">/**\n * Creates a thread pool that creates new threads as needed, but\n * will reuse previously constructed threads when they are\n * available.  These pools will typically improve the performance\n * of programs that execute many short-lived asynchronous tasks.\n * Calls to {@code execute} will reuse previously constructed\n * threads if available. If no existing thread is available, a new\n * thread will be created and added to the pool. Threads that have\n * not been used for sixty seconds are terminated and removed from\n * the cache. Thus, a pool that remains idle for long enough will\n * not consume any resources. Note that pools with similar\n * properties but different details (for example, timeout parameters)\n * may be created using {@link ThreadPoolExecutor} constructors.\n *\n * @return the newly created thread pool\n */\npublic static ExecutorService newCachedThreadPool() {\n    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n            60L, TimeUnit.SECONDS,\n            new SynchronousQueue&lt;Runnable&gt;());\n}</code></pre>\n<p>主要特点：<br>1    创建一个可缓存线程池，如果线程池长度超过处理要求，可灵活回收空线程，若无可回收，则新建线程。<br>2    newCacheThreadPool将coreSize设置为0，将maxmiumSize设置为Integer.MAX_VALUE，使用的是SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程<br>场景：<br>执行很多短期异步的小程序或者负载较轻的服务</p>\n<h4 id=\"7大参数\"><a href=\"#7大参数\" class=\"headerlink\" title=\"7大参数\"></a>7大参数</h4><pre><code class=\"java\">/**\n * Creates a new {@code ThreadPoolExecutor} with the given initial\n * parameters and default thread factory and rejected execution handler.\n * It may be more convenient to use one of the {@link Executors} factory\n * methods instead of this general purpose constructor.\n *\n * @param corePoolSize the number of threads to keep in the pool, even\n *        if they are idle, unless {@code allowCoreThreadTimeOut} is set\n * @param maximumPoolSize the maximum number of threads to allow in the\n *        pool\n * @param keepAliveTime when the number of threads is greater than\n *        the core, this is the maximum time that excess idle threads\n *        will wait for new tasks before terminating.\n * @param unit the time unit for the {@code keepAliveTime} argument\n * @param workQueue the queue to use for holding tasks before they are\n *        executed.  This queue will hold only the {@code Runnable}\n *        tasks submitted by the {@code execute} method.\n * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;\n *         {@code corePoolSize &lt; 0}&lt;br&gt;\n *         {@code keepAliveTime &lt; 0}&lt;br&gt;\n *         {@code maximumPoolSize &lt;= 0}&lt;br&gt;\n *         {@code maximumPoolSize &lt; corePoolSize}\n * @throws NullPointerException if {@code workQueue} is null\n */\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue&lt;Runnable&gt; workQueue) {\n    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,\n            Executors.defaultThreadFactory(), defaultHandler);\n}</code></pre>\n<h5 id=\"corePoolSize\"><a href=\"#corePoolSize\" class=\"headerlink\" title=\"corePoolSize\"></a>corePoolSize</h5><p>线程池中的常驻核心线程数</p>\n<h5 id=\"maximumPoolSize\"><a href=\"#maximumPoolSize\" class=\"headerlink\" title=\"maximumPoolSize\"></a>maximumPoolSize</h5><p>线程池能够容纳同时执行的最大线程数，此值必须大于等于1</p>\n<h5 id=\"keepAliveTime\"><a href=\"#keepAliveTime\" class=\"headerlink\" title=\"keepAliveTime\"></a>keepAliveTime</h5><p>多余的空闲线程的存活时间。<br>当前线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止<br>默认情况下：<br>只有当线程池中的线程数大于corePoolSize时，keepAlive才会起作用，直到线程池中的线程数不大于corePoolSize</p>\n<h5 id=\"unit\"><a href=\"#unit\" class=\"headerlink\" title=\"unit\"></a>unit</h5><p>keepAliveTime的单位</p>\n<h5 id=\"workQueue\"><a href=\"#workQueue\" class=\"headerlink\" title=\"workQueue\"></a>workQueue</h5><p>任务队列，被提交但尚未被执行的任务</p>\n<h5 id=\"threadFactory\"><a href=\"#threadFactory\" class=\"headerlink\" title=\"threadFactory\"></a>threadFactory</h5><p>表示生成线程池中工作线程的线程工厂，用于创建线程一般用默认的即可</p>\n<h5 id=\"handler\"><a href=\"#handler\" class=\"headerlink\" title=\"handler\"></a>handler</h5><p>拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数（maximumPoolSize）时如何来拒绝请求执行的runnable的策略<br>等待队列也已经满了，再也塞不下新任务了<br>同时，线程池中的max线程也达到了，无法继续为信任服务<br>这时候我们就需要拒绝策略机制合理的处理这个问题</p>\n<ul>\n<li>AbortPolicy（默认）<br>中断抛异常</li>\n<li>CallerRunsPolicy<br>调用者运行。该策略既不会抛弃任务也不会抛异常，而是将任务回退给调用者，从而降低新任的流量</li>\n<li>DiscardPolicy<br>该策略会默默的抛弃无法处理的任务，不予任何处理也不会抛异常。如果任务允许丢失，这是最好的一种策略</li>\n<li>DiscardOldestPolicy<br>抛弃队列中等待最久的任务，把当前任务加入队列中尝试再次提交任务</li>\n</ul>\n<h4 id=\"说说线程池底层的工作原理\"><a href=\"#说说线程池底层的工作原理\" class=\"headerlink\" title=\"说说线程池底层的工作原理\"></a>说说线程池底层的工作原理</h4><ul>\n<li>在创建来线程池后，等待提交过来的任务请求</li>\n<li>当调用execute()方法添加一个任务时，线程池会作以下判断：<ul>\n<li>如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务</li>\n<li>如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务加入队列</li>\n<li>如果这时队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程运行这个任务</li>\n<li>如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行</li>\n</ul>\n</li>\n<li>当一个线程完成任务是，它会从队列中取下一个任务来执行</li>\n<li>当一个线程无事可做超过一定的时间（keepAliveTime）时，线程池会判断：<br>如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。<br>所以线程池的所有任务完成后它最终会收缩到corePoolSize的大小。</li>\n</ul>\n<h4 id=\"execute方法-和submit方法的区别\"><a href=\"#execute方法-和submit方法的区别\" class=\"headerlink\" title=\"execute方法 和submit方法的区别\"></a>execute方法 和submit方法的区别</h4><ul>\n<li>execute 没有返回值，submit带有返回值</li>\n<li>execute可以传入Runnable接口，submit可以传入Runnable和Callable接口</li>\n</ul>\n<h4 id=\"合理配置线程池你是如何考虑的\"><a href=\"#合理配置线程池你是如何考虑的\" class=\"headerlink\" title=\"合理配置线程池你是如何考虑的\"></a>合理配置线程池你是如何考虑的</h4><h5 id=\"CPU密集型\"><a href=\"#CPU密集型\" class=\"headerlink\" title=\"CPU密集型\"></a>CPU密集型</h5><p>CPU密集型，即该任务需要大量CPU运算，没有阻塞，CPU一直处于全速运行状态<br>CPU密集型任务只有在真正多核CPU上才可能得到加速（通过多线程）<br>在单核CPU上，无论你开几个模拟的多线程该任务都不可能得到加速，因为CPU总的运算能力就那些<br>CPU密集型任务配置尽可能少的线程数量：<br>一般公式：线程池=CPU核数+1个线程<br>Runtime.getRuntime().availableProcessors()+[1-2]</p>\n<h5 id=\"IO密集型\"><a href=\"#IO密集型\" class=\"headerlink\" title=\"IO密集型\"></a>IO密集型</h5><ul>\n<li><p>方案一<br>由于IO密集型任务线程并不是一直在执行任务，则应该配置尽可能多的线程，如CPU核数*2</p>\n</li>\n<li><p>方案二<br>IO密集型，该任务需要大量的IO操作，即大量的阻塞<br>在单线程上运行IO密集型的任务会导致浪费大量的CPU运算能力在等待上，所以在IO密集型任务中使用多线程可以大大的加速程序运行，在单核CPU上，这种加速主要就是利用了被浪费的阻塞时间<br>IO密集型，大部分线程都在阻塞，故要多配置线程数：<br>参考公式：CPU核数／1-阻塞系数<br>阻塞系数=0.8～0.9<br>阻塞系数一般取0.9<br>比如8核CPU：8/（1-0.9）=80个线程数</p>\n</li>\n</ul>\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><p>阻塞队列，顾名思义，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如下：<br>线程1往队列中添加元素，而线程2从阻塞队列中移除元素<br>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞。<br>当阻塞队列满的时候，往队列中添加元素的操作将会被阻塞。<br>试图从空的阻塞队列中国年获取元素的线程将会阻塞，直到其他的线程往空的队列插入新的元素。同样，试图往已满的阻塞队列中添加新元素的线程同样也会被阻塞，直到其他的线程从队列中移除一个或多个元素或者完全清空队列后使队列重新变得空闲起来并后续新增。</p>\n<h4 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h4><p>在多线程领域：所谓阻塞。在某些情况下会挂起线程（即阻塞），一旦条件被满足，被挂起的线程又会自动被唤醒</p>\n<h4 id=\"BlockingQueue\"><a href=\"#BlockingQueue\" class=\"headerlink\" title=\"BlockingQueue\"></a>BlockingQueue</h4><p>空的时候不能获取，满的时候不能生产 </p>\n<p>好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手操办了。<br>在concurrent包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，而这会使我们的程序带来不小的复杂度。</p>\n<h5 id=\"ArrayBlockingQueue\"><a href=\"#ArrayBlockingQueue\" class=\"headerlink\" title=\"ArrayBlockingQueue\"></a>ArrayBlockingQueue</h5><p>由数组结构组成的有界阻塞队列</p>\n<h5 id=\"LinkedBlockingQueue\"><a href=\"#LinkedBlockingQueue\" class=\"headerlink\" title=\"LinkedBlockingQueue\"></a>LinkedBlockingQueue</h5><p>由链表结构构成的有界队列（但大小默认值为Inter.MAX_VALUE）阻塞队列</p>\n<h5 id=\"PriorityBlockingQueue\"><a href=\"#PriorityBlockingQueue\" class=\"headerlink\" title=\"PriorityBlockingQueue\"></a>PriorityBlockingQueue</h5><p>支持优先级排序的无界阻塞队列</p>\n<h5 id=\"DelayQueue\"><a href=\"#DelayQueue\" class=\"headerlink\" title=\"DelayQueue\"></a>DelayQueue</h5><p>使用优先级队列实现的延迟无界阻塞队列</p>\n<h5 id=\"SynchronousQueue\"><a href=\"#SynchronousQueue\" class=\"headerlink\" title=\"SynchronousQueue\"></a>SynchronousQueue</h5><p>不存储元素的阻塞队列，也即单个元素的队列<br>SynchronousQueue 没有容量<br>与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue<br>每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然</p>\n<ul>\n<li>Demo<pre><code class=\"java\">public class SynchronousQueueDemo {\n  public static void main(String[] args) {\n      SynchronousQueue&lt;Object&gt; synchronousQueue = new SynchronousQueue&lt;&gt;();\n      new Thread(() -&gt; {\n          try {\n              System.out.println(Thread.currentThread().getName() + &quot;\\t put 1&quot;);\n              synchronousQueue.put(&quot;1&quot;);\n              System.out.println(Thread.currentThread().getName() + &quot;\\t put 2&quot;);\n              synchronousQueue.put(&quot;2&quot;);\n              System.out.println(Thread.currentThread().getName() + &quot;\\t put 3&quot;);\n              synchronousQueue.put(&quot;3&quot;);\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }\n      }, &quot;t1&quot;).start();\n      new Thread(() -&gt; {\n          try {\n              System.out.println(Thread.currentThread().getName() + &quot;\\t take 1&quot;);\n              synchronousQueue.take();\n              TimeUnit.SECONDS.sleep(5);\n              System.out.println(Thread.currentThread().getName() + &quot;\\t take 2&quot;);\n              synchronousQueue.take();\n              TimeUnit.SECONDS.sleep(5);\n              System.out.println(Thread.currentThread().getName() + &quot;\\t take 3&quot;);\n              synchronousQueue.take();\n              TimeUnit.SECONDS.sleep(5);\n          } catch (Exception e) {\n              e.printStackTrace();\n          }\n      }, &quot;t2&quot;).start();\n  }\n}</code></pre>\n<h5 id=\"LinkedTransferQueue\"><a href=\"#LinkedTransferQueue\" class=\"headerlink\" title=\"LinkedTransferQueue\"></a>LinkedTransferQueue</h5>由链表结构组成的无界阻塞队列<h5 id=\"LinkedBlockingDeque\"><a href=\"#LinkedBlockingDeque\" class=\"headerlink\" title=\"LinkedBlockingDeque\"></a>LinkedBlockingDeque</h5>由链表结构组成的双向阻塞队列</li>\n</ul>\n<h4 id=\"核心方法\"><a href=\"#核心方法\" class=\"headerlink\" title=\"核心方法\"></a>核心方法</h4><h5 id=\"抛异常\"><a href=\"#抛异常\" class=\"headerlink\" title=\"抛异常\"></a>抛异常</h5><ul>\n<li>add<br>当队列满时，再添加元素会抛出异常（Queue Full）</li>\n<li>remove<br>当队列空时，再移除元素会抛出异常（NoSuchElementException）</li>\n<li>element<br>检查队列第一个元素</li>\n</ul>\n<h5 id=\"有返回值\"><a href=\"#有返回值\" class=\"headerlink\" title=\"有返回值\"></a>有返回值</h5><ul>\n<li>offer(e)<br>当队列满时，再添加元素不会抛出异常会返回false</li>\n<li>poll<br>当队列空时，再移除元素不会抛出异常会返回null</li>\n<li>peek<br>检查队列第一个元素</li>\n</ul>\n<h5 id=\"阻塞\"><a href=\"#阻塞\" class=\"headerlink\" title=\"阻塞\"></a>阻塞</h5><ul>\n<li>put<br>当队列满时，再添加元素会一直阻塞，直到可以添加元素</li>\n<li>take<br>当队列空时，再移除元素会一直阻塞，直到有元素可以移除</li>\n</ul>\n<h5 id=\"超时\"><a href=\"#超时\" class=\"headerlink\" title=\"超时\"></a>超时</h5><ul>\n<li>offer(e,time,unit)<br>当队列满时，再添加元素会等待，直到超时时间到达，返回false</li>\n<li>poll(time,unit)<br>当队列空时，再移除元素会等待，直到超时时间到达，返回null</li>\n</ul>\n<h4 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h4><h5 id=\"生产者消费者模式\"><a href=\"#生产者消费者模式\" class=\"headerlink\" title=\"生产者消费者模式\"></a>生产者消费者模式</h5><ul>\n<li>传统版</li>\n<li>Demo<pre><code class=\"java\">class ShareData{\n  int number=0;\n  Lock lock=new ReentrantLock();\n  Condition condition=lock.newCondition();\n  public void increment()throws Exception{\n      lock.lock();\n      try{\n          while (number!=0){\n              condition.await();\n          }\n          number++;\n          System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + number);\n          condition.signalAll();\n      }catch (Exception e){\n          e.printStackTrace();\n      }finally {\n          lock.unlock();\n      }\n  }\n  public void decrement()throws Exception{\n      lock.lock();\n      try{\n          while (number==0){\n              condition.await();\n          }\n          number--;\n          System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + number);\n          condition.signalAll();\n      }catch (Exception e){\n          e.printStackTrace();\n      }finally {\n          lock.unlock();\n      }\n  }\n}\npublic class ProdConsumer_TraditionDemo {\n  public static void main(String[] args) {\n      ShareData shareData = new ShareData();\n      new Thread(() -&gt; {\n          for (int i = 0; i &lt; 5; i++) {\n              try {\n                  shareData.increment();\n              } catch (Exception e) {\n                  e.printStackTrace();\n              }\n          }\n      }, &quot;t1&quot;).start();\n      new Thread(() -&gt; {\n          for (int i = 0; i &lt; 5; i++) {\n              try {\n                  shareData.decrement();\n              } catch (Exception e) {\n                  e.printStackTrace();\n              }\n          }\n      }, &quot;t2&quot;).start();\n  }\n}</code></pre>\n</li>\n<li>阻塞队列版</li>\n</ul>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><p>公平锁／非公平锁／可重入锁／递归锁／自旋锁</p>\n<h3 id=\"四种状态\"><a href=\"#四种状态\" class=\"headerlink\" title=\"四种状态\"></a>四种状态</h3><h4 id=\"无锁\"><a href=\"#无锁\" class=\"headerlink\" title=\"无锁\"></a>无锁</h4><h4 id=\"偏向锁\"><a href=\"#偏向锁\" class=\"headerlink\" title=\"偏向锁\"></a>偏向锁</h4><h4 id=\"轻量级锁\"><a href=\"#轻量级锁\" class=\"headerlink\" title=\"轻量级锁\"></a>轻量级锁</h4><h4 id=\"重量级锁\"><a href=\"#重量级锁\" class=\"headerlink\" title=\"重量级锁\"></a>重量级锁</h4><h3 id=\"锁的升级\"><a href=\"#锁的升级\" class=\"headerlink\" title=\"锁的升级\"></a>锁的升级</h3><p>当只有一个线程访问是叫做偏向锁——&gt;发生竞争时升级成轻量级锁（自选锁等）——&gt;自选等待没结果时升级成重量级锁</p>\n<h3 id=\"公平锁\"><a href=\"#公平锁\" class=\"headerlink\" title=\"公平锁\"></a>公平锁</h3><p>是指多个线程按照申请锁的顺序来获取锁，类似排队打饭，先来后到。</p>\n<h3 id=\"非公平锁\"><a href=\"#非公平锁\" class=\"headerlink\" title=\"非公平锁\"></a>非公平锁</h3><p>是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发的情况下，有可能会造成优先级反转或者饥饿现象。</p>\n<h3 id=\"公平锁／非公平锁-两者区别\"><a href=\"#公平锁／非公平锁-两者区别\" class=\"headerlink\" title=\"公平锁／非公平锁 两者区别\"></a>公平锁／非公平锁 两者区别</h3><p>并发包中ReentrantLock的创建可以指定构造函数的boolean类型来得到公平锁或非公平锁，默认是非公平锁。<br>Java ReentrantLock 而言，通过构造函数指定该锁是否是公平锁（默认是非公平锁）。非公平锁的优点在于吞吐量比公平锁大。<br>对于Synchronized而言，也是一种非公平锁。</p>\n<pre><code class=\"java\">/**\n * Creates an instance of {@code ReentrantLock}.\n * This is equivalent to using {@code ReentrantLock(false)}.\n */\npublic ReentrantLock() {\n    sync = new NonfairSync();\n}\n\n/**\n * Creates an instance of {@code ReentrantLock} with the\n * given fairness policy.\n *\n * @param fair {@code true} if this lock should use a fair ordering policy\n */\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}</code></pre>\n<p>公平锁：Threads acquire a fair lock in the order in which they requested it<br>公平锁，就是很公平，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己<br>非公平锁：Threads acquire a fair lock in the order in which they requested it<br>非公平锁比较粗鲁，上来就尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。</p>\n<h3 id=\"可重入锁（递归锁）\"><a href=\"#可重入锁（递归锁）\" class=\"headerlink\" title=\"可重入锁（递归锁）\"></a>可重入锁（递归锁）</h3><p>指的是统一线程外层函数获得锁之后，内层递归函数仍然能获取该所的代码。<br>统一线程在外层方法获取锁之后，进入内层方法后会自动获取锁。也就是说，线程可以进入任何一个它已经拥有的锁所同步着的代码块。</p>\n<ul>\n<li>ReentrantLock/Synchronized就是一个典型的可重入锁</li>\n<li>可重入锁的最大作用就是避免死锁</li>\n<li>ReenterLockDemo<pre><code class=\"java\">class Phone implements  Runnable{\n  public synchronized void  sedSMS(){\n      System.out.println(Thread.currentThread().getName()+&quot;\\t invoked sendSMS&quot;);\n      sedMail();\n  }\n  public synchronized void  sedMail(){\n      System.out.println(Thread.currentThread().getName()+&quot;\\t invoked sedMail&quot;);\n  }\n  @Override\n  public void run() {\n      get();\n  }\n  public void get(){\n      Lock lock = new ReentrantLock();\n      lock.lock();\n      try{\n          System.out.println(Thread.currentThread().getName()+&quot;\\t invoked get&quot;);\n          set();\n      }finally {\n          lock.unlock();\n      }\n  }\n  public void set(){\n      Lock lock = new ReentrantLock();\n      lock.lock();\n      try{\n          System.out.println(Thread.currentThread().getName()+&quot;\\t invoked set&quot;);\n      }finally {\n          lock.unlock();\n      }\n  }\n}\npublic class ReenterLockDemo {\n  public static void main(String[] args) throws InterruptedException {\n      Phone phone = new Phone();\n      new Thread(()-&gt;{phone.sedSMS();},&quot;t1&quot;).start();\n      new Thread(()-&gt;{phone.sedSMS();},&quot;t2&quot;).start();\n      TimeUnit.SECONDS.sleep(2);\n      System.out.println(&quot;=======================&quot;);\n      System.out.println();\n      System.out.println();\n      System.out.println();\n      new Thread(phone,&quot;t3&quot;).start();\n      new Thread(phone,&quot;t4&quot;).start();\n  }\n}</code></pre>\n<h3 id=\"独占锁\"><a href=\"#独占锁\" class=\"headerlink\" title=\"独占锁\"></a>独占锁</h3>指该锁一次只能被一个线程持有。对ReentrantLock和Synchronized而言都是独占锁</li>\n</ul>\n<h3 id=\"共享锁\"><a href=\"#共享锁\" class=\"headerlink\" title=\"共享锁\"></a>共享锁</h3><p>指该锁可被多个线程所持有<br>对ReentrantReadWriteLock其读锁是共享锁，其写锁是独占锁<br>读锁对共享锁可保证并发读是非常高效的，读写，写读，写写的过程是互斥的。</p>\n<pre><code class=\"java\">public class ReadWriteLockDemo {\n    volatile Map map= new HashMap&lt;String,Object&gt;();\n    ReadWriteLock rwLock=new ReentrantReadWriteLock();\n    public void get(String key) throws InterruptedException {\n        rwLock.readLock().lock();\n        try{\n            System.out.println(Thread.currentThread().getName()+&quot;\\t 正在读&quot;);\n            TimeUnit.MILLISECONDS.sleep(300);\n            Object res=map.get(key);\n            System.out.println(Thread.currentThread().getName()+&quot;\\t 读完成：&quot;+res);\n        }catch (Exception e){\n            e.printStackTrace();\n        }finally{\n            rwLock.readLock().unlock();\n        }\n    }\n    public void put(String key,Object value) throws InterruptedException {\n        rwLock.writeLock().lock();\n        try{\n            System.out.println(Thread.currentThread().getName()+&quot;\\t 正在写：&quot;+key);\n            TimeUnit.MILLISECONDS.sleep(300);\n            map.put(key,value);\n            System.out.println(Thread.currentThread().getName() + &quot;\\t 写完成&quot;);\n        }catch (Exception e){\n            e.printStackTrace();\n        }finally{\n            rwLock.writeLock().unlock();\n        }\n    }\n    public static void main(String[] args) {\n        ReadWriteLockDemo readWriteLockDemo = new ReadWriteLockDemo();\n        for (int i=0;i&lt;10;i++){\n            final int tmp=i;\n            new Thread(()-&gt;{\n                try {\n                    readWriteLockDemo.put(tmp+&quot;&quot;,tmp);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            },String.valueOf(i)).start();\n        }\n        for (int i=0;i&lt;5;i++){\n            final int tmp=i;\n            new Thread(()-&gt;{\n                try {\n                    readWriteLockDemo.get(tmp+&quot;&quot;);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            },String.valueOf(i)).start();\n        }\n    }\n}</code></pre>\n<h3 id=\"自旋锁（spinlock）\"><a href=\"#自旋锁（spinlock）\" class=\"headerlink\" title=\"自旋锁（spinlock）\"></a>自旋锁（spinlock）</h3><p>是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式尝试去获取锁，这样的好出是减少线程上下文切换的消耗，缺点是循环会消耗CPU</p>\n<pre><code class=\"java\">//unsafe.getAndAddInt\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n    int var5;\n    do {\n        var5 = this.getIntVolatile(var1, var2);\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n    return var5;\n}</code></pre>\n<ul>\n<li>Demo<pre><code class=\"java\">public class SpinLockDemo {\n  AtomicReference&lt;Thread&gt; atomicReference=new AtomicReference&lt;&gt;();\n  public void myLock(){\n      Thread thread=Thread.currentThread();\n      System.out.println(thread.getName()+&quot;\\t come in &quot;);\n      while (!atomicReference.compareAndSet(null,thread)){}\n  }\n  public void myUnLock(){\n      atomicReference.compareAndSet(Thread.currentThread(),null);\n      System.out.println(Thread.currentThread().getName()+&quot;\\t out &quot;);\n  }\n  public static void main(String[] args) throws InterruptedException {\n      SpinLockDemo spinLockDemo = new SpinLockDemo();\n      new Thread(()-&gt;{\n          spinLockDemo.myLock();\n          try {\n              TimeUnit.SECONDS.sleep(5);\n          } catch (InterruptedException e) {\n              e.printStackTrace();\n          }\n          spinLockDemo.myUnLock();\n      },&quot;t1&quot;).start();\n      TimeUnit.SECONDS.sleep(1);\n      new Thread(()-&gt;{\n          spinLockDemo.myLock();\n          spinLockDemo.myUnLock();\n      },&quot;t2&quot;).start();\n  }\n}</code></pre>\n<h3 id=\"Synchornized\"><a href=\"#Synchornized\" class=\"headerlink\" title=\"Synchornized\"></a>Synchornized</h3>实现同步方法的基础是Java中的每个对象都可以作为锁<br>Synchronized （对象锁），static synchronized （类锁|全局锁），这两种锁互补影响，互相没有关系，可以同时访问</li>\n</ul>\n<h4 id=\"具体表现\"><a href=\"#具体表现\" class=\"headerlink\" title=\"具体表现\"></a>具体表现</h4><ul>\n<li>对于普通同步方法，锁的是当前实例对象，锁的是this</li>\n<li>对于同步方法块，锁的是synchroniezd括号里面的配置对象</li>\n<li>对于静态同步方法，锁的是当前类的Class对象</li>\n</ul>\n<h4 id=\"Synchronized与Lock有什么区别\"><a href=\"#Synchronized与Lock有什么区别\" class=\"headerlink\" title=\"Synchronized与Lock有什么区别\"></a>Synchronized与Lock有什么区别</h4><h5 id=\"原始构成\"><a href=\"#原始构成\" class=\"headerlink\" title=\"原始构成\"></a>原始构成</h5><ul>\n<li>Synchronized是关键字属于JVM层面，底层是通过monitor对象来完成，其wait／notify等方法也依赖与monitor对象，只有在同步块或方法中才能调用wait／notify等方法<br>monitorenter   进入，monitorexit    退出（有两层退出，正常情况和非正常情况都能退出，不会造成死锁）</li>\n<li>Lock 是API层面</li>\n</ul>\n<h5 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h5><ul>\n<li>Synchronized 不需要用户手动去释放锁，当synchronized代码执行完成后系统会自动让线程释放对锁的占用</li>\n<li>ReentrantLock则需要用户手动去释放锁，若没有主动释放锁，就有可能出现死锁现象<br>需要lock和unlock方法配合try finally 语句完成</li>\n</ul>\n<h5 id=\"等待是否可中断\"><a href=\"#等待是否可中断\" class=\"headerlink\" title=\"等待是否可中断\"></a>等待是否可中断</h5><ul>\n<li>Synchronized不可中断，除非抛出异常或者正常执行完成</li>\n<li>ReentrantLock可中断<ul>\n<li>设置超时方法 tryLock（long timeout，TimeUtil unit）</li>\n<li>lockInterruptibly（）放代码块中，调用interrupt（）可中断</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"加锁是否公平\"><a href=\"#加锁是否公平\" class=\"headerlink\" title=\"加锁是否公平\"></a>加锁是否公平</h5><ul>\n<li>Synchronized 非公平锁</li>\n<li>ReentrantLock 两者都可以，默认非公平锁，构造方法可传入boolean值，true为公平锁，false为非公平锁    </li>\n</ul>\n<h5 id=\"锁绑定多个条件Condition\"><a href=\"#锁绑定多个条件Condition\" class=\"headerlink\" title=\"锁绑定多个条件Condition\"></a>锁绑定多个条件Condition</h5><ul>\n<li>Synchronized 没有</li>\n<li>ReentrantLock用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不像synchronized要么随机唤醒一个线程要么唤醒全部线程</li>\n</ul>\n<pre><code class=\"java\">class Data {\n    Lock lock = new ReentrantLock();\n    Condition c1 = lock.newCondition();\n    Condition c2 = lock.newCondition();\n    Condition c3 = lock.newCondition();\n    int number = 1;\n\n    public void print5() {\n        lock.lock();\n        try {\n            while (number != 1) {\n                c1.await();\n            }\n            for (int i = 0; i &lt; 5; i++) {\n                System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + i);\n            }\n            number = 2;\n            c2.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void print10() {\n        lock.lock();\n        try {\n            while (number != 2) {\n                c2.await();\n            }\n            for (int i = 0; i &lt; 10; i++) {\n                System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + i);\n            }\n            number = 3;\n            c3.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void print15() {\n        lock.lock();\n        try {\n            while (number != 3) {\n                c3.await();\n            }\n            for (int i = 0; i &lt; 15; i++) {\n                System.out.println(Thread.currentThread().getName() + &quot;\\t&quot; + i);\n            }\n            number = 1;\n            c1.signal();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic class Conditions {\n    public static void main(String[] args) {\n        Data data = new Data();\n        new Thread(() -&gt; {\n            for (int i = 0; i &lt; 10; i++) {\n                data.print5();\n            }\n        }, &quot;A&quot;).start();\n        new Thread(() -&gt; {\n            for (int i = 0; i &lt; 10; i++) {\n                data.print10();\n            }\n        }, &quot;B&quot;).start();\n        new Thread(() -&gt; {\n            for (int i = 0; i &lt; 10; i++) {\n                data.print15();\n            }\n        }, &quot;C&quot;).start();\n    }\n}</code></pre>\n<h3 id=\"死锁编码及定位分析\"><a href=\"#死锁编码及定位分析\" class=\"headerlink\" title=\"死锁编码及定位分析\"></a>死锁编码及定位分析</h3><p>死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉那么它们都将无法推进下去，如果系统资源充足，线程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</p>\n<h4 id=\"系统资源不足\"><a href=\"#系统资源不足\" class=\"headerlink\" title=\"系统资源不足\"></a>系统资源不足</h4><h4 id=\"线程进行推进的顺序不合适\"><a href=\"#线程进行推进的顺序不合适\" class=\"headerlink\" title=\"线程进行推进的顺序不合适\"></a>线程进行推进的顺序不合适</h4><h4 id=\"资源分配不当\"><a href=\"#资源分配不当\" class=\"headerlink\" title=\"资源分配不当\"></a>资源分配不当</h4><pre><code class=\"java\">class HoldLockThread implements Runnable {\n    String lockA;\n    String lockB;\n\n    public HoldLockThread(String lockA, String lockB) {\n        this.lockA = lockA;\n        this.lockB = lockB;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lockA) {\n            System.out.println(Thread.currentThread().getName() + &quot;\\t 持有锁：&quot; + lockA + &quot;\\t 试图获取锁：&quot; + lockB);\n            try {\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            synchronized (lockB) {\n                System.out.println(Thread.currentThread().getName() + &quot;\\t 持有锁：&quot; + lockB + &quot;\\t 试图获取锁：&quot; + lockA);\n            }\n        }\n    }\n}\n\npublic class DeadLockDemo {\n    public static void main(String[] args) {\n        String lockA = &quot;lockA&quot;;\n        String lockB = &quot;lockB&quot;;\n        new Thread(new HoldLockThread(lockA, lockB), &quot;t1&quot;).start();\n        new Thread(new HoldLockThread(lockB, lockA), &quot;t2&quot;).start();\n    }\n}</code></pre>\n<h4 id=\"解决\"><a href=\"#解决\" class=\"headerlink\" title=\"解决\"></a>解决</h4><ul>\n<li>jps命令定位进程号</li>\n<li>jstack找到死锁查看</li>\n</ul>\n<h3 id=\"什么是分布式锁\"><a href=\"#什么是分布式锁\" class=\"headerlink\" title=\"什么是分布式锁\"></a>什么是分布式锁</h3><p>当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。分布式锁可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存，如 Redis，通过set (key,value,nx,px,timeout)方法添加分布式锁。</p>\n<h3 id=\"什么是分布式事务\"><a href=\"#什么是分布式事务\" class=\"headerlink\" title=\"什么是分布式事务\"></a>什么是分布式事务</h3><p>分布式事务指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。简单的说，就是一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。</p>\n<h2 id=\"集合（Collection）\"><a href=\"#集合（Collection）\" class=\"headerlink\" title=\"集合（Collection）\"></a>集合（Collection）</h2><h3 id=\"List集合\"><a href=\"#List集合\" class=\"headerlink\" title=\"List集合\"></a>List集合</h3><p>ArrayList扩容为原来一半</p>\n<h3 id=\"Set集合\"><a href=\"#Set集合\" class=\"headerlink\" title=\"Set集合\"></a>Set集合</h3><h4 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h4><pre><code class=\"java\">public HashSet() {\n    map = new HashMap&lt;&gt;();\n}\n\nHashSet底层是HashMap，put的值是key，value是一个Object类型的静态常量\nprivate static final Object PRESENT = new Object();\n\npublic boolean add(E e) {\n    return map.put(e, PRESENT) == null;\n}</code></pre>\n<h3 id=\"Map集合\"><a href=\"#Map集合\" class=\"headerlink\" title=\"Map集合\"></a>Map集合</h3><h4 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h4><p>初始长度16 负载因子 3/4 扩容为2倍原长度，调用构造函数只是进行了默认长度和负载因子的设置并没有初始化数组，开辟存储空间。 1.7数组加单向链表，每个元素是entry，1.8 链表最大长度8 超过会转成红黑树，每个元素是Node。key可以为null，将key为null放在下标为0的位置</p>\n<h5 id=\"put-key1-value1\"><a href=\"#put-key1-value1\" class=\"headerlink\" title=\"put(key1,value1)\"></a>put(key1,value1)</h5><p>七上八下（1.7 新加元素会在链表上面添加，1.8会在下面添加）</p>\n<ul>\n<li>首先调用key1的hashCode方法，然后再经过特定计算，计算出hash值，hash值&amp;（length-1）计算出存放位置（Entry数组下标）</li>\n<li>如果此位置上的数据为空，此时添加成功          —情况1   </li>\n<li>如果此位置上的数据不为空（意味着，此位置上存在一个或多个数据（以链表方式存在）），比较key1和已经存在的一个或多个数据的哈希值<ul>\n<li>如果key1的哈希值与已经存在的数据哈希值都不同，此时添加成功    —-情况2</li>\n<li>如果key1的哈希值和已经存在的某一个数据（key2，value2）key2的哈希值相同，继续比较。调用key1所在类的equals（key2）<ul>\n<li>如果equals的返回值为false：此时添加成功       —情况3</li>\n<li>如果equals的返回值为true：使用value1替换掉value2</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>补充：关于情况2和情况3:此时key1-value1的数据以链表的方式存储。</p>\n<h5 id=\"扩容\"><a href=\"#扩容\" class=\"headerlink\" title=\"扩容\"></a>扩容</h5><p>在不断的添加过程中会涉及到扩容问题，默认的扩容方式：扩容为原来的2倍，并将原来的数据迁移过来。（不是rehash，而是链表上的数据通过用新数组长度进行计算得到的下标，会有两种情况，一种是和之前下标一样，一种是在原来下标基础上加上原来数组长度的下标。例如：原来下标为2，原来数组长度为8，新数组长度为16，链表上的数据有可能下标是2，有可能下标是2+8=10。）</p>\n<ul>\n<li>1.7：size &gt;= threshold) &amp;&amp; (null != table[bucketIndex]</li>\n<li>1.8：++size &gt; threshold或tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY<h4 id=\"为什么HashMap的长度是2的n次幂\"><a href=\"#为什么HashMap的长度是2的n次幂\" class=\"headerlink\" title=\"为什么HashMap的长度是2的n次幂\"></a>为什么HashMap的长度是2的n次幂</h4>当长度2的n次幂时，2的n次幂 - 1=1111（2进制），任何值与此值按位（&amp;）计算，这样才会快速拿到数组下标，并且数据分布相对均匀。<h4 id=\"1-8-链表改为红黑树条件\"><a href=\"#1-8-链表改为红黑树条件\" class=\"headerlink\" title=\"1.8 链表改为红黑树条件\"></a>1.8 链表改为红黑树条件</h4>当数组的某一个索引位置上的元素以链表的形式存在的，数据个数&gt;8且当前数组长度&gt;64时，此时次位置伤的所有数据改为使用红黑树存储。<h4 id=\"1-8-链表变成红黑树的阀值为8\"><a href=\"#1-8-链表变成红黑树的阀值为8\" class=\"headerlink\" title=\"1.8 链表变成红黑树的阀值为8\"></a>1.8 链表变成红黑树的阀值为8</h4>因为哈希桶中节点个数服从参数为0.5的泊松分布，超过8的概率很小<h4 id=\"HashMap和HashTable区别\"><a href=\"#HashMap和HashTable区别\" class=\"headerlink\" title=\"HashMap和HashTable区别\"></a>HashMap和HashTable区别</h4><h5 id=\"线程安全性不同\"><a href=\"#线程安全性不同\" class=\"headerlink\" title=\"线程安全性不同\"></a>线程安全性不同</h5>HashMap是线程不安全的，HashTable是线程安全的，其中的方法是Synchronize的，在多线程并发的情况下，可以直接使用HashTable，但是使用HashMap时必须自己增加同步处理。<h5 id=\"是否提供contains方法\"><a href=\"#是否提供contains方法\" class=\"headerlink\" title=\"是否提供contains方法\"></a>是否提供contains方法</h5>HashMap只有containsValue和containsKey方法；HashTable有contains、containsKey和containsValue三个方法，其中contains和containsValue方法功能相同。<h5 id=\"key和value是否允许null值\"><a href=\"#key和value是否允许null值\" class=\"headerlink\" title=\"key和value是否允许null值\"></a>key和value是否允许null值</h5>HashTable中，key和value都不允许出现null值。HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。<h5 id=\"数组初始化和扩容机制\"><a href=\"#数组初始化和扩容机制\" class=\"headerlink\" title=\"数组初始化和扩容机制\"></a>数组初始化和扩容机制</h5></li>\n<li>HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。</li>\n<li>HashTable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。<h4 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h4></li>\n<li>Segment：一个小型的HashMap，大小由并发级别确定</li>\n<li>线程安全，使用分段锁来控制同步访问问题</li>\n</ul>\n<h4 id=\"TreeSet和HashSet区别\"><a href=\"#TreeSet和HashSet区别\" class=\"headerlink\" title=\"TreeSet和HashSet区别\"></a>TreeSet和HashSet区别</h4><p>HashSet是采用hash表来实现的。其中的元素没有按顺序排列，add()、remove()以及contains()等方法都是复杂度为O(1)的方法。<br>TreeSet是采用树结构实现(红黑树算法)。元素是按顺序进行排列，但是add()、remove()以及contains()等方法都是复杂度为O(log (n))的方法。它还提供了一些方法来处理排序的set，如first(), last(), headSet(), tailSet()等等。</p>\n<h2 id=\"字符串（String）\"><a href=\"#字符串（String）\" class=\"headerlink\" title=\"字符串（String）\"></a>字符串（String）</h2><h3 id=\"String-buffer和String-build区别\"><a href=\"#String-buffer和String-build区别\" class=\"headerlink\" title=\"String buffer和String build区别\"></a>String buffer和String build区别</h3><ul>\n<li>StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，</li>\n<li>只是StringBuffer 中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。 </li>\n<li>在单线程程序下，StringBuilder效率更快，因为它不需要加锁，不具备多线程安全而StringBuffer则每次都需要判断锁，效率相对更低</li>\n</ul>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h3><h4 id=\"强引用（默认支持模式）\"><a href=\"#强引用（默认支持模式）\" class=\"headerlink\" title=\"强引用（默认支持模式）\"></a>强引用（默认支持模式）</h4><p>当内存不足，JVM开始垃圾回收，对于强引用当对象，就算是出现了OOM也不会对该对象进行回收，死都不回收。<br>强引用是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。在java中最常见的就是强引用，把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到JVM也不会回收。因此强引用是造成java内存泄漏的主要原因之一。<br>对于一个普通对象，如果没有其他的引用关系，只要超过了引用作用域或者显式的将相应（强）引用赋值为null，一般认为就是可以被垃圾收集的了（当然具体回收时机还要看垃圾收集策略）。</p>\n<h4 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h4><p>软引用是一种相对强引用弱化了一些的引用，需要用java.lang.ref.SoftReference类来实现，可以让对象豁免一些垃圾收集。<br>对于只有弱引用的对象来说，<br>当系统内存充足时不会被回收<br>当系统内存不足时会被回收<br>软引用通常用在对内存敏感的程序中，比如高速缓存就有用到软引用，内存够用就保留，不够用就回收。</p>\n<h4 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h4><p>弱引用需要用java.lang.ref.WeakReference类来实现，它比软引用的生存周期更短，<br>对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管JVM的内存空间是否足够，都会回收该对象占用的内存。<br>软引用、弱引用应用场景：<br>假如有一个应用需要读取大量的本地图片：<br>如果每次读取图片都要从硬盘读取图片则会严重影响性能<br>如果一次性全部加载到内存中又能造成内存溢出<br>设计思路：<br>用一个HashMap来保存图片的路径和相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免来OOM的问题。<br><code>Map&lt;String,SoftReference&lt;Bitmap&gt;&gt; imageCache =new HashMap&lt;String,SoftReference&lt;Bitmap&gt;&gt;();</code></p>\n<h4 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h4><h3 id=\"Final、Finally、Finalize\"><a href=\"#Final、Finally、Finalize\" class=\"headerlink\" title=\"Final、Finally、Finalize\"></a>Final、Finally、Finalize</h3><h4 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h4><p>修饰符（关键字）有三种用法：修饰类、变量和方法。修饰类时，意味着它不能再派生出新的子类，即不能被继承，因此它和abstract是反义词。修饰变量时，该变量使用中不被改变，必须在声明时给定初值，在引用中只能读取不可修改，即为常量。修饰方法时，也同样只能使用，不能在子类中被重写。</p>\n<h4 id=\"Finally\"><a href=\"#Finally\" class=\"headerlink\" title=\"Finally\"></a>Finally</h4><p>通常放在try…catch的后面构造最终执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要JVM不关闭都能执行，可以将释放外部资源的代码写在finally块中。</p>\n<h4 id=\"Finalize\"><a href=\"#Finalize\" class=\"headerlink\" title=\"Finalize\"></a>Finalize</h4><p>Object类中定义的方法，Java中允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写finalize() 方法可以整理系统资源或者执行其他清理工作。</p>\n<h3 id=\"和Equals区别\"><a href=\"#和Equals区别\" class=\"headerlink\" title=\"==和Equals区别\"></a>==和Equals区别</h3><h4 id><a href=\"#\" class=\"headerlink\" title=\"==\"></a>==</h4><p>如果比较的是基本数据类型，那么比较的是变量的值<br>如果比较的是引用数据类型，那么比较的是地址值（两个对象是否指向同一块内存）</p>\n<h4 id=\"Equals\"><a href=\"#Equals\" class=\"headerlink\" title=\"Equals\"></a>Equals</h4><p>如果没重写equals方法比较的是两个对象的地址值。<br>如果重写了equals方法后我们往往比较的是对象中的属性的内容<br>equals方法是从Object类中继承的，默认的实现就是使用==</p>\n<h3 id=\"B-tree和B-tree的区别\"><a href=\"#B-tree和B-tree的区别\" class=\"headerlink\" title=\"B-tree和B+tree的区别\"></a>B-tree和B+tree的区别</h3><ul>\n<li>B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。</li>\n<li>在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。</li>\n</ul>\n<h2 id=\"1-8-新特性\"><a href=\"#1-8-新特性\" class=\"headerlink\" title=\"1.8 新特性\"></a>1.8 新特性</h2><h3 id=\"四大函数接口\"><a href=\"#四大函数接口\" class=\"headerlink\" title=\"四大函数接口\"></a>四大函数接口</h3><ul>\n<li><p>Consumer<t><br>重写accept，参数T，无返回</t></p>\n</li>\n<li><p>Supplier<t><br>重写get，无参数，返回T</t></p>\n</li>\n<li><p>Function&lt;T,R&gt;<br>重写apply，参数T，返回R</p>\n</li>\n<li><p>Predicate<t><br>重写test，参数T，返回boolean类型值</t></p>\n</li>\n</ul>\n<h3 id=\"Stream\"><a href=\"#Stream\" class=\"headerlink\" title=\"Stream\"></a>Stream</h3><h3 id=\"分支合并框架\"><a href=\"#分支合并框架\" class=\"headerlink\" title=\"分支合并框架\"></a>分支合并框架</h3><ul>\n<li>ForkJoinPool</li>\n<li>ForJoinTask</li>\n<li>RecursiveTask</li>\n</ul>\n<h3 id=\"异步调用\"><a href=\"#异步调用\" class=\"headerlink\" title=\"异步调用\"></a>异步调用</h3><ul>\n<li>CompletableFuture</li>\n</ul>\n<h3 id=\"lambada表达式\"><a href=\"#lambada表达式\" class=\"headerlink\" title=\"lambada表达式\"></a>lambada表达式</h3><ul>\n<li>()-&gt;{}</li>\n<li>lambada表达式只可以使用在函数式接口上</li>\n<li>java 8以前函数interface接口只能有方法定义，不能有实现。java 8以后可以由方法实现（default 关键字 修饰，可以由多个方法实现），有且仅有一个方法定义</li>\n</ul>\n"}],"Post":[{"title":"Hello World","date":"2018-09-12T14:25:00.000Z","author":"blinkfox","_content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2018-09-12 22:25:00\nauthor: blinkfox\ncategories: 前端\ntags:\n  - Hexo\n---\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2020-03-19T04:51:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8o1ha9u000113s6ok4mepz0","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre class=\" language-bash\"><code class=\"language-bash\">$ hexo new <span class=\"token string\">\"My New Post\"</span></code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre class=\" language-bash\"><code class=\"language-bash\">$ hexo server</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre class=\" language-bash\"><code class=\"language-bash\">$ hexo generate</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre class=\" language-bash\"><code class=\"language-bash\">$ hexo deploy</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"Kafka安全认证","date":"2020-04-05T03:21:00.000Z","_content":"\n\n## 生成服务端keystore（密钥和证书）\n\nkeytool -keystore server.kestore.jks -alias server -validity 365 -storepass blw -kepass blw -genkey -dname \\* CH=CA,OU=eBay,O=eBay,L=SH,ST=SH,C=CN\\*\n\n## 生成客户端keystore（密钥和证书）\n\nkeytool -keystore client.kestore.jks -alias client -validity 365 -storepass blw -kepass blw -gankey -dname \\* CH=CA,OU=eBay,O=eBay,L=SH,ST=SH,C=CN\\*\n\n## 将CA证书导入服务端truststore\n\nkeytool -v -keystore server.truststore.jks -alias CARoot -import -file cat.crt -storepass blw\n\n\n## 将CA证书导入客户端truststore\n\nkeytool -v -keystore client.truststore.jks -alias CARoot -import -file cat.crt -storepass blw\n\n\n## 导出服务端证书\n\nkeytool -keystore server.keystore.jks -alias server -certreq -file server.crt -storepass blw\n\n## 用CA证书给服务端证书签名\n\nopenssl x509 -req -CA ca.crt -CAkey ca.key -in server.crt -out server-signed.crt -days 365 -CAcreateserial -passin pass:blw\n\n## 将CA证书导入服务器keystore\n\nkeytool -keystore server.keystore.jks -alias CARoot -import -file ca.crt -storepass blw\n\n## 将已签名服务端证书导入服务端keystore\n\nkeytool -keystore server.keystore.jks -alias server -import -file server.signed.crt -storepass blw\n\n## 验证broker SSL是否已经生效\n\nopenssl s_client -debug -connect localhost:9093 -tls1","source":"_posts/SSL.md","raw":"---\ntitle: Kafka安全认证\ndate: 2020-04-05 11:21:00\ncategories: Kafka\ntags: Kafka\n---\n\n\n## 生成服务端keystore（密钥和证书）\n\nkeytool -keystore server.kestore.jks -alias server -validity 365 -storepass blw -kepass blw -genkey -dname \\* CH=CA,OU=eBay,O=eBay,L=SH,ST=SH,C=CN\\*\n\n## 生成客户端keystore（密钥和证书）\n\nkeytool -keystore client.kestore.jks -alias client -validity 365 -storepass blw -kepass blw -gankey -dname \\* CH=CA,OU=eBay,O=eBay,L=SH,ST=SH,C=CN\\*\n\n## 将CA证书导入服务端truststore\n\nkeytool -v -keystore server.truststore.jks -alias CARoot -import -file cat.crt -storepass blw\n\n\n## 将CA证书导入客户端truststore\n\nkeytool -v -keystore client.truststore.jks -alias CARoot -import -file cat.crt -storepass blw\n\n\n## 导出服务端证书\n\nkeytool -keystore server.keystore.jks -alias server -certreq -file server.crt -storepass blw\n\n## 用CA证书给服务端证书签名\n\nopenssl x509 -req -CA ca.crt -CAkey ca.key -in server.crt -out server-signed.crt -days 365 -CAcreateserial -passin pass:blw\n\n## 将CA证书导入服务器keystore\n\nkeytool -keystore server.keystore.jks -alias CARoot -import -file ca.crt -storepass blw\n\n## 将已签名服务端证书导入服务端keystore\n\nkeytool -keystore server.keystore.jks -alias server -import -file server.signed.crt -storepass blw\n\n## 验证broker SSL是否已经生效\n\nopenssl s_client -debug -connect localhost:9093 -tls1","slug":"SSL","published":1,"updated":"2020-04-05T03:22:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8o1ha9z000313s6h2x50w1q","content":"<h2 id=\"生成服务端keystore（密钥和证书）\"><a href=\"#生成服务端keystore（密钥和证书）\" class=\"headerlink\" title=\"生成服务端keystore（密钥和证书）\"></a>生成服务端keystore（密钥和证书）</h2><p>keytool -keystore server.kestore.jks -alias server -validity 365 -storepass blw -kepass blw -genkey -dname * CH=CA,OU=eBay,O=eBay,L=SH,ST=SH,C=CN*</p>\n<h2 id=\"生成客户端keystore（密钥和证书）\"><a href=\"#生成客户端keystore（密钥和证书）\" class=\"headerlink\" title=\"生成客户端keystore（密钥和证书）\"></a>生成客户端keystore（密钥和证书）</h2><p>keytool -keystore client.kestore.jks -alias client -validity 365 -storepass blw -kepass blw -gankey -dname * CH=CA,OU=eBay,O=eBay,L=SH,ST=SH,C=CN*</p>\n<h2 id=\"将CA证书导入服务端truststore\"><a href=\"#将CA证书导入服务端truststore\" class=\"headerlink\" title=\"将CA证书导入服务端truststore\"></a>将CA证书导入服务端truststore</h2><p>keytool -v -keystore server.truststore.jks -alias CARoot -import -file cat.crt -storepass blw</p>\n<h2 id=\"将CA证书导入客户端truststore\"><a href=\"#将CA证书导入客户端truststore\" class=\"headerlink\" title=\"将CA证书导入客户端truststore\"></a>将CA证书导入客户端truststore</h2><p>keytool -v -keystore client.truststore.jks -alias CARoot -import -file cat.crt -storepass blw</p>\n<h2 id=\"导出服务端证书\"><a href=\"#导出服务端证书\" class=\"headerlink\" title=\"导出服务端证书\"></a>导出服务端证书</h2><p>keytool -keystore server.keystore.jks -alias server -certreq -file server.crt -storepass blw</p>\n<h2 id=\"用CA证书给服务端证书签名\"><a href=\"#用CA证书给服务端证书签名\" class=\"headerlink\" title=\"用CA证书给服务端证书签名\"></a>用CA证书给服务端证书签名</h2><p>openssl x509 -req -CA ca.crt -CAkey ca.key -in server.crt -out server-signed.crt -days 365 -CAcreateserial -passin pass:blw</p>\n<h2 id=\"将CA证书导入服务器keystore\"><a href=\"#将CA证书导入服务器keystore\" class=\"headerlink\" title=\"将CA证书导入服务器keystore\"></a>将CA证书导入服务器keystore</h2><p>keytool -keystore server.keystore.jks -alias CARoot -import -file ca.crt -storepass blw</p>\n<h2 id=\"将已签名服务端证书导入服务端keystore\"><a href=\"#将已签名服务端证书导入服务端keystore\" class=\"headerlink\" title=\"将已签名服务端证书导入服务端keystore\"></a>将已签名服务端证书导入服务端keystore</h2><p>keytool -keystore server.keystore.jks -alias server -import -file server.signed.crt -storepass blw</p>\n<h2 id=\"验证broker-SSL是否已经生效\"><a href=\"#验证broker-SSL是否已经生效\" class=\"headerlink\" title=\"验证broker SSL是否已经生效\"></a>验证broker SSL是否已经生效</h2><p>openssl s_client -debug -connect localhost:9093 -tls1</p>\n","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<h2 id=\"生成服务端keystore（密钥和证书）\"><a href=\"#生成服务端keystore（密钥和证书）\" class=\"headerlink\" title=\"生成服务端keystore（密钥和证书）\"></a>生成服务端keystore（密钥和证书）</h2><p>keytool -keystore server.kestore.jks -alias server -validity 365 -storepass blw -kepass blw -genkey -dname * CH=CA,OU=eBay,O=eBay,L=SH,ST=SH,C=CN*</p>\n<h2 id=\"生成客户端keystore（密钥和证书）\"><a href=\"#生成客户端keystore（密钥和证书）\" class=\"headerlink\" title=\"生成客户端keystore（密钥和证书）\"></a>生成客户端keystore（密钥和证书）</h2><p>keytool -keystore client.kestore.jks -alias client -validity 365 -storepass blw -kepass blw -gankey -dname * CH=CA,OU=eBay,O=eBay,L=SH,ST=SH,C=CN*</p>\n<h2 id=\"将CA证书导入服务端truststore\"><a href=\"#将CA证书导入服务端truststore\" class=\"headerlink\" title=\"将CA证书导入服务端truststore\"></a>将CA证书导入服务端truststore</h2><p>keytool -v -keystore server.truststore.jks -alias CARoot -import -file cat.crt -storepass blw</p>\n<h2 id=\"将CA证书导入客户端truststore\"><a href=\"#将CA证书导入客户端truststore\" class=\"headerlink\" title=\"将CA证书导入客户端truststore\"></a>将CA证书导入客户端truststore</h2><p>keytool -v -keystore client.truststore.jks -alias CARoot -import -file cat.crt -storepass blw</p>\n<h2 id=\"导出服务端证书\"><a href=\"#导出服务端证书\" class=\"headerlink\" title=\"导出服务端证书\"></a>导出服务端证书</h2><p>keytool -keystore server.keystore.jks -alias server -certreq -file server.crt -storepass blw</p>\n<h2 id=\"用CA证书给服务端证书签名\"><a href=\"#用CA证书给服务端证书签名\" class=\"headerlink\" title=\"用CA证书给服务端证书签名\"></a>用CA证书给服务端证书签名</h2><p>openssl x509 -req -CA ca.crt -CAkey ca.key -in server.crt -out server-signed.crt -days 365 -CAcreateserial -passin pass:blw</p>\n<h2 id=\"将CA证书导入服务器keystore\"><a href=\"#将CA证书导入服务器keystore\" class=\"headerlink\" title=\"将CA证书导入服务器keystore\"></a>将CA证书导入服务器keystore</h2><p>keytool -keystore server.keystore.jks -alias CARoot -import -file ca.crt -storepass blw</p>\n<h2 id=\"将已签名服务端证书导入服务端keystore\"><a href=\"#将已签名服务端证书导入服务端keystore\" class=\"headerlink\" title=\"将已签名服务端证书导入服务端keystore\"></a>将已签名服务端证书导入服务端keystore</h2><p>keytool -keystore server.keystore.jks -alias server -import -file server.signed.crt -storepass blw</p>\n<h2 id=\"验证broker-SSL是否已经生效\"><a href=\"#验证broker-SSL是否已经生效\" class=\"headerlink\" title=\"验证broker SSL是否已经生效\"></a>验证broker SSL是否已经生效</h2><p>openssl s_client -debug -connect localhost:9093 -tls1</p>\n"},{"title":"自建CA证书认证","date":"2020-04-05T03:21:00.000Z","_content":"\n\n# 自建CA证书认证\n\nCA证书认证通常包含三部分，CA认证服务器、业务服务器、客户端，也可以简单分成两部分CA/业务服务器，和客户端\n\n## CA服务器\n\n### 生成私钥(pem)\nopenssl genrsa -out cakey.pem -des 2048\n\n>gen:生成\t rsa:加密算法\tout:输出\tdes:秘钥加密口令(可加可不加)\t2048:秘钥生成长度(2048 bits)，默认1024\n\n### 生成根证书签发请求(csr)\nopenssl req -new -key cakey.pem -out cakey.csr\n\n### 生成自签发根CA证书\n创建CA的方式有多种，可以分别使用req、x509、ca 等伪命令来创建和签发CA证书\n\n- req\nopenssl req -new -x509 -key cakey.pem -days 365 -out cacert.pem\n\n- x509\nopenssl x509 -req -in cakey.csr -signkey key.pem -out cacert.pem\n\n- ca\nopenssl ca -selfsign -keyfile cakey.pem -in cakey.csr -batch -out cacert.pem\n\n\n>这是采用 etc/pki/tls/openssl.cnf 默认文件的配置方式生成CA证书，是比较规范推荐的生成方式，\n>采用默认配置 -key 、-signkey、-keyfile等属性可以不用添加，系统会到默认文件夹下自己加载\n>使用默认配置文件方式必须提前按照规定创建好index.txt和serial文件，其他文件和文件夹的命名也必须一致，看[相关重要文件夹](#相关重要文件夹)\n\n### 获取serial\n获取客户端/服务端证书的serial\nopenssl x509 -in client.crt/server.crt -noout -subject\n\n### 吊销证书\n对比获取到的serial序列号是否与index数据库中的信息一致，一致吊销证书\nopenssl ca -revoke serial.pem\nserial为new_certs_dir文件夹下要吊销的证书编号与在客户端或者服务端查出的serial一致\n\n### 刷新吊销列表\n第一次要生成吊销证书序号`echo 00 > /etc/pki/CA/crlnumber`\nopenssl ca -gencrl -out crl.crl\n\n\n\n## 业务服务端\n\n### 生成私钥(pem)\nopenssl genrsa -out server.pem -des 2048\n\n### 生成证书签发请求(csr)\nopenssl req -new -key server.pem -out server.csr\n\n### 由根CA颁发证书\nopenssl ca -in server.csr -out server.crt -days 100\n\n## 客户端\n\n### 生成私钥(pem)\nopenssl genrsa -out client.pem -des 2048\n\n### 生成证书签发请求(csr)\nopenssl req -new -key client.pem -out client.csr\n\n### 由根CA颁发证书\nopenssl ca -in client.csr -out client.crt -days 100\n\n\n\n\n## 相关重要文件夹\n\ndir     \t\t\t\t \t   =   \t\t   /etc/pki/CA\t\t\t\t\t\t\t\ncerts  \t\t\t\t   \t= \t\t      \\$dir/certs\t\t\t\t\t\t\t  //证书归档文件夹\ndatabase\t\t\t     =\t\t\t  \\$dir/index.txt\t\t\t\t\t    //证书数据库\nnew_certs_dir\t\t =\t\t  \t\\$dir/newcerts\t\t\t\t\t   //新颁发证书文件夹\ncertificates\t\t\t  = \t\t \t\\$dir/cacet.pem\t\t\t\t\t //Root CA\nserial\t\t\t\t\t\t=\t\t      \\$dir/serial\t\t\t\t\t\t \t//下一个颁发证书的序列号，由16进制数字构成最低2位\nprivate_key\t          =   \t\t  \\$dir/private/cakey.pem\t  //私钥\n\n\n## 其他命令\n\n- 生成用户密码口令\nopenssl passwd -1 -salt\n-1 为使用的加密算法(hash)，-salt是加盐(最长8bits)，可以随机或者自己在后面指定\n\n- 加密\nopenssl enc -e -des3 -a -salt -in encode.txt -out encode.enc\n\tenc：加密/解密\t-e：加密\t-des3：加密算法\t-salt：加盐\t-in：输入文件\t-out：输出文件\n\n- 解密\nopenssl enc -d -des3 -a -salt -in encode.enc -out encode.encd\n-d：解密\n\n\n\n> 从私钥中获取公钥\n> openssl rsa -in cakey.pem -pubout -out cakey.pubkey\n> 显示证书信息\n> openssl x509 -in server.csr -noout -text \n> 查看crl文件\n> openssl crl -in crl.crl -noout -text\n>\n> tls：传输层安全协议 Transport Layer Security的缩写\n> ssl：安全套接字层 Secure Socket Layer的缩写\n> csr：是Certificate Signing Request的缩写，即证书签名请求，这不是证书\n> crt：即 certificate的缩写，即证书。linux/unix常用的证书后缀，一般为ascii文件\n>\n> cer：是crt的替代形式，windows常用证书的后缀，一般为二进制文件。证书中没有私钥\n>\n> pem：Privacy Enhanced Mail,打开看文本格式,以\"-----BEGIN...\"开头, \"-----END...\"结尾,内容是BASE64编码.","source":"_posts/自建CA证书认证.md","raw":"---\ntitle: 自建CA证书认证\ndate: 2020-04-05 11:21:00\ncategories: Linux,Web\ntags: Linux,Web\n---\n\n\n# 自建CA证书认证\n\nCA证书认证通常包含三部分，CA认证服务器、业务服务器、客户端，也可以简单分成两部分CA/业务服务器，和客户端\n\n## CA服务器\n\n### 生成私钥(pem)\nopenssl genrsa -out cakey.pem -des 2048\n\n>gen:生成\t rsa:加密算法\tout:输出\tdes:秘钥加密口令(可加可不加)\t2048:秘钥生成长度(2048 bits)，默认1024\n\n### 生成根证书签发请求(csr)\nopenssl req -new -key cakey.pem -out cakey.csr\n\n### 生成自签发根CA证书\n创建CA的方式有多种，可以分别使用req、x509、ca 等伪命令来创建和签发CA证书\n\n- req\nopenssl req -new -x509 -key cakey.pem -days 365 -out cacert.pem\n\n- x509\nopenssl x509 -req -in cakey.csr -signkey key.pem -out cacert.pem\n\n- ca\nopenssl ca -selfsign -keyfile cakey.pem -in cakey.csr -batch -out cacert.pem\n\n\n>这是采用 etc/pki/tls/openssl.cnf 默认文件的配置方式生成CA证书，是比较规范推荐的生成方式，\n>采用默认配置 -key 、-signkey、-keyfile等属性可以不用添加，系统会到默认文件夹下自己加载\n>使用默认配置文件方式必须提前按照规定创建好index.txt和serial文件，其他文件和文件夹的命名也必须一致，看[相关重要文件夹](#相关重要文件夹)\n\n### 获取serial\n获取客户端/服务端证书的serial\nopenssl x509 -in client.crt/server.crt -noout -subject\n\n### 吊销证书\n对比获取到的serial序列号是否与index数据库中的信息一致，一致吊销证书\nopenssl ca -revoke serial.pem\nserial为new_certs_dir文件夹下要吊销的证书编号与在客户端或者服务端查出的serial一致\n\n### 刷新吊销列表\n第一次要生成吊销证书序号`echo 00 > /etc/pki/CA/crlnumber`\nopenssl ca -gencrl -out crl.crl\n\n\n\n## 业务服务端\n\n### 生成私钥(pem)\nopenssl genrsa -out server.pem -des 2048\n\n### 生成证书签发请求(csr)\nopenssl req -new -key server.pem -out server.csr\n\n### 由根CA颁发证书\nopenssl ca -in server.csr -out server.crt -days 100\n\n## 客户端\n\n### 生成私钥(pem)\nopenssl genrsa -out client.pem -des 2048\n\n### 生成证书签发请求(csr)\nopenssl req -new -key client.pem -out client.csr\n\n### 由根CA颁发证书\nopenssl ca -in client.csr -out client.crt -days 100\n\n\n\n\n## 相关重要文件夹\n\ndir     \t\t\t\t \t   =   \t\t   /etc/pki/CA\t\t\t\t\t\t\t\ncerts  \t\t\t\t   \t= \t\t      \\$dir/certs\t\t\t\t\t\t\t  //证书归档文件夹\ndatabase\t\t\t     =\t\t\t  \\$dir/index.txt\t\t\t\t\t    //证书数据库\nnew_certs_dir\t\t =\t\t  \t\\$dir/newcerts\t\t\t\t\t   //新颁发证书文件夹\ncertificates\t\t\t  = \t\t \t\\$dir/cacet.pem\t\t\t\t\t //Root CA\nserial\t\t\t\t\t\t=\t\t      \\$dir/serial\t\t\t\t\t\t \t//下一个颁发证书的序列号，由16进制数字构成最低2位\nprivate_key\t          =   \t\t  \\$dir/private/cakey.pem\t  //私钥\n\n\n## 其他命令\n\n- 生成用户密码口令\nopenssl passwd -1 -salt\n-1 为使用的加密算法(hash)，-salt是加盐(最长8bits)，可以随机或者自己在后面指定\n\n- 加密\nopenssl enc -e -des3 -a -salt -in encode.txt -out encode.enc\n\tenc：加密/解密\t-e：加密\t-des3：加密算法\t-salt：加盐\t-in：输入文件\t-out：输出文件\n\n- 解密\nopenssl enc -d -des3 -a -salt -in encode.enc -out encode.encd\n-d：解密\n\n\n\n> 从私钥中获取公钥\n> openssl rsa -in cakey.pem -pubout -out cakey.pubkey\n> 显示证书信息\n> openssl x509 -in server.csr -noout -text \n> 查看crl文件\n> openssl crl -in crl.crl -noout -text\n>\n> tls：传输层安全协议 Transport Layer Security的缩写\n> ssl：安全套接字层 Secure Socket Layer的缩写\n> csr：是Certificate Signing Request的缩写，即证书签名请求，这不是证书\n> crt：即 certificate的缩写，即证书。linux/unix常用的证书后缀，一般为ascii文件\n>\n> cer：是crt的替代形式，windows常用证书的后缀，一般为二进制文件。证书中没有私钥\n>\n> pem：Privacy Enhanced Mail,打开看文本格式,以\"-----BEGIN...\"开头, \"-----END...\"结尾,内容是BASE64编码.","slug":"自建CA证书认证","published":1,"updated":"2020-04-05T03:21:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8o1haa3000713s6i9t8z6x4","content":"<h1 id=\"自建CA证书认证\"><a href=\"#自建CA证书认证\" class=\"headerlink\" title=\"自建CA证书认证\"></a>自建CA证书认证</h1><p>CA证书认证通常包含三部分，CA认证服务器、业务服务器、客户端，也可以简单分成两部分CA/业务服务器，和客户端</p>\n<h2 id=\"CA服务器\"><a href=\"#CA服务器\" class=\"headerlink\" title=\"CA服务器\"></a>CA服务器</h2><h3 id=\"生成私钥-pem\"><a href=\"#生成私钥-pem\" class=\"headerlink\" title=\"生成私钥(pem)\"></a>生成私钥(pem)</h3><p>openssl genrsa -out cakey.pem -des 2048</p>\n<blockquote>\n<p>gen:生成     rsa:加密算法    out:输出    des:秘钥加密口令(可加可不加)    2048:秘钥生成长度(2048 bits)，默认1024</p>\n</blockquote>\n<h3 id=\"生成根证书签发请求-csr\"><a href=\"#生成根证书签发请求-csr\" class=\"headerlink\" title=\"生成根证书签发请求(csr)\"></a>生成根证书签发请求(csr)</h3><p>openssl req -new -key cakey.pem -out cakey.csr</p>\n<h3 id=\"生成自签发根CA证书\"><a href=\"#生成自签发根CA证书\" class=\"headerlink\" title=\"生成自签发根CA证书\"></a>生成自签发根CA证书</h3><p>创建CA的方式有多种，可以分别使用req、x509、ca 等伪命令来创建和签发CA证书</p>\n<ul>\n<li><p>req<br>openssl req -new -x509 -key cakey.pem -days 365 -out cacert.pem</p>\n</li>\n<li><p>x509<br>openssl x509 -req -in cakey.csr -signkey key.pem -out cacert.pem</p>\n</li>\n<li><p>ca<br>openssl ca -selfsign -keyfile cakey.pem -in cakey.csr -batch -out cacert.pem</p>\n</li>\n</ul>\n<blockquote>\n<p>这是采用 etc/pki/tls/openssl.cnf 默认文件的配置方式生成CA证书，是比较规范推荐的生成方式，<br>采用默认配置 -key 、-signkey、-keyfile等属性可以不用添加，系统会到默认文件夹下自己加载<br>使用默认配置文件方式必须提前按照规定创建好index.txt和serial文件，其他文件和文件夹的命名也必须一致，看<a href=\"#相关重要文件夹\">相关重要文件夹</a></p>\n</blockquote>\n<h3 id=\"获取serial\"><a href=\"#获取serial\" class=\"headerlink\" title=\"获取serial\"></a>获取serial</h3><p>获取客户端/服务端证书的serial<br>openssl x509 -in client.crt/server.crt -noout -subject</p>\n<h3 id=\"吊销证书\"><a href=\"#吊销证书\" class=\"headerlink\" title=\"吊销证书\"></a>吊销证书</h3><p>对比获取到的serial序列号是否与index数据库中的信息一致，一致吊销证书<br>openssl ca -revoke serial.pem<br>serial为new_certs_dir文件夹下要吊销的证书编号与在客户端或者服务端查出的serial一致</p>\n<h3 id=\"刷新吊销列表\"><a href=\"#刷新吊销列表\" class=\"headerlink\" title=\"刷新吊销列表\"></a>刷新吊销列表</h3><p>第一次要生成吊销证书序号<code>echo 00 &gt; /etc/pki/CA/crlnumber</code><br>openssl ca -gencrl -out crl.crl</p>\n<h2 id=\"业务服务端\"><a href=\"#业务服务端\" class=\"headerlink\" title=\"业务服务端\"></a>业务服务端</h2><h3 id=\"生成私钥-pem-1\"><a href=\"#生成私钥-pem-1\" class=\"headerlink\" title=\"生成私钥(pem)\"></a>生成私钥(pem)</h3><p>openssl genrsa -out server.pem -des 2048</p>\n<h3 id=\"生成证书签发请求-csr\"><a href=\"#生成证书签发请求-csr\" class=\"headerlink\" title=\"生成证书签发请求(csr)\"></a>生成证书签发请求(csr)</h3><p>openssl req -new -key server.pem -out server.csr</p>\n<h3 id=\"由根CA颁发证书\"><a href=\"#由根CA颁发证书\" class=\"headerlink\" title=\"由根CA颁发证书\"></a>由根CA颁发证书</h3><p>openssl ca -in server.csr -out server.crt -days 100</p>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><h3 id=\"生成私钥-pem-2\"><a href=\"#生成私钥-pem-2\" class=\"headerlink\" title=\"生成私钥(pem)\"></a>生成私钥(pem)</h3><p>openssl genrsa -out client.pem -des 2048</p>\n<h3 id=\"生成证书签发请求-csr-1\"><a href=\"#生成证书签发请求-csr-1\" class=\"headerlink\" title=\"生成证书签发请求(csr)\"></a>生成证书签发请求(csr)</h3><p>openssl req -new -key client.pem -out client.csr</p>\n<h3 id=\"由根CA颁发证书-1\"><a href=\"#由根CA颁发证书-1\" class=\"headerlink\" title=\"由根CA颁发证书\"></a>由根CA颁发证书</h3><p>openssl ca -in client.csr -out client.crt -days 100</p>\n<h2 id=\"相关重要文件夹\"><a href=\"#相关重要文件夹\" class=\"headerlink\" title=\"相关重要文件夹\"></a>相关重要文件夹</h2><p>dir                             =              /etc/pki/CA<br>certs                         =               $dir/certs                              //证书归档文件夹<br>database                 =              $dir/index.txt                        //证书数据库<br>new_certs_dir         =              $dir/newcerts                       //新颁发证书文件夹<br>certificates              =              $dir/cacet.pem                     //Root CA<br>serial                        =              $dir/serial                             //下一个颁发证书的序列号，由16进制数字构成最低2位<br>private_key              =             $dir/private/cakey.pem      //私钥</p>\n<h2 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h2><ul>\n<li><p>生成用户密码口令<br>openssl passwd -1 -salt</p>\n</li>\n<li><p>1 为使用的加密算法(hash)，-salt是加盐(最长8bits)，可以随机或者自己在后面指定</p>\n</li>\n<li><p>加密<br>openssl enc -e -des3 -a -salt -in encode.txt -out encode.enc<br>  enc：加密/解密    -e：加密    -des3：加密算法    -salt：加盐    -in：输入文件    -out：输出文件</p>\n</li>\n<li><p>解密<br>openssl enc -d -des3 -a -salt -in encode.enc -out encode.encd</p>\n</li>\n<li><p>d：解密</p>\n</li>\n</ul>\n<blockquote>\n<p>从私钥中获取公钥<br>openssl rsa -in cakey.pem -pubout -out cakey.pubkey<br>显示证书信息<br>openssl x509 -in server.csr -noout -text<br>查看crl文件<br>openssl crl -in crl.crl -noout -text</p>\n<p>tls：传输层安全协议 Transport Layer Security的缩写<br>ssl：安全套接字层 Secure Socket Layer的缩写<br>csr：是Certificate Signing Request的缩写，即证书签名请求，这不是证书<br>crt：即 certificate的缩写，即证书。linux/unix常用的证书后缀，一般为ascii文件</p>\n<p>cer：是crt的替代形式，windows常用证书的后缀，一般为二进制文件。证书中没有私钥</p>\n<p>pem：Privacy Enhanced Mail,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是BASE64编码.</p>\n</blockquote>\n","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<h1 id=\"自建CA证书认证\"><a href=\"#自建CA证书认证\" class=\"headerlink\" title=\"自建CA证书认证\"></a>自建CA证书认证</h1><p>CA证书认证通常包含三部分，CA认证服务器、业务服务器、客户端，也可以简单分成两部分CA/业务服务器，和客户端</p>\n<h2 id=\"CA服务器\"><a href=\"#CA服务器\" class=\"headerlink\" title=\"CA服务器\"></a>CA服务器</h2><h3 id=\"生成私钥-pem\"><a href=\"#生成私钥-pem\" class=\"headerlink\" title=\"生成私钥(pem)\"></a>生成私钥(pem)</h3><p>openssl genrsa -out cakey.pem -des 2048</p>\n<blockquote>\n<p>gen:生成     rsa:加密算法    out:输出    des:秘钥加密口令(可加可不加)    2048:秘钥生成长度(2048 bits)，默认1024</p>\n</blockquote>\n<h3 id=\"生成根证书签发请求-csr\"><a href=\"#生成根证书签发请求-csr\" class=\"headerlink\" title=\"生成根证书签发请求(csr)\"></a>生成根证书签发请求(csr)</h3><p>openssl req -new -key cakey.pem -out cakey.csr</p>\n<h3 id=\"生成自签发根CA证书\"><a href=\"#生成自签发根CA证书\" class=\"headerlink\" title=\"生成自签发根CA证书\"></a>生成自签发根CA证书</h3><p>创建CA的方式有多种，可以分别使用req、x509、ca 等伪命令来创建和签发CA证书</p>\n<ul>\n<li><p>req<br>openssl req -new -x509 -key cakey.pem -days 365 -out cacert.pem</p>\n</li>\n<li><p>x509<br>openssl x509 -req -in cakey.csr -signkey key.pem -out cacert.pem</p>\n</li>\n<li><p>ca<br>openssl ca -selfsign -keyfile cakey.pem -in cakey.csr -batch -out cacert.pem</p>\n</li>\n</ul>\n<blockquote>\n<p>这是采用 etc/pki/tls/openssl.cnf 默认文件的配置方式生成CA证书，是比较规范推荐的生成方式，<br>采用默认配置 -key 、-signkey、-keyfile等属性可以不用添加，系统会到默认文件夹下自己加载<br>使用默认配置文件方式必须提前按照规定创建好index.txt和serial文件，其他文件和文件夹的命名也必须一致，看<a href=\"#相关重要文件夹\">相关重要文件夹</a></p>\n</blockquote>\n<h3 id=\"获取serial\"><a href=\"#获取serial\" class=\"headerlink\" title=\"获取serial\"></a>获取serial</h3><p>获取客户端/服务端证书的serial<br>openssl x509 -in client.crt/server.crt -noout -subject</p>\n<h3 id=\"吊销证书\"><a href=\"#吊销证书\" class=\"headerlink\" title=\"吊销证书\"></a>吊销证书</h3><p>对比获取到的serial序列号是否与index数据库中的信息一致，一致吊销证书<br>openssl ca -revoke serial.pem<br>serial为new_certs_dir文件夹下要吊销的证书编号与在客户端或者服务端查出的serial一致</p>\n<h3 id=\"刷新吊销列表\"><a href=\"#刷新吊销列表\" class=\"headerlink\" title=\"刷新吊销列表\"></a>刷新吊销列表</h3><p>第一次要生成吊销证书序号<code>echo 00 &gt; /etc/pki/CA/crlnumber</code><br>openssl ca -gencrl -out crl.crl</p>\n<h2 id=\"业务服务端\"><a href=\"#业务服务端\" class=\"headerlink\" title=\"业务服务端\"></a>业务服务端</h2><h3 id=\"生成私钥-pem-1\"><a href=\"#生成私钥-pem-1\" class=\"headerlink\" title=\"生成私钥(pem)\"></a>生成私钥(pem)</h3><p>openssl genrsa -out server.pem -des 2048</p>\n<h3 id=\"生成证书签发请求-csr\"><a href=\"#生成证书签发请求-csr\" class=\"headerlink\" title=\"生成证书签发请求(csr)\"></a>生成证书签发请求(csr)</h3><p>openssl req -new -key server.pem -out server.csr</p>\n<h3 id=\"由根CA颁发证书\"><a href=\"#由根CA颁发证书\" class=\"headerlink\" title=\"由根CA颁发证书\"></a>由根CA颁发证书</h3><p>openssl ca -in server.csr -out server.crt -days 100</p>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><h3 id=\"生成私钥-pem-2\"><a href=\"#生成私钥-pem-2\" class=\"headerlink\" title=\"生成私钥(pem)\"></a>生成私钥(pem)</h3><p>openssl genrsa -out client.pem -des 2048</p>\n<h3 id=\"生成证书签发请求-csr-1\"><a href=\"#生成证书签发请求-csr-1\" class=\"headerlink\" title=\"生成证书签发请求(csr)\"></a>生成证书签发请求(csr)</h3><p>openssl req -new -key client.pem -out client.csr</p>\n<h3 id=\"由根CA颁发证书-1\"><a href=\"#由根CA颁发证书-1\" class=\"headerlink\" title=\"由根CA颁发证书\"></a>由根CA颁发证书</h3><p>openssl ca -in client.csr -out client.crt -days 100</p>\n<h2 id=\"相关重要文件夹\"><a href=\"#相关重要文件夹\" class=\"headerlink\" title=\"相关重要文件夹\"></a>相关重要文件夹</h2><p>dir                             =              /etc/pki/CA<br>certs                         =               $dir/certs                              //证书归档文件夹<br>database                 =              $dir/index.txt                        //证书数据库<br>new_certs_dir         =              $dir/newcerts                       //新颁发证书文件夹<br>certificates              =              $dir/cacet.pem                     //Root CA<br>serial                        =              $dir/serial                             //下一个颁发证书的序列号，由16进制数字构成最低2位<br>private_key              =             $dir/private/cakey.pem      //私钥</p>\n<h2 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h2><ul>\n<li><p>生成用户密码口令<br>openssl passwd -1 -salt</p>\n</li>\n<li><p>1 为使用的加密算法(hash)，-salt是加盐(最长8bits)，可以随机或者自己在后面指定</p>\n</li>\n<li><p>加密<br>openssl enc -e -des3 -a -salt -in encode.txt -out encode.enc<br>  enc：加密/解密    -e：加密    -des3：加密算法    -salt：加盐    -in：输入文件    -out：输出文件</p>\n</li>\n<li><p>解密<br>openssl enc -d -des3 -a -salt -in encode.enc -out encode.encd</p>\n</li>\n<li><p>d：解密</p>\n</li>\n</ul>\n<blockquote>\n<p>从私钥中获取公钥<br>openssl rsa -in cakey.pem -pubout -out cakey.pubkey<br>显示证书信息<br>openssl x509 -in server.csr -noout -text<br>查看crl文件<br>openssl crl -in crl.crl -noout -text</p>\n<p>tls：传输层安全协议 Transport Layer Security的缩写<br>ssl：安全套接字层 Secure Socket Layer的缩写<br>csr：是Certificate Signing Request的缩写，即证书签名请求，这不是证书<br>crt：即 certificate的缩写，即证书。linux/unix常用的证书后缀，一般为ascii文件</p>\n<p>cer：是crt的替代形式，windows常用证书的后缀，一般为二进制文件。证书中没有私钥</p>\n<p>pem：Privacy Enhanced Mail,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是BASE64编码.</p>\n</blockquote>\n"},{"title":"Go插件工具安装问题","date":"2020-04-06T01:41:52.000Z","_content":"\n\n\n# Go插件工具安装问题\n\n在Mac上在学习使用Go或者安装其他带有Go依赖的安装包时（比如git-lfs）可能会遇到Go插件工具安装问题![QQ20200406-095236@2x](Go插件工具安装问题.assets/QQ20200406-095236@2x-6150876.png)\n\n下面我们就来解决一下这个问题（网上也有相关使用代理的情况，这里不再说明）\n\n## 引发原因\n\nmac 下的包管理工具brew 可以方便的安装工具包或者相应的软件应用，当使用brew 安装git-lfs（git上传大文件的工具）时，因为依赖Go 语言工具，所以在安装时会报错。下面就brew install git-lfs 时的问题来给出解决方案。\n\n## 过程思路\n\n如果想直接解决可以直接跳转到[解决方案](#解决方案)\n\n在网上搜索时发现 https://github.com/golang/tools 是 https://go.googlesource.com/tools.git 的一个镜像。这样我们只要修改brew下载git-lfs的脚本，将 https://go.googlesource.com/tools.git 替换成 https://github.com/golang/tools 应该就可以解决我们的问题。\n\n\n\n登录 [Homebrew](https://brew.sh/) 的官网，找到Packages，![QQ20200406-101042@2x](Go插件工具安装问题.assets/QQ20200406-101042@2x-6150888.png)\n\n点击 [formulae.brew.sh](https://formulae.brew.sh/) ，选择 [Browse all macOS formulae](https://formulae.brew.sh/formula/)\n\n![QQ20200406-101332@2x](Go插件工具安装问题.assets/QQ20200406-101332@2x-6150899.png)\n\n在搜索框搜索git-lfs，在页面找到[Formula code](https://github.com/Homebrew/homebrew-core/blob/master/Formula/git-lfs.rb) ，查看git-lfs在GitHub上的脚本源码。\n\n```ruby\nclass GitLfs < Formula\n  desc \"Git extension for versioning large files\"\n  homepage \"https://github.com/git-lfs/git-lfs\"\n  url \"https://github.com/git-lfs/git-lfs/releases/download/v2.10.0/git-lfs-v2.10.0.tar.gz\"\n  sha256 \"07fd5c57a1039d5717dc192affbe3268ec2fd03accdca462cb504c0b4194cd23\"\n\n  bottle do\n    cellar :any_skip_relocation\n    sha256 \"8fec7d8b8ad7c3332bfa1862dd8615712dab8315a9128ed8b5609fa1659431e7\" => :catalina\n    sha256 \"3c5bcef656ca742c6697b952c9f7c483c1fad046f52136dbe9ee0f16f44835c4\" => :mojave\n    sha256 \"ed0d8f1271d9d81a2c22622023c260ef040f2172e75357893ef54134bc6eedff\" => :high_sierra\n  end\n\n  depends_on \"go\" => :build\n  depends_on \"ruby\" => :build\n\n  def install\n    ENV[\"GIT_LFS_SHA\"] = \"\"\n    ENV[\"VERSION\"] = version\n\n    (buildpath/\"src/github.com/git-lfs/git-lfs\").install buildpath.children\n    cd \"src/github.com/git-lfs/git-lfs\" do\n      ENV[\"GEM_HOME\"] = \".gem_home\"\n      system \"gem\", \"install\", \"ronn\"\n\n      system \"make\", \"vendor\"\n      system \"make\"\n      system \"make\", \"man\", \"RONN=.gem_home/bin/ronn\"\n\n      bin.install \"bin/git-lfs\"\n      man1.install Dir[\"man/*.1\"]\n      man5.install Dir[\"man/*.5\"]\n      doc.install Dir[\"man/*.html\"]\n    end\n  end\n\n  def caveats\n    <<~EOS\n      Update your git config to finish installation:\n        # Update global git config\n        $ git lfs install\n        # Update system git config\n        $ git lfs install --system\n    EOS\n  end\n\n  test do\n    system \"git\", \"init\"\n    system \"git\", \"lfs\", \"track\", \"test\"\n    assert_match(/^test filter=lfs/, File.read(\".gitattributes\"))\n  end\nend\n```\n\n当前代码中并没有相关 https://go.googlesource.com/tools.git 的信息，因为当前是Go的tools，所以再去查看Go的安装脚本（git-lfs的脚本中依赖Go和Ruby，所以只有可能是这两个里面有问题，因为tools是Go相关的的工具，所以首先我们可以查看Go的安装脚本）。这是Go语言brew的安装脚本 https://github.com/Homebrew/homebrew-core/blob/master/Formula/go.rb\n\n```ruby\nclass Go < Formula\n  desc \"Open source programming language to build simple/reliable/efficient software\"\n  homepage \"https://golang.org\"\n\n  stable do\n    url \"https://dl.google.com/go/go1.14.1.src.tar.gz\"\n    mirror \"https://fossies.org/linux/misc/go1.14.1.src.tar.gz\"\n    sha256 \"2ad2572115b0d1b4cb4c138e6b3a31cee6294cb48af75ee86bec3dca04507676\"\n\n    go_version = version.to_s.split(\".\")[0..1].join(\".\")\n    resource \"gotools\" do\n      url \"https://go.googlesource.com/tools.git\",\n          :branch => \"release-branch.go#{go_version}\"\n    end\n  end\n\n  bottle do\n    sha256 \"36fdd54a9307ba19cc69425586e2d63188f2f2b7f541ab9fd2ef3447e376329f\" => :catalina\n    sha256 \"bab387fda3e4683943bd7b9b9208141502d6a2cc42c4b21137effaec9f208e1c\" => :mojave\n    sha256 \"ffb583abeb5263269281532f45a70a074ae0affe6edecb13442024b70bf13b04\" => :high_sierra\n  end\n\n  head do\n    url \"https://go.googlesource.com/go.git\"\n\n    resource \"gotools\" do\n      url \"https://go.googlesource.com/tools.git\"\n    end\n  end\n\n  depends_on :macos => :el_capitan\n\n  # Don't update this unless this version cannot bootstrap the new version.\n  resource \"gobootstrap\" do\n    url \"https://storage.googleapis.com/golang/go1.7.darwin-amd64.tar.gz\"\n    sha256 \"51d905e0b43b3d0ed41aaf23e19001ab4bc3f96c3ca134b48f7892485fc52961\"\n  end\n\n  def install\n    (buildpath/\"gobootstrap\").install resource(\"gobootstrap\")\n    ENV[\"GOROOT_BOOTSTRAP\"] = buildpath/\"gobootstrap\"\n\n    cd \"src\" do\n      ENV[\"GOROOT_FINAL\"] = libexec\n      ENV[\"GOOS\"]         = \"darwin\"\n      system \"./make.bash\", \"--no-clean\"\n    end\n\n    (buildpath/\"pkg/obj\").rmtree\n    rm_rf \"gobootstrap\" # Bootstrap not required beyond compile.\n    libexec.install Dir[\"*\"]\n    bin.install_symlink Dir[libexec/\"bin/go*\"]\n\n    system bin/\"go\", \"install\", \"-race\", \"std\"\n\n    # Build and install godoc\n    ENV.prepend_path \"PATH\", bin\n    ENV[\"GOPATH\"] = buildpath\n    (buildpath/\"src/golang.org/x/tools\").install resource(\"gotools\")\n    cd \"src/golang.org/x/tools/cmd/godoc/\" do\n      system \"go\", \"build\"\n      (libexec/\"bin\").install \"godoc\"\n    end\n    bin.install_symlink libexec/\"bin/godoc\"\n  end\n\n  test do\n    (testpath/\"hello.go\").write <<~EOS\n      package main\n      import \"fmt\"\n      func main() {\n          fmt.Println(\"Hello World\")\n      }\n    EOS\n    # Run go fmt check for no errors then run the program.\n    # This is a a bare minimum of go working as it uses fmt, build, and run.\n    system bin/\"go\", \"fmt\", \"hello.go\"\n    assert_equal \"Hello World\\n\", shell_output(\"#{bin}/go run hello.go\")\n\n    # godoc was installed\n    assert_predicate libexec/\"bin/godoc\", :exist?\n    assert_predicate libexec/\"bin/godoc\", :executable?\n\n    ENV[\"GOOS\"] = \"freebsd\"\n    ENV[\"GOARCH\"] = \"amd64\"\n    system bin/\"go\", \"build\", \"hello.go\"\n  end\nend\n```\n\n安装脚本里面有请求 https://go.googlesource.com/tools.git 地址的信息，我们可以将这块的替换掉应该就可以。\n\n## 解决方案\n\nbrew在本地管理安装包的文件夹为\n\n```shell\n/usr/local/Cellar/\n```\n\nbrew在本地管理安装脚本的文件夹为\n\n```shell\n/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula\n```\n\n这里我们只需要修改`/usr/local/Homebrew/Library/Taps`下Go的安装脚本，将 https://go.googlesource.com/tools.git 替换成 https://github.com/golang/tools 即可。\n\n```ruby\nclass Go < Formula\n  desc \"Open source programming language to build simple/reliable/efficient software\"\n  homepage \"https://golang.org\"\n\n  stable do\n    url \"https://dl.google.com/go/go1.14.1.src.tar.gz\"\n    mirror \"https://fossies.org/linux/misc/go1.14.1.src.tar.gz\"\n    sha256 \"2ad2572115b0d1b4cb4c138e6b3a31cee6294cb48af75ee86bec3dca04507676\"\n\n    go_version = version.to_s.split(\".\")[0..1].join(\".\")\n    resource \"gotools\" do\n    #url \"https://go.googlesource.com/tools.git\",\n    url \"https://github.com/golang/tools.git\",\n          :branch => \"release-branch.go#{go_version}\"\n    end\n  end\n\n  bottle do\n    sha256 \"36fdd54a9307ba19cc69425586e2d63188f2f2b7f541ab9fd2ef3447e376329f\" => :catalina\n    sha256 \"bab387fda3e4683943bd7b9b9208141502d6a2cc42c4b21137effaec9f208e1c\" => :mojave\n    sha256 \"ffb583abeb5263269281532f45a70a074ae0affe6edecb13442024b70bf13b04\" => :high_sierra\n  end\n\n  head do\n      #url \"https://go.googlesource.com/go.git\"\n      url \"https://github.com/golang/tools.git\"\n\n    resource \"gotools\" do\n        #url \"https://go.googlesource.com/tools.git\"\n      url \"https://github.com/golang/tools.git\"\n    end\n  end\n\n  depends_on :macos => :el_capitan\n\n  # Don't update this unless this version cannot bootstrap the new version.\n  resource \"gobootstrap\" do\n    url \"https://storage.googleapis.com/golang/go1.7.darwin-amd64.tar.gz\"\n    sha256 \"51d905e0b43b3d0ed41aaf23e19001ab4bc3f96c3ca134b48f7892485fc52961\"\n  end\n\n  def install\n    (buildpath/\"gobootstrap\").install resource(\"gobootstrap\")\n    ENV[\"GOROOT_BOOTSTRAP\"] = buildpath/\"gobootstrap\"\n\n    cd \"src\" do\n      ENV[\"GOROOT_FINAL\"] = libexec\n      ENV[\"GOOS\"]         = \"darwin\"\n      system \"./make.bash\", \"--no-clean\"\n    end\n\n    (buildpath/\"pkg/obj\").rmtree\n    rm_rf \"gobootstrap\" # Bootstrap not required beyond compile.\n    libexec.install Dir[\"*\"]\n    bin.install_symlink Dir[libexec/\"bin/go*\"]\n\n    system bin/\"go\", \"install\", \"-race\", \"std\"\n\n    # Build and install godoc\n    ENV.prepend_path \"PATH\", bin\n    ENV[\"GOPATH\"] = buildpath\n    (buildpath/\"src/golang.org/x/tools\").install resource(\"gotools\")\n    cd \"src/golang.org/x/tools/cmd/godoc/\" do\n      system \"go\", \"build\"\n      (libexec/\"bin\").install \"godoc\"\n    end\n    bin.install_symlink libexec/\"bin/godoc\"\n  end\n\n  test do\n    (testpath/\"hello.go\").write <<~EOS\n      package main\n\n      import \"fmt\"\n\n      func main() {\n          fmt.Println(\"Hello World\")\n      }\n    EOS\n    # Run go fmt check for no errors then run the program.\n    # This is a a bare minimum of go working as it uses fmt, build, and run.\n    system bin/\"go\", \"fmt\", \"hello.go\"\n    assert_equal \"Hello World\\n\", shell_output(\"#{bin}/go run hello.go\")\n\n    # godoc was installed\n    assert_predicate libexec/\"bin/godoc\", :exist?\n    assert_predicate libexec/\"bin/godoc\", :executable?\n\n    ENV[\"GOOS\"] = \"freebsd\"\n    ENV[\"GOARCH\"] = \"amd64\"\n    system bin/\"go\", \"build\", \"hello.go\"\n  end\nend\n\n```\n\n","source":"_posts/Go插件工具安装问题.md","raw":"---\ntitle: Go插件工具安装问题\ndate: 2020-04-06 09:41:52\ntags: Go\n---\n\n\n\n# Go插件工具安装问题\n\n在Mac上在学习使用Go或者安装其他带有Go依赖的安装包时（比如git-lfs）可能会遇到Go插件工具安装问题![QQ20200406-095236@2x](Go插件工具安装问题.assets/QQ20200406-095236@2x-6150876.png)\n\n下面我们就来解决一下这个问题（网上也有相关使用代理的情况，这里不再说明）\n\n## 引发原因\n\nmac 下的包管理工具brew 可以方便的安装工具包或者相应的软件应用，当使用brew 安装git-lfs（git上传大文件的工具）时，因为依赖Go 语言工具，所以在安装时会报错。下面就brew install git-lfs 时的问题来给出解决方案。\n\n## 过程思路\n\n如果想直接解决可以直接跳转到[解决方案](#解决方案)\n\n在网上搜索时发现 https://github.com/golang/tools 是 https://go.googlesource.com/tools.git 的一个镜像。这样我们只要修改brew下载git-lfs的脚本，将 https://go.googlesource.com/tools.git 替换成 https://github.com/golang/tools 应该就可以解决我们的问题。\n\n\n\n登录 [Homebrew](https://brew.sh/) 的官网，找到Packages，![QQ20200406-101042@2x](Go插件工具安装问题.assets/QQ20200406-101042@2x-6150888.png)\n\n点击 [formulae.brew.sh](https://formulae.brew.sh/) ，选择 [Browse all macOS formulae](https://formulae.brew.sh/formula/)\n\n![QQ20200406-101332@2x](Go插件工具安装问题.assets/QQ20200406-101332@2x-6150899.png)\n\n在搜索框搜索git-lfs，在页面找到[Formula code](https://github.com/Homebrew/homebrew-core/blob/master/Formula/git-lfs.rb) ，查看git-lfs在GitHub上的脚本源码。\n\n```ruby\nclass GitLfs < Formula\n  desc \"Git extension for versioning large files\"\n  homepage \"https://github.com/git-lfs/git-lfs\"\n  url \"https://github.com/git-lfs/git-lfs/releases/download/v2.10.0/git-lfs-v2.10.0.tar.gz\"\n  sha256 \"07fd5c57a1039d5717dc192affbe3268ec2fd03accdca462cb504c0b4194cd23\"\n\n  bottle do\n    cellar :any_skip_relocation\n    sha256 \"8fec7d8b8ad7c3332bfa1862dd8615712dab8315a9128ed8b5609fa1659431e7\" => :catalina\n    sha256 \"3c5bcef656ca742c6697b952c9f7c483c1fad046f52136dbe9ee0f16f44835c4\" => :mojave\n    sha256 \"ed0d8f1271d9d81a2c22622023c260ef040f2172e75357893ef54134bc6eedff\" => :high_sierra\n  end\n\n  depends_on \"go\" => :build\n  depends_on \"ruby\" => :build\n\n  def install\n    ENV[\"GIT_LFS_SHA\"] = \"\"\n    ENV[\"VERSION\"] = version\n\n    (buildpath/\"src/github.com/git-lfs/git-lfs\").install buildpath.children\n    cd \"src/github.com/git-lfs/git-lfs\" do\n      ENV[\"GEM_HOME\"] = \".gem_home\"\n      system \"gem\", \"install\", \"ronn\"\n\n      system \"make\", \"vendor\"\n      system \"make\"\n      system \"make\", \"man\", \"RONN=.gem_home/bin/ronn\"\n\n      bin.install \"bin/git-lfs\"\n      man1.install Dir[\"man/*.1\"]\n      man5.install Dir[\"man/*.5\"]\n      doc.install Dir[\"man/*.html\"]\n    end\n  end\n\n  def caveats\n    <<~EOS\n      Update your git config to finish installation:\n        # Update global git config\n        $ git lfs install\n        # Update system git config\n        $ git lfs install --system\n    EOS\n  end\n\n  test do\n    system \"git\", \"init\"\n    system \"git\", \"lfs\", \"track\", \"test\"\n    assert_match(/^test filter=lfs/, File.read(\".gitattributes\"))\n  end\nend\n```\n\n当前代码中并没有相关 https://go.googlesource.com/tools.git 的信息，因为当前是Go的tools，所以再去查看Go的安装脚本（git-lfs的脚本中依赖Go和Ruby，所以只有可能是这两个里面有问题，因为tools是Go相关的的工具，所以首先我们可以查看Go的安装脚本）。这是Go语言brew的安装脚本 https://github.com/Homebrew/homebrew-core/blob/master/Formula/go.rb\n\n```ruby\nclass Go < Formula\n  desc \"Open source programming language to build simple/reliable/efficient software\"\n  homepage \"https://golang.org\"\n\n  stable do\n    url \"https://dl.google.com/go/go1.14.1.src.tar.gz\"\n    mirror \"https://fossies.org/linux/misc/go1.14.1.src.tar.gz\"\n    sha256 \"2ad2572115b0d1b4cb4c138e6b3a31cee6294cb48af75ee86bec3dca04507676\"\n\n    go_version = version.to_s.split(\".\")[0..1].join(\".\")\n    resource \"gotools\" do\n      url \"https://go.googlesource.com/tools.git\",\n          :branch => \"release-branch.go#{go_version}\"\n    end\n  end\n\n  bottle do\n    sha256 \"36fdd54a9307ba19cc69425586e2d63188f2f2b7f541ab9fd2ef3447e376329f\" => :catalina\n    sha256 \"bab387fda3e4683943bd7b9b9208141502d6a2cc42c4b21137effaec9f208e1c\" => :mojave\n    sha256 \"ffb583abeb5263269281532f45a70a074ae0affe6edecb13442024b70bf13b04\" => :high_sierra\n  end\n\n  head do\n    url \"https://go.googlesource.com/go.git\"\n\n    resource \"gotools\" do\n      url \"https://go.googlesource.com/tools.git\"\n    end\n  end\n\n  depends_on :macos => :el_capitan\n\n  # Don't update this unless this version cannot bootstrap the new version.\n  resource \"gobootstrap\" do\n    url \"https://storage.googleapis.com/golang/go1.7.darwin-amd64.tar.gz\"\n    sha256 \"51d905e0b43b3d0ed41aaf23e19001ab4bc3f96c3ca134b48f7892485fc52961\"\n  end\n\n  def install\n    (buildpath/\"gobootstrap\").install resource(\"gobootstrap\")\n    ENV[\"GOROOT_BOOTSTRAP\"] = buildpath/\"gobootstrap\"\n\n    cd \"src\" do\n      ENV[\"GOROOT_FINAL\"] = libexec\n      ENV[\"GOOS\"]         = \"darwin\"\n      system \"./make.bash\", \"--no-clean\"\n    end\n\n    (buildpath/\"pkg/obj\").rmtree\n    rm_rf \"gobootstrap\" # Bootstrap not required beyond compile.\n    libexec.install Dir[\"*\"]\n    bin.install_symlink Dir[libexec/\"bin/go*\"]\n\n    system bin/\"go\", \"install\", \"-race\", \"std\"\n\n    # Build and install godoc\n    ENV.prepend_path \"PATH\", bin\n    ENV[\"GOPATH\"] = buildpath\n    (buildpath/\"src/golang.org/x/tools\").install resource(\"gotools\")\n    cd \"src/golang.org/x/tools/cmd/godoc/\" do\n      system \"go\", \"build\"\n      (libexec/\"bin\").install \"godoc\"\n    end\n    bin.install_symlink libexec/\"bin/godoc\"\n  end\n\n  test do\n    (testpath/\"hello.go\").write <<~EOS\n      package main\n      import \"fmt\"\n      func main() {\n          fmt.Println(\"Hello World\")\n      }\n    EOS\n    # Run go fmt check for no errors then run the program.\n    # This is a a bare minimum of go working as it uses fmt, build, and run.\n    system bin/\"go\", \"fmt\", \"hello.go\"\n    assert_equal \"Hello World\\n\", shell_output(\"#{bin}/go run hello.go\")\n\n    # godoc was installed\n    assert_predicate libexec/\"bin/godoc\", :exist?\n    assert_predicate libexec/\"bin/godoc\", :executable?\n\n    ENV[\"GOOS\"] = \"freebsd\"\n    ENV[\"GOARCH\"] = \"amd64\"\n    system bin/\"go\", \"build\", \"hello.go\"\n  end\nend\n```\n\n安装脚本里面有请求 https://go.googlesource.com/tools.git 地址的信息，我们可以将这块的替换掉应该就可以。\n\n## 解决方案\n\nbrew在本地管理安装包的文件夹为\n\n```shell\n/usr/local/Cellar/\n```\n\nbrew在本地管理安装脚本的文件夹为\n\n```shell\n/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula\n```\n\n这里我们只需要修改`/usr/local/Homebrew/Library/Taps`下Go的安装脚本，将 https://go.googlesource.com/tools.git 替换成 https://github.com/golang/tools 即可。\n\n```ruby\nclass Go < Formula\n  desc \"Open source programming language to build simple/reliable/efficient software\"\n  homepage \"https://golang.org\"\n\n  stable do\n    url \"https://dl.google.com/go/go1.14.1.src.tar.gz\"\n    mirror \"https://fossies.org/linux/misc/go1.14.1.src.tar.gz\"\n    sha256 \"2ad2572115b0d1b4cb4c138e6b3a31cee6294cb48af75ee86bec3dca04507676\"\n\n    go_version = version.to_s.split(\".\")[0..1].join(\".\")\n    resource \"gotools\" do\n    #url \"https://go.googlesource.com/tools.git\",\n    url \"https://github.com/golang/tools.git\",\n          :branch => \"release-branch.go#{go_version}\"\n    end\n  end\n\n  bottle do\n    sha256 \"36fdd54a9307ba19cc69425586e2d63188f2f2b7f541ab9fd2ef3447e376329f\" => :catalina\n    sha256 \"bab387fda3e4683943bd7b9b9208141502d6a2cc42c4b21137effaec9f208e1c\" => :mojave\n    sha256 \"ffb583abeb5263269281532f45a70a074ae0affe6edecb13442024b70bf13b04\" => :high_sierra\n  end\n\n  head do\n      #url \"https://go.googlesource.com/go.git\"\n      url \"https://github.com/golang/tools.git\"\n\n    resource \"gotools\" do\n        #url \"https://go.googlesource.com/tools.git\"\n      url \"https://github.com/golang/tools.git\"\n    end\n  end\n\n  depends_on :macos => :el_capitan\n\n  # Don't update this unless this version cannot bootstrap the new version.\n  resource \"gobootstrap\" do\n    url \"https://storage.googleapis.com/golang/go1.7.darwin-amd64.tar.gz\"\n    sha256 \"51d905e0b43b3d0ed41aaf23e19001ab4bc3f96c3ca134b48f7892485fc52961\"\n  end\n\n  def install\n    (buildpath/\"gobootstrap\").install resource(\"gobootstrap\")\n    ENV[\"GOROOT_BOOTSTRAP\"] = buildpath/\"gobootstrap\"\n\n    cd \"src\" do\n      ENV[\"GOROOT_FINAL\"] = libexec\n      ENV[\"GOOS\"]         = \"darwin\"\n      system \"./make.bash\", \"--no-clean\"\n    end\n\n    (buildpath/\"pkg/obj\").rmtree\n    rm_rf \"gobootstrap\" # Bootstrap not required beyond compile.\n    libexec.install Dir[\"*\"]\n    bin.install_symlink Dir[libexec/\"bin/go*\"]\n\n    system bin/\"go\", \"install\", \"-race\", \"std\"\n\n    # Build and install godoc\n    ENV.prepend_path \"PATH\", bin\n    ENV[\"GOPATH\"] = buildpath\n    (buildpath/\"src/golang.org/x/tools\").install resource(\"gotools\")\n    cd \"src/golang.org/x/tools/cmd/godoc/\" do\n      system \"go\", \"build\"\n      (libexec/\"bin\").install \"godoc\"\n    end\n    bin.install_symlink libexec/\"bin/godoc\"\n  end\n\n  test do\n    (testpath/\"hello.go\").write <<~EOS\n      package main\n\n      import \"fmt\"\n\n      func main() {\n          fmt.Println(\"Hello World\")\n      }\n    EOS\n    # Run go fmt check for no errors then run the program.\n    # This is a a bare minimum of go working as it uses fmt, build, and run.\n    system bin/\"go\", \"fmt\", \"hello.go\"\n    assert_equal \"Hello World\\n\", shell_output(\"#{bin}/go run hello.go\")\n\n    # godoc was installed\n    assert_predicate libexec/\"bin/godoc\", :exist?\n    assert_predicate libexec/\"bin/godoc\", :executable?\n\n    ENV[\"GOOS\"] = \"freebsd\"\n    ENV[\"GOARCH\"] = \"amd64\"\n    system bin/\"go\", \"build\", \"hello.go\"\n  end\nend\n\n```\n\n","slug":"Go插件工具安装问题","published":1,"updated":"2020-04-06T05:35:30.000Z","_id":"ck8o1haay000t13s6ne70704r","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Go插件工具安装问题\"><a href=\"#Go插件工具安装问题\" class=\"headerlink\" title=\"Go插件工具安装问题\"></a>Go插件工具安装问题</h1><p>在Mac上在学习使用Go或者安装其他带有Go依赖的安装包时（比如git-lfs）可能会遇到Go插件工具安装问题<img src=\"Go%E6%8F%92%E4%BB%B6%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98.assets/QQ20200406-095236@2x-6150876.png\" alt=\"QQ20200406-095236@2x\"></p>\n<p>下面我们就来解决一下这个问题（网上也有相关使用代理的情况，这里不再说明）</p>\n<h2 id=\"引发原因\"><a href=\"#引发原因\" class=\"headerlink\" title=\"引发原因\"></a>引发原因</h2><p>mac 下的包管理工具brew 可以方便的安装工具包或者相应的软件应用，当使用brew 安装git-lfs（git上传大文件的工具）时，因为依赖Go 语言工具，所以在安装时会报错。下面就brew install git-lfs 时的问题来给出解决方案。</p>\n<h2 id=\"过程思路\"><a href=\"#过程思路\" class=\"headerlink\" title=\"过程思路\"></a>过程思路</h2><p>如果想直接解决可以直接跳转到<a href=\"#解决方案\">解决方案</a></p>\n<p>在网上搜索时发现 <a href=\"https://github.com/golang/tools\" target=\"_blank\" rel=\"noopener\">https://github.com/golang/tools</a> 是 <a href=\"https://go.googlesource.com/tools.git\" target=\"_blank\" rel=\"noopener\">https://go.googlesource.com/tools.git</a> 的一个镜像。这样我们只要修改brew下载git-lfs的脚本，将 <a href=\"https://go.googlesource.com/tools.git\" target=\"_blank\" rel=\"noopener\">https://go.googlesource.com/tools.git</a> 替换成 <a href=\"https://github.com/golang/tools\" target=\"_blank\" rel=\"noopener\">https://github.com/golang/tools</a> 应该就可以解决我们的问题。</p>\n<p>登录 <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">Homebrew</a> 的官网，找到Packages，<img src=\"Go%E6%8F%92%E4%BB%B6%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98.assets/QQ20200406-101042@2x-6150888.png\" alt=\"QQ20200406-101042@2x\"></p>\n<p>点击 <a href=\"https://formulae.brew.sh/\" target=\"_blank\" rel=\"noopener\">formulae.brew.sh</a> ，选择 <a href=\"https://formulae.brew.sh/formula/\" target=\"_blank\" rel=\"noopener\">Browse all macOS formulae</a></p>\n<p><img src=\"Go%E6%8F%92%E4%BB%B6%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98.assets/QQ20200406-101332@2x-6150899.png\" alt=\"QQ20200406-101332@2x\"></p>\n<p>在搜索框搜索git-lfs，在页面找到<a href=\"https://github.com/Homebrew/homebrew-core/blob/master/Formula/git-lfs.rb\" target=\"_blank\" rel=\"noopener\">Formula code</a> ，查看git-lfs在GitHub上的脚本源码。</p>\n<pre class=\" language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">GitLfs</span> <span class=\"token operator\">&lt;</span> <span class=\"token constant\">Formula</span>\n  desc <span class=\"token string\">\"Git extension for versioning large files\"</span>\n  homepage <span class=\"token string\">\"https://github.com/git-lfs/git-lfs\"</span>\n  url <span class=\"token string\">\"https://github.com/git-lfs/git-lfs/releases/download/v2.10.0/git-lfs-v2.10.0.tar.gz\"</span>\n  sha256 <span class=\"token string\">\"07fd5c57a1039d5717dc192affbe3268ec2fd03accdca462cb504c0b4194cd23\"</span>\n\n  bottle <span class=\"token keyword\">do</span>\n    cellar <span class=\"token symbol\">:any_skip_relocation</span>\n    sha256 <span class=\"token string\">\"8fec7d8b8ad7c3332bfa1862dd8615712dab8315a9128ed8b5609fa1659431e7\"</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token symbol\">:catalina</span>\n    sha256 <span class=\"token string\">\"3c5bcef656ca742c6697b952c9f7c483c1fad046f52136dbe9ee0f16f44835c4\"</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token symbol\">:mojave</span>\n    sha256 <span class=\"token string\">\"ed0d8f1271d9d81a2c22622023c260ef040f2172e75357893ef54134bc6eedff\"</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token symbol\">:high_sierra</span>\n  <span class=\"token keyword\">end</span>\n\n  depends_on <span class=\"token string\">\"go\"</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token symbol\">:build</span>\n  depends_on <span class=\"token string\">\"ruby\"</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token symbol\">:build</span>\n\n  <span class=\"token keyword\">def</span> install\n    <span class=\"token constant\">ENV</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"GIT_LFS_SHA\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"\"</span>\n    <span class=\"token constant\">ENV</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"VERSION\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">version</span>\n\n    <span class=\"token punctuation\">(</span>buildpath<span class=\"token operator\">/</span><span class=\"token string\">\"src/github.com/git-lfs/git-lfs\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>install buildpath<span class=\"token punctuation\">.</span>children\n    cd <span class=\"token string\">\"src/github.com/git-lfs/git-lfs\"</span> <span class=\"token keyword\">do</span>\n      <span class=\"token constant\">ENV</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"GEM_HOME\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\".gem_home\"</span>\n      system <span class=\"token string\">\"gem\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"install\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"ronn\"</span>\n\n      system <span class=\"token string\">\"make\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"vendor\"</span>\n      system <span class=\"token string\">\"make\"</span>\n      system <span class=\"token string\">\"make\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"man\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"RONN=.gem_home/bin/ronn\"</span>\n\n      bin<span class=\"token punctuation\">.</span>install <span class=\"token string\">\"bin/git-lfs\"</span>\n      man1<span class=\"token punctuation\">.</span>install <span class=\"token builtin\">Dir</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"man/*.1\"</span><span class=\"token punctuation\">]</span>\n      man5<span class=\"token punctuation\">.</span>install <span class=\"token builtin\">Dir</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"man/*.5\"</span><span class=\"token punctuation\">]</span>\n      doc<span class=\"token punctuation\">.</span>install <span class=\"token builtin\">Dir</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"man/*.html\"</span><span class=\"token punctuation\">]</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">def</span> caveats\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">~</span><span class=\"token constant\">EOS</span>\n      <span class=\"token constant\">Update</span> your git config to finish installation<span class=\"token punctuation\">:</span>\n        <span class=\"token comment\" spellcheck=\"true\"># Update global git config</span>\n        $ git lfs install\n        <span class=\"token comment\" spellcheck=\"true\"># Update system git config</span>\n        $ git lfs install <span class=\"token operator\">--</span>system\n    <span class=\"token constant\">EOS</span>\n  <span class=\"token keyword\">end</span>\n\n  test <span class=\"token keyword\">do</span>\n    system <span class=\"token string\">\"git\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"init\"</span>\n    system <span class=\"token string\">\"git\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"lfs\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"track\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"test\"</span>\n    <span class=\"token function\">assert_match</span><span class=\"token punctuation\">(</span><span class=\"token regex\">/^test filter=lfs/</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">File</span><span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span><span class=\"token string\">\".gitattributes\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre>\n<p>当前代码中并没有相关 <a href=\"https://go.googlesource.com/tools.git\" target=\"_blank\" rel=\"noopener\">https://go.googlesource.com/tools.git</a> 的信息，因为当前是Go的tools，所以再去查看Go的安装脚本（git-lfs的脚本中依赖Go和Ruby，所以只有可能是这两个里面有问题，因为tools是Go相关的的工具，所以首先我们可以查看Go的安装脚本）。这是Go语言brew的安装脚本 <a href=\"https://github.com/Homebrew/homebrew-core/blob/master/Formula/go.rb\" target=\"_blank\" rel=\"noopener\">https://github.com/Homebrew/homebrew-core/blob/master/Formula/go.rb</a></p>\n<pre class=\" language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Go</span> <span class=\"token operator\">&lt;</span> <span class=\"token constant\">Formula</span>\n  desc <span class=\"token string\">\"Open source programming language to build simple/reliable/efficient software\"</span>\n  homepage <span class=\"token string\">\"https://golang.org\"</span>\n\n  stable <span class=\"token keyword\">do</span>\n    url <span class=\"token string\">\"https://dl.google.com/go/go1.14.1.src.tar.gz\"</span>\n    mirror <span class=\"token string\">\"https://fossies.org/linux/misc/go1.14.1.src.tar.gz\"</span>\n    sha256 <span class=\"token string\">\"2ad2572115b0d1b4cb4c138e6b3a31cee6294cb48af75ee86bec3dca04507676\"</span>\n\n    go_version <span class=\"token operator\">=</span> version<span class=\"token punctuation\">.</span>to_s<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\".\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\".\"</span><span class=\"token punctuation\">)</span>\n    resource <span class=\"token string\">\"gotools\"</span> <span class=\"token keyword\">do</span>\n      url <span class=\"token string\">\"https://go.googlesource.com/tools.git\"</span><span class=\"token punctuation\">,</span>\n          <span class=\"token symbol\">:branch</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token string\">\"release-branch.go<span class=\"token interpolation\"><span class=\"token delimiter tag\">#{</span>go_version<span class=\"token delimiter tag\">}</span></span>\"</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n\n  bottle <span class=\"token keyword\">do</span>\n    sha256 <span class=\"token string\">\"36fdd54a9307ba19cc69425586e2d63188f2f2b7f541ab9fd2ef3447e376329f\"</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token symbol\">:catalina</span>\n    sha256 <span class=\"token string\">\"bab387fda3e4683943bd7b9b9208141502d6a2cc42c4b21137effaec9f208e1c\"</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token symbol\">:mojave</span>\n    sha256 <span class=\"token string\">\"ffb583abeb5263269281532f45a70a074ae0affe6edecb13442024b70bf13b04\"</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token symbol\">:high_sierra</span>\n  <span class=\"token keyword\">end</span>\n\n  head <span class=\"token keyword\">do</span>\n    url <span class=\"token string\">\"https://go.googlesource.com/go.git\"</span>\n\n    resource <span class=\"token string\">\"gotools\"</span> <span class=\"token keyword\">do</span>\n      url <span class=\"token string\">\"https://go.googlesource.com/tools.git\"</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n\n  depends_on <span class=\"token symbol\">:macos</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token symbol\">:el_capitan</span>\n\n  <span class=\"token comment\" spellcheck=\"true\"># Don't update this unless this version cannot bootstrap the new version.</span>\n  resource <span class=\"token string\">\"gobootstrap\"</span> <span class=\"token keyword\">do</span>\n    url <span class=\"token string\">\"https://storage.googleapis.com/golang/go1.7.darwin-amd64.tar.gz\"</span>\n    sha256 <span class=\"token string\">\"51d905e0b43b3d0ed41aaf23e19001ab4bc3f96c3ca134b48f7892485fc52961\"</span>\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">def</span> <span class=\"token function\">install</span>\n    <span class=\"token punctuation\">(</span>buildpath<span class=\"token operator\">/</span><span class=\"token string\">\"gobootstrap\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>install <span class=\"token function\">resource</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"gobootstrap\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token constant\">ENV</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"GOROOT_BOOTSTRAP\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> buildpath<span class=\"token operator\">/</span><span class=\"token string\">\"gobootstrap\"</span>\n\n    cd <span class=\"token string\">\"src\"</span> <span class=\"token keyword\">do</span>\n      <span class=\"token constant\">ENV</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"GOROOT_FINAL\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> libexec\n      <span class=\"token constant\">ENV</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"GOOS\"</span><span class=\"token punctuation\">]</span>         <span class=\"token operator\">=</span> <span class=\"token string\">\"darwin\"</span>\n      system <span class=\"token string\">\"./make.bash\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"--no-clean\"</span>\n    <span class=\"token keyword\">end</span>\n\n    <span class=\"token punctuation\">(</span>buildpath<span class=\"token operator\">/</span><span class=\"token string\">\"pkg/obj\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rmtree\n    rm_rf <span class=\"token string\">\"gobootstrap\"</span> <span class=\"token comment\" spellcheck=\"true\"># Bootstrap not required beyond compile.</span>\n    libexec<span class=\"token punctuation\">.</span>install <span class=\"token builtin\">Dir</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"*\"</span><span class=\"token punctuation\">]</span>\n    bin<span class=\"token punctuation\">.</span>install_symlink <span class=\"token builtin\">Dir</span><span class=\"token punctuation\">[</span>libexec<span class=\"token operator\">/</span><span class=\"token string\">\"bin/go*\"</span><span class=\"token punctuation\">]</span>\n\n    system bin<span class=\"token operator\">/</span><span class=\"token string\">\"go\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"install\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"-race\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"std\"</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Build and install godoc</span>\n    <span class=\"token constant\">ENV</span><span class=\"token punctuation\">.</span>prepend_path <span class=\"token string\">\"PATH\"</span><span class=\"token punctuation\">,</span> bin\n    <span class=\"token constant\">ENV</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"GOPATH\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">buildpath</span>\n    <span class=\"token punctuation\">(</span>buildpath<span class=\"token operator\">/</span><span class=\"token string\">\"src/golang.org/x/tools\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>install <span class=\"token function\">resource</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"gotools\"</span><span class=\"token punctuation\">)</span>\n    cd <span class=\"token string\">\"src/golang.org/x/tools/cmd/godoc/\"</span> <span class=\"token keyword\">do</span>\n      system <span class=\"token string\">\"go\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"build\"</span>\n      <span class=\"token punctuation\">(</span>libexec<span class=\"token operator\">/</span><span class=\"token string\">\"bin\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>install <span class=\"token string\">\"godoc\"</span>\n    <span class=\"token keyword\">end</span>\n    bin<span class=\"token punctuation\">.</span>install_symlink libexec<span class=\"token operator\">/</span><span class=\"token string\">\"bin/godoc\"</span>\n  <span class=\"token keyword\">end</span>\n\n  test <span class=\"token keyword\">do</span>\n    <span class=\"token punctuation\">(</span>testpath<span class=\"token operator\">/</span><span class=\"token string\">\"hello.go\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>write <span class=\"token operator\">&lt;</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">~</span><span class=\"token constant\">EOS</span>\n      package main\n      import <span class=\"token string\">\"fmt\"</span>\n      func <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello World\"</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token constant\">EOS</span>\n    <span class=\"token comment\" spellcheck=\"true\"># Run go fmt check for no errors then run the program.</span>\n    <span class=\"token comment\" spellcheck=\"true\"># This is a a bare minimum of go working as it uses fmt, build, and run.</span>\n    system bin<span class=\"token operator\">/</span><span class=\"token string\">\"go\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"fmt\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"hello.go\"</span>\n    assert_equal <span class=\"token string\">\"Hello World\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">shell_output</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"<span class=\"token interpolation\"><span class=\"token delimiter tag\">#{</span>bin<span class=\"token delimiter tag\">}</span></span>/go run hello.go\"</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># godoc was installed</span>\n    assert_predicate libexec<span class=\"token operator\">/</span><span class=\"token string\">\"bin/godoc\"</span><span class=\"token punctuation\">,</span> <span class=\"token symbol\">:exist?</span>\n    assert_predicate libexec<span class=\"token operator\">/</span><span class=\"token string\">\"bin/godoc\"</span><span class=\"token punctuation\">,</span> <span class=\"token symbol\">:executable?</span>\n\n    <span class=\"token constant\">ENV</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"GOOS\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"freebsd\"</span>\n    <span class=\"token constant\">ENV</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"GOARCH\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"amd64\"</span>\n    system bin<span class=\"token operator\">/</span><span class=\"token string\">\"go\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"build\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"hello.go\"</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre>\n<p>安装脚本里面有请求 <a href=\"https://go.googlesource.com/tools.git\" target=\"_blank\" rel=\"noopener\">https://go.googlesource.com/tools.git</a> 地址的信息，我们可以将这块的替换掉应该就可以。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>brew在本地管理安装包的文件夹为</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">/usr/local/Cellar/</code></pre>\n<p>brew在本地管理安装脚本的文件夹为</p>\n<pre class=\" language-shell\"><code class=\"language-shell\">/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula</code></pre>\n<p>这里我们只需要修改<code>/usr/local/Homebrew/Library/Taps</code>下Go的安装脚本，将 <a href=\"https://go.googlesource.com/tools.git\" target=\"_blank\" rel=\"noopener\">https://go.googlesource.com/tools.git</a> 替换成 <a href=\"https://github.com/golang/tools\" target=\"_blank\" rel=\"noopener\">https://github.com/golang/tools</a> 即可。</p>\n<pre class=\" language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Go</span> <span class=\"token operator\">&lt;</span> <span class=\"token constant\">Formula</span>\n  desc <span class=\"token string\">\"Open source programming language to build simple/reliable/efficient software\"</span>\n  homepage <span class=\"token string\">\"https://golang.org\"</span>\n\n  stable <span class=\"token keyword\">do</span>\n    url <span class=\"token string\">\"https://dl.google.com/go/go1.14.1.src.tar.gz\"</span>\n    mirror <span class=\"token string\">\"https://fossies.org/linux/misc/go1.14.1.src.tar.gz\"</span>\n    sha256 <span class=\"token string\">\"2ad2572115b0d1b4cb4c138e6b3a31cee6294cb48af75ee86bec3dca04507676\"</span>\n\n    go_version <span class=\"token operator\">=</span> version<span class=\"token punctuation\">.</span>to_s<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">\".\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">\".\"</span><span class=\"token punctuation\">)</span>\n    resource <span class=\"token string\">\"gotools\"</span> <span class=\"token keyword\">do</span>\n    <span class=\"token comment\" spellcheck=\"true\">#url \"https://go.googlesource.com/tools.git\",</span>\n    url <span class=\"token string\">\"https://github.com/golang/tools.git\"</span><span class=\"token punctuation\">,</span>\n          <span class=\"token symbol\">:branch</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token string\">\"release-branch.go<span class=\"token interpolation\"><span class=\"token delimiter tag\">#{</span>go_version<span class=\"token delimiter tag\">}</span></span>\"</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n\n  bottle <span class=\"token keyword\">do</span>\n    sha256 <span class=\"token string\">\"36fdd54a9307ba19cc69425586e2d63188f2f2b7f541ab9fd2ef3447e376329f\"</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token symbol\">:catalina</span>\n    sha256 <span class=\"token string\">\"bab387fda3e4683943bd7b9b9208141502d6a2cc42c4b21137effaec9f208e1c\"</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token symbol\">:mojave</span>\n    sha256 <span class=\"token string\">\"ffb583abeb5263269281532f45a70a074ae0affe6edecb13442024b70bf13b04\"</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token symbol\">:high_sierra</span>\n  <span class=\"token keyword\">end</span>\n\n  head <span class=\"token keyword\">do</span>\n      <span class=\"token comment\" spellcheck=\"true\">#url \"https://go.googlesource.com/go.git\"</span>\n      url <span class=\"token string\">\"https://github.com/golang/tools.git\"</span>\n\n    resource <span class=\"token string\">\"gotools\"</span> <span class=\"token keyword\">do</span>\n        <span class=\"token comment\" spellcheck=\"true\">#url \"https://go.googlesource.com/tools.git\"</span>\n      url <span class=\"token string\">\"https://github.com/golang/tools.git\"</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n\n  depends_on <span class=\"token symbol\">:macos</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token symbol\">:el_capitan</span>\n\n  <span class=\"token comment\" spellcheck=\"true\"># Don't update this unless this version cannot bootstrap the new version.</span>\n  resource <span class=\"token string\">\"gobootstrap\"</span> <span class=\"token keyword\">do</span>\n    url <span class=\"token string\">\"https://storage.googleapis.com/golang/go1.7.darwin-amd64.tar.gz\"</span>\n    sha256 <span class=\"token string\">\"51d905e0b43b3d0ed41aaf23e19001ab4bc3f96c3ca134b48f7892485fc52961\"</span>\n  <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">def</span> <span class=\"token function\">install</span>\n    <span class=\"token punctuation\">(</span>buildpath<span class=\"token operator\">/</span><span class=\"token string\">\"gobootstrap\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>install <span class=\"token function\">resource</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"gobootstrap\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token constant\">ENV</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"GOROOT_BOOTSTRAP\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> buildpath<span class=\"token operator\">/</span><span class=\"token string\">\"gobootstrap\"</span>\n\n    cd <span class=\"token string\">\"src\"</span> <span class=\"token keyword\">do</span>\n      <span class=\"token constant\">ENV</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"GOROOT_FINAL\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> libexec\n      <span class=\"token constant\">ENV</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"GOOS\"</span><span class=\"token punctuation\">]</span>         <span class=\"token operator\">=</span> <span class=\"token string\">\"darwin\"</span>\n      system <span class=\"token string\">\"./make.bash\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"--no-clean\"</span>\n    <span class=\"token keyword\">end</span>\n\n    <span class=\"token punctuation\">(</span>buildpath<span class=\"token operator\">/</span><span class=\"token string\">\"pkg/obj\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>rmtree\n    rm_rf <span class=\"token string\">\"gobootstrap\"</span> <span class=\"token comment\" spellcheck=\"true\"># Bootstrap not required beyond compile.</span>\n    libexec<span class=\"token punctuation\">.</span>install <span class=\"token builtin\">Dir</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"*\"</span><span class=\"token punctuation\">]</span>\n    bin<span class=\"token punctuation\">.</span>install_symlink <span class=\"token builtin\">Dir</span><span class=\"token punctuation\">[</span>libexec<span class=\"token operator\">/</span><span class=\"token string\">\"bin/go*\"</span><span class=\"token punctuation\">]</span>\n\n    system bin<span class=\"token operator\">/</span><span class=\"token string\">\"go\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"install\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"-race\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"std\"</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># Build and install godoc</span>\n    <span class=\"token constant\">ENV</span><span class=\"token punctuation\">.</span>prepend_path <span class=\"token string\">\"PATH\"</span><span class=\"token punctuation\">,</span> bin\n    <span class=\"token constant\">ENV</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"GOPATH\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">buildpath</span>\n    <span class=\"token punctuation\">(</span>buildpath<span class=\"token operator\">/</span><span class=\"token string\">\"src/golang.org/x/tools\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>install <span class=\"token function\">resource</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"gotools\"</span><span class=\"token punctuation\">)</span>\n    cd <span class=\"token string\">\"src/golang.org/x/tools/cmd/godoc/\"</span> <span class=\"token keyword\">do</span>\n      system <span class=\"token string\">\"go\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"build\"</span>\n      <span class=\"token punctuation\">(</span>libexec<span class=\"token operator\">/</span><span class=\"token string\">\"bin\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>install <span class=\"token string\">\"godoc\"</span>\n    <span class=\"token keyword\">end</span>\n    bin<span class=\"token punctuation\">.</span>install_symlink libexec<span class=\"token operator\">/</span><span class=\"token string\">\"bin/godoc\"</span>\n  <span class=\"token keyword\">end</span>\n\n  test <span class=\"token keyword\">do</span>\n    <span class=\"token punctuation\">(</span>testpath<span class=\"token operator\">/</span><span class=\"token string\">\"hello.go\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>write <span class=\"token operator\">&lt;</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">~</span><span class=\"token constant\">EOS</span>\n      package main\n\n      import <span class=\"token string\">\"fmt\"</span>\n\n      func <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello World\"</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token constant\">EOS</span>\n    <span class=\"token comment\" spellcheck=\"true\"># Run go fmt check for no errors then run the program.</span>\n    <span class=\"token comment\" spellcheck=\"true\"># This is a a bare minimum of go working as it uses fmt, build, and run.</span>\n    system bin<span class=\"token operator\">/</span><span class=\"token string\">\"go\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"fmt\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"hello.go\"</span>\n    assert_equal <span class=\"token string\">\"Hello World\\n\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">shell_output</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"<span class=\"token interpolation\"><span class=\"token delimiter tag\">#{</span>bin<span class=\"token delimiter tag\">}</span></span>/go run hello.go\"</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\"># godoc was installed</span>\n    assert_predicate libexec<span class=\"token operator\">/</span><span class=\"token string\">\"bin/godoc\"</span><span class=\"token punctuation\">,</span> <span class=\"token symbol\">:exist?</span>\n    assert_predicate libexec<span class=\"token operator\">/</span><span class=\"token string\">\"bin/godoc\"</span><span class=\"token punctuation\">,</span> <span class=\"token symbol\">:executable?</span>\n\n    <span class=\"token constant\">ENV</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"GOOS\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"freebsd\"</span>\n    <span class=\"token constant\">ENV</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"GOARCH\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"amd64\"</span>\n    system bin<span class=\"token operator\">/</span><span class=\"token string\">\"go\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"build\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"hello.go\"</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n</code></pre>\n","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<h1 id=\"Go插件工具安装问题\"><a href=\"#Go插件工具安装问题\" class=\"headerlink\" title=\"Go插件工具安装问题\"></a>Go插件工具安装问题</h1><p>在Mac上在学习使用Go或者安装其他带有Go依赖的安装包时（比如git-lfs）可能会遇到Go插件工具安装问题<img src=\"Go%E6%8F%92%E4%BB%B6%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98.assets/QQ20200406-095236@2x-6150876.png\" alt=\"QQ20200406-095236@2x\"></p>\n<p>下面我们就来解决一下这个问题（网上也有相关使用代理的情况，这里不再说明）</p>\n<h2 id=\"引发原因\"><a href=\"#引发原因\" class=\"headerlink\" title=\"引发原因\"></a>引发原因</h2><p>mac 下的包管理工具brew 可以方便的安装工具包或者相应的软件应用，当使用brew 安装git-lfs（git上传大文件的工具）时，因为依赖Go 语言工具，所以在安装时会报错。下面就brew install git-lfs 时的问题来给出解决方案。</p>\n<h2 id=\"过程思路\"><a href=\"#过程思路\" class=\"headerlink\" title=\"过程思路\"></a>过程思路</h2><p>如果想直接解决可以直接跳转到<a href=\"#解决方案\">解决方案</a></p>\n<p>在网上搜索时发现 <a href=\"https://github.com/golang/tools\" target=\"_blank\" rel=\"noopener\">https://github.com/golang/tools</a> 是 <a href=\"https://go.googlesource.com/tools.git\" target=\"_blank\" rel=\"noopener\">https://go.googlesource.com/tools.git</a> 的一个镜像。这样我们只要修改brew下载git-lfs的脚本，将 <a href=\"https://go.googlesource.com/tools.git\" target=\"_blank\" rel=\"noopener\">https://go.googlesource.com/tools.git</a> 替换成 <a href=\"https://github.com/golang/tools\" target=\"_blank\" rel=\"noopener\">https://github.com/golang/tools</a> 应该就可以解决我们的问题。</p>\n<p>登录 <a href=\"https://brew.sh/\" target=\"_blank\" rel=\"noopener\">Homebrew</a> 的官网，找到Packages，<img src=\"Go%E6%8F%92%E4%BB%B6%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98.assets/QQ20200406-101042@2x-6150888.png\" alt=\"QQ20200406-101042@2x\"></p>\n<p>点击 <a href=\"https://formulae.brew.sh/\" target=\"_blank\" rel=\"noopener\">formulae.brew.sh</a> ，选择 <a href=\"https://formulae.brew.sh/formula/\" target=\"_blank\" rel=\"noopener\">Browse all macOS formulae</a></p>\n<p><img src=\"Go%E6%8F%92%E4%BB%B6%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98.assets/QQ20200406-101332@2x-6150899.png\" alt=\"QQ20200406-101332@2x\"></p>\n<p>在搜索框搜索git-lfs，在页面找到<a href=\"https://github.com/Homebrew/homebrew-core/blob/master/Formula/git-lfs.rb\" target=\"_blank\" rel=\"noopener\">Formula code</a> ，查看git-lfs在GitHub上的脚本源码。</p>\n<pre><code class=\"ruby\">class GitLfs &lt; Formula\n  desc &quot;Git extension for versioning large files&quot;\n  homepage &quot;https://github.com/git-lfs/git-lfs&quot;\n  url &quot;https://github.com/git-lfs/git-lfs/releases/download/v2.10.0/git-lfs-v2.10.0.tar.gz&quot;\n  sha256 &quot;07fd5c57a1039d5717dc192affbe3268ec2fd03accdca462cb504c0b4194cd23&quot;\n\n  bottle do\n    cellar :any_skip_relocation\n    sha256 &quot;8fec7d8b8ad7c3332bfa1862dd8615712dab8315a9128ed8b5609fa1659431e7&quot; =&gt; :catalina\n    sha256 &quot;3c5bcef656ca742c6697b952c9f7c483c1fad046f52136dbe9ee0f16f44835c4&quot; =&gt; :mojave\n    sha256 &quot;ed0d8f1271d9d81a2c22622023c260ef040f2172e75357893ef54134bc6eedff&quot; =&gt; :high_sierra\n  end\n\n  depends_on &quot;go&quot; =&gt; :build\n  depends_on &quot;ruby&quot; =&gt; :build\n\n  def install\n    ENV[&quot;GIT_LFS_SHA&quot;] = &quot;&quot;\n    ENV[&quot;VERSION&quot;] = version\n\n    (buildpath/&quot;src/github.com/git-lfs/git-lfs&quot;).install buildpath.children\n    cd &quot;src/github.com/git-lfs/git-lfs&quot; do\n      ENV[&quot;GEM_HOME&quot;] = &quot;.gem_home&quot;\n      system &quot;gem&quot;, &quot;install&quot;, &quot;ronn&quot;\n\n      system &quot;make&quot;, &quot;vendor&quot;\n      system &quot;make&quot;\n      system &quot;make&quot;, &quot;man&quot;, &quot;RONN=.gem_home/bin/ronn&quot;\n\n      bin.install &quot;bin/git-lfs&quot;\n      man1.install Dir[&quot;man/*.1&quot;]\n      man5.install Dir[&quot;man/*.5&quot;]\n      doc.install Dir[&quot;man/*.html&quot;]\n    end\n  end\n\n  def caveats\n    &lt;&lt;~EOS\n      Update your git config to finish installation:\n        # Update global git config\n        $ git lfs install\n        # Update system git config\n        $ git lfs install --system\n    EOS\n  end\n\n  test do\n    system &quot;git&quot;, &quot;init&quot;\n    system &quot;git&quot;, &quot;lfs&quot;, &quot;track&quot;, &quot;test&quot;\n    assert_match(/^test filter=lfs/, File.read(&quot;.gitattributes&quot;))\n  end\nend</code></pre>\n<p>当前代码中并没有相关 <a href=\"https://go.googlesource.com/tools.git\" target=\"_blank\" rel=\"noopener\">https://go.googlesource.com/tools.git</a> 的信息，因为当前是Go的tools，所以再去查看Go的安装脚本（git-lfs的脚本中依赖Go和Ruby，所以只有可能是这两个里面有问题，因为tools是Go相关的的工具，所以首先我们可以查看Go的安装脚本）。这是Go语言brew的安装脚本 <a href=\"https://github.com/Homebrew/homebrew-core/blob/master/Formula/go.rb\" target=\"_blank\" rel=\"noopener\">https://github.com/Homebrew/homebrew-core/blob/master/Formula/go.rb</a></p>\n<pre><code class=\"ruby\">class Go &lt; Formula\n  desc &quot;Open source programming language to build simple/reliable/efficient software&quot;\n  homepage &quot;https://golang.org&quot;\n\n  stable do\n    url &quot;https://dl.google.com/go/go1.14.1.src.tar.gz&quot;\n    mirror &quot;https://fossies.org/linux/misc/go1.14.1.src.tar.gz&quot;\n    sha256 &quot;2ad2572115b0d1b4cb4c138e6b3a31cee6294cb48af75ee86bec3dca04507676&quot;\n\n    go_version = version.to_s.split(&quot;.&quot;)[0..1].join(&quot;.&quot;)\n    resource &quot;gotools&quot; do\n      url &quot;https://go.googlesource.com/tools.git&quot;,\n          :branch =&gt; &quot;release-branch.go#{go_version}&quot;\n    end\n  end\n\n  bottle do\n    sha256 &quot;36fdd54a9307ba19cc69425586e2d63188f2f2b7f541ab9fd2ef3447e376329f&quot; =&gt; :catalina\n    sha256 &quot;bab387fda3e4683943bd7b9b9208141502d6a2cc42c4b21137effaec9f208e1c&quot; =&gt; :mojave\n    sha256 &quot;ffb583abeb5263269281532f45a70a074ae0affe6edecb13442024b70bf13b04&quot; =&gt; :high_sierra\n  end\n\n  head do\n    url &quot;https://go.googlesource.com/go.git&quot;\n\n    resource &quot;gotools&quot; do\n      url &quot;https://go.googlesource.com/tools.git&quot;\n    end\n  end\n\n  depends_on :macos =&gt; :el_capitan\n\n  # Don&#39;t update this unless this version cannot bootstrap the new version.\n  resource &quot;gobootstrap&quot; do\n    url &quot;https://storage.googleapis.com/golang/go1.7.darwin-amd64.tar.gz&quot;\n    sha256 &quot;51d905e0b43b3d0ed41aaf23e19001ab4bc3f96c3ca134b48f7892485fc52961&quot;\n  end\n\n  def install\n    (buildpath/&quot;gobootstrap&quot;).install resource(&quot;gobootstrap&quot;)\n    ENV[&quot;GOROOT_BOOTSTRAP&quot;] = buildpath/&quot;gobootstrap&quot;\n\n    cd &quot;src&quot; do\n      ENV[&quot;GOROOT_FINAL&quot;] = libexec\n      ENV[&quot;GOOS&quot;]         = &quot;darwin&quot;\n      system &quot;./make.bash&quot;, &quot;--no-clean&quot;\n    end\n\n    (buildpath/&quot;pkg/obj&quot;).rmtree\n    rm_rf &quot;gobootstrap&quot; # Bootstrap not required beyond compile.\n    libexec.install Dir[&quot;*&quot;]\n    bin.install_symlink Dir[libexec/&quot;bin/go*&quot;]\n\n    system bin/&quot;go&quot;, &quot;install&quot;, &quot;-race&quot;, &quot;std&quot;\n\n    # Build and install godoc\n    ENV.prepend_path &quot;PATH&quot;, bin\n    ENV[&quot;GOPATH&quot;] = buildpath\n    (buildpath/&quot;src/golang.org/x/tools&quot;).install resource(&quot;gotools&quot;)\n    cd &quot;src/golang.org/x/tools/cmd/godoc/&quot; do\n      system &quot;go&quot;, &quot;build&quot;\n      (libexec/&quot;bin&quot;).install &quot;godoc&quot;\n    end\n    bin.install_symlink libexec/&quot;bin/godoc&quot;\n  end\n\n  test do\n    (testpath/&quot;hello.go&quot;).write &lt;&lt;~EOS\n      package main\n      import &quot;fmt&quot;\n      func main() {\n          fmt.Println(&quot;Hello World&quot;)\n      }\n    EOS\n    # Run go fmt check for no errors then run the program.\n    # This is a a bare minimum of go working as it uses fmt, build, and run.\n    system bin/&quot;go&quot;, &quot;fmt&quot;, &quot;hello.go&quot;\n    assert_equal &quot;Hello World\\n&quot;, shell_output(&quot;#{bin}/go run hello.go&quot;)\n\n    # godoc was installed\n    assert_predicate libexec/&quot;bin/godoc&quot;, :exist?\n    assert_predicate libexec/&quot;bin/godoc&quot;, :executable?\n\n    ENV[&quot;GOOS&quot;] = &quot;freebsd&quot;\n    ENV[&quot;GOARCH&quot;] = &quot;amd64&quot;\n    system bin/&quot;go&quot;, &quot;build&quot;, &quot;hello.go&quot;\n  end\nend</code></pre>\n<p>安装脚本里面有请求 <a href=\"https://go.googlesource.com/tools.git\" target=\"_blank\" rel=\"noopener\">https://go.googlesource.com/tools.git</a> 地址的信息，我们可以将这块的替换掉应该就可以。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>brew在本地管理安装包的文件夹为</p>\n<pre><code class=\"shell\">/usr/local/Cellar/</code></pre>\n<p>brew在本地管理安装脚本的文件夹为</p>\n<pre><code class=\"shell\">/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula</code></pre>\n<p>这里我们只需要修改<code>/usr/local/Homebrew/Library/Taps</code>下Go的安装脚本，将 <a href=\"https://go.googlesource.com/tools.git\" target=\"_blank\" rel=\"noopener\">https://go.googlesource.com/tools.git</a> 替换成 <a href=\"https://github.com/golang/tools\" target=\"_blank\" rel=\"noopener\">https://github.com/golang/tools</a> 即可。</p>\n<pre><code class=\"ruby\">class Go &lt; Formula\n  desc &quot;Open source programming language to build simple/reliable/efficient software&quot;\n  homepage &quot;https://golang.org&quot;\n\n  stable do\n    url &quot;https://dl.google.com/go/go1.14.1.src.tar.gz&quot;\n    mirror &quot;https://fossies.org/linux/misc/go1.14.1.src.tar.gz&quot;\n    sha256 &quot;2ad2572115b0d1b4cb4c138e6b3a31cee6294cb48af75ee86bec3dca04507676&quot;\n\n    go_version = version.to_s.split(&quot;.&quot;)[0..1].join(&quot;.&quot;)\n    resource &quot;gotools&quot; do\n    #url &quot;https://go.googlesource.com/tools.git&quot;,\n    url &quot;https://github.com/golang/tools.git&quot;,\n          :branch =&gt; &quot;release-branch.go#{go_version}&quot;\n    end\n  end\n\n  bottle do\n    sha256 &quot;36fdd54a9307ba19cc69425586e2d63188f2f2b7f541ab9fd2ef3447e376329f&quot; =&gt; :catalina\n    sha256 &quot;bab387fda3e4683943bd7b9b9208141502d6a2cc42c4b21137effaec9f208e1c&quot; =&gt; :mojave\n    sha256 &quot;ffb583abeb5263269281532f45a70a074ae0affe6edecb13442024b70bf13b04&quot; =&gt; :high_sierra\n  end\n\n  head do\n      #url &quot;https://go.googlesource.com/go.git&quot;\n      url &quot;https://github.com/golang/tools.git&quot;\n\n    resource &quot;gotools&quot; do\n        #url &quot;https://go.googlesource.com/tools.git&quot;\n      url &quot;https://github.com/golang/tools.git&quot;\n    end\n  end\n\n  depends_on :macos =&gt; :el_capitan\n\n  # Don&#39;t update this unless this version cannot bootstrap the new version.\n  resource &quot;gobootstrap&quot; do\n    url &quot;https://storage.googleapis.com/golang/go1.7.darwin-amd64.tar.gz&quot;\n    sha256 &quot;51d905e0b43b3d0ed41aaf23e19001ab4bc3f96c3ca134b48f7892485fc52961&quot;\n  end\n\n  def install\n    (buildpath/&quot;gobootstrap&quot;).install resource(&quot;gobootstrap&quot;)\n    ENV[&quot;GOROOT_BOOTSTRAP&quot;] = buildpath/&quot;gobootstrap&quot;\n\n    cd &quot;src&quot; do\n      ENV[&quot;GOROOT_FINAL&quot;] = libexec\n      ENV[&quot;GOOS&quot;]         = &quot;darwin&quot;\n      system &quot;./make.bash&quot;, &quot;--no-clean&quot;\n    end\n\n    (buildpath/&quot;pkg/obj&quot;).rmtree\n    rm_rf &quot;gobootstrap&quot; # Bootstrap not required beyond compile.\n    libexec.install Dir[&quot;*&quot;]\n    bin.install_symlink Dir[libexec/&quot;bin/go*&quot;]\n\n    system bin/&quot;go&quot;, &quot;install&quot;, &quot;-race&quot;, &quot;std&quot;\n\n    # Build and install godoc\n    ENV.prepend_path &quot;PATH&quot;, bin\n    ENV[&quot;GOPATH&quot;] = buildpath\n    (buildpath/&quot;src/golang.org/x/tools&quot;).install resource(&quot;gotools&quot;)\n    cd &quot;src/golang.org/x/tools/cmd/godoc/&quot; do\n      system &quot;go&quot;, &quot;build&quot;\n      (libexec/&quot;bin&quot;).install &quot;godoc&quot;\n    end\n    bin.install_symlink libexec/&quot;bin/godoc&quot;\n  end\n\n  test do\n    (testpath/&quot;hello.go&quot;).write &lt;&lt;~EOS\n      package main\n\n      import &quot;fmt&quot;\n\n      func main() {\n          fmt.Println(&quot;Hello World&quot;)\n      }\n    EOS\n    # Run go fmt check for no errors then run the program.\n    # This is a a bare minimum of go working as it uses fmt, build, and run.\n    system bin/&quot;go&quot;, &quot;fmt&quot;, &quot;hello.go&quot;\n    assert_equal &quot;Hello World\\n&quot;, shell_output(&quot;#{bin}/go run hello.go&quot;)\n\n    # godoc was installed\n    assert_predicate libexec/&quot;bin/godoc&quot;, :exist?\n    assert_predicate libexec/&quot;bin/godoc&quot;, :executable?\n\n    ENV[&quot;GOOS&quot;] = &quot;freebsd&quot;\n    ENV[&quot;GOARCH&quot;] = &quot;amd64&quot;\n    system bin/&quot;go&quot;, &quot;build&quot;, &quot;hello.go&quot;\n  end\nend\n</code></pre>\n"},{"title":"大数据面试题","date":"2020-01-15T08:42:00.000Z","_content":"\n#  大数据面试题\n\n\n\n**1、你能简单描述一下Hbase吗？能画出它的架构图吗？**\n\n[hbase](http://lib.csdn.net/base/hbase)是一个面向列的 NoSQL 分布式[数据库](http://lib.csdn.net/base/mysql)，它利用HDFS作为底层存储系统。那么，HBase相对于传统的关系型数据库有什么不同呢？\n\n- HBase是schema-free的，它的列是可以动态增加的（仅仅定义列族），并且为空的列不占物理存储空间。\n- HBase是基于列存储的，每个列族都由几个文件保存，不同的列族的文件是分离的。\n- HBase自动切分数据，使得数据存储自动具有很好的横向扩展性。\n- HBase没有任何事务，提供了高并发读写操作的支持。\n\nHBase中的Table是一个稀疏的、多维度的、排序的映射表，这张表的索引是[RowKey, ColumnFamily, ColumnQualifier, Timestamp]，其中Timestamp表示版本，默认获取最新版本。HBase是通过RowKey来检索数据的，RowKey是Table设计的核心，它按照ASCII有序排序，因此应尽量避免顺序写入。RowKey设计应该注意三点：\n\n- 唯一原则：在HBase中rowkey可以看成是表的主键，必须保证其唯一性。\n- 散列原则：由于rowkey是按字典有序的，故应避免rowkey连续有序而导致在某一台RegionServer上堆积的现象。例如可以拼接随机数、将时间戳倒序等。\n- 长度原则：设计时RowKey要尽量短，这样可以提高有效数据的比例，节省存储空间，也可以提高查询的性能。\n\n下面是HBase的整体架构图：\n\n![img](http://img.blog.csdn.net/20160423184359154)\n\n**2、你说了解kafka，能简单描述一下Kafka吗？能画出它的架构图吗？**\n\nKafka是一个高吞吐、易扩展的分布式发布-订阅消息系统，它能够将消息持久化到磁盘，用于批量的消费。Kafka中有以下几个概念：\n\n- Topic：特指Kafka处理的消息源（feeds of messages）的不同分类。\n- Partition：Topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。\n- Broker：Kafa集群中包含一台或多台服务器，这种服务器被称为broker。\n- Producer：生产者，向Kafka的一个topic发布消息。\n- Consumers：消费者，从kafka的某个topic读取消息。\n\nKafka架构图如下：\n\n![img](http://img.blog.csdn.net/20160423204357095)\n\n详见：[Apache Kafka：下一代分布式消息系统](http://www.infoq.com/cn/articles/apache-kafka/)\n\n**3、请介绍你的一个亮点项目？你在其中做了什么？碰到了什么技术难点？**\n\n【解】介绍项目《九州卡牌》手游，我在项目中主要负责客户端逻辑与战斗效果的实现，以及网络通信模块的设计与开发。\n首先，对于网络通信我们选择使用**TCP长连接**，因为对于卡牌类手游可以容忍偶尔地延迟，并且有服务器主动给客户端推送消息的需求。\n优点：\n\n- 简单有效的长连接\n- 可靠的信息传输\n- 数据包的大小没有限制\n- 服务器可以主动向客户端推送消息（广播等）\n\n客户端每隔3s发送一次心跳包给服务器，通知服务器自己仍然在线，并获取服务器数据更新 —— 心跳包可以防止TCP的死连接问题，避免出现长时间不在线的死链接仍然出现在服务端的管理任务中。当客户端长时间切换到后台时，进程被挂起，连接会断开。\nTCP协议本身就有keep-alive机制，为什么还要在应用层实现自己的心跳检测机制呢？\n\n- TCP的keep-alive机制可能在短暂的网络异常中，将一个良好的连接给断开；\n- keep-alive设计初衷是清除和回收死亡时间长的连接，不适合实时性高的场合，而且它会先要求连接一定时间内没有活动，周期长，这样其实已经断开很长一段时间，没有及时性；\n- keep-alive不能主动通知应用层；\n- 另外，想要通过心跳包来获取服务器的数据更新，所以选择自己在应用层实现；\n\n还有一个问题就是一台机器的连接数有限制，可以通过**滚服**或者**分布式**来解决。\n\n- **滚服：**指老的服务器连接数达到上限了，就开新的服务区，不同服务区的用户不能交互。\n- **分布式：**长连接不分服的话，可以多个cluster节点连接同样的CACHE数据源，只是跨节点进行通信比较麻烦一点（如用户A连接到节点1，用户B连接到节点2，用户A向节点1发起TCP请求处理业务需要再通知到节点2的用户B）。一般来说有2种解决方案： \n  ①是建立场景服务器，即专门用一个socket server来保持所有玩家的连接，然后它只处理数据推送，不做业务，可以达到10-20W承载；②是采用发布订阅方式实现节点间的实时通信。\n\n我在[Linux](http://lib.csdn.net/base/linux)下写了一个**Socket心跳包示例程序**，见文《[TCP socket心跳包示例程序](http://blog.csdn.net/lisonglisonglisong/article/details/51327695)》。\n\n**4、请介绍一下MapReduce的工作原理。**\n\n【解】MapReduce是一个分布式计算框架，用于大规模数据集的并行运算。简单地说，MapReduce就是”任务的分解与结果的汇总”：将一个大的数据处理任务划分成许多个子任务，并将这些子任务分配给各个节点并行处理，然后通过整合各个节点的中间结果，得到最终结果。\n\nMapReduce是主从架构，在master上跑的是JobTracker/ResourceManager，负责资源分配与任务调度；而各个slave上跑的是TaskTracker/NodeManager，负责执行任务，并定期向master汇报最新状态与执行进度。\n\n对于一个MR任务，它的输入、输出以及中间结果都是`<key, value>`键值对：\n\n- Map：`<k1, v1>` ——> `list(<k2, v2>)`\n- Reduce：`<k2, list(v2)>` ——> `list(<k3, v3>)`\n\nMR程序的执行过程主要分为三步：Map阶段、Shuffle阶段、Reduce阶段，如下图：\n\n![img](http://img.blog.csdn.net/20160811132825039)\n\n1. **Map阶段**\n   - 分片（Split）：map阶段的输入通常是HDFS上文件，在运行Mapper前，FileInputFormat会将输入文件分割成多个split ——1个split至少包含1个HDFS的Block（默认为64M）；然后每一个分片运行一个map进行处理。\n   - 执行（Map）：对输入分片中的每个键值对调用`map()`函数进行运算，然后输出一个结果键值对。\n     - Partitioner：对 map 函数的输出进行partition，即根据key或value及reduce的数量来决定当前的这对键值对最终应该交由哪个reduce处理。默认是对key哈希后再以reduce task数量取模，默认的取模方式只是为了避免数据倾斜。然后该key/value对以及partitionIdx的结果都会被写入环形缓冲区。\n   - 溢写（Spill）：map输出写在内存中的环形缓冲区，默认当缓冲区满80%，启动溢写线程，将缓冲的数据写出到磁盘。\n     - Sort：在溢写到磁盘之前，使用快排对缓冲区数据按照partitionIdx, key排序。（每个partitionIdx表示一个分区，一个分区对应一个reduce）\n     - Combiner：如果设置了Combiner，那么在Sort之后，还会对具有相同key的键值对进行合并，减少溢写到磁盘的数据量。\n   - 合并（Merge）：溢写可能会生成多个文件，这时需要将多个文件合并成一个文件。合并的过程中会不断地进行 sort & combine 操作，最后合并成了一个已分区且已排序的文件。\n2. **Shuffle阶段**：广义上Shuffle阶段横跨Map端和Reduce端，在Map端包括Spill过程，在Reduce端包括copy和merge/sort过程。通常认为Shuffle阶段就是将map的输出作为reduce的输入的过程\n   - Copy过程：Reduce端启动一些copy线程，通过HTTP方式将map端输出文件中属于自己的部分拉取到本地。Reduce会从多个map端拉取数据，并且每个map的数据都是有序的。\n   - Merge过程：Copy过来的数据会先放入内存缓冲区中，这里的缓冲区比较大；当缓冲区数据量达到一定阈值时，将数据溢写到磁盘（与map端类似，溢写过程会执行 sort & combine）。如果生成了多个溢写文件，它们会被merge成一个**有序的最终文件**。这个过程也会不停地执行 sort & combine 操作。\n3. **Reduce阶段**：Shuffle阶段最终生成了一个有序的文件作为Reduce的输入，对于该文件中的每一个键值对调用`reduce()`方法，并将结果写到HDFS。\n\n参考《[了解MapReduce核心Shuff](http://www.aboutyun.com/thread-7078-1-1.html)","source":"_posts/大数据面试题.md","raw":"---\ntitle: 大数据面试题\ndate: 2020-01-15 16:42:00\ncategories: 大数据面试题\ntags: 大数据面试题\n---\n\n#  大数据面试题\n\n\n\n**1、你能简单描述一下Hbase吗？能画出它的架构图吗？**\n\n[hbase](http://lib.csdn.net/base/hbase)是一个面向列的 NoSQL 分布式[数据库](http://lib.csdn.net/base/mysql)，它利用HDFS作为底层存储系统。那么，HBase相对于传统的关系型数据库有什么不同呢？\n\n- HBase是schema-free的，它的列是可以动态增加的（仅仅定义列族），并且为空的列不占物理存储空间。\n- HBase是基于列存储的，每个列族都由几个文件保存，不同的列族的文件是分离的。\n- HBase自动切分数据，使得数据存储自动具有很好的横向扩展性。\n- HBase没有任何事务，提供了高并发读写操作的支持。\n\nHBase中的Table是一个稀疏的、多维度的、排序的映射表，这张表的索引是[RowKey, ColumnFamily, ColumnQualifier, Timestamp]，其中Timestamp表示版本，默认获取最新版本。HBase是通过RowKey来检索数据的，RowKey是Table设计的核心，它按照ASCII有序排序，因此应尽量避免顺序写入。RowKey设计应该注意三点：\n\n- 唯一原则：在HBase中rowkey可以看成是表的主键，必须保证其唯一性。\n- 散列原则：由于rowkey是按字典有序的，故应避免rowkey连续有序而导致在某一台RegionServer上堆积的现象。例如可以拼接随机数、将时间戳倒序等。\n- 长度原则：设计时RowKey要尽量短，这样可以提高有效数据的比例，节省存储空间，也可以提高查询的性能。\n\n下面是HBase的整体架构图：\n\n![img](http://img.blog.csdn.net/20160423184359154)\n\n**2、你说了解kafka，能简单描述一下Kafka吗？能画出它的架构图吗？**\n\nKafka是一个高吞吐、易扩展的分布式发布-订阅消息系统，它能够将消息持久化到磁盘，用于批量的消费。Kafka中有以下几个概念：\n\n- Topic：特指Kafka处理的消息源（feeds of messages）的不同分类。\n- Partition：Topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。\n- Broker：Kafa集群中包含一台或多台服务器，这种服务器被称为broker。\n- Producer：生产者，向Kafka的一个topic发布消息。\n- Consumers：消费者，从kafka的某个topic读取消息。\n\nKafka架构图如下：\n\n![img](http://img.blog.csdn.net/20160423204357095)\n\n详见：[Apache Kafka：下一代分布式消息系统](http://www.infoq.com/cn/articles/apache-kafka/)\n\n**3、请介绍你的一个亮点项目？你在其中做了什么？碰到了什么技术难点？**\n\n【解】介绍项目《九州卡牌》手游，我在项目中主要负责客户端逻辑与战斗效果的实现，以及网络通信模块的设计与开发。\n首先，对于网络通信我们选择使用**TCP长连接**，因为对于卡牌类手游可以容忍偶尔地延迟，并且有服务器主动给客户端推送消息的需求。\n优点：\n\n- 简单有效的长连接\n- 可靠的信息传输\n- 数据包的大小没有限制\n- 服务器可以主动向客户端推送消息（广播等）\n\n客户端每隔3s发送一次心跳包给服务器，通知服务器自己仍然在线，并获取服务器数据更新 —— 心跳包可以防止TCP的死连接问题，避免出现长时间不在线的死链接仍然出现在服务端的管理任务中。当客户端长时间切换到后台时，进程被挂起，连接会断开。\nTCP协议本身就有keep-alive机制，为什么还要在应用层实现自己的心跳检测机制呢？\n\n- TCP的keep-alive机制可能在短暂的网络异常中，将一个良好的连接给断开；\n- keep-alive设计初衷是清除和回收死亡时间长的连接，不适合实时性高的场合，而且它会先要求连接一定时间内没有活动，周期长，这样其实已经断开很长一段时间，没有及时性；\n- keep-alive不能主动通知应用层；\n- 另外，想要通过心跳包来获取服务器的数据更新，所以选择自己在应用层实现；\n\n还有一个问题就是一台机器的连接数有限制，可以通过**滚服**或者**分布式**来解决。\n\n- **滚服：**指老的服务器连接数达到上限了，就开新的服务区，不同服务区的用户不能交互。\n- **分布式：**长连接不分服的话，可以多个cluster节点连接同样的CACHE数据源，只是跨节点进行通信比较麻烦一点（如用户A连接到节点1，用户B连接到节点2，用户A向节点1发起TCP请求处理业务需要再通知到节点2的用户B）。一般来说有2种解决方案： \n  ①是建立场景服务器，即专门用一个socket server来保持所有玩家的连接，然后它只处理数据推送，不做业务，可以达到10-20W承载；②是采用发布订阅方式实现节点间的实时通信。\n\n我在[Linux](http://lib.csdn.net/base/linux)下写了一个**Socket心跳包示例程序**，见文《[TCP socket心跳包示例程序](http://blog.csdn.net/lisonglisonglisong/article/details/51327695)》。\n\n**4、请介绍一下MapReduce的工作原理。**\n\n【解】MapReduce是一个分布式计算框架，用于大规模数据集的并行运算。简单地说，MapReduce就是”任务的分解与结果的汇总”：将一个大的数据处理任务划分成许多个子任务，并将这些子任务分配给各个节点并行处理，然后通过整合各个节点的中间结果，得到最终结果。\n\nMapReduce是主从架构，在master上跑的是JobTracker/ResourceManager，负责资源分配与任务调度；而各个slave上跑的是TaskTracker/NodeManager，负责执行任务，并定期向master汇报最新状态与执行进度。\n\n对于一个MR任务，它的输入、输出以及中间结果都是`<key, value>`键值对：\n\n- Map：`<k1, v1>` ——> `list(<k2, v2>)`\n- Reduce：`<k2, list(v2)>` ——> `list(<k3, v3>)`\n\nMR程序的执行过程主要分为三步：Map阶段、Shuffle阶段、Reduce阶段，如下图：\n\n![img](http://img.blog.csdn.net/20160811132825039)\n\n1. **Map阶段**\n   - 分片（Split）：map阶段的输入通常是HDFS上文件，在运行Mapper前，FileInputFormat会将输入文件分割成多个split ——1个split至少包含1个HDFS的Block（默认为64M）；然后每一个分片运行一个map进行处理。\n   - 执行（Map）：对输入分片中的每个键值对调用`map()`函数进行运算，然后输出一个结果键值对。\n     - Partitioner：对 map 函数的输出进行partition，即根据key或value及reduce的数量来决定当前的这对键值对最终应该交由哪个reduce处理。默认是对key哈希后再以reduce task数量取模，默认的取模方式只是为了避免数据倾斜。然后该key/value对以及partitionIdx的结果都会被写入环形缓冲区。\n   - 溢写（Spill）：map输出写在内存中的环形缓冲区，默认当缓冲区满80%，启动溢写线程，将缓冲的数据写出到磁盘。\n     - Sort：在溢写到磁盘之前，使用快排对缓冲区数据按照partitionIdx, key排序。（每个partitionIdx表示一个分区，一个分区对应一个reduce）\n     - Combiner：如果设置了Combiner，那么在Sort之后，还会对具有相同key的键值对进行合并，减少溢写到磁盘的数据量。\n   - 合并（Merge）：溢写可能会生成多个文件，这时需要将多个文件合并成一个文件。合并的过程中会不断地进行 sort & combine 操作，最后合并成了一个已分区且已排序的文件。\n2. **Shuffle阶段**：广义上Shuffle阶段横跨Map端和Reduce端，在Map端包括Spill过程，在Reduce端包括copy和merge/sort过程。通常认为Shuffle阶段就是将map的输出作为reduce的输入的过程\n   - Copy过程：Reduce端启动一些copy线程，通过HTTP方式将map端输出文件中属于自己的部分拉取到本地。Reduce会从多个map端拉取数据，并且每个map的数据都是有序的。\n   - Merge过程：Copy过来的数据会先放入内存缓冲区中，这里的缓冲区比较大；当缓冲区数据量达到一定阈值时，将数据溢写到磁盘（与map端类似，溢写过程会执行 sort & combine）。如果生成了多个溢写文件，它们会被merge成一个**有序的最终文件**。这个过程也会不停地执行 sort & combine 操作。\n3. **Reduce阶段**：Shuffle阶段最终生成了一个有序的文件作为Reduce的输入，对于该文件中的每一个键值对调用`reduce()`方法，并将结果写到HDFS。\n\n参考《[了解MapReduce核心Shuff](http://www.aboutyun.com/thread-7078-1-1.html)","slug":"大数据面试题","published":1,"updated":"2020-03-18T11:52:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8o1haaz000v13s66l977a3g","content":"<h1 id=\"大数据面试题\"><a href=\"#大数据面试题\" class=\"headerlink\" title=\"大数据面试题\"></a>大数据面试题</h1><p><strong>1、你能简单描述一下Hbase吗？能画出它的架构图吗？</strong></p>\n<p><a href=\"http://lib.csdn.net/base/hbase\" target=\"_blank\" rel=\"noopener\">hbase</a>是一个面向列的 NoSQL 分布式<a href=\"http://lib.csdn.net/base/mysql\" target=\"_blank\" rel=\"noopener\">数据库</a>，它利用HDFS作为底层存储系统。那么，HBase相对于传统的关系型数据库有什么不同呢？</p>\n<ul>\n<li>HBase是schema-free的，它的列是可以动态增加的（仅仅定义列族），并且为空的列不占物理存储空间。</li>\n<li>HBase是基于列存储的，每个列族都由几个文件保存，不同的列族的文件是分离的。</li>\n<li>HBase自动切分数据，使得数据存储自动具有很好的横向扩展性。</li>\n<li>HBase没有任何事务，提供了高并发读写操作的支持。</li>\n</ul>\n<p>HBase中的Table是一个稀疏的、多维度的、排序的映射表，这张表的索引是[RowKey, ColumnFamily, ColumnQualifier, Timestamp]，其中Timestamp表示版本，默认获取最新版本。HBase是通过RowKey来检索数据的，RowKey是Table设计的核心，它按照ASCII有序排序，因此应尽量避免顺序写入。RowKey设计应该注意三点：</p>\n<ul>\n<li>唯一原则：在HBase中rowkey可以看成是表的主键，必须保证其唯一性。</li>\n<li>散列原则：由于rowkey是按字典有序的，故应避免rowkey连续有序而导致在某一台RegionServer上堆积的现象。例如可以拼接随机数、将时间戳倒序等。</li>\n<li>长度原则：设计时RowKey要尽量短，这样可以提高有效数据的比例，节省存储空间，也可以提高查询的性能。</li>\n</ul>\n<p>下面是HBase的整体架构图：</p>\n<p><img src=\"http://img.blog.csdn.net/20160423184359154\" alt=\"img\"></p>\n<p><strong>2、你说了解kafka，能简单描述一下Kafka吗？能画出它的架构图吗？</strong></p>\n<p>Kafka是一个高吞吐、易扩展的分布式发布-订阅消息系统，它能够将消息持久化到磁盘，用于批量的消费。Kafka中有以下几个概念：</p>\n<ul>\n<li>Topic：特指Kafka处理的消息源（feeds of messages）的不同分类。</li>\n<li>Partition：Topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。</li>\n<li>Broker：Kafa集群中包含一台或多台服务器，这种服务器被称为broker。</li>\n<li>Producer：生产者，向Kafka的一个topic发布消息。</li>\n<li>Consumers：消费者，从kafka的某个topic读取消息。</li>\n</ul>\n<p>Kafka架构图如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20160423204357095\" alt=\"img\"></p>\n<p>详见：<a href=\"http://www.infoq.com/cn/articles/apache-kafka/\" target=\"_blank\" rel=\"noopener\">Apache Kafka：下一代分布式消息系统</a></p>\n<p><strong>3、请介绍你的一个亮点项目？你在其中做了什么？碰到了什么技术难点？</strong></p>\n<p>【解】介绍项目《九州卡牌》手游，我在项目中主要负责客户端逻辑与战斗效果的实现，以及网络通信模块的设计与开发。<br>首先，对于网络通信我们选择使用<strong>TCP长连接</strong>，因为对于卡牌类手游可以容忍偶尔地延迟，并且有服务器主动给客户端推送消息的需求。<br>优点：</p>\n<ul>\n<li>简单有效的长连接</li>\n<li>可靠的信息传输</li>\n<li>数据包的大小没有限制</li>\n<li>服务器可以主动向客户端推送消息（广播等）</li>\n</ul>\n<p>客户端每隔3s发送一次心跳包给服务器，通知服务器自己仍然在线，并获取服务器数据更新 —— 心跳包可以防止TCP的死连接问题，避免出现长时间不在线的死链接仍然出现在服务端的管理任务中。当客户端长时间切换到后台时，进程被挂起，连接会断开。<br>TCP协议本身就有keep-alive机制，为什么还要在应用层实现自己的心跳检测机制呢？</p>\n<ul>\n<li>TCP的keep-alive机制可能在短暂的网络异常中，将一个良好的连接给断开；</li>\n<li>keep-alive设计初衷是清除和回收死亡时间长的连接，不适合实时性高的场合，而且它会先要求连接一定时间内没有活动，周期长，这样其实已经断开很长一段时间，没有及时性；</li>\n<li>keep-alive不能主动通知应用层；</li>\n<li>另外，想要通过心跳包来获取服务器的数据更新，所以选择自己在应用层实现；</li>\n</ul>\n<p>还有一个问题就是一台机器的连接数有限制，可以通过<strong>滚服</strong>或者<strong>分布式</strong>来解决。</p>\n<ul>\n<li><strong>滚服：</strong>指老的服务器连接数达到上限了，就开新的服务区，不同服务区的用户不能交互。</li>\n<li><strong>分布式：</strong>长连接不分服的话，可以多个cluster节点连接同样的CACHE数据源，只是跨节点进行通信比较麻烦一点（如用户A连接到节点1，用户B连接到节点2，用户A向节点1发起TCP请求处理业务需要再通知到节点2的用户B）。一般来说有2种解决方案：<br>①是建立场景服务器，即专门用一个socket server来保持所有玩家的连接，然后它只处理数据推送，不做业务，可以达到10-20W承载；②是采用发布订阅方式实现节点间的实时通信。</li>\n</ul>\n<p>我在<a href=\"http://lib.csdn.net/base/linux\" target=\"_blank\" rel=\"noopener\">Linux</a>下写了一个<strong>Socket心跳包示例程序</strong>，见文《<a href=\"http://blog.csdn.net/lisonglisonglisong/article/details/51327695\" target=\"_blank\" rel=\"noopener\">TCP socket心跳包示例程序</a>》。</p>\n<p><strong>4、请介绍一下MapReduce的工作原理。</strong></p>\n<p>【解】MapReduce是一个分布式计算框架，用于大规模数据集的并行运算。简单地说，MapReduce就是”任务的分解与结果的汇总”：将一个大的数据处理任务划分成许多个子任务，并将这些子任务分配给各个节点并行处理，然后通过整合各个节点的中间结果，得到最终结果。</p>\n<p>MapReduce是主从架构，在master上跑的是JobTracker/ResourceManager，负责资源分配与任务调度；而各个slave上跑的是TaskTracker/NodeManager，负责执行任务，并定期向master汇报最新状态与执行进度。</p>\n<p>对于一个MR任务，它的输入、输出以及中间结果都是<code>&lt;key, value&gt;</code>键值对：</p>\n<ul>\n<li>Map：<code>&lt;k1, v1&gt;</code> ——&gt; <code>list(&lt;k2, v2&gt;)</code></li>\n<li>Reduce：<code>&lt;k2, list(v2)&gt;</code> ——&gt; <code>list(&lt;k3, v3&gt;)</code></li>\n</ul>\n<p>MR程序的执行过程主要分为三步：Map阶段、Shuffle阶段、Reduce阶段，如下图：</p>\n<p><img src=\"http://img.blog.csdn.net/20160811132825039\" alt=\"img\"></p>\n<ol>\n<li><strong>Map阶段</strong><ul>\n<li>分片（Split）：map阶段的输入通常是HDFS上文件，在运行Mapper前，FileInputFormat会将输入文件分割成多个split ——1个split至少包含1个HDFS的Block（默认为64M）；然后每一个分片运行一个map进行处理。</li>\n<li>执行（Map）：对输入分片中的每个键值对调用<code>map()</code>函数进行运算，然后输出一个结果键值对。<ul>\n<li>Partitioner：对 map 函数的输出进行partition，即根据key或value及reduce的数量来决定当前的这对键值对最终应该交由哪个reduce处理。默认是对key哈希后再以reduce task数量取模，默认的取模方式只是为了避免数据倾斜。然后该key/value对以及partitionIdx的结果都会被写入环形缓冲区。</li>\n</ul>\n</li>\n<li>溢写（Spill）：map输出写在内存中的环形缓冲区，默认当缓冲区满80%，启动溢写线程，将缓冲的数据写出到磁盘。<ul>\n<li>Sort：在溢写到磁盘之前，使用快排对缓冲区数据按照partitionIdx, key排序。（每个partitionIdx表示一个分区，一个分区对应一个reduce）</li>\n<li>Combiner：如果设置了Combiner，那么在Sort之后，还会对具有相同key的键值对进行合并，减少溢写到磁盘的数据量。</li>\n</ul>\n</li>\n<li>合并（Merge）：溢写可能会生成多个文件，这时需要将多个文件合并成一个文件。合并的过程中会不断地进行 sort &amp; combine 操作，最后合并成了一个已分区且已排序的文件。</li>\n</ul>\n</li>\n<li><strong>Shuffle阶段</strong>：广义上Shuffle阶段横跨Map端和Reduce端，在Map端包括Spill过程，在Reduce端包括copy和merge/sort过程。通常认为Shuffle阶段就是将map的输出作为reduce的输入的过程<ul>\n<li>Copy过程：Reduce端启动一些copy线程，通过HTTP方式将map端输出文件中属于自己的部分拉取到本地。Reduce会从多个map端拉取数据，并且每个map的数据都是有序的。</li>\n<li>Merge过程：Copy过来的数据会先放入内存缓冲区中，这里的缓冲区比较大；当缓冲区数据量达到一定阈值时，将数据溢写到磁盘（与map端类似，溢写过程会执行 sort &amp; combine）。如果生成了多个溢写文件，它们会被merge成一个<strong>有序的最终文件</strong>。这个过程也会不停地执行 sort &amp; combine 操作。</li>\n</ul>\n</li>\n<li><strong>Reduce阶段</strong>：Shuffle阶段最终生成了一个有序的文件作为Reduce的输入，对于该文件中的每一个键值对调用<code>reduce()</code>方法，并将结果写到HDFS。</li>\n</ol>\n<p>参考《<a href=\"http://www.aboutyun.com/thread-7078-1-1.html\" target=\"_blank\" rel=\"noopener\">了解MapReduce核心Shuff</a></p>\n","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<h1 id=\"大数据面试题\"><a href=\"#大数据面试题\" class=\"headerlink\" title=\"大数据面试题\"></a>大数据面试题</h1><p><strong>1、你能简单描述一下Hbase吗？能画出它的架构图吗？</strong></p>\n<p><a href=\"http://lib.csdn.net/base/hbase\" target=\"_blank\" rel=\"noopener\">hbase</a>是一个面向列的 NoSQL 分布式<a href=\"http://lib.csdn.net/base/mysql\" target=\"_blank\" rel=\"noopener\">数据库</a>，它利用HDFS作为底层存储系统。那么，HBase相对于传统的关系型数据库有什么不同呢？</p>\n<ul>\n<li>HBase是schema-free的，它的列是可以动态增加的（仅仅定义列族），并且为空的列不占物理存储空间。</li>\n<li>HBase是基于列存储的，每个列族都由几个文件保存，不同的列族的文件是分离的。</li>\n<li>HBase自动切分数据，使得数据存储自动具有很好的横向扩展性。</li>\n<li>HBase没有任何事务，提供了高并发读写操作的支持。</li>\n</ul>\n<p>HBase中的Table是一个稀疏的、多维度的、排序的映射表，这张表的索引是[RowKey, ColumnFamily, ColumnQualifier, Timestamp]，其中Timestamp表示版本，默认获取最新版本。HBase是通过RowKey来检索数据的，RowKey是Table设计的核心，它按照ASCII有序排序，因此应尽量避免顺序写入。RowKey设计应该注意三点：</p>\n<ul>\n<li>唯一原则：在HBase中rowkey可以看成是表的主键，必须保证其唯一性。</li>\n<li>散列原则：由于rowkey是按字典有序的，故应避免rowkey连续有序而导致在某一台RegionServer上堆积的现象。例如可以拼接随机数、将时间戳倒序等。</li>\n<li>长度原则：设计时RowKey要尽量短，这样可以提高有效数据的比例，节省存储空间，也可以提高查询的性能。</li>\n</ul>\n<p>下面是HBase的整体架构图：</p>\n<p><img src=\"http://img.blog.csdn.net/20160423184359154\" alt=\"img\"></p>\n<p><strong>2、你说了解kafka，能简单描述一下Kafka吗？能画出它的架构图吗？</strong></p>\n<p>Kafka是一个高吞吐、易扩展的分布式发布-订阅消息系统，它能够将消息持久化到磁盘，用于批量的消费。Kafka中有以下几个概念：</p>\n<ul>\n<li>Topic：特指Kafka处理的消息源（feeds of messages）的不同分类。</li>\n<li>Partition：Topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。</li>\n<li>Broker：Kafa集群中包含一台或多台服务器，这种服务器被称为broker。</li>\n<li>Producer：生产者，向Kafka的一个topic发布消息。</li>\n<li>Consumers：消费者，从kafka的某个topic读取消息。</li>\n</ul>\n<p>Kafka架构图如下：</p>\n<p><img src=\"http://img.blog.csdn.net/20160423204357095\" alt=\"img\"></p>\n<p>详见：<a href=\"http://www.infoq.com/cn/articles/apache-kafka/\" target=\"_blank\" rel=\"noopener\">Apache Kafka：下一代分布式消息系统</a></p>\n<p><strong>3、请介绍你的一个亮点项目？你在其中做了什么？碰到了什么技术难点？</strong></p>\n<p>【解】介绍项目《九州卡牌》手游，我在项目中主要负责客户端逻辑与战斗效果的实现，以及网络通信模块的设计与开发。<br>首先，对于网络通信我们选择使用<strong>TCP长连接</strong>，因为对于卡牌类手游可以容忍偶尔地延迟，并且有服务器主动给客户端推送消息的需求。<br>优点：</p>\n<ul>\n<li>简单有效的长连接</li>\n<li>可靠的信息传输</li>\n<li>数据包的大小没有限制</li>\n<li>服务器可以主动向客户端推送消息（广播等）</li>\n</ul>\n<p>客户端每隔3s发送一次心跳包给服务器，通知服务器自己仍然在线，并获取服务器数据更新 —— 心跳包可以防止TCP的死连接问题，避免出现长时间不在线的死链接仍然出现在服务端的管理任务中。当客户端长时间切换到后台时，进程被挂起，连接会断开。<br>TCP协议本身就有keep-alive机制，为什么还要在应用层实现自己的心跳检测机制呢？</p>\n<ul>\n<li>TCP的keep-alive机制可能在短暂的网络异常中，将一个良好的连接给断开；</li>\n<li>keep-alive设计初衷是清除和回收死亡时间长的连接，不适合实时性高的场合，而且它会先要求连接一定时间内没有活动，周期长，这样其实已经断开很长一段时间，没有及时性；</li>\n<li>keep-alive不能主动通知应用层；</li>\n<li>另外，想要通过心跳包来获取服务器的数据更新，所以选择自己在应用层实现；</li>\n</ul>\n<p>还有一个问题就是一台机器的连接数有限制，可以通过<strong>滚服</strong>或者<strong>分布式</strong>来解决。</p>\n<ul>\n<li><strong>滚服：</strong>指老的服务器连接数达到上限了，就开新的服务区，不同服务区的用户不能交互。</li>\n<li><strong>分布式：</strong>长连接不分服的话，可以多个cluster节点连接同样的CACHE数据源，只是跨节点进行通信比较麻烦一点（如用户A连接到节点1，用户B连接到节点2，用户A向节点1发起TCP请求处理业务需要再通知到节点2的用户B）。一般来说有2种解决方案：<br>①是建立场景服务器，即专门用一个socket server来保持所有玩家的连接，然后它只处理数据推送，不做业务，可以达到10-20W承载；②是采用发布订阅方式实现节点间的实时通信。</li>\n</ul>\n<p>我在<a href=\"http://lib.csdn.net/base/linux\" target=\"_blank\" rel=\"noopener\">Linux</a>下写了一个<strong>Socket心跳包示例程序</strong>，见文《<a href=\"http://blog.csdn.net/lisonglisonglisong/article/details/51327695\" target=\"_blank\" rel=\"noopener\">TCP socket心跳包示例程序</a>》。</p>\n<p><strong>4、请介绍一下MapReduce的工作原理。</strong></p>\n<p>【解】MapReduce是一个分布式计算框架，用于大规模数据集的并行运算。简单地说，MapReduce就是”任务的分解与结果的汇总”：将一个大的数据处理任务划分成许多个子任务，并将这些子任务分配给各个节点并行处理，然后通过整合各个节点的中间结果，得到最终结果。</p>\n<p>MapReduce是主从架构，在master上跑的是JobTracker/ResourceManager，负责资源分配与任务调度；而各个slave上跑的是TaskTracker/NodeManager，负责执行任务，并定期向master汇报最新状态与执行进度。</p>\n<p>对于一个MR任务，它的输入、输出以及中间结果都是<code>&lt;key, value&gt;</code>键值对：</p>\n<ul>\n<li>Map：<code>&lt;k1, v1&gt;</code> ——&gt; <code>list(&lt;k2, v2&gt;)</code></li>\n<li>Reduce：<code>&lt;k2, list(v2)&gt;</code> ——&gt; <code>list(&lt;k3, v3&gt;)</code></li>\n</ul>\n<p>MR程序的执行过程主要分为三步：Map阶段、Shuffle阶段、Reduce阶段，如下图：</p>\n<p><img src=\"http://img.blog.csdn.net/20160811132825039\" alt=\"img\"></p>\n<ol>\n<li><strong>Map阶段</strong><ul>\n<li>分片（Split）：map阶段的输入通常是HDFS上文件，在运行Mapper前，FileInputFormat会将输入文件分割成多个split ——1个split至少包含1个HDFS的Block（默认为64M）；然后每一个分片运行一个map进行处理。</li>\n<li>执行（Map）：对输入分片中的每个键值对调用<code>map()</code>函数进行运算，然后输出一个结果键值对。<ul>\n<li>Partitioner：对 map 函数的输出进行partition，即根据key或value及reduce的数量来决定当前的这对键值对最终应该交由哪个reduce处理。默认是对key哈希后再以reduce task数量取模，默认的取模方式只是为了避免数据倾斜。然后该key/value对以及partitionIdx的结果都会被写入环形缓冲区。</li>\n</ul>\n</li>\n<li>溢写（Spill）：map输出写在内存中的环形缓冲区，默认当缓冲区满80%，启动溢写线程，将缓冲的数据写出到磁盘。<ul>\n<li>Sort：在溢写到磁盘之前，使用快排对缓冲区数据按照partitionIdx, key排序。（每个partitionIdx表示一个分区，一个分区对应一个reduce）</li>\n<li>Combiner：如果设置了Combiner，那么在Sort之后，还会对具有相同key的键值对进行合并，减少溢写到磁盘的数据量。</li>\n</ul>\n</li>\n<li>合并（Merge）：溢写可能会生成多个文件，这时需要将多个文件合并成一个文件。合并的过程中会不断地进行 sort &amp; combine 操作，最后合并成了一个已分区且已排序的文件。</li>\n</ul>\n</li>\n<li><strong>Shuffle阶段</strong>：广义上Shuffle阶段横跨Map端和Reduce端，在Map端包括Spill过程，在Reduce端包括copy和merge/sort过程。通常认为Shuffle阶段就是将map的输出作为reduce的输入的过程<ul>\n<li>Copy过程：Reduce端启动一些copy线程，通过HTTP方式将map端输出文件中属于自己的部分拉取到本地。Reduce会从多个map端拉取数据，并且每个map的数据都是有序的。</li>\n<li>Merge过程：Copy过来的数据会先放入内存缓冲区中，这里的缓冲区比较大；当缓冲区数据量达到一定阈值时，将数据溢写到磁盘（与map端类似，溢写过程会执行 sort &amp; combine）。如果生成了多个溢写文件，它们会被merge成一个<strong>有序的最终文件</strong>。这个过程也会不停地执行 sort &amp; combine 操作。</li>\n</ul>\n</li>\n<li><strong>Reduce阶段</strong>：Shuffle阶段最终生成了一个有序的文件作为Reduce的输入，对于该文件中的每一个键值对调用<code>reduce()</code>方法，并将结果写到HDFS。</li>\n</ol>\n<p>参考《<a href=\"http://www.aboutyun.com/thread-7078-1-1.html\" target=\"_blank\" rel=\"noopener\">了解MapReduce核心Shuff</a></p>\n"},{"title":"手撕Spark之WordCount RDD执行流程","date":"2019-12-18T02:03:14.000Z","_content":"\n##  手撕Spark之WordCount RDD执行流程\n\n[TOC]\n\n\n\n### 写在前面\n\n一个Spark程序在初始化的时候会构造DAGScheduler、TaskSchedulerImpl、MapOutTrackerMaster等对象，DAGScheduler主要负责生成DAG、启动Job、提交Stage等操作，TaskSchedulerImpl主要负责Task Set的添加调度等，MapOutTrackerMaster主要负责数据的Shuffle等，这里不再赘述。\n\n**注意几个概念：**\n\n- Application   //一个Spark程序会有一个Application，也就拥有了唯一的一个applicationId\n- Job    //调用Action 算子 触发runJob，触发一次runJob就会产生一个Job\n- Stage  //遇到一次宽依赖就会生成一个Stage\n- Task  //Spark程序运行的最小单元\n\n> 注：一个Spark程序会有1个Application，会有1～N 个Job，会有1～N 个Stage，会有1～N 个Task\n>\n> 1 Application = [1 ~ N  ] Job\n> 1 Job = [ 1 ~ N ] Stage\n> 1 Stage = [ 1 ~ N ] Task\n>\n> Stage数 = Shuffle数 +1\n\n\n\n### 软件环境\n\n+ Spark：2.3.0\n\n### 代码\n\n写一个简单的WordCount计算代码\n\ndata.txt\n\n~~~txt\nhello world\nhello java\nhello scala\nhello hadoop\nhello spark\n~~~\n\nWCAnalyzer.scala\n\n~~~scala\n\n    //设置日志输出级别，便于观察日志\n    Logger.getLogger(\"org.apache\").setLevel(Level.ALL)\n\n    //创建sc\n    val sc = new SparkContext(new SparkConf().setMaster(\"local[1]\")\n                              .setAppName(\"WCAnalyzer\"))\n\n    //从文件读取数据\n    sc.textFile(\"data/data.txt\", 1)\n      //将数据按照空格进行切分（切分出单个单词）\n      .flatMap(_.split(\" \"))\n      //将每个单词和1组成一个Tuple\n      .map((_, 1))\n      //按照相同的单词进行聚合\n      .reduceByKey(_ + _)\n      //将聚合后的结果将（key，value）数据进行倒置 转换成（value，key）便于排序\n      .map(v => (v._2, v._1))\n      //按照聚合后的单词数量进行降序排序\n      .sortByKey(false)\n      //将排序后的数据进行倒置\n      .map(v => (v._2, v._1))\n      //将数据收集到driver\n      .collect()\n      //输出数据\n      .foreach(println)\n\n    //关闭sc\n    sc.stop()\n  }\n~~~\n\n\n\n### 过程分析\n\n本代码只会生成一个Job，3个Stage，8个RDD。\n\n+ 划分Stage\n\n  Stage的划分要从后向前，每遇到一次宽依赖就划分一个Stage，因此这个简单的WC代码可以分为3个Stage，分别是由textFile、flatMap、map算子组成的第一个Stage 0；由reduceByKey、map算子组成的Stage 1；由sortByKey、map算子组成的Stage 2。\n\n+ RDD的生成 \n\n  textFile（HadoopRDD [0] ，MapPartitionsRDD [1] ）  //[ ] 内为该rdd的序号\n\n  flatMap（MapPartitionsRDD [2] ）\n\n  map（MapPartitionsRDD [3] ）\n\n  reduceByKey（ShuffledRDD [4] ）\n\n  map（MapPartitionsRDD [5] ）\n\n  sortByKey（ShuffledRDD [6] ）\n\n  map （MapPartitionsRDD [7] ）\n\n+ 日志分析\n\n    ~~~txt\n    org.apache.spark.SparkContext                     - Starting job: collect at WCAnalyzer.scala:34\n    ~~~\n    由collect算子触发runJob 启动一个Job，代码中的`foreach(println)`其中`foreach`并不是RDD中的算子，因此不会触发runJob，也就不会生成一个Job\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler           - Got job 0 (collect at WCAnalyzer.scala:34) with 1 output partitions\n    ~~~\n\n    \t生成一个Job 0 ，这个Job是由collect算子生成，在代码第34行，有一个分区\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler          - Final stage: ResultStage 2 (collect at WCAnalyzer.scala:34)\n    org.apache.spark.scheduler.DAGScheduler          - Parents of final stage: List(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - Missing parents: List(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List(ShuffleMapStage 0)\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 0)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List()\n    ~~~\n\n    Job 的Final Stage 为ResultStage 0，ResultStage 的父依赖为ShuffleMapStage 1，遗留的父依赖为ShuffleMapStage 1。\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - submitStage(ResultStage 2)\n    ~~~\n\n    尝试提交ResultStage 2\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - missing: List(ShuffleMapStage 1)\n    ~~~\n\n    遗留一个ShuffleMapStage 1\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - submitStage(ShuffleMapStage 1)\n    ~~~\n\n    尝试提交ShuffleMapStage 1\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - missing: List(ShuffleMapStage 0)\n    ~~~\n\n    遗留一个ShuffleMapStage 0\n\n     ~~~txt\n      org.apache.spark.scheduler.DAGScheduler         - submitStage(ShuffleMapStage 0)\n     ~~~\n    \n     尝试提交ShuffleMapStage 0\n    \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - missing: List()\n    ~~~\n  \n    没有遗留的Stage\n  \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - Submitting ShuffleMapStage 0 (MapPartitionsRDD[3] at map at WCAnalyzer.scala:24), which has no missing parents\n    ~~~\n  \n    提交ShuffleMapStage 0，该Stage的最后一个RDD是MapPartitionsRDD[3]，是由map算子生成，在代码第24行\n  \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - submitMissingTasks(ShuffleMapStage 0)\n    ~~~\n  \n    提交Tasks，一个Stage就是一个Task Set集合\n  \n    ~~~txt\n    org.apache.spark.scheduler.TaskSchedulerImpl    - Adding task set 0.0 with 1 tasks\n    ~~~\n    TaskSchedulerImpl 调度器添加一个Task Set集合\n  \n    ~~~txt\n    org.apache.spark.scheduler.TaskSetManager       - Starting task 0.0 in stage 0.0 (TID 0, localhost, executor driver, partition 0, PROCESS_LOCAL, 7909 bytes)\n    ~~~\n  \n    TaskSetManager 启动stage 0.0 中的task 0.0（taskid=0.0，host=localhost，executor=driver，partition=0，taskLocality=PROCESS_LOCAL，serializedTask=7909 bytes\n  \n    ~~~txt\n    org.apache.spark.executor.Executor              - Running task 0.0 in stage 0.0 (TID 0)\n    ~~~\n  \n    Executor 端运行task\n  \n    ~~~txt\n    org.apache.spark.executor.Executor              - Finished task 0.0 in stage 0.0 (TID 0). 1159 bytes result sent to driver\n    ~~~\n  \n    Executor 端 运行完成task，将序列化后大小为1159 bytes结果数据发送回driver端\n  \n    ~~~txt\n    org.apache.spark.scheduler.TaskSetManager       - Finished task 0.0 in stage 0.0 (TID 0) in 194 ms on localhost (executor driver) (1/1)\n    ~~~\n  \n    TaskSetManager 运行完task  完成task数量／总攻task数量\n  \n    ~~~txt\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 0.0, whose tasks have all completed, from pool \n    ~~~\n  \n    TaskSchedulerImpl 移除TaskSet 集合\n  \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler          - ShuffleMapTask finished on driver\n    ~~~\n  \n    DAGScheduler 完成ShuffleMapTask 的计算\n  \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler          - ShuffleMapStage 0 (map at WCAnalyzer.scala:24) finished in 0.289 s\n    ~~~\n  \n    DAGScheduler 完成ShuffleMapStage 的计算，用时共 0.289 s\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler          - looking for newly runnable stages\n    org.apache.spark.scheduler.DAGScheduler          - running: Set()\n    org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ShuffleMapStage 1, ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n    org.apache.spark.MapOutputTrackerMaster          - Increasing epoch to 1\n    org.apache.spark.scheduler.DAGScheduler          - Checking if any dependencies of ShuffleMapStage 0 are now runnable\n    org.apache.spark.scheduler.DAGScheduler          - running: Set()\n    org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ShuffleMapStage 1, ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n    ~~~\n    \n    Stage在计算完后，DAGScheduler会查询是否还有未完成的计算，直到有新的Stage提交\n    \n    ~~~txt\n    ============================   ShuffleMapStage 1 的提交计算过程  ==========================\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List()\n    org.apache.spark.scheduler.DAGScheduler          - Submitting ShuffleMapStage 1 (MapPartitionsRDD[5] at map at WCAnalyzer.scala:28), which has no missing parents\n    org.apache.spark.scheduler.DAGScheduler          - submitMissingTasks(ShuffleMapStage 1)\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Adding task set 1.0 with 1 tasks\n    org.apache.spark.scheduler.TaskSetManager        - Starting task 0.0 in stage 1.0 (TID 1, localhost, executor driver, partition 0, ANY, 7638 bytes)\n    org.apache.spark.executor.Executor               - Running task 0.0 in stage 1.0 (TID 1)\n    org.apache.spark.executor.Executor               - Finished task 0.0 in stage 1.0 (TID 1). 1331 bytes result sent to driver\n    org.apache.spark.scheduler.TaskSetManager        - Finished task 0.0 in stage 1.0 (TID 1) in 102 ms on localhost (executor driver) (1/1)\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 1.0, whose tasks have all completed, from pool \n    org.apache.spark.scheduler.DAGScheduler          - ShuffleMapTask finished on driver\n    org.apache.spark.scheduler.DAGScheduler          - ShuffleMapStage 1 (map at WCAnalyzer.scala:28) finished in 0.117 s\n    ============================   ResultStage 2 的提交计算过程  =============================\n    org.apache.spark.scheduler.DAGScheduler          - looking for newly runnable stages\n    org.apache.spark.scheduler.DAGScheduler          - running: Set()\n    org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n    org.apache.spark.MapOutputTrackerMaster          - Increasing epoch to 2\n    org.apache.spark.scheduler.DAGScheduler          - Checking if any dependencies of ShuffleMapStage 1 are now runnable\n    org.apache.spark.scheduler.DAGScheduler          - running: Set()\n    org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List()\n    org.apache.spark.scheduler.DAGScheduler          - Submitting ResultStage 2 (MapPartitionsRDD[7] at map at WCAnalyzer.scala:32), which has no missing parents\n    org.apache.spark.scheduler.DAGScheduler          - submitMissingTasks(ResultStage 2)\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Adding task set 2.0 with 1 tasks\n    org.apache.spark.scheduler.TaskSetManager        - Starting task 0.0 in stage 2.0 (TID 2, localhost, executor driver, partition 0, ANY, 7649 bytes)\n    org.apache.spark.executor.Executor               - Running task 0.0 in stage 2.0 (TID 2)\n    org.apache.spark.executor.Executor               - Finished task 0.0 in stage 2.0 (TID 2). 1387 bytes result sent to driver\n    org.apache.spark.scheduler.TaskSetManager        - Finished task 0.0 in stage 2.0 (TID 2) in 44 ms on localhost (executor driver) (1/1)\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 2.0, whose tasks have all completed, from pool \n    org.apache.spark.scheduler.DAGScheduler          - ResultStage 2 (collect at WCAnalyzer.scala:34) finished in 0.057 s\n    ~~~\n    \n    以上是ShuffleMapStage 1和ResultStage 2的提交计算过程，与ShuffleMapStage 0一样，不再赘述\n    \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - Job 0 finished: collect at WCAnalyzer.scala:34, took 0.770898 s\n    ~~~\n    \n    DAGScheduler 当所有的Stage 提交计算完成 结束Job\n\n\n\n\n","source":"_posts/手撕Spark之WordCount RDD执行流程.md","raw":"---\ntitle: 手撕Spark之WordCount RDD执行流程\ndate: 2019-12-18 10:03:14\ncategories: Spark\ntags: Spark\n---\n\n##  手撕Spark之WordCount RDD执行流程\n\n[TOC]\n\n\n\n### 写在前面\n\n一个Spark程序在初始化的时候会构造DAGScheduler、TaskSchedulerImpl、MapOutTrackerMaster等对象，DAGScheduler主要负责生成DAG、启动Job、提交Stage等操作，TaskSchedulerImpl主要负责Task Set的添加调度等，MapOutTrackerMaster主要负责数据的Shuffle等，这里不再赘述。\n\n**注意几个概念：**\n\n- Application   //一个Spark程序会有一个Application，也就拥有了唯一的一个applicationId\n- Job    //调用Action 算子 触发runJob，触发一次runJob就会产生一个Job\n- Stage  //遇到一次宽依赖就会生成一个Stage\n- Task  //Spark程序运行的最小单元\n\n> 注：一个Spark程序会有1个Application，会有1～N 个Job，会有1～N 个Stage，会有1～N 个Task\n>\n> 1 Application = [1 ~ N  ] Job\n> 1 Job = [ 1 ~ N ] Stage\n> 1 Stage = [ 1 ~ N ] Task\n>\n> Stage数 = Shuffle数 +1\n\n\n\n### 软件环境\n\n+ Spark：2.3.0\n\n### 代码\n\n写一个简单的WordCount计算代码\n\ndata.txt\n\n~~~txt\nhello world\nhello java\nhello scala\nhello hadoop\nhello spark\n~~~\n\nWCAnalyzer.scala\n\n~~~scala\n\n    //设置日志输出级别，便于观察日志\n    Logger.getLogger(\"org.apache\").setLevel(Level.ALL)\n\n    //创建sc\n    val sc = new SparkContext(new SparkConf().setMaster(\"local[1]\")\n                              .setAppName(\"WCAnalyzer\"))\n\n    //从文件读取数据\n    sc.textFile(\"data/data.txt\", 1)\n      //将数据按照空格进行切分（切分出单个单词）\n      .flatMap(_.split(\" \"))\n      //将每个单词和1组成一个Tuple\n      .map((_, 1))\n      //按照相同的单词进行聚合\n      .reduceByKey(_ + _)\n      //将聚合后的结果将（key，value）数据进行倒置 转换成（value，key）便于排序\n      .map(v => (v._2, v._1))\n      //按照聚合后的单词数量进行降序排序\n      .sortByKey(false)\n      //将排序后的数据进行倒置\n      .map(v => (v._2, v._1))\n      //将数据收集到driver\n      .collect()\n      //输出数据\n      .foreach(println)\n\n    //关闭sc\n    sc.stop()\n  }\n~~~\n\n\n\n### 过程分析\n\n本代码只会生成一个Job，3个Stage，8个RDD。\n\n+ 划分Stage\n\n  Stage的划分要从后向前，每遇到一次宽依赖就划分一个Stage，因此这个简单的WC代码可以分为3个Stage，分别是由textFile、flatMap、map算子组成的第一个Stage 0；由reduceByKey、map算子组成的Stage 1；由sortByKey、map算子组成的Stage 2。\n\n+ RDD的生成 \n\n  textFile（HadoopRDD [0] ，MapPartitionsRDD [1] ）  //[ ] 内为该rdd的序号\n\n  flatMap（MapPartitionsRDD [2] ）\n\n  map（MapPartitionsRDD [3] ）\n\n  reduceByKey（ShuffledRDD [4] ）\n\n  map（MapPartitionsRDD [5] ）\n\n  sortByKey（ShuffledRDD [6] ）\n\n  map （MapPartitionsRDD [7] ）\n\n+ 日志分析\n\n    ~~~txt\n    org.apache.spark.SparkContext                     - Starting job: collect at WCAnalyzer.scala:34\n    ~~~\n    由collect算子触发runJob 启动一个Job，代码中的`foreach(println)`其中`foreach`并不是RDD中的算子，因此不会触发runJob，也就不会生成一个Job\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler           - Got job 0 (collect at WCAnalyzer.scala:34) with 1 output partitions\n    ~~~\n\n    \t生成一个Job 0 ，这个Job是由collect算子生成，在代码第34行，有一个分区\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler          - Final stage: ResultStage 2 (collect at WCAnalyzer.scala:34)\n    org.apache.spark.scheduler.DAGScheduler          - Parents of final stage: List(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - Missing parents: List(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List(ShuffleMapStage 0)\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 0)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List()\n    ~~~\n\n    Job 的Final Stage 为ResultStage 0，ResultStage 的父依赖为ShuffleMapStage 1，遗留的父依赖为ShuffleMapStage 1。\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - submitStage(ResultStage 2)\n    ~~~\n\n    尝试提交ResultStage 2\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - missing: List(ShuffleMapStage 1)\n    ~~~\n\n    遗留一个ShuffleMapStage 1\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - submitStage(ShuffleMapStage 1)\n    ~~~\n\n    尝试提交ShuffleMapStage 1\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - missing: List(ShuffleMapStage 0)\n    ~~~\n\n    遗留一个ShuffleMapStage 0\n\n     ~~~txt\n      org.apache.spark.scheduler.DAGScheduler         - submitStage(ShuffleMapStage 0)\n     ~~~\n    \n     尝试提交ShuffleMapStage 0\n    \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - missing: List()\n    ~~~\n  \n    没有遗留的Stage\n  \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - Submitting ShuffleMapStage 0 (MapPartitionsRDD[3] at map at WCAnalyzer.scala:24), which has no missing parents\n    ~~~\n  \n    提交ShuffleMapStage 0，该Stage的最后一个RDD是MapPartitionsRDD[3]，是由map算子生成，在代码第24行\n  \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - submitMissingTasks(ShuffleMapStage 0)\n    ~~~\n  \n    提交Tasks，一个Stage就是一个Task Set集合\n  \n    ~~~txt\n    org.apache.spark.scheduler.TaskSchedulerImpl    - Adding task set 0.0 with 1 tasks\n    ~~~\n    TaskSchedulerImpl 调度器添加一个Task Set集合\n  \n    ~~~txt\n    org.apache.spark.scheduler.TaskSetManager       - Starting task 0.0 in stage 0.0 (TID 0, localhost, executor driver, partition 0, PROCESS_LOCAL, 7909 bytes)\n    ~~~\n  \n    TaskSetManager 启动stage 0.0 中的task 0.0（taskid=0.0，host=localhost，executor=driver，partition=0，taskLocality=PROCESS_LOCAL，serializedTask=7909 bytes\n  \n    ~~~txt\n    org.apache.spark.executor.Executor              - Running task 0.0 in stage 0.0 (TID 0)\n    ~~~\n  \n    Executor 端运行task\n  \n    ~~~txt\n    org.apache.spark.executor.Executor              - Finished task 0.0 in stage 0.0 (TID 0). 1159 bytes result sent to driver\n    ~~~\n  \n    Executor 端 运行完成task，将序列化后大小为1159 bytes结果数据发送回driver端\n  \n    ~~~txt\n    org.apache.spark.scheduler.TaskSetManager       - Finished task 0.0 in stage 0.0 (TID 0) in 194 ms on localhost (executor driver) (1/1)\n    ~~~\n  \n    TaskSetManager 运行完task  完成task数量／总攻task数量\n  \n    ~~~txt\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 0.0, whose tasks have all completed, from pool \n    ~~~\n  \n    TaskSchedulerImpl 移除TaskSet 集合\n  \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler          - ShuffleMapTask finished on driver\n    ~~~\n  \n    DAGScheduler 完成ShuffleMapTask 的计算\n  \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler          - ShuffleMapStage 0 (map at WCAnalyzer.scala:24) finished in 0.289 s\n    ~~~\n  \n    DAGScheduler 完成ShuffleMapStage 的计算，用时共 0.289 s\n\n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler          - looking for newly runnable stages\n    org.apache.spark.scheduler.DAGScheduler          - running: Set()\n    org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ShuffleMapStage 1, ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n    org.apache.spark.MapOutputTrackerMaster          - Increasing epoch to 1\n    org.apache.spark.scheduler.DAGScheduler          - Checking if any dependencies of ShuffleMapStage 0 are now runnable\n    org.apache.spark.scheduler.DAGScheduler          - running: Set()\n    org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ShuffleMapStage 1, ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n    ~~~\n    \n    Stage在计算完后，DAGScheduler会查询是否还有未完成的计算，直到有新的Stage提交\n    \n    ~~~txt\n    ============================   ShuffleMapStage 1 的提交计算过程  ==========================\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 1)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List()\n    org.apache.spark.scheduler.DAGScheduler          - Submitting ShuffleMapStage 1 (MapPartitionsRDD[5] at map at WCAnalyzer.scala:28), which has no missing parents\n    org.apache.spark.scheduler.DAGScheduler          - submitMissingTasks(ShuffleMapStage 1)\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Adding task set 1.0 with 1 tasks\n    org.apache.spark.scheduler.TaskSetManager        - Starting task 0.0 in stage 1.0 (TID 1, localhost, executor driver, partition 0, ANY, 7638 bytes)\n    org.apache.spark.executor.Executor               - Running task 0.0 in stage 1.0 (TID 1)\n    org.apache.spark.executor.Executor               - Finished task 0.0 in stage 1.0 (TID 1). 1331 bytes result sent to driver\n    org.apache.spark.scheduler.TaskSetManager        - Finished task 0.0 in stage 1.0 (TID 1) in 102 ms on localhost (executor driver) (1/1)\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 1.0, whose tasks have all completed, from pool \n    org.apache.spark.scheduler.DAGScheduler          - ShuffleMapTask finished on driver\n    org.apache.spark.scheduler.DAGScheduler          - ShuffleMapStage 1 (map at WCAnalyzer.scala:28) finished in 0.117 s\n    ============================   ResultStage 2 的提交计算过程  =============================\n    org.apache.spark.scheduler.DAGScheduler          - looking for newly runnable stages\n    org.apache.spark.scheduler.DAGScheduler          - running: Set()\n    org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n    org.apache.spark.MapOutputTrackerMaster          - Increasing epoch to 2\n    org.apache.spark.scheduler.DAGScheduler          - Checking if any dependencies of ShuffleMapStage 1 are now runnable\n    org.apache.spark.scheduler.DAGScheduler          - running: Set()\n    org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n    org.apache.spark.scheduler.DAGScheduler          - submitStage(ResultStage 2)\n    org.apache.spark.scheduler.DAGScheduler          - missing: List()\n    org.apache.spark.scheduler.DAGScheduler          - Submitting ResultStage 2 (MapPartitionsRDD[7] at map at WCAnalyzer.scala:32), which has no missing parents\n    org.apache.spark.scheduler.DAGScheduler          - submitMissingTasks(ResultStage 2)\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Adding task set 2.0 with 1 tasks\n    org.apache.spark.scheduler.TaskSetManager        - Starting task 0.0 in stage 2.0 (TID 2, localhost, executor driver, partition 0, ANY, 7649 bytes)\n    org.apache.spark.executor.Executor               - Running task 0.0 in stage 2.0 (TID 2)\n    org.apache.spark.executor.Executor               - Finished task 0.0 in stage 2.0 (TID 2). 1387 bytes result sent to driver\n    org.apache.spark.scheduler.TaskSetManager        - Finished task 0.0 in stage 2.0 (TID 2) in 44 ms on localhost (executor driver) (1/1)\n    org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 2.0, whose tasks have all completed, from pool \n    org.apache.spark.scheduler.DAGScheduler          - ResultStage 2 (collect at WCAnalyzer.scala:34) finished in 0.057 s\n    ~~~\n    \n    以上是ShuffleMapStage 1和ResultStage 2的提交计算过程，与ShuffleMapStage 0一样，不再赘述\n    \n    ~~~txt\n    org.apache.spark.scheduler.DAGScheduler         - Job 0 finished: collect at WCAnalyzer.scala:34, took 0.770898 s\n    ~~~\n    \n    DAGScheduler 当所有的Stage 提交计算完成 结束Job\n\n\n\n\n","slug":"手撕Spark之WordCount RDD执行流程","published":1,"updated":"2020-03-18T11:52:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck8o1hab1000y13s6cf9536w1","content":"<h2 id=\"手撕Spark之WordCount-RDD执行流程\"><a href=\"#手撕Spark之WordCount-RDD执行流程\" class=\"headerlink\" title=\"手撕Spark之WordCount RDD执行流程\"></a>手撕Spark之WordCount RDD执行流程</h2><p>[TOC]</p>\n<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><p>一个Spark程序在初始化的时候会构造DAGScheduler、TaskSchedulerImpl、MapOutTrackerMaster等对象，DAGScheduler主要负责生成DAG、启动Job、提交Stage等操作，TaskSchedulerImpl主要负责Task Set的添加调度等，MapOutTrackerMaster主要负责数据的Shuffle等，这里不再赘述。</p>\n<p><strong>注意几个概念：</strong></p>\n<ul>\n<li>Application   //一个Spark程序会有一个Application，也就拥有了唯一的一个applicationId</li>\n<li>Job    //调用Action 算子 触发runJob，触发一次runJob就会产生一个Job</li>\n<li>Stage  //遇到一次宽依赖就会生成一个Stage</li>\n<li>Task  //Spark程序运行的最小单元</li>\n</ul>\n<blockquote>\n<p>注：一个Spark程序会有1个Application，会有1～N 个Job，会有1～N 个Stage，会有1～N 个Task</p>\n<p>1 Application = [1 ~ N  ] Job<br>1 Job = [ 1 ~ N ] Stage<br>1 Stage = [ 1 ~ N ] Task</p>\n<p>Stage数 = Shuffle数 +1</p>\n</blockquote>\n<h3 id=\"软件环境\"><a href=\"#软件环境\" class=\"headerlink\" title=\"软件环境\"></a>软件环境</h3><ul>\n<li>Spark：2.3.0</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>写一个简单的WordCount计算代码</p>\n<p>data.txt</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">hello world\nhello java\nhello scala\nhello hadoop\nhello spark</code></pre>\n<p>WCAnalyzer.scala</p>\n<pre class=\" language-scala\"><code class=\"language-scala\">\n    <span class=\"token comment\" spellcheck=\"true\">//设置日志输出级别，便于观察日志</span>\n    Logger<span class=\"token punctuation\">.</span>getLogger<span class=\"token punctuation\">(</span><span class=\"token string\">\"org.apache\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>setLevel<span class=\"token punctuation\">(</span>Level<span class=\"token punctuation\">.</span>ALL<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//创建sc</span>\n    <span class=\"token keyword\">val</span> sc <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> SparkContext<span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> SparkConf<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>setMaster<span class=\"token punctuation\">(</span><span class=\"token string\">\"local[1]\"</span><span class=\"token punctuation\">)</span>\n                              <span class=\"token punctuation\">.</span>setAppName<span class=\"token punctuation\">(</span><span class=\"token string\">\"WCAnalyzer\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//从文件读取数据</span>\n    sc<span class=\"token punctuation\">.</span>textFile<span class=\"token punctuation\">(</span><span class=\"token string\">\"data/data.txt\"</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">//将数据按照空格进行切分（切分出单个单词）</span>\n      <span class=\"token punctuation\">.</span>flatMap<span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">.</span>split<span class=\"token punctuation\">(</span><span class=\"token string\">\" \"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">//将每个单词和1组成一个Tuple</span>\n      <span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">//按照相同的单词进行聚合</span>\n      <span class=\"token punctuation\">.</span>reduceByKey<span class=\"token punctuation\">(</span>_ <span class=\"token operator\">+</span> _<span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">//将聚合后的结果将（key，value）数据进行倒置 转换成（value，key）便于排序</span>\n      <span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>v <span class=\"token keyword\">=></span> <span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span>_2<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">.</span>_1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">//按照聚合后的单词数量进行降序排序</span>\n      <span class=\"token punctuation\">.</span>sortByKey<span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">//将排序后的数据进行倒置</span>\n      <span class=\"token punctuation\">.</span>map<span class=\"token punctuation\">(</span>v <span class=\"token keyword\">=></span> <span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">.</span>_2<span class=\"token punctuation\">,</span> v<span class=\"token punctuation\">.</span>_1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">//将数据收集到driver</span>\n      <span class=\"token punctuation\">.</span>collect<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token comment\" spellcheck=\"true\">//输出数据</span>\n      <span class=\"token punctuation\">.</span>foreach<span class=\"token punctuation\">(</span>println<span class=\"token punctuation\">)</span>\n\n    <span class=\"token comment\" spellcheck=\"true\">//关闭sc</span>\n    sc<span class=\"token punctuation\">.</span>stop<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"过程分析\"><a href=\"#过程分析\" class=\"headerlink\" title=\"过程分析\"></a>过程分析</h3><p>本代码只会生成一个Job，3个Stage，8个RDD。</p>\n<ul>\n<li><p>划分Stage</p>\n<p>Stage的划分要从后向前，每遇到一次宽依赖就划分一个Stage，因此这个简单的WC代码可以分为3个Stage，分别是由textFile、flatMap、map算子组成的第一个Stage 0；由reduceByKey、map算子组成的Stage 1；由sortByKey、map算子组成的Stage 2。</p>\n</li>\n<li><p>RDD的生成 </p>\n<p>textFile（HadoopRDD [0] ，MapPartitionsRDD [1] ）  //[ ] 内为该rdd的序号</p>\n<p>flatMap（MapPartitionsRDD [2] ）</p>\n<p>map（MapPartitionsRDD [3] ）</p>\n<p>reduceByKey（ShuffledRDD [4] ）</p>\n<p>map（MapPartitionsRDD [5] ）</p>\n<p>sortByKey（ShuffledRDD [6] ）</p>\n<p>map （MapPartitionsRDD [7] ）</p>\n</li>\n<li><p>日志分析</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.SparkContext                     - Starting job: collect at WCAnalyzer.scala:34</code></pre>\n<p>  由collect算子触发runJob 启动一个Job，代码中的<code>foreach(println)</code>其中<code>foreach</code>并不是RDD中的算子，因此不会触发runJob，也就不会生成一个Job</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler           - Got job 0 (collect at WCAnalyzer.scala:34) with 1 output partitions</code></pre>\n<pre><code>  生成一个Job 0 ，这个Job是由collect算子生成，在代码第34行，有一个分区</code></pre><pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler          - Final stage: ResultStage 2 (collect at WCAnalyzer.scala:34)\n  org.apache.spark.scheduler.DAGScheduler          - Parents of final stage: List(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - Missing parents: List(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List(ShuffleMapStage 0)\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 0)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List()</code></pre>\n<p>  Job 的Final Stage 为ResultStage 0，ResultStage 的父依赖为ShuffleMapStage 1，遗留的父依赖为ShuffleMapStage 1。</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler         - submitStage(ResultStage 2)</code></pre>\n<p>  尝试提交ResultStage 2</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler         - missing: List(ShuffleMapStage 1)</code></pre>\n<p>  遗留一个ShuffleMapStage 1</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler         - submitStage(ShuffleMapStage 1)</code></pre>\n<p>  尝试提交ShuffleMapStage 1</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler         - missing: List(ShuffleMapStage 0)</code></pre>\n<p>  遗留一个ShuffleMapStage 0</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">    org.apache.spark.scheduler.DAGScheduler         - submitStage(ShuffleMapStage 0)</code></pre>\n<p>   尝试提交ShuffleMapStage 0</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler         - missing: List()</code></pre>\n<p>  没有遗留的Stage</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler         - Submitting ShuffleMapStage 0 (MapPartitionsRDD[3] at map at WCAnalyzer.scala:24), which has no missing parents</code></pre>\n<p>  提交ShuffleMapStage 0，该Stage的最后一个RDD是MapPartitionsRDD[3]，是由map算子生成，在代码第24行</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler         - submitMissingTasks(ShuffleMapStage 0)</code></pre>\n<p>  提交Tasks，一个Stage就是一个Task Set集合</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.TaskSchedulerImpl    - Adding task set 0.0 with 1 tasks</code></pre>\n<p>  TaskSchedulerImpl 调度器添加一个Task Set集合</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.TaskSetManager       - Starting task 0.0 in stage 0.0 (TID 0, localhost, executor driver, partition 0, PROCESS_LOCAL, 7909 bytes)</code></pre>\n<p>  TaskSetManager 启动stage 0.0 中的task 0.0（taskid=0.0，host=localhost，executor=driver，partition=0，taskLocality=PROCESS_LOCAL，serializedTask=7909 bytes</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.executor.Executor              - Running task 0.0 in stage 0.0 (TID 0)</code></pre>\n<p>  Executor 端运行task</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.executor.Executor              - Finished task 0.0 in stage 0.0 (TID 0). 1159 bytes result sent to driver</code></pre>\n<p>  Executor 端 运行完成task，将序列化后大小为1159 bytes结果数据发送回driver端</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.TaskSetManager       - Finished task 0.0 in stage 0.0 (TID 0) in 194 ms on localhost (executor driver) (1/1)</code></pre>\n<p>  TaskSetManager 运行完task  完成task数量／总攻task数量</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 0.0, whose tasks have all completed, from pool </code></pre>\n<p>  TaskSchedulerImpl 移除TaskSet 集合</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler          - ShuffleMapTask finished on driver</code></pre>\n<p>  DAGScheduler 完成ShuffleMapTask 的计算</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler          - ShuffleMapStage 0 (map at WCAnalyzer.scala:24) finished in 0.289 s</code></pre>\n<p>  DAGScheduler 完成ShuffleMapStage 的计算，用时共 0.289 s</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler          - looking for newly runnable stages\n  org.apache.spark.scheduler.DAGScheduler          - running: Set()\n  org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ShuffleMapStage 1, ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n  org.apache.spark.MapOutputTrackerMaster          - Increasing epoch to 1\n  org.apache.spark.scheduler.DAGScheduler          - Checking if any dependencies of ShuffleMapStage 0 are now runnable\n  org.apache.spark.scheduler.DAGScheduler          - running: Set()\n  org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ShuffleMapStage 1, ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - failed: Set()</code></pre>\n<p>  Stage在计算完后，DAGScheduler会查询是否还有未完成的计算，直到有新的Stage提交</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  ============================   ShuffleMapStage 1 的提交计算过程  ==========================\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List()\n  org.apache.spark.scheduler.DAGScheduler          - Submitting ShuffleMapStage 1 (MapPartitionsRDD[5] at map at WCAnalyzer.scala:28), which has no missing parents\n  org.apache.spark.scheduler.DAGScheduler          - submitMissingTasks(ShuffleMapStage 1)\n  org.apache.spark.scheduler.TaskSchedulerImpl     - Adding task set 1.0 with 1 tasks\n  org.apache.spark.scheduler.TaskSetManager        - Starting task 0.0 in stage 1.0 (TID 1, localhost, executor driver, partition 0, ANY, 7638 bytes)\n  org.apache.spark.executor.Executor               - Running task 0.0 in stage 1.0 (TID 1)\n  org.apache.spark.executor.Executor               - Finished task 0.0 in stage 1.0 (TID 1). 1331 bytes result sent to driver\n  org.apache.spark.scheduler.TaskSetManager        - Finished task 0.0 in stage 1.0 (TID 1) in 102 ms on localhost (executor driver) (1/1)\n  org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 1.0, whose tasks have all completed, from pool \n  org.apache.spark.scheduler.DAGScheduler          - ShuffleMapTask finished on driver\n  org.apache.spark.scheduler.DAGScheduler          - ShuffleMapStage 1 (map at WCAnalyzer.scala:28) finished in 0.117 s\n  ============================   ResultStage 2 的提交计算过程  =============================\n  org.apache.spark.scheduler.DAGScheduler          - looking for newly runnable stages\n  org.apache.spark.scheduler.DAGScheduler          - running: Set()\n  org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n  org.apache.spark.MapOutputTrackerMaster          - Increasing epoch to 2\n  org.apache.spark.scheduler.DAGScheduler          - Checking if any dependencies of ShuffleMapStage 1 are now runnable\n  org.apache.spark.scheduler.DAGScheduler          - running: Set()\n  org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List()\n  org.apache.spark.scheduler.DAGScheduler          - Submitting ResultStage 2 (MapPartitionsRDD[7] at map at WCAnalyzer.scala:32), which has no missing parents\n  org.apache.spark.scheduler.DAGScheduler          - submitMissingTasks(ResultStage 2)\n  org.apache.spark.scheduler.TaskSchedulerImpl     - Adding task set 2.0 with 1 tasks\n  org.apache.spark.scheduler.TaskSetManager        - Starting task 0.0 in stage 2.0 (TID 2, localhost, executor driver, partition 0, ANY, 7649 bytes)\n  org.apache.spark.executor.Executor               - Running task 0.0 in stage 2.0 (TID 2)\n  org.apache.spark.executor.Executor               - Finished task 0.0 in stage 2.0 (TID 2). 1387 bytes result sent to driver\n  org.apache.spark.scheduler.TaskSetManager        - Finished task 0.0 in stage 2.0 (TID 2) in 44 ms on localhost (executor driver) (1/1)\n  org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 2.0, whose tasks have all completed, from pool \n  org.apache.spark.scheduler.DAGScheduler          - ResultStage 2 (collect at WCAnalyzer.scala:34) finished in 0.057 s</code></pre>\n<p>  以上是ShuffleMapStage 1和ResultStage 2的提交计算过程，与ShuffleMapStage 0一样，不再赘述</p>\n<pre class=\" language-txt\"><code class=\"language-txt\">  org.apache.spark.scheduler.DAGScheduler         - Job 0 finished: collect at WCAnalyzer.scala:34, took 0.770898 s</code></pre>\n<p>  DAGScheduler 当所有的Stage 提交计算完成 结束Job</p>\n</li>\n</ul>\n","site":{"data":{"musics":[{"name":"五月雨变奏电音","artist":"AnimeVibe","url":"http://static.blinkfox.com/music1.mp3","cover":"http://static.blinkfox.com/music-cover1.png"},{"name":"Take me hand","artist":"DAISHI DANCE,Cecile Corbel","url":"http://static.blinkfox.com/music2.mp3","cover":"http://static.blinkfox.com/music-cover2.png"},{"name":"Shape of You","artist":"J.Fla","url":"http://static.blinkfox.com/music3.mp3","cover":"http://static.blinkfox.com/music-cover3.png"}],"friends":[{"avatar":"http://image.luokangyuan.com/1_qq_27922023.jpg","name":"码酱","introduction":"我不是大佬，只是在追寻大佬的脚步","url":"http://luokangyuan.com/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/20190601.png","name":"码农","introduction":"这里不隐含扭曲的价值观，而是整合并充盈正能量","url":"https://www.90c.vip/","title":"前去学习"},{"avatar":"https://jiangliuhong.gitee.io/images/avatar.jpg","name":"编程常青树","introduction":"平凡的脚步也可以走出伟大的行程","url":"https://jiangliuhong.gitee.io/","title":"前去学习"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar2.png","name":"洪卫の博客","introduction":"凭寄狂夫书一纸，信在成都万里桥。","url":"https://sunhwee.com","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar.jpg","name":"过客~励む","introduction":"你现在的努力，是为了以后有更多的选择。","url":"https://yafine-blog.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar5.png","name":"Sitoi","introduction":"妄想通过成为 Spider-Man 来实现财富自由的程序猿","url":"https://sitoi.cn","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/11/23/avatar3.jpeg","name":"Five-great","introduction":"有事多研究，没事瞎琢磨。","url":"http://www.fivecc.cn/","title":"前去探索"},{"avatar":"http://static.blinkfox.com/2019/12/24logo.png","name":"A2Data","introduction":"武术跨行大数据，用技术推动梦想的落地！","url":"https://www.a2data.cn","title":"开启跨行之旅"}]}},"excerpt":"","more":"<h2 id=\"手撕Spark之WordCount-RDD执行流程\"><a href=\"#手撕Spark之WordCount-RDD执行流程\" class=\"headerlink\" title=\"手撕Spark之WordCount RDD执行流程\"></a>手撕Spark之WordCount RDD执行流程</h2><p>[TOC]</p>\n<h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><p>一个Spark程序在初始化的时候会构造DAGScheduler、TaskSchedulerImpl、MapOutTrackerMaster等对象，DAGScheduler主要负责生成DAG、启动Job、提交Stage等操作，TaskSchedulerImpl主要负责Task Set的添加调度等，MapOutTrackerMaster主要负责数据的Shuffle等，这里不再赘述。</p>\n<p><strong>注意几个概念：</strong></p>\n<ul>\n<li>Application   //一个Spark程序会有一个Application，也就拥有了唯一的一个applicationId</li>\n<li>Job    //调用Action 算子 触发runJob，触发一次runJob就会产生一个Job</li>\n<li>Stage  //遇到一次宽依赖就会生成一个Stage</li>\n<li>Task  //Spark程序运行的最小单元</li>\n</ul>\n<blockquote>\n<p>注：一个Spark程序会有1个Application，会有1～N 个Job，会有1～N 个Stage，会有1～N 个Task</p>\n<p>1 Application = [1 ~ N  ] Job<br>1 Job = [ 1 ~ N ] Stage<br>1 Stage = [ 1 ~ N ] Task</p>\n<p>Stage数 = Shuffle数 +1</p>\n</blockquote>\n<h3 id=\"软件环境\"><a href=\"#软件环境\" class=\"headerlink\" title=\"软件环境\"></a>软件环境</h3><ul>\n<li>Spark：2.3.0</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><p>写一个简单的WordCount计算代码</p>\n<p>data.txt</p>\n<pre><code class=\"txt\">hello world\nhello java\nhello scala\nhello hadoop\nhello spark</code></pre>\n<p>WCAnalyzer.scala</p>\n<pre><code class=\"scala\">\n    //设置日志输出级别，便于观察日志\n    Logger.getLogger(&quot;org.apache&quot;).setLevel(Level.ALL)\n\n    //创建sc\n    val sc = new SparkContext(new SparkConf().setMaster(&quot;local[1]&quot;)\n                              .setAppName(&quot;WCAnalyzer&quot;))\n\n    //从文件读取数据\n    sc.textFile(&quot;data/data.txt&quot;, 1)\n      //将数据按照空格进行切分（切分出单个单词）\n      .flatMap(_.split(&quot; &quot;))\n      //将每个单词和1组成一个Tuple\n      .map((_, 1))\n      //按照相同的单词进行聚合\n      .reduceByKey(_ + _)\n      //将聚合后的结果将（key，value）数据进行倒置 转换成（value，key）便于排序\n      .map(v =&gt; (v._2, v._1))\n      //按照聚合后的单词数量进行降序排序\n      .sortByKey(false)\n      //将排序后的数据进行倒置\n      .map(v =&gt; (v._2, v._1))\n      //将数据收集到driver\n      .collect()\n      //输出数据\n      .foreach(println)\n\n    //关闭sc\n    sc.stop()\n  }</code></pre>\n<h3 id=\"过程分析\"><a href=\"#过程分析\" class=\"headerlink\" title=\"过程分析\"></a>过程分析</h3><p>本代码只会生成一个Job，3个Stage，8个RDD。</p>\n<ul>\n<li><p>划分Stage</p>\n<p>Stage的划分要从后向前，每遇到一次宽依赖就划分一个Stage，因此这个简单的WC代码可以分为3个Stage，分别是由textFile、flatMap、map算子组成的第一个Stage 0；由reduceByKey、map算子组成的Stage 1；由sortByKey、map算子组成的Stage 2。</p>\n</li>\n<li><p>RDD的生成 </p>\n<p>textFile（HadoopRDD [0] ，MapPartitionsRDD [1] ）  //[ ] 内为该rdd的序号</p>\n<p>flatMap（MapPartitionsRDD [2] ）</p>\n<p>map（MapPartitionsRDD [3] ）</p>\n<p>reduceByKey（ShuffledRDD [4] ）</p>\n<p>map（MapPartitionsRDD [5] ）</p>\n<p>sortByKey（ShuffledRDD [6] ）</p>\n<p>map （MapPartitionsRDD [7] ）</p>\n</li>\n<li><p>日志分析</p>\n<pre><code class=\"txt\">  org.apache.spark.SparkContext                     - Starting job: collect at WCAnalyzer.scala:34</code></pre>\n<p>  由collect算子触发runJob 启动一个Job，代码中的<code>foreach(println)</code>其中<code>foreach</code>并不是RDD中的算子，因此不会触发runJob，也就不会生成一个Job</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler           - Got job 0 (collect at WCAnalyzer.scala:34) with 1 output partitions</code></pre>\n<pre><code>  生成一个Job 0 ，这个Job是由collect算子生成，在代码第34行，有一个分区</code></pre><pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler          - Final stage: ResultStage 2 (collect at WCAnalyzer.scala:34)\n  org.apache.spark.scheduler.DAGScheduler          - Parents of final stage: List(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - Missing parents: List(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List(ShuffleMapStage 0)\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 0)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List()</code></pre>\n<p>  Job 的Final Stage 为ResultStage 0，ResultStage 的父依赖为ShuffleMapStage 1，遗留的父依赖为ShuffleMapStage 1。</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler         - submitStage(ResultStage 2)</code></pre>\n<p>  尝试提交ResultStage 2</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler         - missing: List(ShuffleMapStage 1)</code></pre>\n<p>  遗留一个ShuffleMapStage 1</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler         - submitStage(ShuffleMapStage 1)</code></pre>\n<p>  尝试提交ShuffleMapStage 1</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler         - missing: List(ShuffleMapStage 0)</code></pre>\n<p>  遗留一个ShuffleMapStage 0</p>\n<pre><code class=\"txt\">    org.apache.spark.scheduler.DAGScheduler         - submitStage(ShuffleMapStage 0)</code></pre>\n<p>   尝试提交ShuffleMapStage 0</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler         - missing: List()</code></pre>\n<p>  没有遗留的Stage</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler         - Submitting ShuffleMapStage 0 (MapPartitionsRDD[3] at map at WCAnalyzer.scala:24), which has no missing parents</code></pre>\n<p>  提交ShuffleMapStage 0，该Stage的最后一个RDD是MapPartitionsRDD[3]，是由map算子生成，在代码第24行</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler         - submitMissingTasks(ShuffleMapStage 0)</code></pre>\n<p>  提交Tasks，一个Stage就是一个Task Set集合</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.TaskSchedulerImpl    - Adding task set 0.0 with 1 tasks</code></pre>\n<p>  TaskSchedulerImpl 调度器添加一个Task Set集合</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.TaskSetManager       - Starting task 0.0 in stage 0.0 (TID 0, localhost, executor driver, partition 0, PROCESS_LOCAL, 7909 bytes)</code></pre>\n<p>  TaskSetManager 启动stage 0.0 中的task 0.0（taskid=0.0，host=localhost，executor=driver，partition=0，taskLocality=PROCESS_LOCAL，serializedTask=7909 bytes</p>\n<pre><code class=\"txt\">  org.apache.spark.executor.Executor              - Running task 0.0 in stage 0.0 (TID 0)</code></pre>\n<p>  Executor 端运行task</p>\n<pre><code class=\"txt\">  org.apache.spark.executor.Executor              - Finished task 0.0 in stage 0.0 (TID 0). 1159 bytes result sent to driver</code></pre>\n<p>  Executor 端 运行完成task，将序列化后大小为1159 bytes结果数据发送回driver端</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.TaskSetManager       - Finished task 0.0 in stage 0.0 (TID 0) in 194 ms on localhost (executor driver) (1/1)</code></pre>\n<p>  TaskSetManager 运行完task  完成task数量／总攻task数量</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 0.0, whose tasks have all completed, from pool </code></pre>\n<p>  TaskSchedulerImpl 移除TaskSet 集合</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler          - ShuffleMapTask finished on driver</code></pre>\n<p>  DAGScheduler 完成ShuffleMapTask 的计算</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler          - ShuffleMapStage 0 (map at WCAnalyzer.scala:24) finished in 0.289 s</code></pre>\n<p>  DAGScheduler 完成ShuffleMapStage 的计算，用时共 0.289 s</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler          - looking for newly runnable stages\n  org.apache.spark.scheduler.DAGScheduler          - running: Set()\n  org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ShuffleMapStage 1, ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n  org.apache.spark.MapOutputTrackerMaster          - Increasing epoch to 1\n  org.apache.spark.scheduler.DAGScheduler          - Checking if any dependencies of ShuffleMapStage 0 are now runnable\n  org.apache.spark.scheduler.DAGScheduler          - running: Set()\n  org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ShuffleMapStage 1, ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - failed: Set()</code></pre>\n<p>  Stage在计算完后，DAGScheduler会查询是否还有未完成的计算，直到有新的Stage提交</p>\n<pre><code class=\"txt\">  ============================   ShuffleMapStage 1 的提交计算过程  ==========================\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ShuffleMapStage 1)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List()\n  org.apache.spark.scheduler.DAGScheduler          - Submitting ShuffleMapStage 1 (MapPartitionsRDD[5] at map at WCAnalyzer.scala:28), which has no missing parents\n  org.apache.spark.scheduler.DAGScheduler          - submitMissingTasks(ShuffleMapStage 1)\n  org.apache.spark.scheduler.TaskSchedulerImpl     - Adding task set 1.0 with 1 tasks\n  org.apache.spark.scheduler.TaskSetManager        - Starting task 0.0 in stage 1.0 (TID 1, localhost, executor driver, partition 0, ANY, 7638 bytes)\n  org.apache.spark.executor.Executor               - Running task 0.0 in stage 1.0 (TID 1)\n  org.apache.spark.executor.Executor               - Finished task 0.0 in stage 1.0 (TID 1). 1331 bytes result sent to driver\n  org.apache.spark.scheduler.TaskSetManager        - Finished task 0.0 in stage 1.0 (TID 1) in 102 ms on localhost (executor driver) (1/1)\n  org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 1.0, whose tasks have all completed, from pool \n  org.apache.spark.scheduler.DAGScheduler          - ShuffleMapTask finished on driver\n  org.apache.spark.scheduler.DAGScheduler          - ShuffleMapStage 1 (map at WCAnalyzer.scala:28) finished in 0.117 s\n  ============================   ResultStage 2 的提交计算过程  =============================\n  org.apache.spark.scheduler.DAGScheduler          - looking for newly runnable stages\n  org.apache.spark.scheduler.DAGScheduler          - running: Set()\n  org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n  org.apache.spark.MapOutputTrackerMaster          - Increasing epoch to 2\n  org.apache.spark.scheduler.DAGScheduler          - Checking if any dependencies of ShuffleMapStage 1 are now runnable\n  org.apache.spark.scheduler.DAGScheduler          - running: Set()\n  org.apache.spark.scheduler.DAGScheduler          - waiting: Set(ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - failed: Set()\n  org.apache.spark.scheduler.DAGScheduler          - submitStage(ResultStage 2)\n  org.apache.spark.scheduler.DAGScheduler          - missing: List()\n  org.apache.spark.scheduler.DAGScheduler          - Submitting ResultStage 2 (MapPartitionsRDD[7] at map at WCAnalyzer.scala:32), which has no missing parents\n  org.apache.spark.scheduler.DAGScheduler          - submitMissingTasks(ResultStage 2)\n  org.apache.spark.scheduler.TaskSchedulerImpl     - Adding task set 2.0 with 1 tasks\n  org.apache.spark.scheduler.TaskSetManager        - Starting task 0.0 in stage 2.0 (TID 2, localhost, executor driver, partition 0, ANY, 7649 bytes)\n  org.apache.spark.executor.Executor               - Running task 0.0 in stage 2.0 (TID 2)\n  org.apache.spark.executor.Executor               - Finished task 0.0 in stage 2.0 (TID 2). 1387 bytes result sent to driver\n  org.apache.spark.scheduler.TaskSetManager        - Finished task 0.0 in stage 2.0 (TID 2) in 44 ms on localhost (executor driver) (1/1)\n  org.apache.spark.scheduler.TaskSchedulerImpl     - Removed TaskSet 2.0, whose tasks have all completed, from pool \n  org.apache.spark.scheduler.DAGScheduler          - ResultStage 2 (collect at WCAnalyzer.scala:34) finished in 0.057 s</code></pre>\n<p>  以上是ShuffleMapStage 1和ResultStage 2的提交计算过程，与ShuffleMapStage 0一样，不再赘述</p>\n<pre><code class=\"txt\">  org.apache.spark.scheduler.DAGScheduler         - Job 0 finished: collect at WCAnalyzer.scala:34, took 0.770898 s</code></pre>\n<p>  DAGScheduler 当所有的Stage 提交计算完成 结束Job</p>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck8o1ha9u000113s6ok4mepz0","category_id":"ck8o1haa1000513s61lvxdac6","_id":"ck8o1haaa000f13s6xalqtsm9"},{"post_id":"ck8o1ha9z000313s6h2x50w1q","category_id":"ck8o1haa7000a13s6f855bt9p","_id":"ck8o1haac000m13s6ri3xkhug"},{"post_id":"ck8o1haa3000713s6i9t8z6x4","category_id":"ck8o1haab000h13s6vccdih26","_id":"ck8o1haae000q13s6l0btrb9b"},{"post_id":"ck8o1haaz000v13s66l977a3g","category_id":"ck8o1hab2001013s6zsdhqks3","_id":"ck8o1hab5001613s6y71ja0w8"},{"post_id":"ck8o1hab1000y13s6cf9536w1","category_id":"ck8o1hab4001413s6nyslk83x","_id":"ck8o1hab6001813s6bwxhqt6s"}],"PostTag":[{"post_id":"ck8o1ha9u000113s6ok4mepz0","tag_id":"ck8o1haa3000613s6eywsbptl","_id":"ck8o1haa8000d13s6qb5i00tj"},{"post_id":"ck8o1ha9z000313s6h2x50w1q","tag_id":"ck8o1haa7000b13s65l1sybva","_id":"ck8o1haab000j13s6hvpxjwgj"},{"post_id":"ck8o1haa3000713s6i9t8z6x4","tag_id":"ck8o1haab000i13s6beemjl12","_id":"ck8o1haad000o13s6mcznppq7"},{"post_id":"ck8o1haay000t13s6ne70704r","tag_id":"ck8o1hab1000x13s6dr0duss3","_id":"ck8o1hab4001313s6vqarqvcf"},{"post_id":"ck8o1haaz000v13s66l977a3g","tag_id":"ck8o1hab4001213s68u8r92me","_id":"ck8o1hab5001713s6y5r8jgic"},{"post_id":"ck8o1hab1000y13s6cf9536w1","tag_id":"ck8o1hab5001513s60mtrco9y","_id":"ck8o1hab6001913s6kpf5gyka"}],"Tag":[{"name":"Hexo","_id":"ck8o1haa3000613s6eywsbptl"},{"name":"Kafka","_id":"ck8o1haa7000b13s65l1sybva"},{"name":"Linux,Web","_id":"ck8o1haab000i13s6beemjl12"},{"name":"Go","_id":"ck8o1hab1000x13s6dr0duss3"},{"name":"大数据面试题","_id":"ck8o1hab4001213s68u8r92me"},{"name":"Spark","_id":"ck8o1hab5001513s60mtrco9y"}]}}